<!DOCTYPE html>
<html>

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>
    Tag Posts - Jinho&#39;s Tech Blog
    
  </title>

  <meta name="description" content="개발에 대한 이야기를 담아내다">

  <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

  <script src="https://use.fontawesome.com/releases/v5.15.3/js/all.js" crossorigin="anonymous"></script>

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/tag/">
  <link rel="alternate" type="application/rss+xml" title="Jinho&#39;s Tech Blog" href="/feed.xml">

</head>


<body>

  <!-- Navigation -->
<nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="/">Jinho&#39;s Tech Blog</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
      Menu
      <i class="fa fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        <li class="nav-item">
          <a class="nav-link" href="/">Home</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/about">About</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/posts">Posts</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/contact">Contact</a>
        </li>
      </ul>
    </div>
  </div>
</nav>


  <!-- Page Header -->

<header class="masthead">

  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        <div class="page-heading">
          <h1 id="tag-title" style="font-size: 50px;"></h1>
        </div>
      </div>
    </div>
  </div>
</header>

<div class="container">
  <div class="row">
    <div class="col-lg-8 col-md-10 mx-auto" id="post-list">
      <!-- 포스트 목록이 여기에 동적으로 추가됨 -->
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const urlParams = new URLSearchParams(window.location.search);
    const tag = urlParams.get('tag');
    
    if (tag) {
        document.getElementById('tag-title').textContent = `Posts tagged with "${decodeURIComponent(tag)}"`;
        showTagPosts(tag);
    } else {
        window.location.href = '/tags/';
    }
});

function showTagPosts(tag) {
    const postsData = {
        
            "Java": [
                
                    {
                        "title": "WAS(Web Application Server)와 Servlet",
                        "url": "/2025/01/28/about-was.html",
                        "subtitle": "Tomcat부터 Spring Boot까지",
                        "excerpt": "웹 서버(WS)의 진화 : Apache vs NGINX\n위 post에 이어지는 내용입니다.\n",
                        "author": "Jinho",
                        "date": "January 28, 2025",
                        "background": "/img/posts/apache_tomcat.jpeg",
                        "content": "<p><a href=\"https://jinho7.github.io/2025/01/27/ws-and-was.html\" target=\"웹 서버(WS)의 진화 : Apache vs NGINX \">웹 서버(WS)의 진화 : Apache vs NGINX</a><br />\n<em>위 post에 이어지는 내용입니다.</em></p>\n\n<h1 id=\"was-란\">WAS 란?</h1>\n\n<h2 id=\"was의-정의\">WAS의 정의</h2>\n\n<p>먼저 WAS(Web Application Server)의 정의는 다음과 같다.</p>\n<blockquote>\n  <p><span class=\"post-highlight\">웹 애플리케이션과 서버 환경을 만들어 동작시키는 기능을 제공하는 소프트웨어 프레임워크</span></p>\n</blockquote>\n\n<p>대표적으로 Apache <span class=\"post-highlight\">Tomcat</span>이 있다.</p>\n<ul>\n  <li><em>참고로 Apache Tomcat는 WS 단계에서 계속 이야기했던 Apache와는 아예 별개의 소프트웨어이다.</em></li>\n</ul>\n\n<details>\n<summary>Apache와 Tomcat</summary>\nApache HTTP Server (보통 Apache라고 부름)\n<ul>\n    <li>웹 서버(WS) 역할을 담당</li>\n    <li>주로 정적 콘텐츠를 처리</li>\n    <li>HTTP 요청을 처리하며, 동적 콘텐츠를 처리할 경우에는 WAS(Tomcat)와 연동하여 작업을 나눕니다.</li>\n</ul>\nApache Tomcat (보통 Tomcat이라고 부름)\n<ul>\n    <li>WAS 역할을 담당</li>\n    <li>Servlet Container로서 동작하며, Servlet/JSP 기반의 동적 콘텐츠를 처리\n        <ul>\n            <li><em>정적 콘텐츠도 처리할 수는 있다.</em></li>\n            <li><em>정적 콘텐츠 처리 성능은 Apache HTTP Server보다 낮다.</em></li>\n        </ul>\n    </li>\n    <li>Java EE 표준의 일부인 Servlet/JSP 스펙을 구현하며, Spring MVC와 같은 프레임워크의 기반이 되는 동작을 지원한다.</li>\n</ul>\n</details>\n\n<p><br /></p>\n\n<p>그러나 이런 물음표가 떠오른다.</p>\n\n<p><strong>❓ WAS? TOMCAT? Servlet? Servlet Container? Spring MVC?</strong></p>\n\n<p>다음 기본 개념부터 인지하고 넘어가면 이해하기 쉽다.</p>\n\n<ol>\n  <li><strong>WAS</strong>는 클라이언트의 요청을 처리하여 <strong>동적인 웹 콘텐츠</strong>를 제공하는 서버를 말한다.</li>\n  <li><strong>Tomcat</strong>은 WAS의 대표적인 예시 중 하나이다.</li>\n  <li>Tomcat은 <strong>Servlet Container의 한 종류</strong>이며, <strong>Servlet/JSP 요청을 처리</strong>하는 역할을 한다.</li>\n  <li>Tomcat은 <strong>Servlet 표준</strong>에 맞춘 애플리케이션을 실행하는 데 최적화되어 있다.\n    <ol>\n      <li><strong>Servlet 표준</strong>은 <strong>Java EE</strong>(현재는 <strong>Jakarta EE</strong>) 명세의 일부로, <strong>Java 기반 동적 웹 콘텐츠 처리</strong>를 위한 규격이다.</li>\n      <li>즉, Tomcat은 <strong>Java 기반의 웹 애플리케이션</strong>을 실행하기 위한 서버이다.</li>\n    </ol>\n  </li>\n</ol>\n\n<p><strong>WS와 WAS의 차이의 핵심는 ‘동적 처리 여부’에 있다.</strong></p>\n<ul>\n  <li>현대 웹사이트는 스크롤에 따라 새로운 피드를 보여주거나,<br />\n사용자 맞춤 광고를 제공하는 등의 동적 기능을 포함한다.</li>\n  <li>이러한 <strong>“사용자 맞춤 가공 처리(동적 콘텐츠)”는 결국 서버가 특정 코드를 실행했다</strong>는 의미다.</li>\n  <li>결국 궁금한 것은 ‘<strong>서버가 어떻게 이 코드를 실행하고, 그 결과를 클라이언트에게 제공하는가</strong>’이다.</li>\n</ul>\n\n<div style=\"display: flex; justify-content: space-between; gap: 20px;\">\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/203ab158-60b0-4376-be93-1de497da3d19\" alt=\"Memory Usage\" style=\"width: 100%;\" />\n        <p style=\"text-align: center; color: #666;\">누구나에게 제공되는 “정적인” 컨텐츠이다.</p>\n    </div>\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/5795047e-ae12-4cda-a1f6-e2b3ab8dfd72\" alt=\"Requests Per Second\" style=\"width: 100%;\" />\n        <p style=\"text-align: center; color: #666;\">하지만 로그인하고 나면 “동적인” 컨텐츠가 로드된다.</p>\n    </div>\n</div>\n\n<p>아래는 동적 페이지를 로드하는 과정을 그림으로 표현한 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/ef604672-3c6c-4724-9f9a-9a226cc6e513\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>우리는 앞서 실제 운영/대규모 서비스는 <span class=\"post-highlight\">WS-WAS 분리 구조</span>를 선호한다고 말했다.</p>\n\n<p>나는 WAS의 한 종류인 Tomcat까지의 웹통신 흐름이 어떻게 이루어지는 지가 궁금해졌다.<br />\n그리고 <u>‘jvm, survlet, spring 등 어떤 개념이고 어떤 연관관계가 있고 어떻게 유동적으로 작동할까…?’</u> 가 궁금했다.</p>\n\n<p><br /></p>\n\n<h2 id=\"jvmjava-virtual-machine\">JVM(Java Virtual Machine)</h2>\n\n<p><img src=\"https://github.com/user-attachments/assets/f48a2ce2-5aa4-495c-a686-79e32ce7eed2\" alt=\"Image\" width=\"70%\" height=\"100%\" class=\"center\" /></p>\n\n<p><em>JVM 자체가 현재 내용에서 매우 중요한 내용은 아니라 짧게 이야기하면,</em></p>\n<ul>\n  <li>⇒ 그냥 JVM은 간단히 Java 코드를 실행시켜주는 놈이라고 생각하자.</li>\n  <li>WAS(Tomcat)는 Java로 작성된 웹 애플리케이션을 실행하는 컨테이너이므로,<br />\nWAS도 JVM 위에서 동작한다.</li>\n</ul>\n\n<details>\n<summary>JVM 이란?</summary>\nApache HTTP Server (보통 Apache라고 부름)\n<ul>\n    <li>JVM은 JVM은 Java 바이트코드(.class 파일)를 해석하고 실행하는 가상 머신</li>\n    <li>JRE는 Java 프로그램을 실행하는 데 필요한 모든 것을 포함한다. 라이브러리 등</li>\n        <ul>\n            <li><em>JRE은 JVM을 시작, 필요한 클래스 라이브러리 로드, main() 메서드를 실행한다.</em></li>\n        </ul>\n    <li>JDK는 Java 애플리케이션을 개발하는 데 필요한 모든 도구를 포함한다.</li>\n</ul>\n</details>\n\n<p><br /></p>\n\n<h2 id=\"servlet-container-tomcat\">Servlet Container [Tomcat]</h2>\n\n<p>위에서 “Tomcat은 <strong><u>Servlet Container의 한 종류</u></strong>이며, <strong><u>Servlet/JSP 요청을 처리</u></strong>하는 역할을 한다.” 라고 했다.</p>\n\n<p>1) <strong>Servlet Container</strong>는 Servlet<strong>의 생명 주기</strong>를 관리하는 곳이다.</p>\n<ul>\n  <li>Servlet과 Servlet Container의 관계를 Bean과 Bean Container의 관계와 흡사하다고 생각하면 된다. (“컨테이너와 관리 대상”의 관계로 이해)\n    <ul>\n      <li>Servlet Container는 HTTP 요청과 응답을 처리하는 Servlet을 관리</li>\n      <li>Bean Container는 Spring의 <strong>애플리케이션 내 객체(Bean)</strong>의 생명 주기와 의존성을 관리</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2) 또한, <strong>HTTP 요청 처리 및 응답 생성 과정</strong>은 Servlet Container의 핵심 기능 중 하나이다.</p>\n<ul>\n  <li>웹 브라우저에서 요청이 들어오면, Tomcat은 그 요청을 받아서 적절한 Java 코드(서블릿)로 전달하고, 그 결과를 다시 브라우저로 보내는 역할을 한다.</li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"servlet\">Servlet</h2>\n\n<p>Servlet은 <strong>HTTP 요청을 처리하고 응답을 생성하는 스펙을 정의한 인터페이스</strong>이다.</p>\n<ul>\n  <li>Servlet은 <strong>jakarta.servlet.Servlet</strong>을 최상위 인터페이스로 가진다. (Java API)</li>\n</ul>\n\n<p>Servlet은 <strong>Servlet Container</strong>에 의해 관리되며, 요청이 들어오면 컨테이너가 Servlet의 생명 주기를 관리하고 요청을 처리하기 위한 스레드를 생성한다.</p>\n\n<p>Servlet은 HTTP 요청을 처리하고, 그에 따른 적절한 응답을 생성하는 기본 단위이다. 이를 통해 <span class=\"post-highlight\">REST API의 엔드포인트</span>가 되거나 <span class=\"post-highlight\">동적 웹 페이지를 생성</span>하는 역할을 수행할 수 있다.</p>\n\n<ol>\n  <li>Servlet은 HTTP 요청을 받아 비즈니스 로직을 처리하고 JSON, XML 등의 형식으로 데이터를 응답할 수 있다.</li>\n  <li>동적인 HTML 콘텐츠를 생성할 때도 사용된다.\n    <ul>\n      <li>예를 들어, 비즈니스 로직 처리가 필요한 HTTP 요청이 Web Server로 들어오면, Web Server는 이를 Servlet Container가 실행하는 Servlet에 전달한다.</li>\n      <li>Servlet은 요청을 처리하고 동적인 웹 콘텐츠를 생성한 뒤, 결과를 Web Server를 통해 클라이언트로 반환한다.</li>\n    </ul>\n  </li>\n</ol>\n\n<p>전체적인 통신 흐름은 다음과 같다.</p>\n<ul>\n  <li>WS 는 HTTP 요청을 받아 정적 리소스를 처리하거나, 요청을 WAS에 전달한다.</li>\n  <li>WAS는 Servlet Container를 통해 요청을 처리하고, 처리 결과를 Web Server를 거쳐 클라이언트에 반환한다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/06d2213c-0f90-4a1b-a765-33531aeed39d\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p><br /></p>\n\n<h3 id=\"servlet의-생명주기\">Servlet의 생명주기</h3>\n\n<p>위 그림을 보면 알 수 있듯, Servlet은 다음과 같은 생명 주기를 가진다.</p>\n\n<p>1) <strong>초기화 단계</strong>:</p>\n<ul>\n  <li>최초 요청이 오면 Servlet 클래스(HelloServlet.class)가 로딩된다.</li>\n  <li>web.xml 설정을 참고하여 매핑할 Servlet을 확인한다.</li>\n  <li><span class=\"post-highlight\">해당 Servlet 인스턴스가 있다면 사용하고, 없다면 init()으로 초기화한다.</span></li>\n</ul>\n\n<p>2) <strong>서비스 단계</strong>:</p>\n<ul>\n  <li>Servlet Container는 각 요청마다 새로운 스레드를 생성한다.</li>\n  <li>새로운 Request/Response 객체를 생성하여 service() 메서드를 실행한다.</li>\n  <li>service()는 요청 방식(GET, POST 등)에 따라 적절한 do메서드를 호출한다.</li>\n  <li>요청 처리가 완료되면 해당 Request/Response 객체는 소멸된다.</li>\n</ul>\n\n<p>3) <strong>소멸 단계</strong>:</p>\n<ul>\n  <li><em>서버 종료나 애플리케이션 재배포 시에만 destroy()가 호출된다.</em></li>\n  <li><em>Servlet이 사용하던 리소스를 정리한다.</em></li>\n</ul>\n\n<p><br /></p>\n\n<p>정리하자면,</p>\n<ul>\n  <li>Tomcat은 Servlet 객체를 한 번 생성하면 메모리에 유지하고, 요청이 올 때마다 해당 객체의 <strong>service()</strong> 메서드를 호출한다.</li>\n  <li>따라서, <strong>init()</strong> 메서드는 <strong>최초 요청 시(또는 설정에 따라 애플리케이션 시작 시)</strong> 단 한 번 실행된다.</li>\n  <li>또 종료되기 전이나 reload 전에 destroy()를 호출하여 매번 객체가 생성되는 것을 방지한다.</li>\n</ul>\n\n<p><strong>(🤔 궁금증) servlet은 왜 생성만 하고 제거는 안하지?</strong>\n만약 사용이 끝날 때마다 제거한다면 다음과 같은 문제가 있다.</p>\n<ul>\n  <li>모든 요청에 대해 servlet을 생성하고 소멸하는 것은 OS 와 JVM 에게 필요없는 부하를 일으킨다.\n    <ul>\n      <li>JVM의 <strong>Garbage Collection</strong>과 <strong>메모리 할당/해제</strong>를 빈번하게 유발</li>\n    </ul>\n  </li>\n  <li>동시에 다수의 요청이 들어올 경우 CPU 또는 메모리 리소스 소모에 대한 제한이 어렵다. \n결국 순간적으로 서버가 다운되거나 동시 처리에 문제가 생길 수 있다.\n    <ul>\n      <li><em>(참고로 Tomcat 3.2 이전 버전은 실제 매번 생성과 제거를 했다.)</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p><strong>(✨해결) 해답은 Servlet의 특징과 관리 방식에 있다.</strong></p>\n<ul>\n  <li>수많은 클라이언트의 요청을 동시에 처리해야 하는 WAS의 특성상,\nServlet은 싱글톤 패턴으로 관리하게 되었다.\n    <ul>\n      <li>한 번 생성된 Servlet 인스턴스는 메모리에 계속 유지된다.</li>\n      <li>모든 요청은 동일한 Servlet 인스턴스를 공유한다.</li>\n      <li>init()은 최초 요청 시 한 번만 실행된다.</li>\n      <li>destroy()는 서버 종료나 재배포 시에만 실행된다.</li>\n    </ul>\n  </li>\n  <li><em>(Tomcat 3.2 부터는 디폴트로 <span class=\"post-highlight\">싱글톤 패턴 도입</span>와 <span class=\"post-highlight\">Thread Pool</span> 을 사용)</em></li>\n</ul>\n\n<p><br /></p>\n\n<h1 id=\"servlet-처리-구조의-발전\">Servlet 처리 구조의 발전</h1>\n\n<h2 id=\"기존-servlet-처리-방식\">기존 Servlet 처리 방식</h2>\n\n<p>Tomcat은 다음과 같은 역할을 한다고 하였다.</p>\n<ul>\n  <li>Servlet Container로서 HTTP 요청과 응답을 처리하는 환경 제공</li>\n  <li>Servlet 객체의 생성, 초기화, 요청 처리, 소멸 등 <strong>생명주기를 관리</strong>하는 역할</li>\n</ul>\n\n<p><strong>(🤔 문제점) Servlet은 요청마다 개별적으로 처리 로직을 구현해야 하므로,</strong><br />\n<strong>비슷한 요청을 처리하는 여러 Servlet에서 <span class=\"post-highlight\">중복된 코드가 발생</span>할 수 있다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/7c5e684e-cd0f-4167-8e55-f3d24172f58e\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 기존 서블릿 방식 - 각 URL마다 서블릿을 따로 만들어야 했습니다</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserServlet</span> <span class=\"kd\">extends</span> <span class=\"nc\">HttpServlet</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">doGet</span><span class=\"o\">(</span><span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"nc\">HttpServletResponse</span> <span class=\"n\">response</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 로깅 처리</span>\n        <span class=\"c1\">// 인증 처리</span>\n        <span class=\"c1\">// 공통 에러 처리</span>\n        <span class=\"c1\">// 실제 비즈니스 로직</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProductServlet</span> <span class=\"kd\">extends</span> <span class=\"nc\">HttpServlet</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">doGet</span><span class=\"o\">(</span><span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"nc\">HttpServletResponse</span> <span class=\"n\">response</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 위와 동일한 로깅, 인증, 에러 처리 코드가 반복됨</span>\n        <span class=\"c1\">// 실제 비즈니스 로직</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>이러한 방식은 다음과 같은 문제가 있다.</p>\n<ol>\n  <li>하나의 서블릿 클래스에 너무 많은 책임이 집중된다.</li>\n  <li>URL 매핑, 파라미터 처리, 뷰 선택 등을 모두 수동으로 처리해야 함</li>\n  <li>모든 서블릿에서 공통 로직(로깅, 인증, 에러 처리 등)이 반복됨</li>\n  <li>각각의 서블릿을 web.xml에 일일이 등록해야 함<br />\n (web.xml : 웹 애플리케이션의 <strong>구성 정보</strong>를 제공)</li>\n</ol>\n\n<ul>\n  <li>과거 web.xml은 다음과 같은 중요한 정보들을 담고 있었다.\n    <ul>\n      <li>어떤 서블릿이 존재하는지</li>\n      <li>각 서블릿이 어떤 URL 패턴을 처리하는지</li>\n      <li>어떤 필터들이 요청을 처리하는지</li>\n      <li>웹 애플리케이션의 시작과 종료 시 필요한 리스너는 무엇인지</li>\n    </ul>\n  </li>\n</ul>\n\n<p>⇒ 각 서블릿(요청을 처리하는 클래스)에 대한 정보를 등록해야 한다는 것이다… 😢</p>\n\n<p><br /></p>\n\n<h2 id=\"dispatcherservlet---spring-mvc--공통-로직의-중앙-집중화\"><strong>DispatcherServlet</strong> - Spring MVC : 공통 로직의 중앙 집중화</h2>\n\n<p><strong>(✨ 해결책) 공통 로직의 중앙 집중화</strong></p>\n\n<p>Spring Framework는 기존 서블릿 스펙의 장점을 활용하면서도 그 한계를 개선하는 방향으로 발전했다.</p>\n\n<p><span class=\"post-highlight\">DispatcherServlet이라는 Front Controller를 사용해 공통 로직을 처리하고 요청에 맞는 컨트롤러를 호출하는 특수한 Servlet</span>을 만들어 새로운 구조를 도입했다.</p>\n\n<ul>\n  <li><em>참고로 <strong>DispatcherServlet</strong> 도 <strong>Servlet이다.</strong></em>\n    <ul>\n      <li><em>(이쯤에서 Spring에서의 Controller의 역할이 아구 맞게 떠오른다.)</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/945895b9-66a2-4713-b7a4-8461f3a66075\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>Spring MVC는 이러한 문제를 DispatcherServlet이라는 하나의 Front Controller로 해결했다.</p>\n\n<ul>\n  <li><em>이제 우리가 아는 친숙한 코드가 나온다….</em></li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Spring MVC 방식</span>\n<span class=\"nd\">@Controller</span>  <span class=\"c1\">// 더 이상 HttpServlet을 상속할 필요가 없음</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserController</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@GetMapping</span><span class=\"o\">(</span><span class=\"s\">\"/users\"</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">handleUsers</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 비즈니스 로직에만 집중</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"userList\"</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"nd\">@Controller</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProductController</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@GetMapping</span><span class=\"o\">(</span><span class=\"s\">\"/products\"</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">handleProducts</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 비즈니스 로직에만 집중</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"productList\"</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p><strong>DispatcherServlet</strong>은 다음과 같은 일을 한다.</p>\n\n<ol>\n  <li><strong>DispatcherServlet</strong>은 웹 애플리케이션에 들어오는 모든 HTTP 요청을 먼저 받는다.</li>\n  <li>요청을 <strong>어떤 컨트롤러가 처리할지 결정</strong>하고, 해당 컨트롤러로 요청을 <strong>디스패치(위임)</strong> 한다.</li>\n  <li>요청에 대해 <strong>공통 처리</strong>(예: 인증, 로깅 등)를 먼저 한 후, 적절한 컨트롤러로 요청을 전달한다.</li>\n  <li><strong>DispatcherServlet</strong> 덕분에, 이제 다른 컨트롤러는 굳이 서블릿을 상속할 필요가 없다.</li>\n</ol>\n\n<p>4번에 대해 추가 설명을 하자면, <strong>Spring MVC</strong>에서는 <strong>DispatcherServlet</strong>만 서블릿으로 등록하고, 실제 비즈니스 로직을 처리하는 <strong>컨트롤러</strong>는 <strong>서블릿</strong>이 아니어도 된다는 뜻이다.</p>\n\n<ul>\n  <li><strong>Spring MVC</strong>에서는 <strong>DispatcherServlet</strong>만 서블릿으로 등록하고, 실제 비즈니스 로직을 처리하는 <strong>컨트롤러</strong>는 <strong>서블릿</strong>이 아니어도 된다는 뜻이다.</li>\n  <li>Spring MVC의 <strong>컨트롤러</strong>는 단순한 <strong>자바 클래스</strong>로, <strong>@Controller</strong> 어노테이션을 붙인 클래스를 만들어 요청을 처리할 수 있다.</li>\n  <li>이때, <strong>컨트롤러 클래스는 Servlet을 상속하지 않아도</strong> 된다.</li>\n  <li><strong>DispatcherServlet</strong>이 모든 요청을 처리하고, 요청을 <strong>컨트롤러</strong>로 전달하기 때문에, 실제로는 <strong>서블릿이 아닌 컨트롤러</strong>가 <strong>Servlet 객체를 상속</strong>하지 않아도 된다는 뜻이다.</li>\n</ul>\n\n<p>이렇듯 Spring 프레임워크는 Front Controller를 제공해주고 이를 Dispather Servlet 이라 부른다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/f5b5a218-c501-43c6-8869-c0ccd63acc77\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p><br /></p>\n\n<h2 id=\"servlet과-dispatcherservlet의-역할-분담의-의의\"><strong>Servlet</strong>과 DispatcherServlet의 역할 분담의 의의</h2>\n\n<p>Servlet 표준에서 중요한 점은 Servlet이 <span class=\"post-highlight\">전체 데이터 처리 과정에서 특정한 역할만 수행</span>한다는 것이다.</p>\n\n<p><strong><u>전통적인 서블릿 방식</u></strong>에서는 HTTP 요청/응답 처리부터 비즈니스 로직까지 모든 것을 책임져야했다.</p>\n\n<p>변화한 Spring MVC 구조에는 다음과 같은 장점이 있다.</p>\n\n<p>1) <strong>관심사의 분리(Separation of Concerns)</strong></p>\n<ol>\n  <li>DispatcherServlet이 모든 HTTP 요청을 먼저 받아서 적절한 Controller로 라우팅하는 역할을 담당하게 되었다.</li>\n  <li>이로 인해 Controller는 비즈니스 로직에만 집중할 수 있게 되었다.</li>\n</ol>\n\n<p>2) <strong>POJO(Plain Old Java Object) 기반 개발</strong></p>\n<ol>\n  <li>Controller가 더 이상 HttpServlet을 상속받지 않아도 된다는 것은 매우 중요한 의미를 가진다.</li>\n  <li>이는 일반적인 자바 클래스로 웹 개발이 가능해졌다는 뜻이다.</li>\n</ol>\n\n<p>3) <strong>각 엔드포인트가 명확하게 분리된다.</strong></p>\n\n<p><br /></p>\n\n<p>⇒ Spring Boot는 이러한 통합을 더욱 단순화했다.</p>\n\n<p>개발자는 복잡한 설정 없이도 Tomcat과 Spring이 자연스럽게 협력하는 환경에서 개발할 수 있게 되었다.</p>\n\n<p>web.xml 없이도 자동 구성을 통해 모든 것이 가능해졌다.</p>\n\n<p><em>@SpringBootApplication 어노테이션은 다음 3가지 핵심 어노테이션의 조합이다.</em></p>\n\n<ol>\n  <li>@SpringBootConfiguration</li>\n  <li><span class=\"post-highlight\">@EnableAutoConfiguration</span> [자동 구성]</li>\n  <li>@ComponentScan</li>\n</ol>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@SpringBootApplication</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">MyApplication</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// Spring Boot가 내장 Tomcat을 자동으로 구성하고 시작</span>\n        <span class=\"nc\">SpringApplication</span><span class=\"o\">.</span><span class=\"na\">run</span><span class=\"o\">(</span><span class=\"nc\">MyApplication</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">,</span> <span class=\"n\">args</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>즉, 현대에 와서 <strong>DispatcherServlet이 서블릿 역할을 하면서</strong> 요청을 <strong>Controller</strong>에 전달하고, <strong>Controller</strong>는 <strong>서비스</strong>를 호출하여 실제 비즈니스 로직을 처리하게 하는 방식으로 발전하였다.</p>\n\n<ul>\n  <li>단지 <strong>DispatcherServlet</strong>은 요청을 받아서 적절한 컨트롤러에게 넘겨주는 역할을 한다.</li>\n</ul>\n\n<p>지금까지 살펴본 WAS의 발전 과정을 보면 다음과 같다.</p>\n<ol>\n  <li>WAS는 동적 컨텐츠 처리를 위한 웹 애플리케이션 서버로 분리되며 시작됐다.</li>\n  <li>Tomcat은 Servlet Container로서 Java 기반 웹 애플리케이션을 실행시킨다.</li>\n  <li>초기 Servlet 방식의 한계(중복 코드, 복잡한 설정)를 Spring MVC가 해결했다.</li>\n  <li>DispatcherServlet의 도입으로 공통 로직 처리와 요청 위임이 체계화되었다.</li>\n</ol>\n\n<p>결국 DispatcherServlet이 모든 요청을 받아 적절한 Controller에 위임하므로\nController는 순수 비즈니스 로직에만 집중할 수 있게 되었다.</p>\n<ul>\n  <li>개발자는 반복적인 설정 없이 핵심 기능 개발에 집중 가능!</li>\n</ul>\n\n<p>이처럼 WAS와 Servlet, 그리고 Spring MVC로 이어지는 발전 과정은 더 나은 웹 개발 환경을 만들어왔다.</p>\n\n<p>더 나아가, 웹 애플리케이션 아키텍처는 계속해서 진화하고 있다.</p>\n<ul>\n  <li>Spring WebFlux를 통한 리액티브 프로그래밍 도입</li>\n  <li>클라우드 네이티브 환경 지원</li>\n  <li>마이크로서비스 아키텍처로의 전환</li>\n  <li>서버리스 아키텍처의 등장</li>\n</ul>\n",
                        "tags": ["WAS","Tomcat","Servlet","SpringMVC","Java","WebDevelopment","Architecture","DispatcherServlet","SpringBoot"]
                    },
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    },
                
                    {
                        "title": "동기/비동기와 블로킹/논블로킹에 대해 깊이 파헤치기",
                        "url": "/2025/01/12/understanding-sync-async-blocking-non-blocking.html",
                        "subtitle": "Java/SpringBoot에서의 비동기 처리",
                        "excerpt": "1. 개념적 이해\n",
                        "author": "Jinho",
                        "date": "January 12, 2025",
                        "background": "/img/posts/sync-async-concept.jpeg",
                        "content": "<h1 id=\"1-개념적-이해\">1. 개념적 이해</h1>\n\n<p>비동기 처리에 대해 이야기하기 앞서, 과연 “동기”란 어떤 것인지부터 바로 잡고 가려고한다.</p>\n\n<p>왜냐하면 <strong>비(非)동기</strong>란 동기가 아니다라는 의미이기 때문에 동기가 무엇인지부터 정확히 하고 싶었다.</p>\n\n<p>또한 나는 처음에 ‘동기=블로킹, 비동기=논블로킹’이라고 단순하게 이해하고 있었다.</p>\n\n<p>하지만 실제로는 두 개념이 분류 기준이 전혀 다른 독립적인 개념이라는 것을 알게 되었다.</p>\n\n<p>이렇듯 서로 혼동되어 쓰이는 각 명칭은 어떤 의미인지 알아보려고 한다.</p>\n\n<p>이에 대해 자세히 알아보자.</p>\n\n<p><br /></p>\n\n<h1 id=\"2-동기와-비동기\">2. 동기와 비동기</h1>\n\n<p><img src=\"https://velog.velcdn.com/images/jinho7/post/a47f1973-3895-4438-a47f-80dd80245e41/image.png\" alt=\"\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<blockquote>\n  <p>동기와 비동기는 “작업의 처리 방식”을 나타내는 개념이다. <br />\n결론부터 말하자면, 이둘의 주요한 차이점은 “작업 순서 처리 차이”이다.</p>\n</blockquote>\n\n<h2 id=\"2-1-동기-순차적으로-실행\">2-1. 동기: 순차적으로 실행</h2>\n<p>필자는 이전에 동기를 <strong>겹치지 않고 순차적으로 작업을 진행하는 것</strong> 정도로 이해하고 있었다.</p>\n\n<p>영어 사전을 참고해보자.</p>\n\n<blockquote>\n  <p>synchronous\nadjective\nhappening or done at the same time or speed:</p>\n</blockquote>\n\n<p><strong>Synchronous</strong> 는 동시에 발생하는 두 개 이상의 사건이나 프로세스가 동일한 시간에서 진행되는 것을 의미하는 형용사이다.</p>\n\n<p>중요한 워딩은 [동일한 시간에 여러 개의 사건이 진행] 된다는 것이다.</p>\n\n<p>‘순차적’과 ‘동시’라는 단어가 서로 상충된다고 생각할 수 있다.</p>\n\n<p>여기서 오해하면 안되는 것이 이는 <strong>병렬적인 작업방식을 말하는 것이 아니다.</strong></p>\n\n<p>“어떠한 일정 시점에 현재 작업의 Response과 다음 작업의 Request이 함께 진행되는 것”</p>\n\n<p>위의 그림을 참고하면 이해가 쉽다.\n작업 A가 끝나는 시간과 작업 B가 시작하는 시간이 동기화된다고 이해하면 좋을 것 같다.</p>\n\n<p>이는 <strong>작업이 순차적으로 처리되며, 이전 작업이 완료될 때까지는 다음 작업이 시작되지 않음을 나타낸다.</strong></p>\n\n<p>즉, <strong>작업들이 서로 시간적 의존성을 가지고 실행된다</strong>는 뜻이다.</p>\n\n<p>동기 방식은 실행 순서가 보장되며 예측 가능하다는 장점이 있지만, <br />\n앞선 작업이 오래 걸리면 전체 작업이 지연된다는 단점도 있다.</p>\n\n<h2 id=\"2-2-비동기-독립적으로-실행\">2-2. 비동기: 독립적으로 실행</h2>\n<p>그렇다면 비동기 방식은 무엇일까?</p>\n\n<p>반대의 경우를 생각하면 된다.</p>\n\n<p>위의 그림을 참고하면 작업들이 병렬적으로 일어나고 있음을 알 수 있다.</p>\n\n<p>동기와 반대로 <strong>“요청을 보냈을 때 응답 상태와 상관없이 다른 동작을 수행할 수 있다.”</strong>는 점이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/0a188e4a-b35f-41aa-9953-94504330dd9f\" alt=\"다운로드\" width=\"68%\" height=\"50%\" class=\"center\" />\n<em class=\"image-caption\">파일 다운로드가 동기 방식이라면?</em></p>\n\n<p>만약에 파일 다운로드를 동기적으로 처리한다고 해보자.</p>\n\n<p>아마 파일이 다운로드될 때까지 아무런 작업도 수행할 수 없을 것이고,\n파일이 완전히 다운로드된 후에 다음 작업을 진행할 수 있을 것이다. 😅</p>\n\n<p>매우 비효율적인 방식이다…</p>\n\n<p>그러나 비동기적인 방식을 활용한다면, 파일 다운로드 작업을 시작시켜놓고, 다른 작업을 수행할 수 있다.</p>\n\n<p>파일이 다운로드되면 특정 콜백 함수를 호출하여, 다운로드된 파일을 처리하거나 결과를 반환받을 수 있다.</p>\n\n<p>콜백 뿐만이 아니고, 그 결과는 콜백 함수, Promise, 이벤트 등을 통해 전달받을 수 있다.</p>\n\n<p>마치 택배를 주문하고 배송 알림을 받는 것과 비슷하다고 할 수 있다.</p>\n\n<h3 id=\"비동기-동작-방식에-대한-오해\">비동기 동작 방식에 대한 오해</h3>\n<p>많은 개발자들이 <strong>비동기 = 멀티 쓰레드</strong>라고 이해하고 있다.</p>\n\n<p>단순히 생각해보아도, 여러 작업이 동시에 처리되는 비동기 동작을 구현하기 위해서는 당연히 여러 개의 쓰레드가 필요할 것 같기 때문이다.</p>\n\n<p>또한, 특히나 대부분의 Java 개발자들이 비동기 프로그래밍을 접할 때 아래와 같은 코드를 통해 배우기 때문이다.</p>\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 여기서 실제로 별도의 스레드에서 실행됨</span>\n    <span class=\"k\">return</span> <span class=\"nf\">heavyTask</span><span class=\"o\">();</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p>우리는 Java에서 비동기 처리에 대해 다룰 때, ExecutorService나 CompletableFuture와 같은 도구들을 함께 배운다.</p>\n\n<p>이들은 내부적으로 <strong>스레드 풀</strong>을 사용하기 때문에, 자연스럽게 비동기 처리와 멀티 쓰레드를 동일시하게 된다.</p>\n\n<p>실제로 Spring Framework의 @Async 어노테이션도 비동기 처리를 위해 기본적으로 스레드 풀을 사용한다.</p>\n\n<p>하지만 비동기 처리의 본질은 <strong>“작업의 완료를 기다리지 않고 다른 작업을 수행할 수 있는 것”</strong>이다.</p>\n\n<p>이는 반드시 멀티스레드로만 구현되어야 하는 것이 아니며, Node.js가 좋은 예시다.</p>\n\n<p>Node.js는 싱글 스레드 기반의 이벤트 루프를 사용하여 비동기 처리를 구현한다.</p>\n\n<p>이벤트 루프는 OS의 비동기 I/O 기능을 활용하여 실제 I/O 작업을 커널 레벨에서 처리하고,</p>\n\n<p>작업이 완료되면 이벤트를 통해 알림을 받는 방식으로 동작한다.</p>\n\n<div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Node.js의 비동기 처리 (싱글스레드)</span>\n<span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nf\">readFile</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">file.txt</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">파일 읽기 완료</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">다음 작업 실행</span><span class=\"dl\">'</span><span class=\"p\">);</span>  <span class=\"c1\">// 파일 읽기를 기다리지 않고 실행</span>\n</code></pre></div></div>\n<p>이러한 이벤트 루프 기반의 비동기 처리는 멀티스레드 없이도 효율적인 비동기 처리를 가능하게 한다.\nOS의 비동기 I/O 기능을 활용하여, 실제 I/O 작업은 커널 레벨에서 처리되고, 완료되면 이벤트를 통해 알림을 받는 방식이다.\n<em>정확히는 JavaScript 엔진이 싱글 스레드 기반이다</em>\n<em>해당 내용에 대해 더 자세히 알고 싶다면 <a href=\"https://puleugo.tistory.com/133\">해당 블로그</a>를 참고하자</em></p>\n\n<p><br /></p>\n\n<h1 id=\"3-블로킹과-논블로킹\">3. 블로킹과 논블로킹</h1>\n<blockquote>\n  <p>블로킹과 논블로킹은 “제어권의 이동” 관점에서 바라보는 개념이다.</p>\n</blockquote>\n\n<p>결국 “호출한 함수가 다른 일을 할 수 있는가?”의 여부를 의미한다.</p>\n\n<h2 id=\"3-1-제어권control-flow의-의미\">3-1. 제어권(Control Flow)의 의미</h2>\n<p>여기서 <strong>제어권</strong>이란 어떤 의미를 갖는지 먼저 보자.\nOS적인 관점에서 보자면, <strong>현재 작업을 진행하고 있는 함수가 CPU를 점유하는 것</strong>을 의미한다.\n쉽게 말해 “코드를 실행시킬 수 있는 권한” 정도로 말할 수 있다.</p>\n\n<p>동기 와 비동기는 Jobs 들이 순서대로 혹은 독립적으로 처리되는가에 관한 이야기라면,\n이번에는 호출한 함수가 별개의 일을 할 수 있는지의 이야기이다.</p>\n\n<h2 id=\"3-2-블로킹-제어권을-넘겨주는-방식\">3-2. 블로킹: 제어권을 넘겨주는 방식</h2>\n<p>마치 시험지를 넘겨주는 방식을 생각하면 편할 것 같다.\n<img src=\"https://github.com/user-attachments/assets/6eb36e86-150c-4144-86ce-6080ef86bece\" alt=\"image\" width=\"60%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : https://www.veritas-a.com/news/articleView.html?idxno=156699</em></p>\n\n<p>내가 뒷 사람에게 시험지를 넘겨줄 때,\n나는 아무런 행동도 하지 않고 <strong>뒷 사람(호출된 함수)가 시험지를 가져가는(자신의 작업을 완료)할 때 까지</strong> 나는 손에 시험지를 쥐고 뒷사람을 바라보고 대기할 수 밖에 없다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d799e31b-9406-44f3-8dcc-9df15b8f8a79\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>둘 간의 구분 방법은 제어권이 누구에게 있는지로 결정된다.</p>\n\n<p>블로킹에서는 함수 A가 함수 B를 호출할 때 제어권이 B로 넘어간다.</p>\n\n<p>제어권을 넘겨준 A는 B의 작업이 완료될 때까지 아무 작업도 수행할 수 없는 상태, 즉 블로킹 상태가 된다.</p>\n\n<p>즉, 위의 사진에서 A함수는 B함수에게 제어권을 넘겨줌과 동시에 함수 실행이 일시 정지된다. = Blocking</p>\n\n<h2 id=\"3-3-논블로킹-제어권을-유지하는-방식\">3-3. 논블로킹: 제어권을 유지하는 방식</h2>\n<p>하지만 시험지를 그냥 뒷 사람 책상에 올려 놓는다면 어떨까.</p>\n\n<p>나는 실제 뒷 사람이 받는 것을 대기할 필요없이, 바로 나의 다른 작업을 할 수 있다.</p>\n\n<p>즉, 뒷 사람(호출된 함수)이 나에 대한 제어권을 바로 반환해줌으로, 호출한 쪽(나)에서는 계속 다른 작업을 할 수 있는 것이다.</p>\n\n<p>같은 “읽기” 작업이어도 동기와 비동기 처리에 따라 어떻게 다르게 동작하는지 보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹: 제어권을 넘겨줌</span>\n<span class=\"nc\">String</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">readFile</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 파일 읽을 때까지 다른 일 못함</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                          <span class=\"c1\">// 파일 다 읽고 나서야 실행</span>\n\n<span class=\"c1\">// 논블로킹: 제어권을 유지</span>\n<span class=\"nc\">Future</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">readFileAsync</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 요청만 하고</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                               <span class=\"c1\">// 바로 다른 일 할 수 있음</span>\n</code></pre></div></div>\n<p><img src=\"https://github.com/user-attachments/assets/4a59addb-b12d-4eaa-90c9-fe783a7556e0\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>반면 논블로킹에서는 A함수가 B함수를 호출하더라도 제어권을 계속 유지한다.</p>\n\n<p>따라서 B함수가 실행되는 동안에도, A함수는 제어권을 가지고 있기 때문에 다른 작업을 수행할 수 있다.</p>\n\n<p>이렇게 호출자(caller)인 A함수는 B함수의 작업 완료 여부와 관계없이 자신의 작업을 계속 수행할 수 있다.</p>\n\n<p><br /></p>\n\n<h1 id=\"4-네-가지-조합의-동작-방식\">4. 네 가지 조합의 동작 방식</h1>\n\n<p>가끔 동기 처리에서는 무조건적으로 블로킹이 일어나고, 비동기에서는 논블로킹이 일어난다고 오해하는 경우가 많다.</p>\n\n<p>하지만 두 쌍의 개념은 서로 다른 관점에서 바라보는 개념이라는 것을 확실하게 하고 넘어가자.</p>\n\n<blockquote>\n  <p>동기/비동기 : 작업들의 시간적 관계성 <br />\n블로킹/논블로킹 : 제어권의 소재</p>\n</blockquote>\n\n<p>하지만 이 개념들이 오해가 잦은 이유는 실제 구현에서 [동기/볼로킹 &amp; 비동기/논블로킹]이 <strong>자주 함께 사용</strong>되기 때문이다.</p>\n\n<p>다음 그림을 보고 4가지 조합에 대해 천천히 살펴보자.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b894be55-d296-424d-913f-ee989233eb60\" alt=\"image\" width=\"100%\" class=\"center\" /></p>\n\n<p>먼저 흔히 쓰이는 [동기/볼로킹 &amp; 비동기/논블로킹] 에 대해 보자.</p>\n\n<h2 id=\"4-1-동기--블로킹\">4-1. 동기 + 블로킹</h2>\n\n<p>작업의 흐름이 순차적으로 진행되는 것이 보장된다. (<strong>동기</strong>)</p>\n\n<p>제어권을 함수 B에게 넘겨준 후 함수 A는 대기하게 된다. (<strong>블로킹</strong>)</p>\n\n<p>함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄 때까지 함수 A는 기다리는 것이다.</p>\n\n<blockquote>\n  <p>이러한 조합은 <strong>작업이 완료될 때까지 기다려야 하는 경우</strong>에 사용된다. <br />\n예를 들면, 파일을 읽은 후 이를 처리하는 코드를 생각해보자. <br />\n파일을 처리하는 과정은 <strong>필연적으로 파일을 모두 읽은 후에 작업이 가능</strong>하기 때문이다. <br />\n또한, 일반적으로 작업이 간단하거나 작업량이 적은 경우에 사용된다. <br />\n작업량이 많거나 오래 걸리는 작업을 해당 방식으로 처리하면 <strong>전체 프로그램이 멈춘 것 처럼 보여</strong> 사용자 경험 측면에서 나빠질 수 있다.</p>\n</blockquote>\n\n<h2 id=\"4-2-비동기--논블로킹\">4-2. 비동기 + 논블로킹</h2>\n\n<p>비동기 + 논블로킹 방식도 비교적 이해가 쉽다.</p>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다. (<strong>논블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 방식이다. (<strong>동기</strong>)</p>\n\n<p>함수 B를 호출 할 때, 콜백 함수를 함께 줌으로써, 함수 B는 자신의 작업이 끝났을 때 <strong>함수 A에게 준 콜백 함수를 실행시켜 자신의 작업이 끝났음</strong>을 알려준다.</p>\n\n<p>작업 A는 함수 B의 종료 여부에는 일단 관심이 없다.</p>\n\n<p>B 함수가 자신의 실행을 완료했다면, A 함수의 어깨를 톡톡 쳐서 알려주면 되는 것이다.</p>\n\n<blockquote>\n  <p>다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우에 활용할 수 있다. <br />\n또한, 대용량의 데이터를 처리하는 서비스에서 흔히 사용된다. <br />\n가장 큰 특징은 호출 함수에 콜백 함수를 넣었다는 점이다.</p>\n</blockquote>\n\n<h2 id=\"4-3-동기--논블로킹\">4-3. 동기 + 논블로킹</h2>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다.</p>\n\n<p>이후 바로 자신의 코드를 실행한다. (<strong>논블로킹</strong>)</p>\n\n<p>즉, 다른 작업이 진행되는 동안에도 자신의 작업을 별개로 처리할 수 있다.</p>\n\n<p>조심할 것이 함수 A는 함수 B의 Return 값을 필요로 하는 것은 변함이 없다는 점이다.</p>\n\n<p>A 함수는 B 함수의 리턴값이 필요하기 때문에, 중간중간 B 함수에게 함수 실행을 완료했는지 물어본다.</p>\n\n<p>즉, A 함수(caller)가 B 함수(callee)의 실행이 종료되었는지 계속 예의 주시해야 한다. (순서 보장을 위해)</p>\n\n<p>이로써 작업을 순차대로 수행할 수 있는 것이다. (<strong>동기</strong>)</p>\n\n<p>여기서 조금 더 깊게 생각해보자.</p>\n\n<p>어떻게 동기적으로 진행되면서 메인 쓰레드가 논블로킹이 될 수 있을까?</p>\n\n<p>이 조합의 특징은 “작업 완료는 비동기로 처리하지만, 호출자는 필요할 때 결과를 동기적으로 받는다.”로 정리할 수 있다.</p>\n\n<p>즉, <strong>순서를 유지하면서 결과를 사용해야 할 때 동기적으로 기다릴 수 있다.</strong></p>\n\n<p>결국 <strong>동기적</strong> 이라는 말은 <strong>호출자의 결과가 필요한 시점에서 순서를 보장</strong>하며 작업을 진행한다는 것이다.</p>\n\n<p>다음 JAVA 코드의 예시를 봐보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SimpleDownloader</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>  <span class=\"c1\">// 다운로드 진행률</span>\n        \n        <span class=\"c1\">// 다운로드 시작</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"파일 다운로드를 시작합니다.\"</span><span class=\"o\">);</span>\n        \n        <span class=\"c1\">// 진행률 확인하면서 다른 작업 수행 (논블로킹)</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">downloadProgress</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">{</span>  <span class=\"c1\">// 동기적: 순서 보장</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"진행률: \"</span> <span class=\"o\">+</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">+</span> <span class=\"s\">\"%\"</span><span class=\"o\">);</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다른 작업을 할 수 있어요!\"</span><span class=\"o\">);</span>\n            \n            <span class=\"c1\">// 진행률이 증가한다고 가정</span>\n            <span class=\"n\">downloadProgress</span> <span class=\"o\">+=</span> <span class=\"mi\">20</span><span class=\"o\">;</span>\n            \n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>  <span class=\"c1\">// 1초 대기</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        \n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다운로드 완료!\"</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><em>🚨 주의: 이 예시 코드는 Thread를 사용하고 있다. <br />\nThread는 기본적으로 작업을 병렬적으로 처리하기 위한 도구이다. <br />\n비동기 프로그래밍에서는 이러한 Thread의 병렬 처리 능력을 활용하여 비동기 작업을 구현하는 것이 일반적이다. <br />\n하지만 이 예시의 주된 목적은 작업이 어떻게 논블로킹하면서도 동기적으로 처리될 수 있는지를 시각적으로 보여주는 것이다. <br />\nThread를 사용한 것은 개념을 쉽게 설명하기 위한 것이다.</em></p>\n\n<p>이 코드의 결과는 다음과 같을 것이다.</p>\n<div class=\"language-css highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">나는</span> <span class=\"nt\">다른</span> <span class=\"nt\">작업을</span> <span class=\"nt\">진행할게</span><span class=\"o\">.</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">시작</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">0</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">1</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">2</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">완료</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드</span> <span class=\"nt\">종료</span> <span class=\"nt\">확인</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">모든</span> <span class=\"nt\">작업</span> <span class=\"nt\">완료</span><span class=\"o\">.</span>\n</code></pre></div></div>\n\n<p>물론, 논블로킹 메서드로 비동기 작업을 시작하더라도, 결과를 기다려야 하는 시점에서는 블로킹처럼 동작할 수 있다. <br />\n왜냐하면 메인 스레드가 결과를 받아야만 다음 작업을 진행할 수 있기 때문에, 그 시점에서는 블로킹이 되는 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b43ec8c4-9783-4fbf-9f7a-3736dff051bb\" alt=\"image\" width=\"80%\" class=\"center\" /></p>\n\n<p>사실 이러한 방식의 구현은 흔치 않다. <br />\n하지만, 몇 가지 활용 예를 알아보자면 <strong>게임 로딩화면 구성</strong> 등에 활용될 수 있다. <br />\n보통 게임에서 패치나 다운로드를 할 때, 사용자에게 ProgressBar나 게임 Tip등을 띄워줘야 할 때가 있다. <br />\n이 때는 Load 하는 동작이 완료될 때 까지 (작업 순서는 보장 = Sync) <br />\n다른 작업이 진행될 수 있다. (Non-Blocking)\n즉, 사용자 경험 측면에서 유용하게 활용될 수 있다.</p>\n\n<blockquote>\n  <p>언어 간에는 구현 방식에 차이가 있을 수 있다. <br />\n이는 각 언어의 특성과 제공되는 라이브러리나 기술에 따라 달라질 수 있다. <br />\n예를 들어, JavaScript는 단일 스레드 기반으로 동작하며, 콜백 함수, 프로미스(Promise), async/await 등의 메커니즘을 사용해 동기와 논블로킹 처리를 구현할 수 있다. <br />\n기본적으로 Promise.then 방식은 비동기적이고 논블로킹 방식으로 처리된다. <br />\n그러나 async/await 키워드를 사용하면, 비동기 작업의 순서를 지정할 수 있다.<br />\n중요한 점은, async 함수가 내부적으로 비동기적으로 동작하며, 메인 콜 스택이 모두 비워져야 실행된다는 것이다. <br />\n이로 인해 async/await도 내부적으로는 여전히 비동기적이고 논블로킹 방식으로 동작한다는 점을 유의해야 한다.\n(동기적인 코드 흐름처럼 보이게 하는 트릭)</p>\n</blockquote>\n\n<h2 id=\"4-4-비동기--블로킹\">4-4. 비동기 + 블로킹</h2>\n\n<p>이러한 방식은 사실 실무에서 마주치기 더더욱 흔치 않다.</p>\n\n<p>개념만 간단히 설명하자면,</p>\n\n<p>다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다린다. (<strong>블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않고, 콜백함수를 보낸 후 기다린다.</p>\n\n<p>이로써 작업 완료의 순서는 보장되지 않을 수 있다. (<strong>비동기</strong>)</p>\n\n<p><strong>즉, 함수 A는 자신과 관련없는 함수 B의 작업이 끝날 때까지 기다려야 한다.</strong>\n<em>매우 비효율적인 로직…</em></p>\n\n<p>1 작업 중에 2 작업을 해야지 Async의 이점을 살릴 수 있는 것인데,\n이것을 다시 Blocking 방식을 사용함여 대기시킴으로써 이점을 제거해버린 것이다…😅\n대부분의 경우 비동기+논블로킹 모델이 더 효율적인 선택이 될 것이다.</p>\n\n<p><br /></p>\n\n<h1 id=\"5-현대-프로그래밍에서-이러한-개념이-왜-중요한가\">5. 현대 프로그래밍에서 이러한 개념이 왜 중요한가?</h1>\n\n<p>이러한 이해는 현대 소프트웨어 개발에서 매우 중요하다. 오늘날의 애플리케이션들은 수많은 동시다발적인 작업을 처리해야 한다. 사용자는 파일을 다운로드하면서 동시에 문서를 편집하길 원하고, 데이터가 백그라운드에서 처리되는 동안에도 끊김 없는 인터페이스 사용을 기대한다.</p>\n\n<p>더군다나 클라우드 컴퓨팅과 마이크로서비스 아키텍처가 보편화된 현대 개발 환경에서는, 네트워크를 통한 수많은 비동기 작업들이 동시에 발생한다. 이때 각 작업을 어떻게 처리할지, 작업 간의 의존성은 어떻게 관리할지를 결정하는 것은 시스템의 성능과 사용자 경험을 좌우하는 핵심 요소가 된다.</p>\n\n<p>결국 이러한 개념들의 이해는 단순히 기술적인 지식을 넘어서, 현대 소프트웨어가 직면한 복잡성과 사용자 경험의 요구사항을 어떻게 조화롭게 해결할 수 있을지에 대한 통찰을 제공한다. 이는 우리가 더 효율적이고, 반응성 높은, 그리고 사용자 친화적인 소프트웨어를 설계하고 구현하는 데 있어 필수적인 기반이 될 것이다.</p>\n\n<h1 id=\"6-마무리\">6. 마무리</h1>\n<p>그렇다면 Java에서는 이러한 비동기 처리를 어떻게 구현할 수 있을까?</p>\n\n<p>Java의 비동기 프로그래밍은 Thread를 시작으로, 현대적인 CompletableFuture까지 꾸준히 발전해왔다.</p>\n\n<p>이제 각각의 방식을 자세히 살펴보겠다.</p>\n",
                        "tags": ["Java","Spring-Boot","Backend","Sync","Async","Concurrency","Blocking","NonBlocking"]
                    }
                
            ],
        
            "Spring-Boot": [
                
                    {
                        "title": "동기/비동기와 블로킹/논블로킹에 대해 깊이 파헤치기",
                        "url": "/2025/01/12/understanding-sync-async-blocking-non-blocking.html",
                        "subtitle": "Java/SpringBoot에서의 비동기 처리",
                        "excerpt": "1. 개념적 이해\n",
                        "author": "Jinho",
                        "date": "January 12, 2025",
                        "background": "/img/posts/sync-async-concept.jpeg",
                        "content": "<h1 id=\"1-개념적-이해\">1. 개념적 이해</h1>\n\n<p>비동기 처리에 대해 이야기하기 앞서, 과연 “동기”란 어떤 것인지부터 바로 잡고 가려고한다.</p>\n\n<p>왜냐하면 <strong>비(非)동기</strong>란 동기가 아니다라는 의미이기 때문에 동기가 무엇인지부터 정확히 하고 싶었다.</p>\n\n<p>또한 나는 처음에 ‘동기=블로킹, 비동기=논블로킹’이라고 단순하게 이해하고 있었다.</p>\n\n<p>하지만 실제로는 두 개념이 분류 기준이 전혀 다른 독립적인 개념이라는 것을 알게 되었다.</p>\n\n<p>이렇듯 서로 혼동되어 쓰이는 각 명칭은 어떤 의미인지 알아보려고 한다.</p>\n\n<p>이에 대해 자세히 알아보자.</p>\n\n<p><br /></p>\n\n<h1 id=\"2-동기와-비동기\">2. 동기와 비동기</h1>\n\n<p><img src=\"https://velog.velcdn.com/images/jinho7/post/a47f1973-3895-4438-a47f-80dd80245e41/image.png\" alt=\"\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<blockquote>\n  <p>동기와 비동기는 “작업의 처리 방식”을 나타내는 개념이다. <br />\n결론부터 말하자면, 이둘의 주요한 차이점은 “작업 순서 처리 차이”이다.</p>\n</blockquote>\n\n<h2 id=\"2-1-동기-순차적으로-실행\">2-1. 동기: 순차적으로 실행</h2>\n<p>필자는 이전에 동기를 <strong>겹치지 않고 순차적으로 작업을 진행하는 것</strong> 정도로 이해하고 있었다.</p>\n\n<p>영어 사전을 참고해보자.</p>\n\n<blockquote>\n  <p>synchronous\nadjective\nhappening or done at the same time or speed:</p>\n</blockquote>\n\n<p><strong>Synchronous</strong> 는 동시에 발생하는 두 개 이상의 사건이나 프로세스가 동일한 시간에서 진행되는 것을 의미하는 형용사이다.</p>\n\n<p>중요한 워딩은 [동일한 시간에 여러 개의 사건이 진행] 된다는 것이다.</p>\n\n<p>‘순차적’과 ‘동시’라는 단어가 서로 상충된다고 생각할 수 있다.</p>\n\n<p>여기서 오해하면 안되는 것이 이는 <strong>병렬적인 작업방식을 말하는 것이 아니다.</strong></p>\n\n<p>“어떠한 일정 시점에 현재 작업의 Response과 다음 작업의 Request이 함께 진행되는 것”</p>\n\n<p>위의 그림을 참고하면 이해가 쉽다.\n작업 A가 끝나는 시간과 작업 B가 시작하는 시간이 동기화된다고 이해하면 좋을 것 같다.</p>\n\n<p>이는 <strong>작업이 순차적으로 처리되며, 이전 작업이 완료될 때까지는 다음 작업이 시작되지 않음을 나타낸다.</strong></p>\n\n<p>즉, <strong>작업들이 서로 시간적 의존성을 가지고 실행된다</strong>는 뜻이다.</p>\n\n<p>동기 방식은 실행 순서가 보장되며 예측 가능하다는 장점이 있지만, <br />\n앞선 작업이 오래 걸리면 전체 작업이 지연된다는 단점도 있다.</p>\n\n<h2 id=\"2-2-비동기-독립적으로-실행\">2-2. 비동기: 독립적으로 실행</h2>\n<p>그렇다면 비동기 방식은 무엇일까?</p>\n\n<p>반대의 경우를 생각하면 된다.</p>\n\n<p>위의 그림을 참고하면 작업들이 병렬적으로 일어나고 있음을 알 수 있다.</p>\n\n<p>동기와 반대로 <strong>“요청을 보냈을 때 응답 상태와 상관없이 다른 동작을 수행할 수 있다.”</strong>는 점이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/0a188e4a-b35f-41aa-9953-94504330dd9f\" alt=\"다운로드\" width=\"68%\" height=\"50%\" class=\"center\" />\n<em class=\"image-caption\">파일 다운로드가 동기 방식이라면?</em></p>\n\n<p>만약에 파일 다운로드를 동기적으로 처리한다고 해보자.</p>\n\n<p>아마 파일이 다운로드될 때까지 아무런 작업도 수행할 수 없을 것이고,\n파일이 완전히 다운로드된 후에 다음 작업을 진행할 수 있을 것이다. 😅</p>\n\n<p>매우 비효율적인 방식이다…</p>\n\n<p>그러나 비동기적인 방식을 활용한다면, 파일 다운로드 작업을 시작시켜놓고, 다른 작업을 수행할 수 있다.</p>\n\n<p>파일이 다운로드되면 특정 콜백 함수를 호출하여, 다운로드된 파일을 처리하거나 결과를 반환받을 수 있다.</p>\n\n<p>콜백 뿐만이 아니고, 그 결과는 콜백 함수, Promise, 이벤트 등을 통해 전달받을 수 있다.</p>\n\n<p>마치 택배를 주문하고 배송 알림을 받는 것과 비슷하다고 할 수 있다.</p>\n\n<h3 id=\"비동기-동작-방식에-대한-오해\">비동기 동작 방식에 대한 오해</h3>\n<p>많은 개발자들이 <strong>비동기 = 멀티 쓰레드</strong>라고 이해하고 있다.</p>\n\n<p>단순히 생각해보아도, 여러 작업이 동시에 처리되는 비동기 동작을 구현하기 위해서는 당연히 여러 개의 쓰레드가 필요할 것 같기 때문이다.</p>\n\n<p>또한, 특히나 대부분의 Java 개발자들이 비동기 프로그래밍을 접할 때 아래와 같은 코드를 통해 배우기 때문이다.</p>\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 여기서 실제로 별도의 스레드에서 실행됨</span>\n    <span class=\"k\">return</span> <span class=\"nf\">heavyTask</span><span class=\"o\">();</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p>우리는 Java에서 비동기 처리에 대해 다룰 때, ExecutorService나 CompletableFuture와 같은 도구들을 함께 배운다.</p>\n\n<p>이들은 내부적으로 <strong>스레드 풀</strong>을 사용하기 때문에, 자연스럽게 비동기 처리와 멀티 쓰레드를 동일시하게 된다.</p>\n\n<p>실제로 Spring Framework의 @Async 어노테이션도 비동기 처리를 위해 기본적으로 스레드 풀을 사용한다.</p>\n\n<p>하지만 비동기 처리의 본질은 <strong>“작업의 완료를 기다리지 않고 다른 작업을 수행할 수 있는 것”</strong>이다.</p>\n\n<p>이는 반드시 멀티스레드로만 구현되어야 하는 것이 아니며, Node.js가 좋은 예시다.</p>\n\n<p>Node.js는 싱글 스레드 기반의 이벤트 루프를 사용하여 비동기 처리를 구현한다.</p>\n\n<p>이벤트 루프는 OS의 비동기 I/O 기능을 활용하여 실제 I/O 작업을 커널 레벨에서 처리하고,</p>\n\n<p>작업이 완료되면 이벤트를 통해 알림을 받는 방식으로 동작한다.</p>\n\n<div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Node.js의 비동기 처리 (싱글스레드)</span>\n<span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nf\">readFile</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">file.txt</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">파일 읽기 완료</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">다음 작업 실행</span><span class=\"dl\">'</span><span class=\"p\">);</span>  <span class=\"c1\">// 파일 읽기를 기다리지 않고 실행</span>\n</code></pre></div></div>\n<p>이러한 이벤트 루프 기반의 비동기 처리는 멀티스레드 없이도 효율적인 비동기 처리를 가능하게 한다.\nOS의 비동기 I/O 기능을 활용하여, 실제 I/O 작업은 커널 레벨에서 처리되고, 완료되면 이벤트를 통해 알림을 받는 방식이다.\n<em>정확히는 JavaScript 엔진이 싱글 스레드 기반이다</em>\n<em>해당 내용에 대해 더 자세히 알고 싶다면 <a href=\"https://puleugo.tistory.com/133\">해당 블로그</a>를 참고하자</em></p>\n\n<p><br /></p>\n\n<h1 id=\"3-블로킹과-논블로킹\">3. 블로킹과 논블로킹</h1>\n<blockquote>\n  <p>블로킹과 논블로킹은 “제어권의 이동” 관점에서 바라보는 개념이다.</p>\n</blockquote>\n\n<p>결국 “호출한 함수가 다른 일을 할 수 있는가?”의 여부를 의미한다.</p>\n\n<h2 id=\"3-1-제어권control-flow의-의미\">3-1. 제어권(Control Flow)의 의미</h2>\n<p>여기서 <strong>제어권</strong>이란 어떤 의미를 갖는지 먼저 보자.\nOS적인 관점에서 보자면, <strong>현재 작업을 진행하고 있는 함수가 CPU를 점유하는 것</strong>을 의미한다.\n쉽게 말해 “코드를 실행시킬 수 있는 권한” 정도로 말할 수 있다.</p>\n\n<p>동기 와 비동기는 Jobs 들이 순서대로 혹은 독립적으로 처리되는가에 관한 이야기라면,\n이번에는 호출한 함수가 별개의 일을 할 수 있는지의 이야기이다.</p>\n\n<h2 id=\"3-2-블로킹-제어권을-넘겨주는-방식\">3-2. 블로킹: 제어권을 넘겨주는 방식</h2>\n<p>마치 시험지를 넘겨주는 방식을 생각하면 편할 것 같다.\n<img src=\"https://github.com/user-attachments/assets/6eb36e86-150c-4144-86ce-6080ef86bece\" alt=\"image\" width=\"60%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : https://www.veritas-a.com/news/articleView.html?idxno=156699</em></p>\n\n<p>내가 뒷 사람에게 시험지를 넘겨줄 때,\n나는 아무런 행동도 하지 않고 <strong>뒷 사람(호출된 함수)가 시험지를 가져가는(자신의 작업을 완료)할 때 까지</strong> 나는 손에 시험지를 쥐고 뒷사람을 바라보고 대기할 수 밖에 없다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d799e31b-9406-44f3-8dcc-9df15b8f8a79\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>둘 간의 구분 방법은 제어권이 누구에게 있는지로 결정된다.</p>\n\n<p>블로킹에서는 함수 A가 함수 B를 호출할 때 제어권이 B로 넘어간다.</p>\n\n<p>제어권을 넘겨준 A는 B의 작업이 완료될 때까지 아무 작업도 수행할 수 없는 상태, 즉 블로킹 상태가 된다.</p>\n\n<p>즉, 위의 사진에서 A함수는 B함수에게 제어권을 넘겨줌과 동시에 함수 실행이 일시 정지된다. = Blocking</p>\n\n<h2 id=\"3-3-논블로킹-제어권을-유지하는-방식\">3-3. 논블로킹: 제어권을 유지하는 방식</h2>\n<p>하지만 시험지를 그냥 뒷 사람 책상에 올려 놓는다면 어떨까.</p>\n\n<p>나는 실제 뒷 사람이 받는 것을 대기할 필요없이, 바로 나의 다른 작업을 할 수 있다.</p>\n\n<p>즉, 뒷 사람(호출된 함수)이 나에 대한 제어권을 바로 반환해줌으로, 호출한 쪽(나)에서는 계속 다른 작업을 할 수 있는 것이다.</p>\n\n<p>같은 “읽기” 작업이어도 동기와 비동기 처리에 따라 어떻게 다르게 동작하는지 보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹: 제어권을 넘겨줌</span>\n<span class=\"nc\">String</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">readFile</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 파일 읽을 때까지 다른 일 못함</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                          <span class=\"c1\">// 파일 다 읽고 나서야 실행</span>\n\n<span class=\"c1\">// 논블로킹: 제어권을 유지</span>\n<span class=\"nc\">Future</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">readFileAsync</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 요청만 하고</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                               <span class=\"c1\">// 바로 다른 일 할 수 있음</span>\n</code></pre></div></div>\n<p><img src=\"https://github.com/user-attachments/assets/4a59addb-b12d-4eaa-90c9-fe783a7556e0\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>반면 논블로킹에서는 A함수가 B함수를 호출하더라도 제어권을 계속 유지한다.</p>\n\n<p>따라서 B함수가 실행되는 동안에도, A함수는 제어권을 가지고 있기 때문에 다른 작업을 수행할 수 있다.</p>\n\n<p>이렇게 호출자(caller)인 A함수는 B함수의 작업 완료 여부와 관계없이 자신의 작업을 계속 수행할 수 있다.</p>\n\n<p><br /></p>\n\n<h1 id=\"4-네-가지-조합의-동작-방식\">4. 네 가지 조합의 동작 방식</h1>\n\n<p>가끔 동기 처리에서는 무조건적으로 블로킹이 일어나고, 비동기에서는 논블로킹이 일어난다고 오해하는 경우가 많다.</p>\n\n<p>하지만 두 쌍의 개념은 서로 다른 관점에서 바라보는 개념이라는 것을 확실하게 하고 넘어가자.</p>\n\n<blockquote>\n  <p>동기/비동기 : 작업들의 시간적 관계성 <br />\n블로킹/논블로킹 : 제어권의 소재</p>\n</blockquote>\n\n<p>하지만 이 개념들이 오해가 잦은 이유는 실제 구현에서 [동기/볼로킹 &amp; 비동기/논블로킹]이 <strong>자주 함께 사용</strong>되기 때문이다.</p>\n\n<p>다음 그림을 보고 4가지 조합에 대해 천천히 살펴보자.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b894be55-d296-424d-913f-ee989233eb60\" alt=\"image\" width=\"100%\" class=\"center\" /></p>\n\n<p>먼저 흔히 쓰이는 [동기/볼로킹 &amp; 비동기/논블로킹] 에 대해 보자.</p>\n\n<h2 id=\"4-1-동기--블로킹\">4-1. 동기 + 블로킹</h2>\n\n<p>작업의 흐름이 순차적으로 진행되는 것이 보장된다. (<strong>동기</strong>)</p>\n\n<p>제어권을 함수 B에게 넘겨준 후 함수 A는 대기하게 된다. (<strong>블로킹</strong>)</p>\n\n<p>함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄 때까지 함수 A는 기다리는 것이다.</p>\n\n<blockquote>\n  <p>이러한 조합은 <strong>작업이 완료될 때까지 기다려야 하는 경우</strong>에 사용된다. <br />\n예를 들면, 파일을 읽은 후 이를 처리하는 코드를 생각해보자. <br />\n파일을 처리하는 과정은 <strong>필연적으로 파일을 모두 읽은 후에 작업이 가능</strong>하기 때문이다. <br />\n또한, 일반적으로 작업이 간단하거나 작업량이 적은 경우에 사용된다. <br />\n작업량이 많거나 오래 걸리는 작업을 해당 방식으로 처리하면 <strong>전체 프로그램이 멈춘 것 처럼 보여</strong> 사용자 경험 측면에서 나빠질 수 있다.</p>\n</blockquote>\n\n<h2 id=\"4-2-비동기--논블로킹\">4-2. 비동기 + 논블로킹</h2>\n\n<p>비동기 + 논블로킹 방식도 비교적 이해가 쉽다.</p>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다. (<strong>논블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 방식이다. (<strong>동기</strong>)</p>\n\n<p>함수 B를 호출 할 때, 콜백 함수를 함께 줌으로써, 함수 B는 자신의 작업이 끝났을 때 <strong>함수 A에게 준 콜백 함수를 실행시켜 자신의 작업이 끝났음</strong>을 알려준다.</p>\n\n<p>작업 A는 함수 B의 종료 여부에는 일단 관심이 없다.</p>\n\n<p>B 함수가 자신의 실행을 완료했다면, A 함수의 어깨를 톡톡 쳐서 알려주면 되는 것이다.</p>\n\n<blockquote>\n  <p>다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우에 활용할 수 있다. <br />\n또한, 대용량의 데이터를 처리하는 서비스에서 흔히 사용된다. <br />\n가장 큰 특징은 호출 함수에 콜백 함수를 넣었다는 점이다.</p>\n</blockquote>\n\n<h2 id=\"4-3-동기--논블로킹\">4-3. 동기 + 논블로킹</h2>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다.</p>\n\n<p>이후 바로 자신의 코드를 실행한다. (<strong>논블로킹</strong>)</p>\n\n<p>즉, 다른 작업이 진행되는 동안에도 자신의 작업을 별개로 처리할 수 있다.</p>\n\n<p>조심할 것이 함수 A는 함수 B의 Return 값을 필요로 하는 것은 변함이 없다는 점이다.</p>\n\n<p>A 함수는 B 함수의 리턴값이 필요하기 때문에, 중간중간 B 함수에게 함수 실행을 완료했는지 물어본다.</p>\n\n<p>즉, A 함수(caller)가 B 함수(callee)의 실행이 종료되었는지 계속 예의 주시해야 한다. (순서 보장을 위해)</p>\n\n<p>이로써 작업을 순차대로 수행할 수 있는 것이다. (<strong>동기</strong>)</p>\n\n<p>여기서 조금 더 깊게 생각해보자.</p>\n\n<p>어떻게 동기적으로 진행되면서 메인 쓰레드가 논블로킹이 될 수 있을까?</p>\n\n<p>이 조합의 특징은 “작업 완료는 비동기로 처리하지만, 호출자는 필요할 때 결과를 동기적으로 받는다.”로 정리할 수 있다.</p>\n\n<p>즉, <strong>순서를 유지하면서 결과를 사용해야 할 때 동기적으로 기다릴 수 있다.</strong></p>\n\n<p>결국 <strong>동기적</strong> 이라는 말은 <strong>호출자의 결과가 필요한 시점에서 순서를 보장</strong>하며 작업을 진행한다는 것이다.</p>\n\n<p>다음 JAVA 코드의 예시를 봐보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SimpleDownloader</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>  <span class=\"c1\">// 다운로드 진행률</span>\n        \n        <span class=\"c1\">// 다운로드 시작</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"파일 다운로드를 시작합니다.\"</span><span class=\"o\">);</span>\n        \n        <span class=\"c1\">// 진행률 확인하면서 다른 작업 수행 (논블로킹)</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">downloadProgress</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">{</span>  <span class=\"c1\">// 동기적: 순서 보장</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"진행률: \"</span> <span class=\"o\">+</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">+</span> <span class=\"s\">\"%\"</span><span class=\"o\">);</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다른 작업을 할 수 있어요!\"</span><span class=\"o\">);</span>\n            \n            <span class=\"c1\">// 진행률이 증가한다고 가정</span>\n            <span class=\"n\">downloadProgress</span> <span class=\"o\">+=</span> <span class=\"mi\">20</span><span class=\"o\">;</span>\n            \n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>  <span class=\"c1\">// 1초 대기</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        \n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다운로드 완료!\"</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><em>🚨 주의: 이 예시 코드는 Thread를 사용하고 있다. <br />\nThread는 기본적으로 작업을 병렬적으로 처리하기 위한 도구이다. <br />\n비동기 프로그래밍에서는 이러한 Thread의 병렬 처리 능력을 활용하여 비동기 작업을 구현하는 것이 일반적이다. <br />\n하지만 이 예시의 주된 목적은 작업이 어떻게 논블로킹하면서도 동기적으로 처리될 수 있는지를 시각적으로 보여주는 것이다. <br />\nThread를 사용한 것은 개념을 쉽게 설명하기 위한 것이다.</em></p>\n\n<p>이 코드의 결과는 다음과 같을 것이다.</p>\n<div class=\"language-css highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">나는</span> <span class=\"nt\">다른</span> <span class=\"nt\">작업을</span> <span class=\"nt\">진행할게</span><span class=\"o\">.</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">시작</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">0</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">1</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">2</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">완료</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드</span> <span class=\"nt\">종료</span> <span class=\"nt\">확인</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">모든</span> <span class=\"nt\">작업</span> <span class=\"nt\">완료</span><span class=\"o\">.</span>\n</code></pre></div></div>\n\n<p>물론, 논블로킹 메서드로 비동기 작업을 시작하더라도, 결과를 기다려야 하는 시점에서는 블로킹처럼 동작할 수 있다. <br />\n왜냐하면 메인 스레드가 결과를 받아야만 다음 작업을 진행할 수 있기 때문에, 그 시점에서는 블로킹이 되는 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b43ec8c4-9783-4fbf-9f7a-3736dff051bb\" alt=\"image\" width=\"80%\" class=\"center\" /></p>\n\n<p>사실 이러한 방식의 구현은 흔치 않다. <br />\n하지만, 몇 가지 활용 예를 알아보자면 <strong>게임 로딩화면 구성</strong> 등에 활용될 수 있다. <br />\n보통 게임에서 패치나 다운로드를 할 때, 사용자에게 ProgressBar나 게임 Tip등을 띄워줘야 할 때가 있다. <br />\n이 때는 Load 하는 동작이 완료될 때 까지 (작업 순서는 보장 = Sync) <br />\n다른 작업이 진행될 수 있다. (Non-Blocking)\n즉, 사용자 경험 측면에서 유용하게 활용될 수 있다.</p>\n\n<blockquote>\n  <p>언어 간에는 구현 방식에 차이가 있을 수 있다. <br />\n이는 각 언어의 특성과 제공되는 라이브러리나 기술에 따라 달라질 수 있다. <br />\n예를 들어, JavaScript는 단일 스레드 기반으로 동작하며, 콜백 함수, 프로미스(Promise), async/await 등의 메커니즘을 사용해 동기와 논블로킹 처리를 구현할 수 있다. <br />\n기본적으로 Promise.then 방식은 비동기적이고 논블로킹 방식으로 처리된다. <br />\n그러나 async/await 키워드를 사용하면, 비동기 작업의 순서를 지정할 수 있다.<br />\n중요한 점은, async 함수가 내부적으로 비동기적으로 동작하며, 메인 콜 스택이 모두 비워져야 실행된다는 것이다. <br />\n이로 인해 async/await도 내부적으로는 여전히 비동기적이고 논블로킹 방식으로 동작한다는 점을 유의해야 한다.\n(동기적인 코드 흐름처럼 보이게 하는 트릭)</p>\n</blockquote>\n\n<h2 id=\"4-4-비동기--블로킹\">4-4. 비동기 + 블로킹</h2>\n\n<p>이러한 방식은 사실 실무에서 마주치기 더더욱 흔치 않다.</p>\n\n<p>개념만 간단히 설명하자면,</p>\n\n<p>다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다린다. (<strong>블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않고, 콜백함수를 보낸 후 기다린다.</p>\n\n<p>이로써 작업 완료의 순서는 보장되지 않을 수 있다. (<strong>비동기</strong>)</p>\n\n<p><strong>즉, 함수 A는 자신과 관련없는 함수 B의 작업이 끝날 때까지 기다려야 한다.</strong>\n<em>매우 비효율적인 로직…</em></p>\n\n<p>1 작업 중에 2 작업을 해야지 Async의 이점을 살릴 수 있는 것인데,\n이것을 다시 Blocking 방식을 사용함여 대기시킴으로써 이점을 제거해버린 것이다…😅\n대부분의 경우 비동기+논블로킹 모델이 더 효율적인 선택이 될 것이다.</p>\n\n<p><br /></p>\n\n<h1 id=\"5-현대-프로그래밍에서-이러한-개념이-왜-중요한가\">5. 현대 프로그래밍에서 이러한 개념이 왜 중요한가?</h1>\n\n<p>이러한 이해는 현대 소프트웨어 개발에서 매우 중요하다. 오늘날의 애플리케이션들은 수많은 동시다발적인 작업을 처리해야 한다. 사용자는 파일을 다운로드하면서 동시에 문서를 편집하길 원하고, 데이터가 백그라운드에서 처리되는 동안에도 끊김 없는 인터페이스 사용을 기대한다.</p>\n\n<p>더군다나 클라우드 컴퓨팅과 마이크로서비스 아키텍처가 보편화된 현대 개발 환경에서는, 네트워크를 통한 수많은 비동기 작업들이 동시에 발생한다. 이때 각 작업을 어떻게 처리할지, 작업 간의 의존성은 어떻게 관리할지를 결정하는 것은 시스템의 성능과 사용자 경험을 좌우하는 핵심 요소가 된다.</p>\n\n<p>결국 이러한 개념들의 이해는 단순히 기술적인 지식을 넘어서, 현대 소프트웨어가 직면한 복잡성과 사용자 경험의 요구사항을 어떻게 조화롭게 해결할 수 있을지에 대한 통찰을 제공한다. 이는 우리가 더 효율적이고, 반응성 높은, 그리고 사용자 친화적인 소프트웨어를 설계하고 구현하는 데 있어 필수적인 기반이 될 것이다.</p>\n\n<h1 id=\"6-마무리\">6. 마무리</h1>\n<p>그렇다면 Java에서는 이러한 비동기 처리를 어떻게 구현할 수 있을까?</p>\n\n<p>Java의 비동기 프로그래밍은 Thread를 시작으로, 현대적인 CompletableFuture까지 꾸준히 발전해왔다.</p>\n\n<p>이제 각각의 방식을 자세히 살펴보겠다.</p>\n",
                        "tags": ["Java","Spring-Boot","Backend","Sync","Async","Concurrency","Blocking","NonBlocking"]
                    }
                
            ],
        
            "Backend": [
                
                    {
                        "title": "동기/비동기와 블로킹/논블로킹에 대해 깊이 파헤치기",
                        "url": "/2025/01/12/understanding-sync-async-blocking-non-blocking.html",
                        "subtitle": "Java/SpringBoot에서의 비동기 처리",
                        "excerpt": "1. 개념적 이해\n",
                        "author": "Jinho",
                        "date": "January 12, 2025",
                        "background": "/img/posts/sync-async-concept.jpeg",
                        "content": "<h1 id=\"1-개념적-이해\">1. 개념적 이해</h1>\n\n<p>비동기 처리에 대해 이야기하기 앞서, 과연 “동기”란 어떤 것인지부터 바로 잡고 가려고한다.</p>\n\n<p>왜냐하면 <strong>비(非)동기</strong>란 동기가 아니다라는 의미이기 때문에 동기가 무엇인지부터 정확히 하고 싶었다.</p>\n\n<p>또한 나는 처음에 ‘동기=블로킹, 비동기=논블로킹’이라고 단순하게 이해하고 있었다.</p>\n\n<p>하지만 실제로는 두 개념이 분류 기준이 전혀 다른 독립적인 개념이라는 것을 알게 되었다.</p>\n\n<p>이렇듯 서로 혼동되어 쓰이는 각 명칭은 어떤 의미인지 알아보려고 한다.</p>\n\n<p>이에 대해 자세히 알아보자.</p>\n\n<p><br /></p>\n\n<h1 id=\"2-동기와-비동기\">2. 동기와 비동기</h1>\n\n<p><img src=\"https://velog.velcdn.com/images/jinho7/post/a47f1973-3895-4438-a47f-80dd80245e41/image.png\" alt=\"\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<blockquote>\n  <p>동기와 비동기는 “작업의 처리 방식”을 나타내는 개념이다. <br />\n결론부터 말하자면, 이둘의 주요한 차이점은 “작업 순서 처리 차이”이다.</p>\n</blockquote>\n\n<h2 id=\"2-1-동기-순차적으로-실행\">2-1. 동기: 순차적으로 실행</h2>\n<p>필자는 이전에 동기를 <strong>겹치지 않고 순차적으로 작업을 진행하는 것</strong> 정도로 이해하고 있었다.</p>\n\n<p>영어 사전을 참고해보자.</p>\n\n<blockquote>\n  <p>synchronous\nadjective\nhappening or done at the same time or speed:</p>\n</blockquote>\n\n<p><strong>Synchronous</strong> 는 동시에 발생하는 두 개 이상의 사건이나 프로세스가 동일한 시간에서 진행되는 것을 의미하는 형용사이다.</p>\n\n<p>중요한 워딩은 [동일한 시간에 여러 개의 사건이 진행] 된다는 것이다.</p>\n\n<p>‘순차적’과 ‘동시’라는 단어가 서로 상충된다고 생각할 수 있다.</p>\n\n<p>여기서 오해하면 안되는 것이 이는 <strong>병렬적인 작업방식을 말하는 것이 아니다.</strong></p>\n\n<p>“어떠한 일정 시점에 현재 작업의 Response과 다음 작업의 Request이 함께 진행되는 것”</p>\n\n<p>위의 그림을 참고하면 이해가 쉽다.\n작업 A가 끝나는 시간과 작업 B가 시작하는 시간이 동기화된다고 이해하면 좋을 것 같다.</p>\n\n<p>이는 <strong>작업이 순차적으로 처리되며, 이전 작업이 완료될 때까지는 다음 작업이 시작되지 않음을 나타낸다.</strong></p>\n\n<p>즉, <strong>작업들이 서로 시간적 의존성을 가지고 실행된다</strong>는 뜻이다.</p>\n\n<p>동기 방식은 실행 순서가 보장되며 예측 가능하다는 장점이 있지만, <br />\n앞선 작업이 오래 걸리면 전체 작업이 지연된다는 단점도 있다.</p>\n\n<h2 id=\"2-2-비동기-독립적으로-실행\">2-2. 비동기: 독립적으로 실행</h2>\n<p>그렇다면 비동기 방식은 무엇일까?</p>\n\n<p>반대의 경우를 생각하면 된다.</p>\n\n<p>위의 그림을 참고하면 작업들이 병렬적으로 일어나고 있음을 알 수 있다.</p>\n\n<p>동기와 반대로 <strong>“요청을 보냈을 때 응답 상태와 상관없이 다른 동작을 수행할 수 있다.”</strong>는 점이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/0a188e4a-b35f-41aa-9953-94504330dd9f\" alt=\"다운로드\" width=\"68%\" height=\"50%\" class=\"center\" />\n<em class=\"image-caption\">파일 다운로드가 동기 방식이라면?</em></p>\n\n<p>만약에 파일 다운로드를 동기적으로 처리한다고 해보자.</p>\n\n<p>아마 파일이 다운로드될 때까지 아무런 작업도 수행할 수 없을 것이고,\n파일이 완전히 다운로드된 후에 다음 작업을 진행할 수 있을 것이다. 😅</p>\n\n<p>매우 비효율적인 방식이다…</p>\n\n<p>그러나 비동기적인 방식을 활용한다면, 파일 다운로드 작업을 시작시켜놓고, 다른 작업을 수행할 수 있다.</p>\n\n<p>파일이 다운로드되면 특정 콜백 함수를 호출하여, 다운로드된 파일을 처리하거나 결과를 반환받을 수 있다.</p>\n\n<p>콜백 뿐만이 아니고, 그 결과는 콜백 함수, Promise, 이벤트 등을 통해 전달받을 수 있다.</p>\n\n<p>마치 택배를 주문하고 배송 알림을 받는 것과 비슷하다고 할 수 있다.</p>\n\n<h3 id=\"비동기-동작-방식에-대한-오해\">비동기 동작 방식에 대한 오해</h3>\n<p>많은 개발자들이 <strong>비동기 = 멀티 쓰레드</strong>라고 이해하고 있다.</p>\n\n<p>단순히 생각해보아도, 여러 작업이 동시에 처리되는 비동기 동작을 구현하기 위해서는 당연히 여러 개의 쓰레드가 필요할 것 같기 때문이다.</p>\n\n<p>또한, 특히나 대부분의 Java 개발자들이 비동기 프로그래밍을 접할 때 아래와 같은 코드를 통해 배우기 때문이다.</p>\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 여기서 실제로 별도의 스레드에서 실행됨</span>\n    <span class=\"k\">return</span> <span class=\"nf\">heavyTask</span><span class=\"o\">();</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p>우리는 Java에서 비동기 처리에 대해 다룰 때, ExecutorService나 CompletableFuture와 같은 도구들을 함께 배운다.</p>\n\n<p>이들은 내부적으로 <strong>스레드 풀</strong>을 사용하기 때문에, 자연스럽게 비동기 처리와 멀티 쓰레드를 동일시하게 된다.</p>\n\n<p>실제로 Spring Framework의 @Async 어노테이션도 비동기 처리를 위해 기본적으로 스레드 풀을 사용한다.</p>\n\n<p>하지만 비동기 처리의 본질은 <strong>“작업의 완료를 기다리지 않고 다른 작업을 수행할 수 있는 것”</strong>이다.</p>\n\n<p>이는 반드시 멀티스레드로만 구현되어야 하는 것이 아니며, Node.js가 좋은 예시다.</p>\n\n<p>Node.js는 싱글 스레드 기반의 이벤트 루프를 사용하여 비동기 처리를 구현한다.</p>\n\n<p>이벤트 루프는 OS의 비동기 I/O 기능을 활용하여 실제 I/O 작업을 커널 레벨에서 처리하고,</p>\n\n<p>작업이 완료되면 이벤트를 통해 알림을 받는 방식으로 동작한다.</p>\n\n<div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Node.js의 비동기 처리 (싱글스레드)</span>\n<span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nf\">readFile</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">file.txt</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">파일 읽기 완료</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">다음 작업 실행</span><span class=\"dl\">'</span><span class=\"p\">);</span>  <span class=\"c1\">// 파일 읽기를 기다리지 않고 실행</span>\n</code></pre></div></div>\n<p>이러한 이벤트 루프 기반의 비동기 처리는 멀티스레드 없이도 효율적인 비동기 처리를 가능하게 한다.\nOS의 비동기 I/O 기능을 활용하여, 실제 I/O 작업은 커널 레벨에서 처리되고, 완료되면 이벤트를 통해 알림을 받는 방식이다.\n<em>정확히는 JavaScript 엔진이 싱글 스레드 기반이다</em>\n<em>해당 내용에 대해 더 자세히 알고 싶다면 <a href=\"https://puleugo.tistory.com/133\">해당 블로그</a>를 참고하자</em></p>\n\n<p><br /></p>\n\n<h1 id=\"3-블로킹과-논블로킹\">3. 블로킹과 논블로킹</h1>\n<blockquote>\n  <p>블로킹과 논블로킹은 “제어권의 이동” 관점에서 바라보는 개념이다.</p>\n</blockquote>\n\n<p>결국 “호출한 함수가 다른 일을 할 수 있는가?”의 여부를 의미한다.</p>\n\n<h2 id=\"3-1-제어권control-flow의-의미\">3-1. 제어권(Control Flow)의 의미</h2>\n<p>여기서 <strong>제어권</strong>이란 어떤 의미를 갖는지 먼저 보자.\nOS적인 관점에서 보자면, <strong>현재 작업을 진행하고 있는 함수가 CPU를 점유하는 것</strong>을 의미한다.\n쉽게 말해 “코드를 실행시킬 수 있는 권한” 정도로 말할 수 있다.</p>\n\n<p>동기 와 비동기는 Jobs 들이 순서대로 혹은 독립적으로 처리되는가에 관한 이야기라면,\n이번에는 호출한 함수가 별개의 일을 할 수 있는지의 이야기이다.</p>\n\n<h2 id=\"3-2-블로킹-제어권을-넘겨주는-방식\">3-2. 블로킹: 제어권을 넘겨주는 방식</h2>\n<p>마치 시험지를 넘겨주는 방식을 생각하면 편할 것 같다.\n<img src=\"https://github.com/user-attachments/assets/6eb36e86-150c-4144-86ce-6080ef86bece\" alt=\"image\" width=\"60%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : https://www.veritas-a.com/news/articleView.html?idxno=156699</em></p>\n\n<p>내가 뒷 사람에게 시험지를 넘겨줄 때,\n나는 아무런 행동도 하지 않고 <strong>뒷 사람(호출된 함수)가 시험지를 가져가는(자신의 작업을 완료)할 때 까지</strong> 나는 손에 시험지를 쥐고 뒷사람을 바라보고 대기할 수 밖에 없다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d799e31b-9406-44f3-8dcc-9df15b8f8a79\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>둘 간의 구분 방법은 제어권이 누구에게 있는지로 결정된다.</p>\n\n<p>블로킹에서는 함수 A가 함수 B를 호출할 때 제어권이 B로 넘어간다.</p>\n\n<p>제어권을 넘겨준 A는 B의 작업이 완료될 때까지 아무 작업도 수행할 수 없는 상태, 즉 블로킹 상태가 된다.</p>\n\n<p>즉, 위의 사진에서 A함수는 B함수에게 제어권을 넘겨줌과 동시에 함수 실행이 일시 정지된다. = Blocking</p>\n\n<h2 id=\"3-3-논블로킹-제어권을-유지하는-방식\">3-3. 논블로킹: 제어권을 유지하는 방식</h2>\n<p>하지만 시험지를 그냥 뒷 사람 책상에 올려 놓는다면 어떨까.</p>\n\n<p>나는 실제 뒷 사람이 받는 것을 대기할 필요없이, 바로 나의 다른 작업을 할 수 있다.</p>\n\n<p>즉, 뒷 사람(호출된 함수)이 나에 대한 제어권을 바로 반환해줌으로, 호출한 쪽(나)에서는 계속 다른 작업을 할 수 있는 것이다.</p>\n\n<p>같은 “읽기” 작업이어도 동기와 비동기 처리에 따라 어떻게 다르게 동작하는지 보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹: 제어권을 넘겨줌</span>\n<span class=\"nc\">String</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">readFile</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 파일 읽을 때까지 다른 일 못함</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                          <span class=\"c1\">// 파일 다 읽고 나서야 실행</span>\n\n<span class=\"c1\">// 논블로킹: 제어권을 유지</span>\n<span class=\"nc\">Future</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">readFileAsync</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 요청만 하고</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                               <span class=\"c1\">// 바로 다른 일 할 수 있음</span>\n</code></pre></div></div>\n<p><img src=\"https://github.com/user-attachments/assets/4a59addb-b12d-4eaa-90c9-fe783a7556e0\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>반면 논블로킹에서는 A함수가 B함수를 호출하더라도 제어권을 계속 유지한다.</p>\n\n<p>따라서 B함수가 실행되는 동안에도, A함수는 제어권을 가지고 있기 때문에 다른 작업을 수행할 수 있다.</p>\n\n<p>이렇게 호출자(caller)인 A함수는 B함수의 작업 완료 여부와 관계없이 자신의 작업을 계속 수행할 수 있다.</p>\n\n<p><br /></p>\n\n<h1 id=\"4-네-가지-조합의-동작-방식\">4. 네 가지 조합의 동작 방식</h1>\n\n<p>가끔 동기 처리에서는 무조건적으로 블로킹이 일어나고, 비동기에서는 논블로킹이 일어난다고 오해하는 경우가 많다.</p>\n\n<p>하지만 두 쌍의 개념은 서로 다른 관점에서 바라보는 개념이라는 것을 확실하게 하고 넘어가자.</p>\n\n<blockquote>\n  <p>동기/비동기 : 작업들의 시간적 관계성 <br />\n블로킹/논블로킹 : 제어권의 소재</p>\n</blockquote>\n\n<p>하지만 이 개념들이 오해가 잦은 이유는 실제 구현에서 [동기/볼로킹 &amp; 비동기/논블로킹]이 <strong>자주 함께 사용</strong>되기 때문이다.</p>\n\n<p>다음 그림을 보고 4가지 조합에 대해 천천히 살펴보자.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b894be55-d296-424d-913f-ee989233eb60\" alt=\"image\" width=\"100%\" class=\"center\" /></p>\n\n<p>먼저 흔히 쓰이는 [동기/볼로킹 &amp; 비동기/논블로킹] 에 대해 보자.</p>\n\n<h2 id=\"4-1-동기--블로킹\">4-1. 동기 + 블로킹</h2>\n\n<p>작업의 흐름이 순차적으로 진행되는 것이 보장된다. (<strong>동기</strong>)</p>\n\n<p>제어권을 함수 B에게 넘겨준 후 함수 A는 대기하게 된다. (<strong>블로킹</strong>)</p>\n\n<p>함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄 때까지 함수 A는 기다리는 것이다.</p>\n\n<blockquote>\n  <p>이러한 조합은 <strong>작업이 완료될 때까지 기다려야 하는 경우</strong>에 사용된다. <br />\n예를 들면, 파일을 읽은 후 이를 처리하는 코드를 생각해보자. <br />\n파일을 처리하는 과정은 <strong>필연적으로 파일을 모두 읽은 후에 작업이 가능</strong>하기 때문이다. <br />\n또한, 일반적으로 작업이 간단하거나 작업량이 적은 경우에 사용된다. <br />\n작업량이 많거나 오래 걸리는 작업을 해당 방식으로 처리하면 <strong>전체 프로그램이 멈춘 것 처럼 보여</strong> 사용자 경험 측면에서 나빠질 수 있다.</p>\n</blockquote>\n\n<h2 id=\"4-2-비동기--논블로킹\">4-2. 비동기 + 논블로킹</h2>\n\n<p>비동기 + 논블로킹 방식도 비교적 이해가 쉽다.</p>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다. (<strong>논블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 방식이다. (<strong>동기</strong>)</p>\n\n<p>함수 B를 호출 할 때, 콜백 함수를 함께 줌으로써, 함수 B는 자신의 작업이 끝났을 때 <strong>함수 A에게 준 콜백 함수를 실행시켜 자신의 작업이 끝났음</strong>을 알려준다.</p>\n\n<p>작업 A는 함수 B의 종료 여부에는 일단 관심이 없다.</p>\n\n<p>B 함수가 자신의 실행을 완료했다면, A 함수의 어깨를 톡톡 쳐서 알려주면 되는 것이다.</p>\n\n<blockquote>\n  <p>다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우에 활용할 수 있다. <br />\n또한, 대용량의 데이터를 처리하는 서비스에서 흔히 사용된다. <br />\n가장 큰 특징은 호출 함수에 콜백 함수를 넣었다는 점이다.</p>\n</blockquote>\n\n<h2 id=\"4-3-동기--논블로킹\">4-3. 동기 + 논블로킹</h2>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다.</p>\n\n<p>이후 바로 자신의 코드를 실행한다. (<strong>논블로킹</strong>)</p>\n\n<p>즉, 다른 작업이 진행되는 동안에도 자신의 작업을 별개로 처리할 수 있다.</p>\n\n<p>조심할 것이 함수 A는 함수 B의 Return 값을 필요로 하는 것은 변함이 없다는 점이다.</p>\n\n<p>A 함수는 B 함수의 리턴값이 필요하기 때문에, 중간중간 B 함수에게 함수 실행을 완료했는지 물어본다.</p>\n\n<p>즉, A 함수(caller)가 B 함수(callee)의 실행이 종료되었는지 계속 예의 주시해야 한다. (순서 보장을 위해)</p>\n\n<p>이로써 작업을 순차대로 수행할 수 있는 것이다. (<strong>동기</strong>)</p>\n\n<p>여기서 조금 더 깊게 생각해보자.</p>\n\n<p>어떻게 동기적으로 진행되면서 메인 쓰레드가 논블로킹이 될 수 있을까?</p>\n\n<p>이 조합의 특징은 “작업 완료는 비동기로 처리하지만, 호출자는 필요할 때 결과를 동기적으로 받는다.”로 정리할 수 있다.</p>\n\n<p>즉, <strong>순서를 유지하면서 결과를 사용해야 할 때 동기적으로 기다릴 수 있다.</strong></p>\n\n<p>결국 <strong>동기적</strong> 이라는 말은 <strong>호출자의 결과가 필요한 시점에서 순서를 보장</strong>하며 작업을 진행한다는 것이다.</p>\n\n<p>다음 JAVA 코드의 예시를 봐보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SimpleDownloader</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>  <span class=\"c1\">// 다운로드 진행률</span>\n        \n        <span class=\"c1\">// 다운로드 시작</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"파일 다운로드를 시작합니다.\"</span><span class=\"o\">);</span>\n        \n        <span class=\"c1\">// 진행률 확인하면서 다른 작업 수행 (논블로킹)</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">downloadProgress</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">{</span>  <span class=\"c1\">// 동기적: 순서 보장</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"진행률: \"</span> <span class=\"o\">+</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">+</span> <span class=\"s\">\"%\"</span><span class=\"o\">);</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다른 작업을 할 수 있어요!\"</span><span class=\"o\">);</span>\n            \n            <span class=\"c1\">// 진행률이 증가한다고 가정</span>\n            <span class=\"n\">downloadProgress</span> <span class=\"o\">+=</span> <span class=\"mi\">20</span><span class=\"o\">;</span>\n            \n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>  <span class=\"c1\">// 1초 대기</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        \n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다운로드 완료!\"</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><em>🚨 주의: 이 예시 코드는 Thread를 사용하고 있다. <br />\nThread는 기본적으로 작업을 병렬적으로 처리하기 위한 도구이다. <br />\n비동기 프로그래밍에서는 이러한 Thread의 병렬 처리 능력을 활용하여 비동기 작업을 구현하는 것이 일반적이다. <br />\n하지만 이 예시의 주된 목적은 작업이 어떻게 논블로킹하면서도 동기적으로 처리될 수 있는지를 시각적으로 보여주는 것이다. <br />\nThread를 사용한 것은 개념을 쉽게 설명하기 위한 것이다.</em></p>\n\n<p>이 코드의 결과는 다음과 같을 것이다.</p>\n<div class=\"language-css highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">나는</span> <span class=\"nt\">다른</span> <span class=\"nt\">작업을</span> <span class=\"nt\">진행할게</span><span class=\"o\">.</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">시작</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">0</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">1</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">2</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">완료</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드</span> <span class=\"nt\">종료</span> <span class=\"nt\">확인</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">모든</span> <span class=\"nt\">작업</span> <span class=\"nt\">완료</span><span class=\"o\">.</span>\n</code></pre></div></div>\n\n<p>물론, 논블로킹 메서드로 비동기 작업을 시작하더라도, 결과를 기다려야 하는 시점에서는 블로킹처럼 동작할 수 있다. <br />\n왜냐하면 메인 스레드가 결과를 받아야만 다음 작업을 진행할 수 있기 때문에, 그 시점에서는 블로킹이 되는 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b43ec8c4-9783-4fbf-9f7a-3736dff051bb\" alt=\"image\" width=\"80%\" class=\"center\" /></p>\n\n<p>사실 이러한 방식의 구현은 흔치 않다. <br />\n하지만, 몇 가지 활용 예를 알아보자면 <strong>게임 로딩화면 구성</strong> 등에 활용될 수 있다. <br />\n보통 게임에서 패치나 다운로드를 할 때, 사용자에게 ProgressBar나 게임 Tip등을 띄워줘야 할 때가 있다. <br />\n이 때는 Load 하는 동작이 완료될 때 까지 (작업 순서는 보장 = Sync) <br />\n다른 작업이 진행될 수 있다. (Non-Blocking)\n즉, 사용자 경험 측면에서 유용하게 활용될 수 있다.</p>\n\n<blockquote>\n  <p>언어 간에는 구현 방식에 차이가 있을 수 있다. <br />\n이는 각 언어의 특성과 제공되는 라이브러리나 기술에 따라 달라질 수 있다. <br />\n예를 들어, JavaScript는 단일 스레드 기반으로 동작하며, 콜백 함수, 프로미스(Promise), async/await 등의 메커니즘을 사용해 동기와 논블로킹 처리를 구현할 수 있다. <br />\n기본적으로 Promise.then 방식은 비동기적이고 논블로킹 방식으로 처리된다. <br />\n그러나 async/await 키워드를 사용하면, 비동기 작업의 순서를 지정할 수 있다.<br />\n중요한 점은, async 함수가 내부적으로 비동기적으로 동작하며, 메인 콜 스택이 모두 비워져야 실행된다는 것이다. <br />\n이로 인해 async/await도 내부적으로는 여전히 비동기적이고 논블로킹 방식으로 동작한다는 점을 유의해야 한다.\n(동기적인 코드 흐름처럼 보이게 하는 트릭)</p>\n</blockquote>\n\n<h2 id=\"4-4-비동기--블로킹\">4-4. 비동기 + 블로킹</h2>\n\n<p>이러한 방식은 사실 실무에서 마주치기 더더욱 흔치 않다.</p>\n\n<p>개념만 간단히 설명하자면,</p>\n\n<p>다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다린다. (<strong>블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않고, 콜백함수를 보낸 후 기다린다.</p>\n\n<p>이로써 작업 완료의 순서는 보장되지 않을 수 있다. (<strong>비동기</strong>)</p>\n\n<p><strong>즉, 함수 A는 자신과 관련없는 함수 B의 작업이 끝날 때까지 기다려야 한다.</strong>\n<em>매우 비효율적인 로직…</em></p>\n\n<p>1 작업 중에 2 작업을 해야지 Async의 이점을 살릴 수 있는 것인데,\n이것을 다시 Blocking 방식을 사용함여 대기시킴으로써 이점을 제거해버린 것이다…😅\n대부분의 경우 비동기+논블로킹 모델이 더 효율적인 선택이 될 것이다.</p>\n\n<p><br /></p>\n\n<h1 id=\"5-현대-프로그래밍에서-이러한-개념이-왜-중요한가\">5. 현대 프로그래밍에서 이러한 개념이 왜 중요한가?</h1>\n\n<p>이러한 이해는 현대 소프트웨어 개발에서 매우 중요하다. 오늘날의 애플리케이션들은 수많은 동시다발적인 작업을 처리해야 한다. 사용자는 파일을 다운로드하면서 동시에 문서를 편집하길 원하고, 데이터가 백그라운드에서 처리되는 동안에도 끊김 없는 인터페이스 사용을 기대한다.</p>\n\n<p>더군다나 클라우드 컴퓨팅과 마이크로서비스 아키텍처가 보편화된 현대 개발 환경에서는, 네트워크를 통한 수많은 비동기 작업들이 동시에 발생한다. 이때 각 작업을 어떻게 처리할지, 작업 간의 의존성은 어떻게 관리할지를 결정하는 것은 시스템의 성능과 사용자 경험을 좌우하는 핵심 요소가 된다.</p>\n\n<p>결국 이러한 개념들의 이해는 단순히 기술적인 지식을 넘어서, 현대 소프트웨어가 직면한 복잡성과 사용자 경험의 요구사항을 어떻게 조화롭게 해결할 수 있을지에 대한 통찰을 제공한다. 이는 우리가 더 효율적이고, 반응성 높은, 그리고 사용자 친화적인 소프트웨어를 설계하고 구현하는 데 있어 필수적인 기반이 될 것이다.</p>\n\n<h1 id=\"6-마무리\">6. 마무리</h1>\n<p>그렇다면 Java에서는 이러한 비동기 처리를 어떻게 구현할 수 있을까?</p>\n\n<p>Java의 비동기 프로그래밍은 Thread를 시작으로, 현대적인 CompletableFuture까지 꾸준히 발전해왔다.</p>\n\n<p>이제 각각의 방식을 자세히 살펴보겠다.</p>\n",
                        "tags": ["Java","Spring-Boot","Backend","Sync","Async","Concurrency","Blocking","NonBlocking"]
                    }
                
            ],
        
            "Sync": [
                
                    {
                        "title": "동기/비동기와 블로킹/논블로킹에 대해 깊이 파헤치기",
                        "url": "/2025/01/12/understanding-sync-async-blocking-non-blocking.html",
                        "subtitle": "Java/SpringBoot에서의 비동기 처리",
                        "excerpt": "1. 개념적 이해\n",
                        "author": "Jinho",
                        "date": "January 12, 2025",
                        "background": "/img/posts/sync-async-concept.jpeg",
                        "content": "<h1 id=\"1-개념적-이해\">1. 개념적 이해</h1>\n\n<p>비동기 처리에 대해 이야기하기 앞서, 과연 “동기”란 어떤 것인지부터 바로 잡고 가려고한다.</p>\n\n<p>왜냐하면 <strong>비(非)동기</strong>란 동기가 아니다라는 의미이기 때문에 동기가 무엇인지부터 정확히 하고 싶었다.</p>\n\n<p>또한 나는 처음에 ‘동기=블로킹, 비동기=논블로킹’이라고 단순하게 이해하고 있었다.</p>\n\n<p>하지만 실제로는 두 개념이 분류 기준이 전혀 다른 독립적인 개념이라는 것을 알게 되었다.</p>\n\n<p>이렇듯 서로 혼동되어 쓰이는 각 명칭은 어떤 의미인지 알아보려고 한다.</p>\n\n<p>이에 대해 자세히 알아보자.</p>\n\n<p><br /></p>\n\n<h1 id=\"2-동기와-비동기\">2. 동기와 비동기</h1>\n\n<p><img src=\"https://velog.velcdn.com/images/jinho7/post/a47f1973-3895-4438-a47f-80dd80245e41/image.png\" alt=\"\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<blockquote>\n  <p>동기와 비동기는 “작업의 처리 방식”을 나타내는 개념이다. <br />\n결론부터 말하자면, 이둘의 주요한 차이점은 “작업 순서 처리 차이”이다.</p>\n</blockquote>\n\n<h2 id=\"2-1-동기-순차적으로-실행\">2-1. 동기: 순차적으로 실행</h2>\n<p>필자는 이전에 동기를 <strong>겹치지 않고 순차적으로 작업을 진행하는 것</strong> 정도로 이해하고 있었다.</p>\n\n<p>영어 사전을 참고해보자.</p>\n\n<blockquote>\n  <p>synchronous\nadjective\nhappening or done at the same time or speed:</p>\n</blockquote>\n\n<p><strong>Synchronous</strong> 는 동시에 발생하는 두 개 이상의 사건이나 프로세스가 동일한 시간에서 진행되는 것을 의미하는 형용사이다.</p>\n\n<p>중요한 워딩은 [동일한 시간에 여러 개의 사건이 진행] 된다는 것이다.</p>\n\n<p>‘순차적’과 ‘동시’라는 단어가 서로 상충된다고 생각할 수 있다.</p>\n\n<p>여기서 오해하면 안되는 것이 이는 <strong>병렬적인 작업방식을 말하는 것이 아니다.</strong></p>\n\n<p>“어떠한 일정 시점에 현재 작업의 Response과 다음 작업의 Request이 함께 진행되는 것”</p>\n\n<p>위의 그림을 참고하면 이해가 쉽다.\n작업 A가 끝나는 시간과 작업 B가 시작하는 시간이 동기화된다고 이해하면 좋을 것 같다.</p>\n\n<p>이는 <strong>작업이 순차적으로 처리되며, 이전 작업이 완료될 때까지는 다음 작업이 시작되지 않음을 나타낸다.</strong></p>\n\n<p>즉, <strong>작업들이 서로 시간적 의존성을 가지고 실행된다</strong>는 뜻이다.</p>\n\n<p>동기 방식은 실행 순서가 보장되며 예측 가능하다는 장점이 있지만, <br />\n앞선 작업이 오래 걸리면 전체 작업이 지연된다는 단점도 있다.</p>\n\n<h2 id=\"2-2-비동기-독립적으로-실행\">2-2. 비동기: 독립적으로 실행</h2>\n<p>그렇다면 비동기 방식은 무엇일까?</p>\n\n<p>반대의 경우를 생각하면 된다.</p>\n\n<p>위의 그림을 참고하면 작업들이 병렬적으로 일어나고 있음을 알 수 있다.</p>\n\n<p>동기와 반대로 <strong>“요청을 보냈을 때 응답 상태와 상관없이 다른 동작을 수행할 수 있다.”</strong>는 점이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/0a188e4a-b35f-41aa-9953-94504330dd9f\" alt=\"다운로드\" width=\"68%\" height=\"50%\" class=\"center\" />\n<em class=\"image-caption\">파일 다운로드가 동기 방식이라면?</em></p>\n\n<p>만약에 파일 다운로드를 동기적으로 처리한다고 해보자.</p>\n\n<p>아마 파일이 다운로드될 때까지 아무런 작업도 수행할 수 없을 것이고,\n파일이 완전히 다운로드된 후에 다음 작업을 진행할 수 있을 것이다. 😅</p>\n\n<p>매우 비효율적인 방식이다…</p>\n\n<p>그러나 비동기적인 방식을 활용한다면, 파일 다운로드 작업을 시작시켜놓고, 다른 작업을 수행할 수 있다.</p>\n\n<p>파일이 다운로드되면 특정 콜백 함수를 호출하여, 다운로드된 파일을 처리하거나 결과를 반환받을 수 있다.</p>\n\n<p>콜백 뿐만이 아니고, 그 결과는 콜백 함수, Promise, 이벤트 등을 통해 전달받을 수 있다.</p>\n\n<p>마치 택배를 주문하고 배송 알림을 받는 것과 비슷하다고 할 수 있다.</p>\n\n<h3 id=\"비동기-동작-방식에-대한-오해\">비동기 동작 방식에 대한 오해</h3>\n<p>많은 개발자들이 <strong>비동기 = 멀티 쓰레드</strong>라고 이해하고 있다.</p>\n\n<p>단순히 생각해보아도, 여러 작업이 동시에 처리되는 비동기 동작을 구현하기 위해서는 당연히 여러 개의 쓰레드가 필요할 것 같기 때문이다.</p>\n\n<p>또한, 특히나 대부분의 Java 개발자들이 비동기 프로그래밍을 접할 때 아래와 같은 코드를 통해 배우기 때문이다.</p>\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 여기서 실제로 별도의 스레드에서 실행됨</span>\n    <span class=\"k\">return</span> <span class=\"nf\">heavyTask</span><span class=\"o\">();</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p>우리는 Java에서 비동기 처리에 대해 다룰 때, ExecutorService나 CompletableFuture와 같은 도구들을 함께 배운다.</p>\n\n<p>이들은 내부적으로 <strong>스레드 풀</strong>을 사용하기 때문에, 자연스럽게 비동기 처리와 멀티 쓰레드를 동일시하게 된다.</p>\n\n<p>실제로 Spring Framework의 @Async 어노테이션도 비동기 처리를 위해 기본적으로 스레드 풀을 사용한다.</p>\n\n<p>하지만 비동기 처리의 본질은 <strong>“작업의 완료를 기다리지 않고 다른 작업을 수행할 수 있는 것”</strong>이다.</p>\n\n<p>이는 반드시 멀티스레드로만 구현되어야 하는 것이 아니며, Node.js가 좋은 예시다.</p>\n\n<p>Node.js는 싱글 스레드 기반의 이벤트 루프를 사용하여 비동기 처리를 구현한다.</p>\n\n<p>이벤트 루프는 OS의 비동기 I/O 기능을 활용하여 실제 I/O 작업을 커널 레벨에서 처리하고,</p>\n\n<p>작업이 완료되면 이벤트를 통해 알림을 받는 방식으로 동작한다.</p>\n\n<div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Node.js의 비동기 처리 (싱글스레드)</span>\n<span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nf\">readFile</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">file.txt</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">파일 읽기 완료</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">다음 작업 실행</span><span class=\"dl\">'</span><span class=\"p\">);</span>  <span class=\"c1\">// 파일 읽기를 기다리지 않고 실행</span>\n</code></pre></div></div>\n<p>이러한 이벤트 루프 기반의 비동기 처리는 멀티스레드 없이도 효율적인 비동기 처리를 가능하게 한다.\nOS의 비동기 I/O 기능을 활용하여, 실제 I/O 작업은 커널 레벨에서 처리되고, 완료되면 이벤트를 통해 알림을 받는 방식이다.\n<em>정확히는 JavaScript 엔진이 싱글 스레드 기반이다</em>\n<em>해당 내용에 대해 더 자세히 알고 싶다면 <a href=\"https://puleugo.tistory.com/133\">해당 블로그</a>를 참고하자</em></p>\n\n<p><br /></p>\n\n<h1 id=\"3-블로킹과-논블로킹\">3. 블로킹과 논블로킹</h1>\n<blockquote>\n  <p>블로킹과 논블로킹은 “제어권의 이동” 관점에서 바라보는 개념이다.</p>\n</blockquote>\n\n<p>결국 “호출한 함수가 다른 일을 할 수 있는가?”의 여부를 의미한다.</p>\n\n<h2 id=\"3-1-제어권control-flow의-의미\">3-1. 제어권(Control Flow)의 의미</h2>\n<p>여기서 <strong>제어권</strong>이란 어떤 의미를 갖는지 먼저 보자.\nOS적인 관점에서 보자면, <strong>현재 작업을 진행하고 있는 함수가 CPU를 점유하는 것</strong>을 의미한다.\n쉽게 말해 “코드를 실행시킬 수 있는 권한” 정도로 말할 수 있다.</p>\n\n<p>동기 와 비동기는 Jobs 들이 순서대로 혹은 독립적으로 처리되는가에 관한 이야기라면,\n이번에는 호출한 함수가 별개의 일을 할 수 있는지의 이야기이다.</p>\n\n<h2 id=\"3-2-블로킹-제어권을-넘겨주는-방식\">3-2. 블로킹: 제어권을 넘겨주는 방식</h2>\n<p>마치 시험지를 넘겨주는 방식을 생각하면 편할 것 같다.\n<img src=\"https://github.com/user-attachments/assets/6eb36e86-150c-4144-86ce-6080ef86bece\" alt=\"image\" width=\"60%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : https://www.veritas-a.com/news/articleView.html?idxno=156699</em></p>\n\n<p>내가 뒷 사람에게 시험지를 넘겨줄 때,\n나는 아무런 행동도 하지 않고 <strong>뒷 사람(호출된 함수)가 시험지를 가져가는(자신의 작업을 완료)할 때 까지</strong> 나는 손에 시험지를 쥐고 뒷사람을 바라보고 대기할 수 밖에 없다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d799e31b-9406-44f3-8dcc-9df15b8f8a79\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>둘 간의 구분 방법은 제어권이 누구에게 있는지로 결정된다.</p>\n\n<p>블로킹에서는 함수 A가 함수 B를 호출할 때 제어권이 B로 넘어간다.</p>\n\n<p>제어권을 넘겨준 A는 B의 작업이 완료될 때까지 아무 작업도 수행할 수 없는 상태, 즉 블로킹 상태가 된다.</p>\n\n<p>즉, 위의 사진에서 A함수는 B함수에게 제어권을 넘겨줌과 동시에 함수 실행이 일시 정지된다. = Blocking</p>\n\n<h2 id=\"3-3-논블로킹-제어권을-유지하는-방식\">3-3. 논블로킹: 제어권을 유지하는 방식</h2>\n<p>하지만 시험지를 그냥 뒷 사람 책상에 올려 놓는다면 어떨까.</p>\n\n<p>나는 실제 뒷 사람이 받는 것을 대기할 필요없이, 바로 나의 다른 작업을 할 수 있다.</p>\n\n<p>즉, 뒷 사람(호출된 함수)이 나에 대한 제어권을 바로 반환해줌으로, 호출한 쪽(나)에서는 계속 다른 작업을 할 수 있는 것이다.</p>\n\n<p>같은 “읽기” 작업이어도 동기와 비동기 처리에 따라 어떻게 다르게 동작하는지 보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹: 제어권을 넘겨줌</span>\n<span class=\"nc\">String</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">readFile</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 파일 읽을 때까지 다른 일 못함</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                          <span class=\"c1\">// 파일 다 읽고 나서야 실행</span>\n\n<span class=\"c1\">// 논블로킹: 제어권을 유지</span>\n<span class=\"nc\">Future</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">readFileAsync</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 요청만 하고</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                               <span class=\"c1\">// 바로 다른 일 할 수 있음</span>\n</code></pre></div></div>\n<p><img src=\"https://github.com/user-attachments/assets/4a59addb-b12d-4eaa-90c9-fe783a7556e0\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>반면 논블로킹에서는 A함수가 B함수를 호출하더라도 제어권을 계속 유지한다.</p>\n\n<p>따라서 B함수가 실행되는 동안에도, A함수는 제어권을 가지고 있기 때문에 다른 작업을 수행할 수 있다.</p>\n\n<p>이렇게 호출자(caller)인 A함수는 B함수의 작업 완료 여부와 관계없이 자신의 작업을 계속 수행할 수 있다.</p>\n\n<p><br /></p>\n\n<h1 id=\"4-네-가지-조합의-동작-방식\">4. 네 가지 조합의 동작 방식</h1>\n\n<p>가끔 동기 처리에서는 무조건적으로 블로킹이 일어나고, 비동기에서는 논블로킹이 일어난다고 오해하는 경우가 많다.</p>\n\n<p>하지만 두 쌍의 개념은 서로 다른 관점에서 바라보는 개념이라는 것을 확실하게 하고 넘어가자.</p>\n\n<blockquote>\n  <p>동기/비동기 : 작업들의 시간적 관계성 <br />\n블로킹/논블로킹 : 제어권의 소재</p>\n</blockquote>\n\n<p>하지만 이 개념들이 오해가 잦은 이유는 실제 구현에서 [동기/볼로킹 &amp; 비동기/논블로킹]이 <strong>자주 함께 사용</strong>되기 때문이다.</p>\n\n<p>다음 그림을 보고 4가지 조합에 대해 천천히 살펴보자.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b894be55-d296-424d-913f-ee989233eb60\" alt=\"image\" width=\"100%\" class=\"center\" /></p>\n\n<p>먼저 흔히 쓰이는 [동기/볼로킹 &amp; 비동기/논블로킹] 에 대해 보자.</p>\n\n<h2 id=\"4-1-동기--블로킹\">4-1. 동기 + 블로킹</h2>\n\n<p>작업의 흐름이 순차적으로 진행되는 것이 보장된다. (<strong>동기</strong>)</p>\n\n<p>제어권을 함수 B에게 넘겨준 후 함수 A는 대기하게 된다. (<strong>블로킹</strong>)</p>\n\n<p>함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄 때까지 함수 A는 기다리는 것이다.</p>\n\n<blockquote>\n  <p>이러한 조합은 <strong>작업이 완료될 때까지 기다려야 하는 경우</strong>에 사용된다. <br />\n예를 들면, 파일을 읽은 후 이를 처리하는 코드를 생각해보자. <br />\n파일을 처리하는 과정은 <strong>필연적으로 파일을 모두 읽은 후에 작업이 가능</strong>하기 때문이다. <br />\n또한, 일반적으로 작업이 간단하거나 작업량이 적은 경우에 사용된다. <br />\n작업량이 많거나 오래 걸리는 작업을 해당 방식으로 처리하면 <strong>전체 프로그램이 멈춘 것 처럼 보여</strong> 사용자 경험 측면에서 나빠질 수 있다.</p>\n</blockquote>\n\n<h2 id=\"4-2-비동기--논블로킹\">4-2. 비동기 + 논블로킹</h2>\n\n<p>비동기 + 논블로킹 방식도 비교적 이해가 쉽다.</p>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다. (<strong>논블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 방식이다. (<strong>동기</strong>)</p>\n\n<p>함수 B를 호출 할 때, 콜백 함수를 함께 줌으로써, 함수 B는 자신의 작업이 끝났을 때 <strong>함수 A에게 준 콜백 함수를 실행시켜 자신의 작업이 끝났음</strong>을 알려준다.</p>\n\n<p>작업 A는 함수 B의 종료 여부에는 일단 관심이 없다.</p>\n\n<p>B 함수가 자신의 실행을 완료했다면, A 함수의 어깨를 톡톡 쳐서 알려주면 되는 것이다.</p>\n\n<blockquote>\n  <p>다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우에 활용할 수 있다. <br />\n또한, 대용량의 데이터를 처리하는 서비스에서 흔히 사용된다. <br />\n가장 큰 특징은 호출 함수에 콜백 함수를 넣었다는 점이다.</p>\n</blockquote>\n\n<h2 id=\"4-3-동기--논블로킹\">4-3. 동기 + 논블로킹</h2>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다.</p>\n\n<p>이후 바로 자신의 코드를 실행한다. (<strong>논블로킹</strong>)</p>\n\n<p>즉, 다른 작업이 진행되는 동안에도 자신의 작업을 별개로 처리할 수 있다.</p>\n\n<p>조심할 것이 함수 A는 함수 B의 Return 값을 필요로 하는 것은 변함이 없다는 점이다.</p>\n\n<p>A 함수는 B 함수의 리턴값이 필요하기 때문에, 중간중간 B 함수에게 함수 실행을 완료했는지 물어본다.</p>\n\n<p>즉, A 함수(caller)가 B 함수(callee)의 실행이 종료되었는지 계속 예의 주시해야 한다. (순서 보장을 위해)</p>\n\n<p>이로써 작업을 순차대로 수행할 수 있는 것이다. (<strong>동기</strong>)</p>\n\n<p>여기서 조금 더 깊게 생각해보자.</p>\n\n<p>어떻게 동기적으로 진행되면서 메인 쓰레드가 논블로킹이 될 수 있을까?</p>\n\n<p>이 조합의 특징은 “작업 완료는 비동기로 처리하지만, 호출자는 필요할 때 결과를 동기적으로 받는다.”로 정리할 수 있다.</p>\n\n<p>즉, <strong>순서를 유지하면서 결과를 사용해야 할 때 동기적으로 기다릴 수 있다.</strong></p>\n\n<p>결국 <strong>동기적</strong> 이라는 말은 <strong>호출자의 결과가 필요한 시점에서 순서를 보장</strong>하며 작업을 진행한다는 것이다.</p>\n\n<p>다음 JAVA 코드의 예시를 봐보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SimpleDownloader</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>  <span class=\"c1\">// 다운로드 진행률</span>\n        \n        <span class=\"c1\">// 다운로드 시작</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"파일 다운로드를 시작합니다.\"</span><span class=\"o\">);</span>\n        \n        <span class=\"c1\">// 진행률 확인하면서 다른 작업 수행 (논블로킹)</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">downloadProgress</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">{</span>  <span class=\"c1\">// 동기적: 순서 보장</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"진행률: \"</span> <span class=\"o\">+</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">+</span> <span class=\"s\">\"%\"</span><span class=\"o\">);</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다른 작업을 할 수 있어요!\"</span><span class=\"o\">);</span>\n            \n            <span class=\"c1\">// 진행률이 증가한다고 가정</span>\n            <span class=\"n\">downloadProgress</span> <span class=\"o\">+=</span> <span class=\"mi\">20</span><span class=\"o\">;</span>\n            \n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>  <span class=\"c1\">// 1초 대기</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        \n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다운로드 완료!\"</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><em>🚨 주의: 이 예시 코드는 Thread를 사용하고 있다. <br />\nThread는 기본적으로 작업을 병렬적으로 처리하기 위한 도구이다. <br />\n비동기 프로그래밍에서는 이러한 Thread의 병렬 처리 능력을 활용하여 비동기 작업을 구현하는 것이 일반적이다. <br />\n하지만 이 예시의 주된 목적은 작업이 어떻게 논블로킹하면서도 동기적으로 처리될 수 있는지를 시각적으로 보여주는 것이다. <br />\nThread를 사용한 것은 개념을 쉽게 설명하기 위한 것이다.</em></p>\n\n<p>이 코드의 결과는 다음과 같을 것이다.</p>\n<div class=\"language-css highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">나는</span> <span class=\"nt\">다른</span> <span class=\"nt\">작업을</span> <span class=\"nt\">진행할게</span><span class=\"o\">.</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">시작</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">0</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">1</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">2</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">완료</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드</span> <span class=\"nt\">종료</span> <span class=\"nt\">확인</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">모든</span> <span class=\"nt\">작업</span> <span class=\"nt\">완료</span><span class=\"o\">.</span>\n</code></pre></div></div>\n\n<p>물론, 논블로킹 메서드로 비동기 작업을 시작하더라도, 결과를 기다려야 하는 시점에서는 블로킹처럼 동작할 수 있다. <br />\n왜냐하면 메인 스레드가 결과를 받아야만 다음 작업을 진행할 수 있기 때문에, 그 시점에서는 블로킹이 되는 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b43ec8c4-9783-4fbf-9f7a-3736dff051bb\" alt=\"image\" width=\"80%\" class=\"center\" /></p>\n\n<p>사실 이러한 방식의 구현은 흔치 않다. <br />\n하지만, 몇 가지 활용 예를 알아보자면 <strong>게임 로딩화면 구성</strong> 등에 활용될 수 있다. <br />\n보통 게임에서 패치나 다운로드를 할 때, 사용자에게 ProgressBar나 게임 Tip등을 띄워줘야 할 때가 있다. <br />\n이 때는 Load 하는 동작이 완료될 때 까지 (작업 순서는 보장 = Sync) <br />\n다른 작업이 진행될 수 있다. (Non-Blocking)\n즉, 사용자 경험 측면에서 유용하게 활용될 수 있다.</p>\n\n<blockquote>\n  <p>언어 간에는 구현 방식에 차이가 있을 수 있다. <br />\n이는 각 언어의 특성과 제공되는 라이브러리나 기술에 따라 달라질 수 있다. <br />\n예를 들어, JavaScript는 단일 스레드 기반으로 동작하며, 콜백 함수, 프로미스(Promise), async/await 등의 메커니즘을 사용해 동기와 논블로킹 처리를 구현할 수 있다. <br />\n기본적으로 Promise.then 방식은 비동기적이고 논블로킹 방식으로 처리된다. <br />\n그러나 async/await 키워드를 사용하면, 비동기 작업의 순서를 지정할 수 있다.<br />\n중요한 점은, async 함수가 내부적으로 비동기적으로 동작하며, 메인 콜 스택이 모두 비워져야 실행된다는 것이다. <br />\n이로 인해 async/await도 내부적으로는 여전히 비동기적이고 논블로킹 방식으로 동작한다는 점을 유의해야 한다.\n(동기적인 코드 흐름처럼 보이게 하는 트릭)</p>\n</blockquote>\n\n<h2 id=\"4-4-비동기--블로킹\">4-4. 비동기 + 블로킹</h2>\n\n<p>이러한 방식은 사실 실무에서 마주치기 더더욱 흔치 않다.</p>\n\n<p>개념만 간단히 설명하자면,</p>\n\n<p>다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다린다. (<strong>블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않고, 콜백함수를 보낸 후 기다린다.</p>\n\n<p>이로써 작업 완료의 순서는 보장되지 않을 수 있다. (<strong>비동기</strong>)</p>\n\n<p><strong>즉, 함수 A는 자신과 관련없는 함수 B의 작업이 끝날 때까지 기다려야 한다.</strong>\n<em>매우 비효율적인 로직…</em></p>\n\n<p>1 작업 중에 2 작업을 해야지 Async의 이점을 살릴 수 있는 것인데,\n이것을 다시 Blocking 방식을 사용함여 대기시킴으로써 이점을 제거해버린 것이다…😅\n대부분의 경우 비동기+논블로킹 모델이 더 효율적인 선택이 될 것이다.</p>\n\n<p><br /></p>\n\n<h1 id=\"5-현대-프로그래밍에서-이러한-개념이-왜-중요한가\">5. 현대 프로그래밍에서 이러한 개념이 왜 중요한가?</h1>\n\n<p>이러한 이해는 현대 소프트웨어 개발에서 매우 중요하다. 오늘날의 애플리케이션들은 수많은 동시다발적인 작업을 처리해야 한다. 사용자는 파일을 다운로드하면서 동시에 문서를 편집하길 원하고, 데이터가 백그라운드에서 처리되는 동안에도 끊김 없는 인터페이스 사용을 기대한다.</p>\n\n<p>더군다나 클라우드 컴퓨팅과 마이크로서비스 아키텍처가 보편화된 현대 개발 환경에서는, 네트워크를 통한 수많은 비동기 작업들이 동시에 발생한다. 이때 각 작업을 어떻게 처리할지, 작업 간의 의존성은 어떻게 관리할지를 결정하는 것은 시스템의 성능과 사용자 경험을 좌우하는 핵심 요소가 된다.</p>\n\n<p>결국 이러한 개념들의 이해는 단순히 기술적인 지식을 넘어서, 현대 소프트웨어가 직면한 복잡성과 사용자 경험의 요구사항을 어떻게 조화롭게 해결할 수 있을지에 대한 통찰을 제공한다. 이는 우리가 더 효율적이고, 반응성 높은, 그리고 사용자 친화적인 소프트웨어를 설계하고 구현하는 데 있어 필수적인 기반이 될 것이다.</p>\n\n<h1 id=\"6-마무리\">6. 마무리</h1>\n<p>그렇다면 Java에서는 이러한 비동기 처리를 어떻게 구현할 수 있을까?</p>\n\n<p>Java의 비동기 프로그래밍은 Thread를 시작으로, 현대적인 CompletableFuture까지 꾸준히 발전해왔다.</p>\n\n<p>이제 각각의 방식을 자세히 살펴보겠다.</p>\n",
                        "tags": ["Java","Spring-Boot","Backend","Sync","Async","Concurrency","Blocking","NonBlocking"]
                    }
                
            ],
        
            "Async": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    },
                
                    {
                        "title": "동기/비동기와 블로킹/논블로킹에 대해 깊이 파헤치기",
                        "url": "/2025/01/12/understanding-sync-async-blocking-non-blocking.html",
                        "subtitle": "Java/SpringBoot에서의 비동기 처리",
                        "excerpt": "1. 개념적 이해\n",
                        "author": "Jinho",
                        "date": "January 12, 2025",
                        "background": "/img/posts/sync-async-concept.jpeg",
                        "content": "<h1 id=\"1-개념적-이해\">1. 개념적 이해</h1>\n\n<p>비동기 처리에 대해 이야기하기 앞서, 과연 “동기”란 어떤 것인지부터 바로 잡고 가려고한다.</p>\n\n<p>왜냐하면 <strong>비(非)동기</strong>란 동기가 아니다라는 의미이기 때문에 동기가 무엇인지부터 정확히 하고 싶었다.</p>\n\n<p>또한 나는 처음에 ‘동기=블로킹, 비동기=논블로킹’이라고 단순하게 이해하고 있었다.</p>\n\n<p>하지만 실제로는 두 개념이 분류 기준이 전혀 다른 독립적인 개념이라는 것을 알게 되었다.</p>\n\n<p>이렇듯 서로 혼동되어 쓰이는 각 명칭은 어떤 의미인지 알아보려고 한다.</p>\n\n<p>이에 대해 자세히 알아보자.</p>\n\n<p><br /></p>\n\n<h1 id=\"2-동기와-비동기\">2. 동기와 비동기</h1>\n\n<p><img src=\"https://velog.velcdn.com/images/jinho7/post/a47f1973-3895-4438-a47f-80dd80245e41/image.png\" alt=\"\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<blockquote>\n  <p>동기와 비동기는 “작업의 처리 방식”을 나타내는 개념이다. <br />\n결론부터 말하자면, 이둘의 주요한 차이점은 “작업 순서 처리 차이”이다.</p>\n</blockquote>\n\n<h2 id=\"2-1-동기-순차적으로-실행\">2-1. 동기: 순차적으로 실행</h2>\n<p>필자는 이전에 동기를 <strong>겹치지 않고 순차적으로 작업을 진행하는 것</strong> 정도로 이해하고 있었다.</p>\n\n<p>영어 사전을 참고해보자.</p>\n\n<blockquote>\n  <p>synchronous\nadjective\nhappening or done at the same time or speed:</p>\n</blockquote>\n\n<p><strong>Synchronous</strong> 는 동시에 발생하는 두 개 이상의 사건이나 프로세스가 동일한 시간에서 진행되는 것을 의미하는 형용사이다.</p>\n\n<p>중요한 워딩은 [동일한 시간에 여러 개의 사건이 진행] 된다는 것이다.</p>\n\n<p>‘순차적’과 ‘동시’라는 단어가 서로 상충된다고 생각할 수 있다.</p>\n\n<p>여기서 오해하면 안되는 것이 이는 <strong>병렬적인 작업방식을 말하는 것이 아니다.</strong></p>\n\n<p>“어떠한 일정 시점에 현재 작업의 Response과 다음 작업의 Request이 함께 진행되는 것”</p>\n\n<p>위의 그림을 참고하면 이해가 쉽다.\n작업 A가 끝나는 시간과 작업 B가 시작하는 시간이 동기화된다고 이해하면 좋을 것 같다.</p>\n\n<p>이는 <strong>작업이 순차적으로 처리되며, 이전 작업이 완료될 때까지는 다음 작업이 시작되지 않음을 나타낸다.</strong></p>\n\n<p>즉, <strong>작업들이 서로 시간적 의존성을 가지고 실행된다</strong>는 뜻이다.</p>\n\n<p>동기 방식은 실행 순서가 보장되며 예측 가능하다는 장점이 있지만, <br />\n앞선 작업이 오래 걸리면 전체 작업이 지연된다는 단점도 있다.</p>\n\n<h2 id=\"2-2-비동기-독립적으로-실행\">2-2. 비동기: 독립적으로 실행</h2>\n<p>그렇다면 비동기 방식은 무엇일까?</p>\n\n<p>반대의 경우를 생각하면 된다.</p>\n\n<p>위의 그림을 참고하면 작업들이 병렬적으로 일어나고 있음을 알 수 있다.</p>\n\n<p>동기와 반대로 <strong>“요청을 보냈을 때 응답 상태와 상관없이 다른 동작을 수행할 수 있다.”</strong>는 점이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/0a188e4a-b35f-41aa-9953-94504330dd9f\" alt=\"다운로드\" width=\"68%\" height=\"50%\" class=\"center\" />\n<em class=\"image-caption\">파일 다운로드가 동기 방식이라면?</em></p>\n\n<p>만약에 파일 다운로드를 동기적으로 처리한다고 해보자.</p>\n\n<p>아마 파일이 다운로드될 때까지 아무런 작업도 수행할 수 없을 것이고,\n파일이 완전히 다운로드된 후에 다음 작업을 진행할 수 있을 것이다. 😅</p>\n\n<p>매우 비효율적인 방식이다…</p>\n\n<p>그러나 비동기적인 방식을 활용한다면, 파일 다운로드 작업을 시작시켜놓고, 다른 작업을 수행할 수 있다.</p>\n\n<p>파일이 다운로드되면 특정 콜백 함수를 호출하여, 다운로드된 파일을 처리하거나 결과를 반환받을 수 있다.</p>\n\n<p>콜백 뿐만이 아니고, 그 결과는 콜백 함수, Promise, 이벤트 등을 통해 전달받을 수 있다.</p>\n\n<p>마치 택배를 주문하고 배송 알림을 받는 것과 비슷하다고 할 수 있다.</p>\n\n<h3 id=\"비동기-동작-방식에-대한-오해\">비동기 동작 방식에 대한 오해</h3>\n<p>많은 개발자들이 <strong>비동기 = 멀티 쓰레드</strong>라고 이해하고 있다.</p>\n\n<p>단순히 생각해보아도, 여러 작업이 동시에 처리되는 비동기 동작을 구현하기 위해서는 당연히 여러 개의 쓰레드가 필요할 것 같기 때문이다.</p>\n\n<p>또한, 특히나 대부분의 Java 개발자들이 비동기 프로그래밍을 접할 때 아래와 같은 코드를 통해 배우기 때문이다.</p>\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 여기서 실제로 별도의 스레드에서 실행됨</span>\n    <span class=\"k\">return</span> <span class=\"nf\">heavyTask</span><span class=\"o\">();</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p>우리는 Java에서 비동기 처리에 대해 다룰 때, ExecutorService나 CompletableFuture와 같은 도구들을 함께 배운다.</p>\n\n<p>이들은 내부적으로 <strong>스레드 풀</strong>을 사용하기 때문에, 자연스럽게 비동기 처리와 멀티 쓰레드를 동일시하게 된다.</p>\n\n<p>실제로 Spring Framework의 @Async 어노테이션도 비동기 처리를 위해 기본적으로 스레드 풀을 사용한다.</p>\n\n<p>하지만 비동기 처리의 본질은 <strong>“작업의 완료를 기다리지 않고 다른 작업을 수행할 수 있는 것”</strong>이다.</p>\n\n<p>이는 반드시 멀티스레드로만 구현되어야 하는 것이 아니며, Node.js가 좋은 예시다.</p>\n\n<p>Node.js는 싱글 스레드 기반의 이벤트 루프를 사용하여 비동기 처리를 구현한다.</p>\n\n<p>이벤트 루프는 OS의 비동기 I/O 기능을 활용하여 실제 I/O 작업을 커널 레벨에서 처리하고,</p>\n\n<p>작업이 완료되면 이벤트를 통해 알림을 받는 방식으로 동작한다.</p>\n\n<div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Node.js의 비동기 처리 (싱글스레드)</span>\n<span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nf\">readFile</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">file.txt</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">파일 읽기 완료</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">다음 작업 실행</span><span class=\"dl\">'</span><span class=\"p\">);</span>  <span class=\"c1\">// 파일 읽기를 기다리지 않고 실행</span>\n</code></pre></div></div>\n<p>이러한 이벤트 루프 기반의 비동기 처리는 멀티스레드 없이도 효율적인 비동기 처리를 가능하게 한다.\nOS의 비동기 I/O 기능을 활용하여, 실제 I/O 작업은 커널 레벨에서 처리되고, 완료되면 이벤트를 통해 알림을 받는 방식이다.\n<em>정확히는 JavaScript 엔진이 싱글 스레드 기반이다</em>\n<em>해당 내용에 대해 더 자세히 알고 싶다면 <a href=\"https://puleugo.tistory.com/133\">해당 블로그</a>를 참고하자</em></p>\n\n<p><br /></p>\n\n<h1 id=\"3-블로킹과-논블로킹\">3. 블로킹과 논블로킹</h1>\n<blockquote>\n  <p>블로킹과 논블로킹은 “제어권의 이동” 관점에서 바라보는 개념이다.</p>\n</blockquote>\n\n<p>결국 “호출한 함수가 다른 일을 할 수 있는가?”의 여부를 의미한다.</p>\n\n<h2 id=\"3-1-제어권control-flow의-의미\">3-1. 제어권(Control Flow)의 의미</h2>\n<p>여기서 <strong>제어권</strong>이란 어떤 의미를 갖는지 먼저 보자.\nOS적인 관점에서 보자면, <strong>현재 작업을 진행하고 있는 함수가 CPU를 점유하는 것</strong>을 의미한다.\n쉽게 말해 “코드를 실행시킬 수 있는 권한” 정도로 말할 수 있다.</p>\n\n<p>동기 와 비동기는 Jobs 들이 순서대로 혹은 독립적으로 처리되는가에 관한 이야기라면,\n이번에는 호출한 함수가 별개의 일을 할 수 있는지의 이야기이다.</p>\n\n<h2 id=\"3-2-블로킹-제어권을-넘겨주는-방식\">3-2. 블로킹: 제어권을 넘겨주는 방식</h2>\n<p>마치 시험지를 넘겨주는 방식을 생각하면 편할 것 같다.\n<img src=\"https://github.com/user-attachments/assets/6eb36e86-150c-4144-86ce-6080ef86bece\" alt=\"image\" width=\"60%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : https://www.veritas-a.com/news/articleView.html?idxno=156699</em></p>\n\n<p>내가 뒷 사람에게 시험지를 넘겨줄 때,\n나는 아무런 행동도 하지 않고 <strong>뒷 사람(호출된 함수)가 시험지를 가져가는(자신의 작업을 완료)할 때 까지</strong> 나는 손에 시험지를 쥐고 뒷사람을 바라보고 대기할 수 밖에 없다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d799e31b-9406-44f3-8dcc-9df15b8f8a79\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>둘 간의 구분 방법은 제어권이 누구에게 있는지로 결정된다.</p>\n\n<p>블로킹에서는 함수 A가 함수 B를 호출할 때 제어권이 B로 넘어간다.</p>\n\n<p>제어권을 넘겨준 A는 B의 작업이 완료될 때까지 아무 작업도 수행할 수 없는 상태, 즉 블로킹 상태가 된다.</p>\n\n<p>즉, 위의 사진에서 A함수는 B함수에게 제어권을 넘겨줌과 동시에 함수 실행이 일시 정지된다. = Blocking</p>\n\n<h2 id=\"3-3-논블로킹-제어권을-유지하는-방식\">3-3. 논블로킹: 제어권을 유지하는 방식</h2>\n<p>하지만 시험지를 그냥 뒷 사람 책상에 올려 놓는다면 어떨까.</p>\n\n<p>나는 실제 뒷 사람이 받는 것을 대기할 필요없이, 바로 나의 다른 작업을 할 수 있다.</p>\n\n<p>즉, 뒷 사람(호출된 함수)이 나에 대한 제어권을 바로 반환해줌으로, 호출한 쪽(나)에서는 계속 다른 작업을 할 수 있는 것이다.</p>\n\n<p>같은 “읽기” 작업이어도 동기와 비동기 처리에 따라 어떻게 다르게 동작하는지 보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹: 제어권을 넘겨줌</span>\n<span class=\"nc\">String</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">readFile</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 파일 읽을 때까지 다른 일 못함</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                          <span class=\"c1\">// 파일 다 읽고 나서야 실행</span>\n\n<span class=\"c1\">// 논블로킹: 제어권을 유지</span>\n<span class=\"nc\">Future</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">readFileAsync</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 요청만 하고</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                               <span class=\"c1\">// 바로 다른 일 할 수 있음</span>\n</code></pre></div></div>\n<p><img src=\"https://github.com/user-attachments/assets/4a59addb-b12d-4eaa-90c9-fe783a7556e0\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>반면 논블로킹에서는 A함수가 B함수를 호출하더라도 제어권을 계속 유지한다.</p>\n\n<p>따라서 B함수가 실행되는 동안에도, A함수는 제어권을 가지고 있기 때문에 다른 작업을 수행할 수 있다.</p>\n\n<p>이렇게 호출자(caller)인 A함수는 B함수의 작업 완료 여부와 관계없이 자신의 작업을 계속 수행할 수 있다.</p>\n\n<p><br /></p>\n\n<h1 id=\"4-네-가지-조합의-동작-방식\">4. 네 가지 조합의 동작 방식</h1>\n\n<p>가끔 동기 처리에서는 무조건적으로 블로킹이 일어나고, 비동기에서는 논블로킹이 일어난다고 오해하는 경우가 많다.</p>\n\n<p>하지만 두 쌍의 개념은 서로 다른 관점에서 바라보는 개념이라는 것을 확실하게 하고 넘어가자.</p>\n\n<blockquote>\n  <p>동기/비동기 : 작업들의 시간적 관계성 <br />\n블로킹/논블로킹 : 제어권의 소재</p>\n</blockquote>\n\n<p>하지만 이 개념들이 오해가 잦은 이유는 실제 구현에서 [동기/볼로킹 &amp; 비동기/논블로킹]이 <strong>자주 함께 사용</strong>되기 때문이다.</p>\n\n<p>다음 그림을 보고 4가지 조합에 대해 천천히 살펴보자.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b894be55-d296-424d-913f-ee989233eb60\" alt=\"image\" width=\"100%\" class=\"center\" /></p>\n\n<p>먼저 흔히 쓰이는 [동기/볼로킹 &amp; 비동기/논블로킹] 에 대해 보자.</p>\n\n<h2 id=\"4-1-동기--블로킹\">4-1. 동기 + 블로킹</h2>\n\n<p>작업의 흐름이 순차적으로 진행되는 것이 보장된다. (<strong>동기</strong>)</p>\n\n<p>제어권을 함수 B에게 넘겨준 후 함수 A는 대기하게 된다. (<strong>블로킹</strong>)</p>\n\n<p>함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄 때까지 함수 A는 기다리는 것이다.</p>\n\n<blockquote>\n  <p>이러한 조합은 <strong>작업이 완료될 때까지 기다려야 하는 경우</strong>에 사용된다. <br />\n예를 들면, 파일을 읽은 후 이를 처리하는 코드를 생각해보자. <br />\n파일을 처리하는 과정은 <strong>필연적으로 파일을 모두 읽은 후에 작업이 가능</strong>하기 때문이다. <br />\n또한, 일반적으로 작업이 간단하거나 작업량이 적은 경우에 사용된다. <br />\n작업량이 많거나 오래 걸리는 작업을 해당 방식으로 처리하면 <strong>전체 프로그램이 멈춘 것 처럼 보여</strong> 사용자 경험 측면에서 나빠질 수 있다.</p>\n</blockquote>\n\n<h2 id=\"4-2-비동기--논블로킹\">4-2. 비동기 + 논블로킹</h2>\n\n<p>비동기 + 논블로킹 방식도 비교적 이해가 쉽다.</p>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다. (<strong>논블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 방식이다. (<strong>동기</strong>)</p>\n\n<p>함수 B를 호출 할 때, 콜백 함수를 함께 줌으로써, 함수 B는 자신의 작업이 끝났을 때 <strong>함수 A에게 준 콜백 함수를 실행시켜 자신의 작업이 끝났음</strong>을 알려준다.</p>\n\n<p>작업 A는 함수 B의 종료 여부에는 일단 관심이 없다.</p>\n\n<p>B 함수가 자신의 실행을 완료했다면, A 함수의 어깨를 톡톡 쳐서 알려주면 되는 것이다.</p>\n\n<blockquote>\n  <p>다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우에 활용할 수 있다. <br />\n또한, 대용량의 데이터를 처리하는 서비스에서 흔히 사용된다. <br />\n가장 큰 특징은 호출 함수에 콜백 함수를 넣었다는 점이다.</p>\n</blockquote>\n\n<h2 id=\"4-3-동기--논블로킹\">4-3. 동기 + 논블로킹</h2>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다.</p>\n\n<p>이후 바로 자신의 코드를 실행한다. (<strong>논블로킹</strong>)</p>\n\n<p>즉, 다른 작업이 진행되는 동안에도 자신의 작업을 별개로 처리할 수 있다.</p>\n\n<p>조심할 것이 함수 A는 함수 B의 Return 값을 필요로 하는 것은 변함이 없다는 점이다.</p>\n\n<p>A 함수는 B 함수의 리턴값이 필요하기 때문에, 중간중간 B 함수에게 함수 실행을 완료했는지 물어본다.</p>\n\n<p>즉, A 함수(caller)가 B 함수(callee)의 실행이 종료되었는지 계속 예의 주시해야 한다. (순서 보장을 위해)</p>\n\n<p>이로써 작업을 순차대로 수행할 수 있는 것이다. (<strong>동기</strong>)</p>\n\n<p>여기서 조금 더 깊게 생각해보자.</p>\n\n<p>어떻게 동기적으로 진행되면서 메인 쓰레드가 논블로킹이 될 수 있을까?</p>\n\n<p>이 조합의 특징은 “작업 완료는 비동기로 처리하지만, 호출자는 필요할 때 결과를 동기적으로 받는다.”로 정리할 수 있다.</p>\n\n<p>즉, <strong>순서를 유지하면서 결과를 사용해야 할 때 동기적으로 기다릴 수 있다.</strong></p>\n\n<p>결국 <strong>동기적</strong> 이라는 말은 <strong>호출자의 결과가 필요한 시점에서 순서를 보장</strong>하며 작업을 진행한다는 것이다.</p>\n\n<p>다음 JAVA 코드의 예시를 봐보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SimpleDownloader</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>  <span class=\"c1\">// 다운로드 진행률</span>\n        \n        <span class=\"c1\">// 다운로드 시작</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"파일 다운로드를 시작합니다.\"</span><span class=\"o\">);</span>\n        \n        <span class=\"c1\">// 진행률 확인하면서 다른 작업 수행 (논블로킹)</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">downloadProgress</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">{</span>  <span class=\"c1\">// 동기적: 순서 보장</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"진행률: \"</span> <span class=\"o\">+</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">+</span> <span class=\"s\">\"%\"</span><span class=\"o\">);</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다른 작업을 할 수 있어요!\"</span><span class=\"o\">);</span>\n            \n            <span class=\"c1\">// 진행률이 증가한다고 가정</span>\n            <span class=\"n\">downloadProgress</span> <span class=\"o\">+=</span> <span class=\"mi\">20</span><span class=\"o\">;</span>\n            \n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>  <span class=\"c1\">// 1초 대기</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        \n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다운로드 완료!\"</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><em>🚨 주의: 이 예시 코드는 Thread를 사용하고 있다. <br />\nThread는 기본적으로 작업을 병렬적으로 처리하기 위한 도구이다. <br />\n비동기 프로그래밍에서는 이러한 Thread의 병렬 처리 능력을 활용하여 비동기 작업을 구현하는 것이 일반적이다. <br />\n하지만 이 예시의 주된 목적은 작업이 어떻게 논블로킹하면서도 동기적으로 처리될 수 있는지를 시각적으로 보여주는 것이다. <br />\nThread를 사용한 것은 개념을 쉽게 설명하기 위한 것이다.</em></p>\n\n<p>이 코드의 결과는 다음과 같을 것이다.</p>\n<div class=\"language-css highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">나는</span> <span class=\"nt\">다른</span> <span class=\"nt\">작업을</span> <span class=\"nt\">진행할게</span><span class=\"o\">.</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">시작</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">0</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">1</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">2</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">완료</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드</span> <span class=\"nt\">종료</span> <span class=\"nt\">확인</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">모든</span> <span class=\"nt\">작업</span> <span class=\"nt\">완료</span><span class=\"o\">.</span>\n</code></pre></div></div>\n\n<p>물론, 논블로킹 메서드로 비동기 작업을 시작하더라도, 결과를 기다려야 하는 시점에서는 블로킹처럼 동작할 수 있다. <br />\n왜냐하면 메인 스레드가 결과를 받아야만 다음 작업을 진행할 수 있기 때문에, 그 시점에서는 블로킹이 되는 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b43ec8c4-9783-4fbf-9f7a-3736dff051bb\" alt=\"image\" width=\"80%\" class=\"center\" /></p>\n\n<p>사실 이러한 방식의 구현은 흔치 않다. <br />\n하지만, 몇 가지 활용 예를 알아보자면 <strong>게임 로딩화면 구성</strong> 등에 활용될 수 있다. <br />\n보통 게임에서 패치나 다운로드를 할 때, 사용자에게 ProgressBar나 게임 Tip등을 띄워줘야 할 때가 있다. <br />\n이 때는 Load 하는 동작이 완료될 때 까지 (작업 순서는 보장 = Sync) <br />\n다른 작업이 진행될 수 있다. (Non-Blocking)\n즉, 사용자 경험 측면에서 유용하게 활용될 수 있다.</p>\n\n<blockquote>\n  <p>언어 간에는 구현 방식에 차이가 있을 수 있다. <br />\n이는 각 언어의 특성과 제공되는 라이브러리나 기술에 따라 달라질 수 있다. <br />\n예를 들어, JavaScript는 단일 스레드 기반으로 동작하며, 콜백 함수, 프로미스(Promise), async/await 등의 메커니즘을 사용해 동기와 논블로킹 처리를 구현할 수 있다. <br />\n기본적으로 Promise.then 방식은 비동기적이고 논블로킹 방식으로 처리된다. <br />\n그러나 async/await 키워드를 사용하면, 비동기 작업의 순서를 지정할 수 있다.<br />\n중요한 점은, async 함수가 내부적으로 비동기적으로 동작하며, 메인 콜 스택이 모두 비워져야 실행된다는 것이다. <br />\n이로 인해 async/await도 내부적으로는 여전히 비동기적이고 논블로킹 방식으로 동작한다는 점을 유의해야 한다.\n(동기적인 코드 흐름처럼 보이게 하는 트릭)</p>\n</blockquote>\n\n<h2 id=\"4-4-비동기--블로킹\">4-4. 비동기 + 블로킹</h2>\n\n<p>이러한 방식은 사실 실무에서 마주치기 더더욱 흔치 않다.</p>\n\n<p>개념만 간단히 설명하자면,</p>\n\n<p>다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다린다. (<strong>블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않고, 콜백함수를 보낸 후 기다린다.</p>\n\n<p>이로써 작업 완료의 순서는 보장되지 않을 수 있다. (<strong>비동기</strong>)</p>\n\n<p><strong>즉, 함수 A는 자신과 관련없는 함수 B의 작업이 끝날 때까지 기다려야 한다.</strong>\n<em>매우 비효율적인 로직…</em></p>\n\n<p>1 작업 중에 2 작업을 해야지 Async의 이점을 살릴 수 있는 것인데,\n이것을 다시 Blocking 방식을 사용함여 대기시킴으로써 이점을 제거해버린 것이다…😅\n대부분의 경우 비동기+논블로킹 모델이 더 효율적인 선택이 될 것이다.</p>\n\n<p><br /></p>\n\n<h1 id=\"5-현대-프로그래밍에서-이러한-개념이-왜-중요한가\">5. 현대 프로그래밍에서 이러한 개념이 왜 중요한가?</h1>\n\n<p>이러한 이해는 현대 소프트웨어 개발에서 매우 중요하다. 오늘날의 애플리케이션들은 수많은 동시다발적인 작업을 처리해야 한다. 사용자는 파일을 다운로드하면서 동시에 문서를 편집하길 원하고, 데이터가 백그라운드에서 처리되는 동안에도 끊김 없는 인터페이스 사용을 기대한다.</p>\n\n<p>더군다나 클라우드 컴퓨팅과 마이크로서비스 아키텍처가 보편화된 현대 개발 환경에서는, 네트워크를 통한 수많은 비동기 작업들이 동시에 발생한다. 이때 각 작업을 어떻게 처리할지, 작업 간의 의존성은 어떻게 관리할지를 결정하는 것은 시스템의 성능과 사용자 경험을 좌우하는 핵심 요소가 된다.</p>\n\n<p>결국 이러한 개념들의 이해는 단순히 기술적인 지식을 넘어서, 현대 소프트웨어가 직면한 복잡성과 사용자 경험의 요구사항을 어떻게 조화롭게 해결할 수 있을지에 대한 통찰을 제공한다. 이는 우리가 더 효율적이고, 반응성 높은, 그리고 사용자 친화적인 소프트웨어를 설계하고 구현하는 데 있어 필수적인 기반이 될 것이다.</p>\n\n<h1 id=\"6-마무리\">6. 마무리</h1>\n<p>그렇다면 Java에서는 이러한 비동기 처리를 어떻게 구현할 수 있을까?</p>\n\n<p>Java의 비동기 프로그래밍은 Thread를 시작으로, 현대적인 CompletableFuture까지 꾸준히 발전해왔다.</p>\n\n<p>이제 각각의 방식을 자세히 살펴보겠다.</p>\n",
                        "tags": ["Java","Spring-Boot","Backend","Sync","Async","Concurrency","Blocking","NonBlocking"]
                    }
                
            ],
        
            "Concurrency": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    },
                
                    {
                        "title": "동기/비동기와 블로킹/논블로킹에 대해 깊이 파헤치기",
                        "url": "/2025/01/12/understanding-sync-async-blocking-non-blocking.html",
                        "subtitle": "Java/SpringBoot에서의 비동기 처리",
                        "excerpt": "1. 개념적 이해\n",
                        "author": "Jinho",
                        "date": "January 12, 2025",
                        "background": "/img/posts/sync-async-concept.jpeg",
                        "content": "<h1 id=\"1-개념적-이해\">1. 개념적 이해</h1>\n\n<p>비동기 처리에 대해 이야기하기 앞서, 과연 “동기”란 어떤 것인지부터 바로 잡고 가려고한다.</p>\n\n<p>왜냐하면 <strong>비(非)동기</strong>란 동기가 아니다라는 의미이기 때문에 동기가 무엇인지부터 정확히 하고 싶었다.</p>\n\n<p>또한 나는 처음에 ‘동기=블로킹, 비동기=논블로킹’이라고 단순하게 이해하고 있었다.</p>\n\n<p>하지만 실제로는 두 개념이 분류 기준이 전혀 다른 독립적인 개념이라는 것을 알게 되었다.</p>\n\n<p>이렇듯 서로 혼동되어 쓰이는 각 명칭은 어떤 의미인지 알아보려고 한다.</p>\n\n<p>이에 대해 자세히 알아보자.</p>\n\n<p><br /></p>\n\n<h1 id=\"2-동기와-비동기\">2. 동기와 비동기</h1>\n\n<p><img src=\"https://velog.velcdn.com/images/jinho7/post/a47f1973-3895-4438-a47f-80dd80245e41/image.png\" alt=\"\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<blockquote>\n  <p>동기와 비동기는 “작업의 처리 방식”을 나타내는 개념이다. <br />\n결론부터 말하자면, 이둘의 주요한 차이점은 “작업 순서 처리 차이”이다.</p>\n</blockquote>\n\n<h2 id=\"2-1-동기-순차적으로-실행\">2-1. 동기: 순차적으로 실행</h2>\n<p>필자는 이전에 동기를 <strong>겹치지 않고 순차적으로 작업을 진행하는 것</strong> 정도로 이해하고 있었다.</p>\n\n<p>영어 사전을 참고해보자.</p>\n\n<blockquote>\n  <p>synchronous\nadjective\nhappening or done at the same time or speed:</p>\n</blockquote>\n\n<p><strong>Synchronous</strong> 는 동시에 발생하는 두 개 이상의 사건이나 프로세스가 동일한 시간에서 진행되는 것을 의미하는 형용사이다.</p>\n\n<p>중요한 워딩은 [동일한 시간에 여러 개의 사건이 진행] 된다는 것이다.</p>\n\n<p>‘순차적’과 ‘동시’라는 단어가 서로 상충된다고 생각할 수 있다.</p>\n\n<p>여기서 오해하면 안되는 것이 이는 <strong>병렬적인 작업방식을 말하는 것이 아니다.</strong></p>\n\n<p>“어떠한 일정 시점에 현재 작업의 Response과 다음 작업의 Request이 함께 진행되는 것”</p>\n\n<p>위의 그림을 참고하면 이해가 쉽다.\n작업 A가 끝나는 시간과 작업 B가 시작하는 시간이 동기화된다고 이해하면 좋을 것 같다.</p>\n\n<p>이는 <strong>작업이 순차적으로 처리되며, 이전 작업이 완료될 때까지는 다음 작업이 시작되지 않음을 나타낸다.</strong></p>\n\n<p>즉, <strong>작업들이 서로 시간적 의존성을 가지고 실행된다</strong>는 뜻이다.</p>\n\n<p>동기 방식은 실행 순서가 보장되며 예측 가능하다는 장점이 있지만, <br />\n앞선 작업이 오래 걸리면 전체 작업이 지연된다는 단점도 있다.</p>\n\n<h2 id=\"2-2-비동기-독립적으로-실행\">2-2. 비동기: 독립적으로 실행</h2>\n<p>그렇다면 비동기 방식은 무엇일까?</p>\n\n<p>반대의 경우를 생각하면 된다.</p>\n\n<p>위의 그림을 참고하면 작업들이 병렬적으로 일어나고 있음을 알 수 있다.</p>\n\n<p>동기와 반대로 <strong>“요청을 보냈을 때 응답 상태와 상관없이 다른 동작을 수행할 수 있다.”</strong>는 점이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/0a188e4a-b35f-41aa-9953-94504330dd9f\" alt=\"다운로드\" width=\"68%\" height=\"50%\" class=\"center\" />\n<em class=\"image-caption\">파일 다운로드가 동기 방식이라면?</em></p>\n\n<p>만약에 파일 다운로드를 동기적으로 처리한다고 해보자.</p>\n\n<p>아마 파일이 다운로드될 때까지 아무런 작업도 수행할 수 없을 것이고,\n파일이 완전히 다운로드된 후에 다음 작업을 진행할 수 있을 것이다. 😅</p>\n\n<p>매우 비효율적인 방식이다…</p>\n\n<p>그러나 비동기적인 방식을 활용한다면, 파일 다운로드 작업을 시작시켜놓고, 다른 작업을 수행할 수 있다.</p>\n\n<p>파일이 다운로드되면 특정 콜백 함수를 호출하여, 다운로드된 파일을 처리하거나 결과를 반환받을 수 있다.</p>\n\n<p>콜백 뿐만이 아니고, 그 결과는 콜백 함수, Promise, 이벤트 등을 통해 전달받을 수 있다.</p>\n\n<p>마치 택배를 주문하고 배송 알림을 받는 것과 비슷하다고 할 수 있다.</p>\n\n<h3 id=\"비동기-동작-방식에-대한-오해\">비동기 동작 방식에 대한 오해</h3>\n<p>많은 개발자들이 <strong>비동기 = 멀티 쓰레드</strong>라고 이해하고 있다.</p>\n\n<p>단순히 생각해보아도, 여러 작업이 동시에 처리되는 비동기 동작을 구현하기 위해서는 당연히 여러 개의 쓰레드가 필요할 것 같기 때문이다.</p>\n\n<p>또한, 특히나 대부분의 Java 개발자들이 비동기 프로그래밍을 접할 때 아래와 같은 코드를 통해 배우기 때문이다.</p>\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 여기서 실제로 별도의 스레드에서 실행됨</span>\n    <span class=\"k\">return</span> <span class=\"nf\">heavyTask</span><span class=\"o\">();</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p>우리는 Java에서 비동기 처리에 대해 다룰 때, ExecutorService나 CompletableFuture와 같은 도구들을 함께 배운다.</p>\n\n<p>이들은 내부적으로 <strong>스레드 풀</strong>을 사용하기 때문에, 자연스럽게 비동기 처리와 멀티 쓰레드를 동일시하게 된다.</p>\n\n<p>실제로 Spring Framework의 @Async 어노테이션도 비동기 처리를 위해 기본적으로 스레드 풀을 사용한다.</p>\n\n<p>하지만 비동기 처리의 본질은 <strong>“작업의 완료를 기다리지 않고 다른 작업을 수행할 수 있는 것”</strong>이다.</p>\n\n<p>이는 반드시 멀티스레드로만 구현되어야 하는 것이 아니며, Node.js가 좋은 예시다.</p>\n\n<p>Node.js는 싱글 스레드 기반의 이벤트 루프를 사용하여 비동기 처리를 구현한다.</p>\n\n<p>이벤트 루프는 OS의 비동기 I/O 기능을 활용하여 실제 I/O 작업을 커널 레벨에서 처리하고,</p>\n\n<p>작업이 완료되면 이벤트를 통해 알림을 받는 방식으로 동작한다.</p>\n\n<div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Node.js의 비동기 처리 (싱글스레드)</span>\n<span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nf\">readFile</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">file.txt</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">파일 읽기 완료</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">다음 작업 실행</span><span class=\"dl\">'</span><span class=\"p\">);</span>  <span class=\"c1\">// 파일 읽기를 기다리지 않고 실행</span>\n</code></pre></div></div>\n<p>이러한 이벤트 루프 기반의 비동기 처리는 멀티스레드 없이도 효율적인 비동기 처리를 가능하게 한다.\nOS의 비동기 I/O 기능을 활용하여, 실제 I/O 작업은 커널 레벨에서 처리되고, 완료되면 이벤트를 통해 알림을 받는 방식이다.\n<em>정확히는 JavaScript 엔진이 싱글 스레드 기반이다</em>\n<em>해당 내용에 대해 더 자세히 알고 싶다면 <a href=\"https://puleugo.tistory.com/133\">해당 블로그</a>를 참고하자</em></p>\n\n<p><br /></p>\n\n<h1 id=\"3-블로킹과-논블로킹\">3. 블로킹과 논블로킹</h1>\n<blockquote>\n  <p>블로킹과 논블로킹은 “제어권의 이동” 관점에서 바라보는 개념이다.</p>\n</blockquote>\n\n<p>결국 “호출한 함수가 다른 일을 할 수 있는가?”의 여부를 의미한다.</p>\n\n<h2 id=\"3-1-제어권control-flow의-의미\">3-1. 제어권(Control Flow)의 의미</h2>\n<p>여기서 <strong>제어권</strong>이란 어떤 의미를 갖는지 먼저 보자.\nOS적인 관점에서 보자면, <strong>현재 작업을 진행하고 있는 함수가 CPU를 점유하는 것</strong>을 의미한다.\n쉽게 말해 “코드를 실행시킬 수 있는 권한” 정도로 말할 수 있다.</p>\n\n<p>동기 와 비동기는 Jobs 들이 순서대로 혹은 독립적으로 처리되는가에 관한 이야기라면,\n이번에는 호출한 함수가 별개의 일을 할 수 있는지의 이야기이다.</p>\n\n<h2 id=\"3-2-블로킹-제어권을-넘겨주는-방식\">3-2. 블로킹: 제어권을 넘겨주는 방식</h2>\n<p>마치 시험지를 넘겨주는 방식을 생각하면 편할 것 같다.\n<img src=\"https://github.com/user-attachments/assets/6eb36e86-150c-4144-86ce-6080ef86bece\" alt=\"image\" width=\"60%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : https://www.veritas-a.com/news/articleView.html?idxno=156699</em></p>\n\n<p>내가 뒷 사람에게 시험지를 넘겨줄 때,\n나는 아무런 행동도 하지 않고 <strong>뒷 사람(호출된 함수)가 시험지를 가져가는(자신의 작업을 완료)할 때 까지</strong> 나는 손에 시험지를 쥐고 뒷사람을 바라보고 대기할 수 밖에 없다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d799e31b-9406-44f3-8dcc-9df15b8f8a79\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>둘 간의 구분 방법은 제어권이 누구에게 있는지로 결정된다.</p>\n\n<p>블로킹에서는 함수 A가 함수 B를 호출할 때 제어권이 B로 넘어간다.</p>\n\n<p>제어권을 넘겨준 A는 B의 작업이 완료될 때까지 아무 작업도 수행할 수 없는 상태, 즉 블로킹 상태가 된다.</p>\n\n<p>즉, 위의 사진에서 A함수는 B함수에게 제어권을 넘겨줌과 동시에 함수 실행이 일시 정지된다. = Blocking</p>\n\n<h2 id=\"3-3-논블로킹-제어권을-유지하는-방식\">3-3. 논블로킹: 제어권을 유지하는 방식</h2>\n<p>하지만 시험지를 그냥 뒷 사람 책상에 올려 놓는다면 어떨까.</p>\n\n<p>나는 실제 뒷 사람이 받는 것을 대기할 필요없이, 바로 나의 다른 작업을 할 수 있다.</p>\n\n<p>즉, 뒷 사람(호출된 함수)이 나에 대한 제어권을 바로 반환해줌으로, 호출한 쪽(나)에서는 계속 다른 작업을 할 수 있는 것이다.</p>\n\n<p>같은 “읽기” 작업이어도 동기와 비동기 처리에 따라 어떻게 다르게 동작하는지 보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹: 제어권을 넘겨줌</span>\n<span class=\"nc\">String</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">readFile</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 파일 읽을 때까지 다른 일 못함</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                          <span class=\"c1\">// 파일 다 읽고 나서야 실행</span>\n\n<span class=\"c1\">// 논블로킹: 제어권을 유지</span>\n<span class=\"nc\">Future</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">readFileAsync</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 요청만 하고</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                               <span class=\"c1\">// 바로 다른 일 할 수 있음</span>\n</code></pre></div></div>\n<p><img src=\"https://github.com/user-attachments/assets/4a59addb-b12d-4eaa-90c9-fe783a7556e0\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>반면 논블로킹에서는 A함수가 B함수를 호출하더라도 제어권을 계속 유지한다.</p>\n\n<p>따라서 B함수가 실행되는 동안에도, A함수는 제어권을 가지고 있기 때문에 다른 작업을 수행할 수 있다.</p>\n\n<p>이렇게 호출자(caller)인 A함수는 B함수의 작업 완료 여부와 관계없이 자신의 작업을 계속 수행할 수 있다.</p>\n\n<p><br /></p>\n\n<h1 id=\"4-네-가지-조합의-동작-방식\">4. 네 가지 조합의 동작 방식</h1>\n\n<p>가끔 동기 처리에서는 무조건적으로 블로킹이 일어나고, 비동기에서는 논블로킹이 일어난다고 오해하는 경우가 많다.</p>\n\n<p>하지만 두 쌍의 개념은 서로 다른 관점에서 바라보는 개념이라는 것을 확실하게 하고 넘어가자.</p>\n\n<blockquote>\n  <p>동기/비동기 : 작업들의 시간적 관계성 <br />\n블로킹/논블로킹 : 제어권의 소재</p>\n</blockquote>\n\n<p>하지만 이 개념들이 오해가 잦은 이유는 실제 구현에서 [동기/볼로킹 &amp; 비동기/논블로킹]이 <strong>자주 함께 사용</strong>되기 때문이다.</p>\n\n<p>다음 그림을 보고 4가지 조합에 대해 천천히 살펴보자.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b894be55-d296-424d-913f-ee989233eb60\" alt=\"image\" width=\"100%\" class=\"center\" /></p>\n\n<p>먼저 흔히 쓰이는 [동기/볼로킹 &amp; 비동기/논블로킹] 에 대해 보자.</p>\n\n<h2 id=\"4-1-동기--블로킹\">4-1. 동기 + 블로킹</h2>\n\n<p>작업의 흐름이 순차적으로 진행되는 것이 보장된다. (<strong>동기</strong>)</p>\n\n<p>제어권을 함수 B에게 넘겨준 후 함수 A는 대기하게 된다. (<strong>블로킹</strong>)</p>\n\n<p>함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄 때까지 함수 A는 기다리는 것이다.</p>\n\n<blockquote>\n  <p>이러한 조합은 <strong>작업이 완료될 때까지 기다려야 하는 경우</strong>에 사용된다. <br />\n예를 들면, 파일을 읽은 후 이를 처리하는 코드를 생각해보자. <br />\n파일을 처리하는 과정은 <strong>필연적으로 파일을 모두 읽은 후에 작업이 가능</strong>하기 때문이다. <br />\n또한, 일반적으로 작업이 간단하거나 작업량이 적은 경우에 사용된다. <br />\n작업량이 많거나 오래 걸리는 작업을 해당 방식으로 처리하면 <strong>전체 프로그램이 멈춘 것 처럼 보여</strong> 사용자 경험 측면에서 나빠질 수 있다.</p>\n</blockquote>\n\n<h2 id=\"4-2-비동기--논블로킹\">4-2. 비동기 + 논블로킹</h2>\n\n<p>비동기 + 논블로킹 방식도 비교적 이해가 쉽다.</p>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다. (<strong>논블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 방식이다. (<strong>동기</strong>)</p>\n\n<p>함수 B를 호출 할 때, 콜백 함수를 함께 줌으로써, 함수 B는 자신의 작업이 끝났을 때 <strong>함수 A에게 준 콜백 함수를 실행시켜 자신의 작업이 끝났음</strong>을 알려준다.</p>\n\n<p>작업 A는 함수 B의 종료 여부에는 일단 관심이 없다.</p>\n\n<p>B 함수가 자신의 실행을 완료했다면, A 함수의 어깨를 톡톡 쳐서 알려주면 되는 것이다.</p>\n\n<blockquote>\n  <p>다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우에 활용할 수 있다. <br />\n또한, 대용량의 데이터를 처리하는 서비스에서 흔히 사용된다. <br />\n가장 큰 특징은 호출 함수에 콜백 함수를 넣었다는 점이다.</p>\n</blockquote>\n\n<h2 id=\"4-3-동기--논블로킹\">4-3. 동기 + 논블로킹</h2>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다.</p>\n\n<p>이후 바로 자신의 코드를 실행한다. (<strong>논블로킹</strong>)</p>\n\n<p>즉, 다른 작업이 진행되는 동안에도 자신의 작업을 별개로 처리할 수 있다.</p>\n\n<p>조심할 것이 함수 A는 함수 B의 Return 값을 필요로 하는 것은 변함이 없다는 점이다.</p>\n\n<p>A 함수는 B 함수의 리턴값이 필요하기 때문에, 중간중간 B 함수에게 함수 실행을 완료했는지 물어본다.</p>\n\n<p>즉, A 함수(caller)가 B 함수(callee)의 실행이 종료되었는지 계속 예의 주시해야 한다. (순서 보장을 위해)</p>\n\n<p>이로써 작업을 순차대로 수행할 수 있는 것이다. (<strong>동기</strong>)</p>\n\n<p>여기서 조금 더 깊게 생각해보자.</p>\n\n<p>어떻게 동기적으로 진행되면서 메인 쓰레드가 논블로킹이 될 수 있을까?</p>\n\n<p>이 조합의 특징은 “작업 완료는 비동기로 처리하지만, 호출자는 필요할 때 결과를 동기적으로 받는다.”로 정리할 수 있다.</p>\n\n<p>즉, <strong>순서를 유지하면서 결과를 사용해야 할 때 동기적으로 기다릴 수 있다.</strong></p>\n\n<p>결국 <strong>동기적</strong> 이라는 말은 <strong>호출자의 결과가 필요한 시점에서 순서를 보장</strong>하며 작업을 진행한다는 것이다.</p>\n\n<p>다음 JAVA 코드의 예시를 봐보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SimpleDownloader</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>  <span class=\"c1\">// 다운로드 진행률</span>\n        \n        <span class=\"c1\">// 다운로드 시작</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"파일 다운로드를 시작합니다.\"</span><span class=\"o\">);</span>\n        \n        <span class=\"c1\">// 진행률 확인하면서 다른 작업 수행 (논블로킹)</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">downloadProgress</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">{</span>  <span class=\"c1\">// 동기적: 순서 보장</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"진행률: \"</span> <span class=\"o\">+</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">+</span> <span class=\"s\">\"%\"</span><span class=\"o\">);</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다른 작업을 할 수 있어요!\"</span><span class=\"o\">);</span>\n            \n            <span class=\"c1\">// 진행률이 증가한다고 가정</span>\n            <span class=\"n\">downloadProgress</span> <span class=\"o\">+=</span> <span class=\"mi\">20</span><span class=\"o\">;</span>\n            \n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>  <span class=\"c1\">// 1초 대기</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        \n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다운로드 완료!\"</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><em>🚨 주의: 이 예시 코드는 Thread를 사용하고 있다. <br />\nThread는 기본적으로 작업을 병렬적으로 처리하기 위한 도구이다. <br />\n비동기 프로그래밍에서는 이러한 Thread의 병렬 처리 능력을 활용하여 비동기 작업을 구현하는 것이 일반적이다. <br />\n하지만 이 예시의 주된 목적은 작업이 어떻게 논블로킹하면서도 동기적으로 처리될 수 있는지를 시각적으로 보여주는 것이다. <br />\nThread를 사용한 것은 개념을 쉽게 설명하기 위한 것이다.</em></p>\n\n<p>이 코드의 결과는 다음과 같을 것이다.</p>\n<div class=\"language-css highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">나는</span> <span class=\"nt\">다른</span> <span class=\"nt\">작업을</span> <span class=\"nt\">진행할게</span><span class=\"o\">.</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">시작</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">0</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">1</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">2</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">완료</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드</span> <span class=\"nt\">종료</span> <span class=\"nt\">확인</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">모든</span> <span class=\"nt\">작업</span> <span class=\"nt\">완료</span><span class=\"o\">.</span>\n</code></pre></div></div>\n\n<p>물론, 논블로킹 메서드로 비동기 작업을 시작하더라도, 결과를 기다려야 하는 시점에서는 블로킹처럼 동작할 수 있다. <br />\n왜냐하면 메인 스레드가 결과를 받아야만 다음 작업을 진행할 수 있기 때문에, 그 시점에서는 블로킹이 되는 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b43ec8c4-9783-4fbf-9f7a-3736dff051bb\" alt=\"image\" width=\"80%\" class=\"center\" /></p>\n\n<p>사실 이러한 방식의 구현은 흔치 않다. <br />\n하지만, 몇 가지 활용 예를 알아보자면 <strong>게임 로딩화면 구성</strong> 등에 활용될 수 있다. <br />\n보통 게임에서 패치나 다운로드를 할 때, 사용자에게 ProgressBar나 게임 Tip등을 띄워줘야 할 때가 있다. <br />\n이 때는 Load 하는 동작이 완료될 때 까지 (작업 순서는 보장 = Sync) <br />\n다른 작업이 진행될 수 있다. (Non-Blocking)\n즉, 사용자 경험 측면에서 유용하게 활용될 수 있다.</p>\n\n<blockquote>\n  <p>언어 간에는 구현 방식에 차이가 있을 수 있다. <br />\n이는 각 언어의 특성과 제공되는 라이브러리나 기술에 따라 달라질 수 있다. <br />\n예를 들어, JavaScript는 단일 스레드 기반으로 동작하며, 콜백 함수, 프로미스(Promise), async/await 등의 메커니즘을 사용해 동기와 논블로킹 처리를 구현할 수 있다. <br />\n기본적으로 Promise.then 방식은 비동기적이고 논블로킹 방식으로 처리된다. <br />\n그러나 async/await 키워드를 사용하면, 비동기 작업의 순서를 지정할 수 있다.<br />\n중요한 점은, async 함수가 내부적으로 비동기적으로 동작하며, 메인 콜 스택이 모두 비워져야 실행된다는 것이다. <br />\n이로 인해 async/await도 내부적으로는 여전히 비동기적이고 논블로킹 방식으로 동작한다는 점을 유의해야 한다.\n(동기적인 코드 흐름처럼 보이게 하는 트릭)</p>\n</blockquote>\n\n<h2 id=\"4-4-비동기--블로킹\">4-4. 비동기 + 블로킹</h2>\n\n<p>이러한 방식은 사실 실무에서 마주치기 더더욱 흔치 않다.</p>\n\n<p>개념만 간단히 설명하자면,</p>\n\n<p>다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다린다. (<strong>블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않고, 콜백함수를 보낸 후 기다린다.</p>\n\n<p>이로써 작업 완료의 순서는 보장되지 않을 수 있다. (<strong>비동기</strong>)</p>\n\n<p><strong>즉, 함수 A는 자신과 관련없는 함수 B의 작업이 끝날 때까지 기다려야 한다.</strong>\n<em>매우 비효율적인 로직…</em></p>\n\n<p>1 작업 중에 2 작업을 해야지 Async의 이점을 살릴 수 있는 것인데,\n이것을 다시 Blocking 방식을 사용함여 대기시킴으로써 이점을 제거해버린 것이다…😅\n대부분의 경우 비동기+논블로킹 모델이 더 효율적인 선택이 될 것이다.</p>\n\n<p><br /></p>\n\n<h1 id=\"5-현대-프로그래밍에서-이러한-개념이-왜-중요한가\">5. 현대 프로그래밍에서 이러한 개념이 왜 중요한가?</h1>\n\n<p>이러한 이해는 현대 소프트웨어 개발에서 매우 중요하다. 오늘날의 애플리케이션들은 수많은 동시다발적인 작업을 처리해야 한다. 사용자는 파일을 다운로드하면서 동시에 문서를 편집하길 원하고, 데이터가 백그라운드에서 처리되는 동안에도 끊김 없는 인터페이스 사용을 기대한다.</p>\n\n<p>더군다나 클라우드 컴퓨팅과 마이크로서비스 아키텍처가 보편화된 현대 개발 환경에서는, 네트워크를 통한 수많은 비동기 작업들이 동시에 발생한다. 이때 각 작업을 어떻게 처리할지, 작업 간의 의존성은 어떻게 관리할지를 결정하는 것은 시스템의 성능과 사용자 경험을 좌우하는 핵심 요소가 된다.</p>\n\n<p>결국 이러한 개념들의 이해는 단순히 기술적인 지식을 넘어서, 현대 소프트웨어가 직면한 복잡성과 사용자 경험의 요구사항을 어떻게 조화롭게 해결할 수 있을지에 대한 통찰을 제공한다. 이는 우리가 더 효율적이고, 반응성 높은, 그리고 사용자 친화적인 소프트웨어를 설계하고 구현하는 데 있어 필수적인 기반이 될 것이다.</p>\n\n<h1 id=\"6-마무리\">6. 마무리</h1>\n<p>그렇다면 Java에서는 이러한 비동기 처리를 어떻게 구현할 수 있을까?</p>\n\n<p>Java의 비동기 프로그래밍은 Thread를 시작으로, 현대적인 CompletableFuture까지 꾸준히 발전해왔다.</p>\n\n<p>이제 각각의 방식을 자세히 살펴보겠다.</p>\n",
                        "tags": ["Java","Spring-Boot","Backend","Sync","Async","Concurrency","Blocking","NonBlocking"]
                    }
                
            ],
        
            "Blocking": [
                
                    {
                        "title": "동기/비동기와 블로킹/논블로킹에 대해 깊이 파헤치기",
                        "url": "/2025/01/12/understanding-sync-async-blocking-non-blocking.html",
                        "subtitle": "Java/SpringBoot에서의 비동기 처리",
                        "excerpt": "1. 개념적 이해\n",
                        "author": "Jinho",
                        "date": "January 12, 2025",
                        "background": "/img/posts/sync-async-concept.jpeg",
                        "content": "<h1 id=\"1-개념적-이해\">1. 개념적 이해</h1>\n\n<p>비동기 처리에 대해 이야기하기 앞서, 과연 “동기”란 어떤 것인지부터 바로 잡고 가려고한다.</p>\n\n<p>왜냐하면 <strong>비(非)동기</strong>란 동기가 아니다라는 의미이기 때문에 동기가 무엇인지부터 정확히 하고 싶었다.</p>\n\n<p>또한 나는 처음에 ‘동기=블로킹, 비동기=논블로킹’이라고 단순하게 이해하고 있었다.</p>\n\n<p>하지만 실제로는 두 개념이 분류 기준이 전혀 다른 독립적인 개념이라는 것을 알게 되었다.</p>\n\n<p>이렇듯 서로 혼동되어 쓰이는 각 명칭은 어떤 의미인지 알아보려고 한다.</p>\n\n<p>이에 대해 자세히 알아보자.</p>\n\n<p><br /></p>\n\n<h1 id=\"2-동기와-비동기\">2. 동기와 비동기</h1>\n\n<p><img src=\"https://velog.velcdn.com/images/jinho7/post/a47f1973-3895-4438-a47f-80dd80245e41/image.png\" alt=\"\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<blockquote>\n  <p>동기와 비동기는 “작업의 처리 방식”을 나타내는 개념이다. <br />\n결론부터 말하자면, 이둘의 주요한 차이점은 “작업 순서 처리 차이”이다.</p>\n</blockquote>\n\n<h2 id=\"2-1-동기-순차적으로-실행\">2-1. 동기: 순차적으로 실행</h2>\n<p>필자는 이전에 동기를 <strong>겹치지 않고 순차적으로 작업을 진행하는 것</strong> 정도로 이해하고 있었다.</p>\n\n<p>영어 사전을 참고해보자.</p>\n\n<blockquote>\n  <p>synchronous\nadjective\nhappening or done at the same time or speed:</p>\n</blockquote>\n\n<p><strong>Synchronous</strong> 는 동시에 발생하는 두 개 이상의 사건이나 프로세스가 동일한 시간에서 진행되는 것을 의미하는 형용사이다.</p>\n\n<p>중요한 워딩은 [동일한 시간에 여러 개의 사건이 진행] 된다는 것이다.</p>\n\n<p>‘순차적’과 ‘동시’라는 단어가 서로 상충된다고 생각할 수 있다.</p>\n\n<p>여기서 오해하면 안되는 것이 이는 <strong>병렬적인 작업방식을 말하는 것이 아니다.</strong></p>\n\n<p>“어떠한 일정 시점에 현재 작업의 Response과 다음 작업의 Request이 함께 진행되는 것”</p>\n\n<p>위의 그림을 참고하면 이해가 쉽다.\n작업 A가 끝나는 시간과 작업 B가 시작하는 시간이 동기화된다고 이해하면 좋을 것 같다.</p>\n\n<p>이는 <strong>작업이 순차적으로 처리되며, 이전 작업이 완료될 때까지는 다음 작업이 시작되지 않음을 나타낸다.</strong></p>\n\n<p>즉, <strong>작업들이 서로 시간적 의존성을 가지고 실행된다</strong>는 뜻이다.</p>\n\n<p>동기 방식은 실행 순서가 보장되며 예측 가능하다는 장점이 있지만, <br />\n앞선 작업이 오래 걸리면 전체 작업이 지연된다는 단점도 있다.</p>\n\n<h2 id=\"2-2-비동기-독립적으로-실행\">2-2. 비동기: 독립적으로 실행</h2>\n<p>그렇다면 비동기 방식은 무엇일까?</p>\n\n<p>반대의 경우를 생각하면 된다.</p>\n\n<p>위의 그림을 참고하면 작업들이 병렬적으로 일어나고 있음을 알 수 있다.</p>\n\n<p>동기와 반대로 <strong>“요청을 보냈을 때 응답 상태와 상관없이 다른 동작을 수행할 수 있다.”</strong>는 점이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/0a188e4a-b35f-41aa-9953-94504330dd9f\" alt=\"다운로드\" width=\"68%\" height=\"50%\" class=\"center\" />\n<em class=\"image-caption\">파일 다운로드가 동기 방식이라면?</em></p>\n\n<p>만약에 파일 다운로드를 동기적으로 처리한다고 해보자.</p>\n\n<p>아마 파일이 다운로드될 때까지 아무런 작업도 수행할 수 없을 것이고,\n파일이 완전히 다운로드된 후에 다음 작업을 진행할 수 있을 것이다. 😅</p>\n\n<p>매우 비효율적인 방식이다…</p>\n\n<p>그러나 비동기적인 방식을 활용한다면, 파일 다운로드 작업을 시작시켜놓고, 다른 작업을 수행할 수 있다.</p>\n\n<p>파일이 다운로드되면 특정 콜백 함수를 호출하여, 다운로드된 파일을 처리하거나 결과를 반환받을 수 있다.</p>\n\n<p>콜백 뿐만이 아니고, 그 결과는 콜백 함수, Promise, 이벤트 등을 통해 전달받을 수 있다.</p>\n\n<p>마치 택배를 주문하고 배송 알림을 받는 것과 비슷하다고 할 수 있다.</p>\n\n<h3 id=\"비동기-동작-방식에-대한-오해\">비동기 동작 방식에 대한 오해</h3>\n<p>많은 개발자들이 <strong>비동기 = 멀티 쓰레드</strong>라고 이해하고 있다.</p>\n\n<p>단순히 생각해보아도, 여러 작업이 동시에 처리되는 비동기 동작을 구현하기 위해서는 당연히 여러 개의 쓰레드가 필요할 것 같기 때문이다.</p>\n\n<p>또한, 특히나 대부분의 Java 개발자들이 비동기 프로그래밍을 접할 때 아래와 같은 코드를 통해 배우기 때문이다.</p>\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 여기서 실제로 별도의 스레드에서 실행됨</span>\n    <span class=\"k\">return</span> <span class=\"nf\">heavyTask</span><span class=\"o\">();</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p>우리는 Java에서 비동기 처리에 대해 다룰 때, ExecutorService나 CompletableFuture와 같은 도구들을 함께 배운다.</p>\n\n<p>이들은 내부적으로 <strong>스레드 풀</strong>을 사용하기 때문에, 자연스럽게 비동기 처리와 멀티 쓰레드를 동일시하게 된다.</p>\n\n<p>실제로 Spring Framework의 @Async 어노테이션도 비동기 처리를 위해 기본적으로 스레드 풀을 사용한다.</p>\n\n<p>하지만 비동기 처리의 본질은 <strong>“작업의 완료를 기다리지 않고 다른 작업을 수행할 수 있는 것”</strong>이다.</p>\n\n<p>이는 반드시 멀티스레드로만 구현되어야 하는 것이 아니며, Node.js가 좋은 예시다.</p>\n\n<p>Node.js는 싱글 스레드 기반의 이벤트 루프를 사용하여 비동기 처리를 구현한다.</p>\n\n<p>이벤트 루프는 OS의 비동기 I/O 기능을 활용하여 실제 I/O 작업을 커널 레벨에서 처리하고,</p>\n\n<p>작업이 완료되면 이벤트를 통해 알림을 받는 방식으로 동작한다.</p>\n\n<div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Node.js의 비동기 처리 (싱글스레드)</span>\n<span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nf\">readFile</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">file.txt</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">파일 읽기 완료</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">다음 작업 실행</span><span class=\"dl\">'</span><span class=\"p\">);</span>  <span class=\"c1\">// 파일 읽기를 기다리지 않고 실행</span>\n</code></pre></div></div>\n<p>이러한 이벤트 루프 기반의 비동기 처리는 멀티스레드 없이도 효율적인 비동기 처리를 가능하게 한다.\nOS의 비동기 I/O 기능을 활용하여, 실제 I/O 작업은 커널 레벨에서 처리되고, 완료되면 이벤트를 통해 알림을 받는 방식이다.\n<em>정확히는 JavaScript 엔진이 싱글 스레드 기반이다</em>\n<em>해당 내용에 대해 더 자세히 알고 싶다면 <a href=\"https://puleugo.tistory.com/133\">해당 블로그</a>를 참고하자</em></p>\n\n<p><br /></p>\n\n<h1 id=\"3-블로킹과-논블로킹\">3. 블로킹과 논블로킹</h1>\n<blockquote>\n  <p>블로킹과 논블로킹은 “제어권의 이동” 관점에서 바라보는 개념이다.</p>\n</blockquote>\n\n<p>결국 “호출한 함수가 다른 일을 할 수 있는가?”의 여부를 의미한다.</p>\n\n<h2 id=\"3-1-제어권control-flow의-의미\">3-1. 제어권(Control Flow)의 의미</h2>\n<p>여기서 <strong>제어권</strong>이란 어떤 의미를 갖는지 먼저 보자.\nOS적인 관점에서 보자면, <strong>현재 작업을 진행하고 있는 함수가 CPU를 점유하는 것</strong>을 의미한다.\n쉽게 말해 “코드를 실행시킬 수 있는 권한” 정도로 말할 수 있다.</p>\n\n<p>동기 와 비동기는 Jobs 들이 순서대로 혹은 독립적으로 처리되는가에 관한 이야기라면,\n이번에는 호출한 함수가 별개의 일을 할 수 있는지의 이야기이다.</p>\n\n<h2 id=\"3-2-블로킹-제어권을-넘겨주는-방식\">3-2. 블로킹: 제어권을 넘겨주는 방식</h2>\n<p>마치 시험지를 넘겨주는 방식을 생각하면 편할 것 같다.\n<img src=\"https://github.com/user-attachments/assets/6eb36e86-150c-4144-86ce-6080ef86bece\" alt=\"image\" width=\"60%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : https://www.veritas-a.com/news/articleView.html?idxno=156699</em></p>\n\n<p>내가 뒷 사람에게 시험지를 넘겨줄 때,\n나는 아무런 행동도 하지 않고 <strong>뒷 사람(호출된 함수)가 시험지를 가져가는(자신의 작업을 완료)할 때 까지</strong> 나는 손에 시험지를 쥐고 뒷사람을 바라보고 대기할 수 밖에 없다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d799e31b-9406-44f3-8dcc-9df15b8f8a79\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>둘 간의 구분 방법은 제어권이 누구에게 있는지로 결정된다.</p>\n\n<p>블로킹에서는 함수 A가 함수 B를 호출할 때 제어권이 B로 넘어간다.</p>\n\n<p>제어권을 넘겨준 A는 B의 작업이 완료될 때까지 아무 작업도 수행할 수 없는 상태, 즉 블로킹 상태가 된다.</p>\n\n<p>즉, 위의 사진에서 A함수는 B함수에게 제어권을 넘겨줌과 동시에 함수 실행이 일시 정지된다. = Blocking</p>\n\n<h2 id=\"3-3-논블로킹-제어권을-유지하는-방식\">3-3. 논블로킹: 제어권을 유지하는 방식</h2>\n<p>하지만 시험지를 그냥 뒷 사람 책상에 올려 놓는다면 어떨까.</p>\n\n<p>나는 실제 뒷 사람이 받는 것을 대기할 필요없이, 바로 나의 다른 작업을 할 수 있다.</p>\n\n<p>즉, 뒷 사람(호출된 함수)이 나에 대한 제어권을 바로 반환해줌으로, 호출한 쪽(나)에서는 계속 다른 작업을 할 수 있는 것이다.</p>\n\n<p>같은 “읽기” 작업이어도 동기와 비동기 처리에 따라 어떻게 다르게 동작하는지 보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹: 제어권을 넘겨줌</span>\n<span class=\"nc\">String</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">readFile</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 파일 읽을 때까지 다른 일 못함</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                          <span class=\"c1\">// 파일 다 읽고 나서야 실행</span>\n\n<span class=\"c1\">// 논블로킹: 제어권을 유지</span>\n<span class=\"nc\">Future</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">readFileAsync</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 요청만 하고</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                               <span class=\"c1\">// 바로 다른 일 할 수 있음</span>\n</code></pre></div></div>\n<p><img src=\"https://github.com/user-attachments/assets/4a59addb-b12d-4eaa-90c9-fe783a7556e0\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>반면 논블로킹에서는 A함수가 B함수를 호출하더라도 제어권을 계속 유지한다.</p>\n\n<p>따라서 B함수가 실행되는 동안에도, A함수는 제어권을 가지고 있기 때문에 다른 작업을 수행할 수 있다.</p>\n\n<p>이렇게 호출자(caller)인 A함수는 B함수의 작업 완료 여부와 관계없이 자신의 작업을 계속 수행할 수 있다.</p>\n\n<p><br /></p>\n\n<h1 id=\"4-네-가지-조합의-동작-방식\">4. 네 가지 조합의 동작 방식</h1>\n\n<p>가끔 동기 처리에서는 무조건적으로 블로킹이 일어나고, 비동기에서는 논블로킹이 일어난다고 오해하는 경우가 많다.</p>\n\n<p>하지만 두 쌍의 개념은 서로 다른 관점에서 바라보는 개념이라는 것을 확실하게 하고 넘어가자.</p>\n\n<blockquote>\n  <p>동기/비동기 : 작업들의 시간적 관계성 <br />\n블로킹/논블로킹 : 제어권의 소재</p>\n</blockquote>\n\n<p>하지만 이 개념들이 오해가 잦은 이유는 실제 구현에서 [동기/볼로킹 &amp; 비동기/논블로킹]이 <strong>자주 함께 사용</strong>되기 때문이다.</p>\n\n<p>다음 그림을 보고 4가지 조합에 대해 천천히 살펴보자.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b894be55-d296-424d-913f-ee989233eb60\" alt=\"image\" width=\"100%\" class=\"center\" /></p>\n\n<p>먼저 흔히 쓰이는 [동기/볼로킹 &amp; 비동기/논블로킹] 에 대해 보자.</p>\n\n<h2 id=\"4-1-동기--블로킹\">4-1. 동기 + 블로킹</h2>\n\n<p>작업의 흐름이 순차적으로 진행되는 것이 보장된다. (<strong>동기</strong>)</p>\n\n<p>제어권을 함수 B에게 넘겨준 후 함수 A는 대기하게 된다. (<strong>블로킹</strong>)</p>\n\n<p>함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄 때까지 함수 A는 기다리는 것이다.</p>\n\n<blockquote>\n  <p>이러한 조합은 <strong>작업이 완료될 때까지 기다려야 하는 경우</strong>에 사용된다. <br />\n예를 들면, 파일을 읽은 후 이를 처리하는 코드를 생각해보자. <br />\n파일을 처리하는 과정은 <strong>필연적으로 파일을 모두 읽은 후에 작업이 가능</strong>하기 때문이다. <br />\n또한, 일반적으로 작업이 간단하거나 작업량이 적은 경우에 사용된다. <br />\n작업량이 많거나 오래 걸리는 작업을 해당 방식으로 처리하면 <strong>전체 프로그램이 멈춘 것 처럼 보여</strong> 사용자 경험 측면에서 나빠질 수 있다.</p>\n</blockquote>\n\n<h2 id=\"4-2-비동기--논블로킹\">4-2. 비동기 + 논블로킹</h2>\n\n<p>비동기 + 논블로킹 방식도 비교적 이해가 쉽다.</p>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다. (<strong>논블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 방식이다. (<strong>동기</strong>)</p>\n\n<p>함수 B를 호출 할 때, 콜백 함수를 함께 줌으로써, 함수 B는 자신의 작업이 끝났을 때 <strong>함수 A에게 준 콜백 함수를 실행시켜 자신의 작업이 끝났음</strong>을 알려준다.</p>\n\n<p>작업 A는 함수 B의 종료 여부에는 일단 관심이 없다.</p>\n\n<p>B 함수가 자신의 실행을 완료했다면, A 함수의 어깨를 톡톡 쳐서 알려주면 되는 것이다.</p>\n\n<blockquote>\n  <p>다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우에 활용할 수 있다. <br />\n또한, 대용량의 데이터를 처리하는 서비스에서 흔히 사용된다. <br />\n가장 큰 특징은 호출 함수에 콜백 함수를 넣었다는 점이다.</p>\n</blockquote>\n\n<h2 id=\"4-3-동기--논블로킹\">4-3. 동기 + 논블로킹</h2>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다.</p>\n\n<p>이후 바로 자신의 코드를 실행한다. (<strong>논블로킹</strong>)</p>\n\n<p>즉, 다른 작업이 진행되는 동안에도 자신의 작업을 별개로 처리할 수 있다.</p>\n\n<p>조심할 것이 함수 A는 함수 B의 Return 값을 필요로 하는 것은 변함이 없다는 점이다.</p>\n\n<p>A 함수는 B 함수의 리턴값이 필요하기 때문에, 중간중간 B 함수에게 함수 실행을 완료했는지 물어본다.</p>\n\n<p>즉, A 함수(caller)가 B 함수(callee)의 실행이 종료되었는지 계속 예의 주시해야 한다. (순서 보장을 위해)</p>\n\n<p>이로써 작업을 순차대로 수행할 수 있는 것이다. (<strong>동기</strong>)</p>\n\n<p>여기서 조금 더 깊게 생각해보자.</p>\n\n<p>어떻게 동기적으로 진행되면서 메인 쓰레드가 논블로킹이 될 수 있을까?</p>\n\n<p>이 조합의 특징은 “작업 완료는 비동기로 처리하지만, 호출자는 필요할 때 결과를 동기적으로 받는다.”로 정리할 수 있다.</p>\n\n<p>즉, <strong>순서를 유지하면서 결과를 사용해야 할 때 동기적으로 기다릴 수 있다.</strong></p>\n\n<p>결국 <strong>동기적</strong> 이라는 말은 <strong>호출자의 결과가 필요한 시점에서 순서를 보장</strong>하며 작업을 진행한다는 것이다.</p>\n\n<p>다음 JAVA 코드의 예시를 봐보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SimpleDownloader</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>  <span class=\"c1\">// 다운로드 진행률</span>\n        \n        <span class=\"c1\">// 다운로드 시작</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"파일 다운로드를 시작합니다.\"</span><span class=\"o\">);</span>\n        \n        <span class=\"c1\">// 진행률 확인하면서 다른 작업 수행 (논블로킹)</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">downloadProgress</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">{</span>  <span class=\"c1\">// 동기적: 순서 보장</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"진행률: \"</span> <span class=\"o\">+</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">+</span> <span class=\"s\">\"%\"</span><span class=\"o\">);</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다른 작업을 할 수 있어요!\"</span><span class=\"o\">);</span>\n            \n            <span class=\"c1\">// 진행률이 증가한다고 가정</span>\n            <span class=\"n\">downloadProgress</span> <span class=\"o\">+=</span> <span class=\"mi\">20</span><span class=\"o\">;</span>\n            \n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>  <span class=\"c1\">// 1초 대기</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        \n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다운로드 완료!\"</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><em>🚨 주의: 이 예시 코드는 Thread를 사용하고 있다. <br />\nThread는 기본적으로 작업을 병렬적으로 처리하기 위한 도구이다. <br />\n비동기 프로그래밍에서는 이러한 Thread의 병렬 처리 능력을 활용하여 비동기 작업을 구현하는 것이 일반적이다. <br />\n하지만 이 예시의 주된 목적은 작업이 어떻게 논블로킹하면서도 동기적으로 처리될 수 있는지를 시각적으로 보여주는 것이다. <br />\nThread를 사용한 것은 개념을 쉽게 설명하기 위한 것이다.</em></p>\n\n<p>이 코드의 결과는 다음과 같을 것이다.</p>\n<div class=\"language-css highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">나는</span> <span class=\"nt\">다른</span> <span class=\"nt\">작업을</span> <span class=\"nt\">진행할게</span><span class=\"o\">.</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">시작</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">0</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">1</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">2</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">완료</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드</span> <span class=\"nt\">종료</span> <span class=\"nt\">확인</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">모든</span> <span class=\"nt\">작업</span> <span class=\"nt\">완료</span><span class=\"o\">.</span>\n</code></pre></div></div>\n\n<p>물론, 논블로킹 메서드로 비동기 작업을 시작하더라도, 결과를 기다려야 하는 시점에서는 블로킹처럼 동작할 수 있다. <br />\n왜냐하면 메인 스레드가 결과를 받아야만 다음 작업을 진행할 수 있기 때문에, 그 시점에서는 블로킹이 되는 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b43ec8c4-9783-4fbf-9f7a-3736dff051bb\" alt=\"image\" width=\"80%\" class=\"center\" /></p>\n\n<p>사실 이러한 방식의 구현은 흔치 않다. <br />\n하지만, 몇 가지 활용 예를 알아보자면 <strong>게임 로딩화면 구성</strong> 등에 활용될 수 있다. <br />\n보통 게임에서 패치나 다운로드를 할 때, 사용자에게 ProgressBar나 게임 Tip등을 띄워줘야 할 때가 있다. <br />\n이 때는 Load 하는 동작이 완료될 때 까지 (작업 순서는 보장 = Sync) <br />\n다른 작업이 진행될 수 있다. (Non-Blocking)\n즉, 사용자 경험 측면에서 유용하게 활용될 수 있다.</p>\n\n<blockquote>\n  <p>언어 간에는 구현 방식에 차이가 있을 수 있다. <br />\n이는 각 언어의 특성과 제공되는 라이브러리나 기술에 따라 달라질 수 있다. <br />\n예를 들어, JavaScript는 단일 스레드 기반으로 동작하며, 콜백 함수, 프로미스(Promise), async/await 등의 메커니즘을 사용해 동기와 논블로킹 처리를 구현할 수 있다. <br />\n기본적으로 Promise.then 방식은 비동기적이고 논블로킹 방식으로 처리된다. <br />\n그러나 async/await 키워드를 사용하면, 비동기 작업의 순서를 지정할 수 있다.<br />\n중요한 점은, async 함수가 내부적으로 비동기적으로 동작하며, 메인 콜 스택이 모두 비워져야 실행된다는 것이다. <br />\n이로 인해 async/await도 내부적으로는 여전히 비동기적이고 논블로킹 방식으로 동작한다는 점을 유의해야 한다.\n(동기적인 코드 흐름처럼 보이게 하는 트릭)</p>\n</blockquote>\n\n<h2 id=\"4-4-비동기--블로킹\">4-4. 비동기 + 블로킹</h2>\n\n<p>이러한 방식은 사실 실무에서 마주치기 더더욱 흔치 않다.</p>\n\n<p>개념만 간단히 설명하자면,</p>\n\n<p>다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다린다. (<strong>블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않고, 콜백함수를 보낸 후 기다린다.</p>\n\n<p>이로써 작업 완료의 순서는 보장되지 않을 수 있다. (<strong>비동기</strong>)</p>\n\n<p><strong>즉, 함수 A는 자신과 관련없는 함수 B의 작업이 끝날 때까지 기다려야 한다.</strong>\n<em>매우 비효율적인 로직…</em></p>\n\n<p>1 작업 중에 2 작업을 해야지 Async의 이점을 살릴 수 있는 것인데,\n이것을 다시 Blocking 방식을 사용함여 대기시킴으로써 이점을 제거해버린 것이다…😅\n대부분의 경우 비동기+논블로킹 모델이 더 효율적인 선택이 될 것이다.</p>\n\n<p><br /></p>\n\n<h1 id=\"5-현대-프로그래밍에서-이러한-개념이-왜-중요한가\">5. 현대 프로그래밍에서 이러한 개념이 왜 중요한가?</h1>\n\n<p>이러한 이해는 현대 소프트웨어 개발에서 매우 중요하다. 오늘날의 애플리케이션들은 수많은 동시다발적인 작업을 처리해야 한다. 사용자는 파일을 다운로드하면서 동시에 문서를 편집하길 원하고, 데이터가 백그라운드에서 처리되는 동안에도 끊김 없는 인터페이스 사용을 기대한다.</p>\n\n<p>더군다나 클라우드 컴퓨팅과 마이크로서비스 아키텍처가 보편화된 현대 개발 환경에서는, 네트워크를 통한 수많은 비동기 작업들이 동시에 발생한다. 이때 각 작업을 어떻게 처리할지, 작업 간의 의존성은 어떻게 관리할지를 결정하는 것은 시스템의 성능과 사용자 경험을 좌우하는 핵심 요소가 된다.</p>\n\n<p>결국 이러한 개념들의 이해는 단순히 기술적인 지식을 넘어서, 현대 소프트웨어가 직면한 복잡성과 사용자 경험의 요구사항을 어떻게 조화롭게 해결할 수 있을지에 대한 통찰을 제공한다. 이는 우리가 더 효율적이고, 반응성 높은, 그리고 사용자 친화적인 소프트웨어를 설계하고 구현하는 데 있어 필수적인 기반이 될 것이다.</p>\n\n<h1 id=\"6-마무리\">6. 마무리</h1>\n<p>그렇다면 Java에서는 이러한 비동기 처리를 어떻게 구현할 수 있을까?</p>\n\n<p>Java의 비동기 프로그래밍은 Thread를 시작으로, 현대적인 CompletableFuture까지 꾸준히 발전해왔다.</p>\n\n<p>이제 각각의 방식을 자세히 살펴보겠다.</p>\n",
                        "tags": ["Java","Spring-Boot","Backend","Sync","Async","Concurrency","Blocking","NonBlocking"]
                    }
                
            ],
        
            "NonBlocking": [
                
                    {
                        "title": "동기/비동기와 블로킹/논블로킹에 대해 깊이 파헤치기",
                        "url": "/2025/01/12/understanding-sync-async-blocking-non-blocking.html",
                        "subtitle": "Java/SpringBoot에서의 비동기 처리",
                        "excerpt": "1. 개념적 이해\n",
                        "author": "Jinho",
                        "date": "January 12, 2025",
                        "background": "/img/posts/sync-async-concept.jpeg",
                        "content": "<h1 id=\"1-개념적-이해\">1. 개념적 이해</h1>\n\n<p>비동기 처리에 대해 이야기하기 앞서, 과연 “동기”란 어떤 것인지부터 바로 잡고 가려고한다.</p>\n\n<p>왜냐하면 <strong>비(非)동기</strong>란 동기가 아니다라는 의미이기 때문에 동기가 무엇인지부터 정확히 하고 싶었다.</p>\n\n<p>또한 나는 처음에 ‘동기=블로킹, 비동기=논블로킹’이라고 단순하게 이해하고 있었다.</p>\n\n<p>하지만 실제로는 두 개념이 분류 기준이 전혀 다른 독립적인 개념이라는 것을 알게 되었다.</p>\n\n<p>이렇듯 서로 혼동되어 쓰이는 각 명칭은 어떤 의미인지 알아보려고 한다.</p>\n\n<p>이에 대해 자세히 알아보자.</p>\n\n<p><br /></p>\n\n<h1 id=\"2-동기와-비동기\">2. 동기와 비동기</h1>\n\n<p><img src=\"https://velog.velcdn.com/images/jinho7/post/a47f1973-3895-4438-a47f-80dd80245e41/image.png\" alt=\"\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<blockquote>\n  <p>동기와 비동기는 “작업의 처리 방식”을 나타내는 개념이다. <br />\n결론부터 말하자면, 이둘의 주요한 차이점은 “작업 순서 처리 차이”이다.</p>\n</blockquote>\n\n<h2 id=\"2-1-동기-순차적으로-실행\">2-1. 동기: 순차적으로 실행</h2>\n<p>필자는 이전에 동기를 <strong>겹치지 않고 순차적으로 작업을 진행하는 것</strong> 정도로 이해하고 있었다.</p>\n\n<p>영어 사전을 참고해보자.</p>\n\n<blockquote>\n  <p>synchronous\nadjective\nhappening or done at the same time or speed:</p>\n</blockquote>\n\n<p><strong>Synchronous</strong> 는 동시에 발생하는 두 개 이상의 사건이나 프로세스가 동일한 시간에서 진행되는 것을 의미하는 형용사이다.</p>\n\n<p>중요한 워딩은 [동일한 시간에 여러 개의 사건이 진행] 된다는 것이다.</p>\n\n<p>‘순차적’과 ‘동시’라는 단어가 서로 상충된다고 생각할 수 있다.</p>\n\n<p>여기서 오해하면 안되는 것이 이는 <strong>병렬적인 작업방식을 말하는 것이 아니다.</strong></p>\n\n<p>“어떠한 일정 시점에 현재 작업의 Response과 다음 작업의 Request이 함께 진행되는 것”</p>\n\n<p>위의 그림을 참고하면 이해가 쉽다.\n작업 A가 끝나는 시간과 작업 B가 시작하는 시간이 동기화된다고 이해하면 좋을 것 같다.</p>\n\n<p>이는 <strong>작업이 순차적으로 처리되며, 이전 작업이 완료될 때까지는 다음 작업이 시작되지 않음을 나타낸다.</strong></p>\n\n<p>즉, <strong>작업들이 서로 시간적 의존성을 가지고 실행된다</strong>는 뜻이다.</p>\n\n<p>동기 방식은 실행 순서가 보장되며 예측 가능하다는 장점이 있지만, <br />\n앞선 작업이 오래 걸리면 전체 작업이 지연된다는 단점도 있다.</p>\n\n<h2 id=\"2-2-비동기-독립적으로-실행\">2-2. 비동기: 독립적으로 실행</h2>\n<p>그렇다면 비동기 방식은 무엇일까?</p>\n\n<p>반대의 경우를 생각하면 된다.</p>\n\n<p>위의 그림을 참고하면 작업들이 병렬적으로 일어나고 있음을 알 수 있다.</p>\n\n<p>동기와 반대로 <strong>“요청을 보냈을 때 응답 상태와 상관없이 다른 동작을 수행할 수 있다.”</strong>는 점이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/0a188e4a-b35f-41aa-9953-94504330dd9f\" alt=\"다운로드\" width=\"68%\" height=\"50%\" class=\"center\" />\n<em class=\"image-caption\">파일 다운로드가 동기 방식이라면?</em></p>\n\n<p>만약에 파일 다운로드를 동기적으로 처리한다고 해보자.</p>\n\n<p>아마 파일이 다운로드될 때까지 아무런 작업도 수행할 수 없을 것이고,\n파일이 완전히 다운로드된 후에 다음 작업을 진행할 수 있을 것이다. 😅</p>\n\n<p>매우 비효율적인 방식이다…</p>\n\n<p>그러나 비동기적인 방식을 활용한다면, 파일 다운로드 작업을 시작시켜놓고, 다른 작업을 수행할 수 있다.</p>\n\n<p>파일이 다운로드되면 특정 콜백 함수를 호출하여, 다운로드된 파일을 처리하거나 결과를 반환받을 수 있다.</p>\n\n<p>콜백 뿐만이 아니고, 그 결과는 콜백 함수, Promise, 이벤트 등을 통해 전달받을 수 있다.</p>\n\n<p>마치 택배를 주문하고 배송 알림을 받는 것과 비슷하다고 할 수 있다.</p>\n\n<h3 id=\"비동기-동작-방식에-대한-오해\">비동기 동작 방식에 대한 오해</h3>\n<p>많은 개발자들이 <strong>비동기 = 멀티 쓰레드</strong>라고 이해하고 있다.</p>\n\n<p>단순히 생각해보아도, 여러 작업이 동시에 처리되는 비동기 동작을 구현하기 위해서는 당연히 여러 개의 쓰레드가 필요할 것 같기 때문이다.</p>\n\n<p>또한, 특히나 대부분의 Java 개발자들이 비동기 프로그래밍을 접할 때 아래와 같은 코드를 통해 배우기 때문이다.</p>\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 여기서 실제로 별도의 스레드에서 실행됨</span>\n    <span class=\"k\">return</span> <span class=\"nf\">heavyTask</span><span class=\"o\">();</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p>우리는 Java에서 비동기 처리에 대해 다룰 때, ExecutorService나 CompletableFuture와 같은 도구들을 함께 배운다.</p>\n\n<p>이들은 내부적으로 <strong>스레드 풀</strong>을 사용하기 때문에, 자연스럽게 비동기 처리와 멀티 쓰레드를 동일시하게 된다.</p>\n\n<p>실제로 Spring Framework의 @Async 어노테이션도 비동기 처리를 위해 기본적으로 스레드 풀을 사용한다.</p>\n\n<p>하지만 비동기 처리의 본질은 <strong>“작업의 완료를 기다리지 않고 다른 작업을 수행할 수 있는 것”</strong>이다.</p>\n\n<p>이는 반드시 멀티스레드로만 구현되어야 하는 것이 아니며, Node.js가 좋은 예시다.</p>\n\n<p>Node.js는 싱글 스레드 기반의 이벤트 루프를 사용하여 비동기 처리를 구현한다.</p>\n\n<p>이벤트 루프는 OS의 비동기 I/O 기능을 활용하여 실제 I/O 작업을 커널 레벨에서 처리하고,</p>\n\n<p>작업이 완료되면 이벤트를 통해 알림을 받는 방식으로 동작한다.</p>\n\n<div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Node.js의 비동기 처리 (싱글스레드)</span>\n<span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nf\">readFile</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">file.txt</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">파일 읽기 완료</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">다음 작업 실행</span><span class=\"dl\">'</span><span class=\"p\">);</span>  <span class=\"c1\">// 파일 읽기를 기다리지 않고 실행</span>\n</code></pre></div></div>\n<p>이러한 이벤트 루프 기반의 비동기 처리는 멀티스레드 없이도 효율적인 비동기 처리를 가능하게 한다.\nOS의 비동기 I/O 기능을 활용하여, 실제 I/O 작업은 커널 레벨에서 처리되고, 완료되면 이벤트를 통해 알림을 받는 방식이다.\n<em>정확히는 JavaScript 엔진이 싱글 스레드 기반이다</em>\n<em>해당 내용에 대해 더 자세히 알고 싶다면 <a href=\"https://puleugo.tistory.com/133\">해당 블로그</a>를 참고하자</em></p>\n\n<p><br /></p>\n\n<h1 id=\"3-블로킹과-논블로킹\">3. 블로킹과 논블로킹</h1>\n<blockquote>\n  <p>블로킹과 논블로킹은 “제어권의 이동” 관점에서 바라보는 개념이다.</p>\n</blockquote>\n\n<p>결국 “호출한 함수가 다른 일을 할 수 있는가?”의 여부를 의미한다.</p>\n\n<h2 id=\"3-1-제어권control-flow의-의미\">3-1. 제어권(Control Flow)의 의미</h2>\n<p>여기서 <strong>제어권</strong>이란 어떤 의미를 갖는지 먼저 보자.\nOS적인 관점에서 보자면, <strong>현재 작업을 진행하고 있는 함수가 CPU를 점유하는 것</strong>을 의미한다.\n쉽게 말해 “코드를 실행시킬 수 있는 권한” 정도로 말할 수 있다.</p>\n\n<p>동기 와 비동기는 Jobs 들이 순서대로 혹은 독립적으로 처리되는가에 관한 이야기라면,\n이번에는 호출한 함수가 별개의 일을 할 수 있는지의 이야기이다.</p>\n\n<h2 id=\"3-2-블로킹-제어권을-넘겨주는-방식\">3-2. 블로킹: 제어권을 넘겨주는 방식</h2>\n<p>마치 시험지를 넘겨주는 방식을 생각하면 편할 것 같다.\n<img src=\"https://github.com/user-attachments/assets/6eb36e86-150c-4144-86ce-6080ef86bece\" alt=\"image\" width=\"60%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : https://www.veritas-a.com/news/articleView.html?idxno=156699</em></p>\n\n<p>내가 뒷 사람에게 시험지를 넘겨줄 때,\n나는 아무런 행동도 하지 않고 <strong>뒷 사람(호출된 함수)가 시험지를 가져가는(자신의 작업을 완료)할 때 까지</strong> 나는 손에 시험지를 쥐고 뒷사람을 바라보고 대기할 수 밖에 없다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d799e31b-9406-44f3-8dcc-9df15b8f8a79\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>둘 간의 구분 방법은 제어권이 누구에게 있는지로 결정된다.</p>\n\n<p>블로킹에서는 함수 A가 함수 B를 호출할 때 제어권이 B로 넘어간다.</p>\n\n<p>제어권을 넘겨준 A는 B의 작업이 완료될 때까지 아무 작업도 수행할 수 없는 상태, 즉 블로킹 상태가 된다.</p>\n\n<p>즉, 위의 사진에서 A함수는 B함수에게 제어권을 넘겨줌과 동시에 함수 실행이 일시 정지된다. = Blocking</p>\n\n<h2 id=\"3-3-논블로킹-제어권을-유지하는-방식\">3-3. 논블로킹: 제어권을 유지하는 방식</h2>\n<p>하지만 시험지를 그냥 뒷 사람 책상에 올려 놓는다면 어떨까.</p>\n\n<p>나는 실제 뒷 사람이 받는 것을 대기할 필요없이, 바로 나의 다른 작업을 할 수 있다.</p>\n\n<p>즉, 뒷 사람(호출된 함수)이 나에 대한 제어권을 바로 반환해줌으로, 호출한 쪽(나)에서는 계속 다른 작업을 할 수 있는 것이다.</p>\n\n<p>같은 “읽기” 작업이어도 동기와 비동기 처리에 따라 어떻게 다르게 동작하는지 보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹: 제어권을 넘겨줌</span>\n<span class=\"nc\">String</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">readFile</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 파일 읽을 때까지 다른 일 못함</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                          <span class=\"c1\">// 파일 다 읽고 나서야 실행</span>\n\n<span class=\"c1\">// 논블로킹: 제어권을 유지</span>\n<span class=\"nc\">Future</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">readFileAsync</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 요청만 하고</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                               <span class=\"c1\">// 바로 다른 일 할 수 있음</span>\n</code></pre></div></div>\n<p><img src=\"https://github.com/user-attachments/assets/4a59addb-b12d-4eaa-90c9-fe783a7556e0\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>반면 논블로킹에서는 A함수가 B함수를 호출하더라도 제어권을 계속 유지한다.</p>\n\n<p>따라서 B함수가 실행되는 동안에도, A함수는 제어권을 가지고 있기 때문에 다른 작업을 수행할 수 있다.</p>\n\n<p>이렇게 호출자(caller)인 A함수는 B함수의 작업 완료 여부와 관계없이 자신의 작업을 계속 수행할 수 있다.</p>\n\n<p><br /></p>\n\n<h1 id=\"4-네-가지-조합의-동작-방식\">4. 네 가지 조합의 동작 방식</h1>\n\n<p>가끔 동기 처리에서는 무조건적으로 블로킹이 일어나고, 비동기에서는 논블로킹이 일어난다고 오해하는 경우가 많다.</p>\n\n<p>하지만 두 쌍의 개념은 서로 다른 관점에서 바라보는 개념이라는 것을 확실하게 하고 넘어가자.</p>\n\n<blockquote>\n  <p>동기/비동기 : 작업들의 시간적 관계성 <br />\n블로킹/논블로킹 : 제어권의 소재</p>\n</blockquote>\n\n<p>하지만 이 개념들이 오해가 잦은 이유는 실제 구현에서 [동기/볼로킹 &amp; 비동기/논블로킹]이 <strong>자주 함께 사용</strong>되기 때문이다.</p>\n\n<p>다음 그림을 보고 4가지 조합에 대해 천천히 살펴보자.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b894be55-d296-424d-913f-ee989233eb60\" alt=\"image\" width=\"100%\" class=\"center\" /></p>\n\n<p>먼저 흔히 쓰이는 [동기/볼로킹 &amp; 비동기/논블로킹] 에 대해 보자.</p>\n\n<h2 id=\"4-1-동기--블로킹\">4-1. 동기 + 블로킹</h2>\n\n<p>작업의 흐름이 순차적으로 진행되는 것이 보장된다. (<strong>동기</strong>)</p>\n\n<p>제어권을 함수 B에게 넘겨준 후 함수 A는 대기하게 된다. (<strong>블로킹</strong>)</p>\n\n<p>함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄 때까지 함수 A는 기다리는 것이다.</p>\n\n<blockquote>\n  <p>이러한 조합은 <strong>작업이 완료될 때까지 기다려야 하는 경우</strong>에 사용된다. <br />\n예를 들면, 파일을 읽은 후 이를 처리하는 코드를 생각해보자. <br />\n파일을 처리하는 과정은 <strong>필연적으로 파일을 모두 읽은 후에 작업이 가능</strong>하기 때문이다. <br />\n또한, 일반적으로 작업이 간단하거나 작업량이 적은 경우에 사용된다. <br />\n작업량이 많거나 오래 걸리는 작업을 해당 방식으로 처리하면 <strong>전체 프로그램이 멈춘 것 처럼 보여</strong> 사용자 경험 측면에서 나빠질 수 있다.</p>\n</blockquote>\n\n<h2 id=\"4-2-비동기--논블로킹\">4-2. 비동기 + 논블로킹</h2>\n\n<p>비동기 + 논블로킹 방식도 비교적 이해가 쉽다.</p>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다. (<strong>논블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 방식이다. (<strong>동기</strong>)</p>\n\n<p>함수 B를 호출 할 때, 콜백 함수를 함께 줌으로써, 함수 B는 자신의 작업이 끝났을 때 <strong>함수 A에게 준 콜백 함수를 실행시켜 자신의 작업이 끝났음</strong>을 알려준다.</p>\n\n<p>작업 A는 함수 B의 종료 여부에는 일단 관심이 없다.</p>\n\n<p>B 함수가 자신의 실행을 완료했다면, A 함수의 어깨를 톡톡 쳐서 알려주면 되는 것이다.</p>\n\n<blockquote>\n  <p>다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우에 활용할 수 있다. <br />\n또한, 대용량의 데이터를 처리하는 서비스에서 흔히 사용된다. <br />\n가장 큰 특징은 호출 함수에 콜백 함수를 넣었다는 점이다.</p>\n</blockquote>\n\n<h2 id=\"4-3-동기--논블로킹\">4-3. 동기 + 논블로킹</h2>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다.</p>\n\n<p>이후 바로 자신의 코드를 실행한다. (<strong>논블로킹</strong>)</p>\n\n<p>즉, 다른 작업이 진행되는 동안에도 자신의 작업을 별개로 처리할 수 있다.</p>\n\n<p>조심할 것이 함수 A는 함수 B의 Return 값을 필요로 하는 것은 변함이 없다는 점이다.</p>\n\n<p>A 함수는 B 함수의 리턴값이 필요하기 때문에, 중간중간 B 함수에게 함수 실행을 완료했는지 물어본다.</p>\n\n<p>즉, A 함수(caller)가 B 함수(callee)의 실행이 종료되었는지 계속 예의 주시해야 한다. (순서 보장을 위해)</p>\n\n<p>이로써 작업을 순차대로 수행할 수 있는 것이다. (<strong>동기</strong>)</p>\n\n<p>여기서 조금 더 깊게 생각해보자.</p>\n\n<p>어떻게 동기적으로 진행되면서 메인 쓰레드가 논블로킹이 될 수 있을까?</p>\n\n<p>이 조합의 특징은 “작업 완료는 비동기로 처리하지만, 호출자는 필요할 때 결과를 동기적으로 받는다.”로 정리할 수 있다.</p>\n\n<p>즉, <strong>순서를 유지하면서 결과를 사용해야 할 때 동기적으로 기다릴 수 있다.</strong></p>\n\n<p>결국 <strong>동기적</strong> 이라는 말은 <strong>호출자의 결과가 필요한 시점에서 순서를 보장</strong>하며 작업을 진행한다는 것이다.</p>\n\n<p>다음 JAVA 코드의 예시를 봐보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SimpleDownloader</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>  <span class=\"c1\">// 다운로드 진행률</span>\n        \n        <span class=\"c1\">// 다운로드 시작</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"파일 다운로드를 시작합니다.\"</span><span class=\"o\">);</span>\n        \n        <span class=\"c1\">// 진행률 확인하면서 다른 작업 수행 (논블로킹)</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">downloadProgress</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">{</span>  <span class=\"c1\">// 동기적: 순서 보장</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"진행률: \"</span> <span class=\"o\">+</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">+</span> <span class=\"s\">\"%\"</span><span class=\"o\">);</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다른 작업을 할 수 있어요!\"</span><span class=\"o\">);</span>\n            \n            <span class=\"c1\">// 진행률이 증가한다고 가정</span>\n            <span class=\"n\">downloadProgress</span> <span class=\"o\">+=</span> <span class=\"mi\">20</span><span class=\"o\">;</span>\n            \n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>  <span class=\"c1\">// 1초 대기</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        \n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다운로드 완료!\"</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><em>🚨 주의: 이 예시 코드는 Thread를 사용하고 있다. <br />\nThread는 기본적으로 작업을 병렬적으로 처리하기 위한 도구이다. <br />\n비동기 프로그래밍에서는 이러한 Thread의 병렬 처리 능력을 활용하여 비동기 작업을 구현하는 것이 일반적이다. <br />\n하지만 이 예시의 주된 목적은 작업이 어떻게 논블로킹하면서도 동기적으로 처리될 수 있는지를 시각적으로 보여주는 것이다. <br />\nThread를 사용한 것은 개념을 쉽게 설명하기 위한 것이다.</em></p>\n\n<p>이 코드의 결과는 다음과 같을 것이다.</p>\n<div class=\"language-css highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">나는</span> <span class=\"nt\">다른</span> <span class=\"nt\">작업을</span> <span class=\"nt\">진행할게</span><span class=\"o\">.</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">시작</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">0</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">1</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">2</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">완료</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드</span> <span class=\"nt\">종료</span> <span class=\"nt\">확인</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">모든</span> <span class=\"nt\">작업</span> <span class=\"nt\">완료</span><span class=\"o\">.</span>\n</code></pre></div></div>\n\n<p>물론, 논블로킹 메서드로 비동기 작업을 시작하더라도, 결과를 기다려야 하는 시점에서는 블로킹처럼 동작할 수 있다. <br />\n왜냐하면 메인 스레드가 결과를 받아야만 다음 작업을 진행할 수 있기 때문에, 그 시점에서는 블로킹이 되는 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b43ec8c4-9783-4fbf-9f7a-3736dff051bb\" alt=\"image\" width=\"80%\" class=\"center\" /></p>\n\n<p>사실 이러한 방식의 구현은 흔치 않다. <br />\n하지만, 몇 가지 활용 예를 알아보자면 <strong>게임 로딩화면 구성</strong> 등에 활용될 수 있다. <br />\n보통 게임에서 패치나 다운로드를 할 때, 사용자에게 ProgressBar나 게임 Tip등을 띄워줘야 할 때가 있다. <br />\n이 때는 Load 하는 동작이 완료될 때 까지 (작업 순서는 보장 = Sync) <br />\n다른 작업이 진행될 수 있다. (Non-Blocking)\n즉, 사용자 경험 측면에서 유용하게 활용될 수 있다.</p>\n\n<blockquote>\n  <p>언어 간에는 구현 방식에 차이가 있을 수 있다. <br />\n이는 각 언어의 특성과 제공되는 라이브러리나 기술에 따라 달라질 수 있다. <br />\n예를 들어, JavaScript는 단일 스레드 기반으로 동작하며, 콜백 함수, 프로미스(Promise), async/await 등의 메커니즘을 사용해 동기와 논블로킹 처리를 구현할 수 있다. <br />\n기본적으로 Promise.then 방식은 비동기적이고 논블로킹 방식으로 처리된다. <br />\n그러나 async/await 키워드를 사용하면, 비동기 작업의 순서를 지정할 수 있다.<br />\n중요한 점은, async 함수가 내부적으로 비동기적으로 동작하며, 메인 콜 스택이 모두 비워져야 실행된다는 것이다. <br />\n이로 인해 async/await도 내부적으로는 여전히 비동기적이고 논블로킹 방식으로 동작한다는 점을 유의해야 한다.\n(동기적인 코드 흐름처럼 보이게 하는 트릭)</p>\n</blockquote>\n\n<h2 id=\"4-4-비동기--블로킹\">4-4. 비동기 + 블로킹</h2>\n\n<p>이러한 방식은 사실 실무에서 마주치기 더더욱 흔치 않다.</p>\n\n<p>개념만 간단히 설명하자면,</p>\n\n<p>다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다린다. (<strong>블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않고, 콜백함수를 보낸 후 기다린다.</p>\n\n<p>이로써 작업 완료의 순서는 보장되지 않을 수 있다. (<strong>비동기</strong>)</p>\n\n<p><strong>즉, 함수 A는 자신과 관련없는 함수 B의 작업이 끝날 때까지 기다려야 한다.</strong>\n<em>매우 비효율적인 로직…</em></p>\n\n<p>1 작업 중에 2 작업을 해야지 Async의 이점을 살릴 수 있는 것인데,\n이것을 다시 Blocking 방식을 사용함여 대기시킴으로써 이점을 제거해버린 것이다…😅\n대부분의 경우 비동기+논블로킹 모델이 더 효율적인 선택이 될 것이다.</p>\n\n<p><br /></p>\n\n<h1 id=\"5-현대-프로그래밍에서-이러한-개념이-왜-중요한가\">5. 현대 프로그래밍에서 이러한 개념이 왜 중요한가?</h1>\n\n<p>이러한 이해는 현대 소프트웨어 개발에서 매우 중요하다. 오늘날의 애플리케이션들은 수많은 동시다발적인 작업을 처리해야 한다. 사용자는 파일을 다운로드하면서 동시에 문서를 편집하길 원하고, 데이터가 백그라운드에서 처리되는 동안에도 끊김 없는 인터페이스 사용을 기대한다.</p>\n\n<p>더군다나 클라우드 컴퓨팅과 마이크로서비스 아키텍처가 보편화된 현대 개발 환경에서는, 네트워크를 통한 수많은 비동기 작업들이 동시에 발생한다. 이때 각 작업을 어떻게 처리할지, 작업 간의 의존성은 어떻게 관리할지를 결정하는 것은 시스템의 성능과 사용자 경험을 좌우하는 핵심 요소가 된다.</p>\n\n<p>결국 이러한 개념들의 이해는 단순히 기술적인 지식을 넘어서, 현대 소프트웨어가 직면한 복잡성과 사용자 경험의 요구사항을 어떻게 조화롭게 해결할 수 있을지에 대한 통찰을 제공한다. 이는 우리가 더 효율적이고, 반응성 높은, 그리고 사용자 친화적인 소프트웨어를 설계하고 구현하는 데 있어 필수적인 기반이 될 것이다.</p>\n\n<h1 id=\"6-마무리\">6. 마무리</h1>\n<p>그렇다면 Java에서는 이러한 비동기 처리를 어떻게 구현할 수 있을까?</p>\n\n<p>Java의 비동기 프로그래밍은 Thread를 시작으로, 현대적인 CompletableFuture까지 꾸준히 발전해왔다.</p>\n\n<p>이제 각각의 방식을 자세히 살펴보겠다.</p>\n",
                        "tags": ["Java","Spring-Boot","Backend","Sync","Async","Concurrency","Blocking","NonBlocking"]
                    }
                
            ],
        
            "Spring": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    }
                
            ],
        
            "SpringBoot": [
                
                    {
                        "title": "WAS(Web Application Server)와 Servlet",
                        "url": "/2025/01/28/about-was.html",
                        "subtitle": "Tomcat부터 Spring Boot까지",
                        "excerpt": "웹 서버(WS)의 진화 : Apache vs NGINX\n위 post에 이어지는 내용입니다.\n",
                        "author": "Jinho",
                        "date": "January 28, 2025",
                        "background": "/img/posts/apache_tomcat.jpeg",
                        "content": "<p><a href=\"https://jinho7.github.io/2025/01/27/ws-and-was.html\" target=\"웹 서버(WS)의 진화 : Apache vs NGINX \">웹 서버(WS)의 진화 : Apache vs NGINX</a><br />\n<em>위 post에 이어지는 내용입니다.</em></p>\n\n<h1 id=\"was-란\">WAS 란?</h1>\n\n<h2 id=\"was의-정의\">WAS의 정의</h2>\n\n<p>먼저 WAS(Web Application Server)의 정의는 다음과 같다.</p>\n<blockquote>\n  <p><span class=\"post-highlight\">웹 애플리케이션과 서버 환경을 만들어 동작시키는 기능을 제공하는 소프트웨어 프레임워크</span></p>\n</blockquote>\n\n<p>대표적으로 Apache <span class=\"post-highlight\">Tomcat</span>이 있다.</p>\n<ul>\n  <li><em>참고로 Apache Tomcat는 WS 단계에서 계속 이야기했던 Apache와는 아예 별개의 소프트웨어이다.</em></li>\n</ul>\n\n<details>\n<summary>Apache와 Tomcat</summary>\nApache HTTP Server (보통 Apache라고 부름)\n<ul>\n    <li>웹 서버(WS) 역할을 담당</li>\n    <li>주로 정적 콘텐츠를 처리</li>\n    <li>HTTP 요청을 처리하며, 동적 콘텐츠를 처리할 경우에는 WAS(Tomcat)와 연동하여 작업을 나눕니다.</li>\n</ul>\nApache Tomcat (보통 Tomcat이라고 부름)\n<ul>\n    <li>WAS 역할을 담당</li>\n    <li>Servlet Container로서 동작하며, Servlet/JSP 기반의 동적 콘텐츠를 처리\n        <ul>\n            <li><em>정적 콘텐츠도 처리할 수는 있다.</em></li>\n            <li><em>정적 콘텐츠 처리 성능은 Apache HTTP Server보다 낮다.</em></li>\n        </ul>\n    </li>\n    <li>Java EE 표준의 일부인 Servlet/JSP 스펙을 구현하며, Spring MVC와 같은 프레임워크의 기반이 되는 동작을 지원한다.</li>\n</ul>\n</details>\n\n<p><br /></p>\n\n<p>그러나 이런 물음표가 떠오른다.</p>\n\n<p><strong>❓ WAS? TOMCAT? Servlet? Servlet Container? Spring MVC?</strong></p>\n\n<p>다음 기본 개념부터 인지하고 넘어가면 이해하기 쉽다.</p>\n\n<ol>\n  <li><strong>WAS</strong>는 클라이언트의 요청을 처리하여 <strong>동적인 웹 콘텐츠</strong>를 제공하는 서버를 말한다.</li>\n  <li><strong>Tomcat</strong>은 WAS의 대표적인 예시 중 하나이다.</li>\n  <li>Tomcat은 <strong>Servlet Container의 한 종류</strong>이며, <strong>Servlet/JSP 요청을 처리</strong>하는 역할을 한다.</li>\n  <li>Tomcat은 <strong>Servlet 표준</strong>에 맞춘 애플리케이션을 실행하는 데 최적화되어 있다.\n    <ol>\n      <li><strong>Servlet 표준</strong>은 <strong>Java EE</strong>(현재는 <strong>Jakarta EE</strong>) 명세의 일부로, <strong>Java 기반 동적 웹 콘텐츠 처리</strong>를 위한 규격이다.</li>\n      <li>즉, Tomcat은 <strong>Java 기반의 웹 애플리케이션</strong>을 실행하기 위한 서버이다.</li>\n    </ol>\n  </li>\n</ol>\n\n<p><strong>WS와 WAS의 차이의 핵심는 ‘동적 처리 여부’에 있다.</strong></p>\n<ul>\n  <li>현대 웹사이트는 스크롤에 따라 새로운 피드를 보여주거나,<br />\n사용자 맞춤 광고를 제공하는 등의 동적 기능을 포함한다.</li>\n  <li>이러한 <strong>“사용자 맞춤 가공 처리(동적 콘텐츠)”는 결국 서버가 특정 코드를 실행했다</strong>는 의미다.</li>\n  <li>결국 궁금한 것은 ‘<strong>서버가 어떻게 이 코드를 실행하고, 그 결과를 클라이언트에게 제공하는가</strong>’이다.</li>\n</ul>\n\n<div style=\"display: flex; justify-content: space-between; gap: 20px;\">\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/203ab158-60b0-4376-be93-1de497da3d19\" alt=\"Memory Usage\" style=\"width: 100%;\" />\n        <p style=\"text-align: center; color: #666;\">누구나에게 제공되는 “정적인” 컨텐츠이다.</p>\n    </div>\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/5795047e-ae12-4cda-a1f6-e2b3ab8dfd72\" alt=\"Requests Per Second\" style=\"width: 100%;\" />\n        <p style=\"text-align: center; color: #666;\">하지만 로그인하고 나면 “동적인” 컨텐츠가 로드된다.</p>\n    </div>\n</div>\n\n<p>아래는 동적 페이지를 로드하는 과정을 그림으로 표현한 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/ef604672-3c6c-4724-9f9a-9a226cc6e513\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>우리는 앞서 실제 운영/대규모 서비스는 <span class=\"post-highlight\">WS-WAS 분리 구조</span>를 선호한다고 말했다.</p>\n\n<p>나는 WAS의 한 종류인 Tomcat까지의 웹통신 흐름이 어떻게 이루어지는 지가 궁금해졌다.<br />\n그리고 <u>‘jvm, survlet, spring 등 어떤 개념이고 어떤 연관관계가 있고 어떻게 유동적으로 작동할까…?’</u> 가 궁금했다.</p>\n\n<p><br /></p>\n\n<h2 id=\"jvmjava-virtual-machine\">JVM(Java Virtual Machine)</h2>\n\n<p><img src=\"https://github.com/user-attachments/assets/f48a2ce2-5aa4-495c-a686-79e32ce7eed2\" alt=\"Image\" width=\"70%\" height=\"100%\" class=\"center\" /></p>\n\n<p><em>JVM 자체가 현재 내용에서 매우 중요한 내용은 아니라 짧게 이야기하면,</em></p>\n<ul>\n  <li>⇒ 그냥 JVM은 간단히 Java 코드를 실행시켜주는 놈이라고 생각하자.</li>\n  <li>WAS(Tomcat)는 Java로 작성된 웹 애플리케이션을 실행하는 컨테이너이므로,<br />\nWAS도 JVM 위에서 동작한다.</li>\n</ul>\n\n<details>\n<summary>JVM 이란?</summary>\nApache HTTP Server (보통 Apache라고 부름)\n<ul>\n    <li>JVM은 JVM은 Java 바이트코드(.class 파일)를 해석하고 실행하는 가상 머신</li>\n    <li>JRE는 Java 프로그램을 실행하는 데 필요한 모든 것을 포함한다. 라이브러리 등</li>\n        <ul>\n            <li><em>JRE은 JVM을 시작, 필요한 클래스 라이브러리 로드, main() 메서드를 실행한다.</em></li>\n        </ul>\n    <li>JDK는 Java 애플리케이션을 개발하는 데 필요한 모든 도구를 포함한다.</li>\n</ul>\n</details>\n\n<p><br /></p>\n\n<h2 id=\"servlet-container-tomcat\">Servlet Container [Tomcat]</h2>\n\n<p>위에서 “Tomcat은 <strong><u>Servlet Container의 한 종류</u></strong>이며, <strong><u>Servlet/JSP 요청을 처리</u></strong>하는 역할을 한다.” 라고 했다.</p>\n\n<p>1) <strong>Servlet Container</strong>는 Servlet<strong>의 생명 주기</strong>를 관리하는 곳이다.</p>\n<ul>\n  <li>Servlet과 Servlet Container의 관계를 Bean과 Bean Container의 관계와 흡사하다고 생각하면 된다. (“컨테이너와 관리 대상”의 관계로 이해)\n    <ul>\n      <li>Servlet Container는 HTTP 요청과 응답을 처리하는 Servlet을 관리</li>\n      <li>Bean Container는 Spring의 <strong>애플리케이션 내 객체(Bean)</strong>의 생명 주기와 의존성을 관리</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2) 또한, <strong>HTTP 요청 처리 및 응답 생성 과정</strong>은 Servlet Container의 핵심 기능 중 하나이다.</p>\n<ul>\n  <li>웹 브라우저에서 요청이 들어오면, Tomcat은 그 요청을 받아서 적절한 Java 코드(서블릿)로 전달하고, 그 결과를 다시 브라우저로 보내는 역할을 한다.</li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"servlet\">Servlet</h2>\n\n<p>Servlet은 <strong>HTTP 요청을 처리하고 응답을 생성하는 스펙을 정의한 인터페이스</strong>이다.</p>\n<ul>\n  <li>Servlet은 <strong>jakarta.servlet.Servlet</strong>을 최상위 인터페이스로 가진다. (Java API)</li>\n</ul>\n\n<p>Servlet은 <strong>Servlet Container</strong>에 의해 관리되며, 요청이 들어오면 컨테이너가 Servlet의 생명 주기를 관리하고 요청을 처리하기 위한 스레드를 생성한다.</p>\n\n<p>Servlet은 HTTP 요청을 처리하고, 그에 따른 적절한 응답을 생성하는 기본 단위이다. 이를 통해 <span class=\"post-highlight\">REST API의 엔드포인트</span>가 되거나 <span class=\"post-highlight\">동적 웹 페이지를 생성</span>하는 역할을 수행할 수 있다.</p>\n\n<ol>\n  <li>Servlet은 HTTP 요청을 받아 비즈니스 로직을 처리하고 JSON, XML 등의 형식으로 데이터를 응답할 수 있다.</li>\n  <li>동적인 HTML 콘텐츠를 생성할 때도 사용된다.\n    <ul>\n      <li>예를 들어, 비즈니스 로직 처리가 필요한 HTTP 요청이 Web Server로 들어오면, Web Server는 이를 Servlet Container가 실행하는 Servlet에 전달한다.</li>\n      <li>Servlet은 요청을 처리하고 동적인 웹 콘텐츠를 생성한 뒤, 결과를 Web Server를 통해 클라이언트로 반환한다.</li>\n    </ul>\n  </li>\n</ol>\n\n<p>전체적인 통신 흐름은 다음과 같다.</p>\n<ul>\n  <li>WS 는 HTTP 요청을 받아 정적 리소스를 처리하거나, 요청을 WAS에 전달한다.</li>\n  <li>WAS는 Servlet Container를 통해 요청을 처리하고, 처리 결과를 Web Server를 거쳐 클라이언트에 반환한다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/06d2213c-0f90-4a1b-a765-33531aeed39d\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p><br /></p>\n\n<h3 id=\"servlet의-생명주기\">Servlet의 생명주기</h3>\n\n<p>위 그림을 보면 알 수 있듯, Servlet은 다음과 같은 생명 주기를 가진다.</p>\n\n<p>1) <strong>초기화 단계</strong>:</p>\n<ul>\n  <li>최초 요청이 오면 Servlet 클래스(HelloServlet.class)가 로딩된다.</li>\n  <li>web.xml 설정을 참고하여 매핑할 Servlet을 확인한다.</li>\n  <li><span class=\"post-highlight\">해당 Servlet 인스턴스가 있다면 사용하고, 없다면 init()으로 초기화한다.</span></li>\n</ul>\n\n<p>2) <strong>서비스 단계</strong>:</p>\n<ul>\n  <li>Servlet Container는 각 요청마다 새로운 스레드를 생성한다.</li>\n  <li>새로운 Request/Response 객체를 생성하여 service() 메서드를 실행한다.</li>\n  <li>service()는 요청 방식(GET, POST 등)에 따라 적절한 do메서드를 호출한다.</li>\n  <li>요청 처리가 완료되면 해당 Request/Response 객체는 소멸된다.</li>\n</ul>\n\n<p>3) <strong>소멸 단계</strong>:</p>\n<ul>\n  <li><em>서버 종료나 애플리케이션 재배포 시에만 destroy()가 호출된다.</em></li>\n  <li><em>Servlet이 사용하던 리소스를 정리한다.</em></li>\n</ul>\n\n<p><br /></p>\n\n<p>정리하자면,</p>\n<ul>\n  <li>Tomcat은 Servlet 객체를 한 번 생성하면 메모리에 유지하고, 요청이 올 때마다 해당 객체의 <strong>service()</strong> 메서드를 호출한다.</li>\n  <li>따라서, <strong>init()</strong> 메서드는 <strong>최초 요청 시(또는 설정에 따라 애플리케이션 시작 시)</strong> 단 한 번 실행된다.</li>\n  <li>또 종료되기 전이나 reload 전에 destroy()를 호출하여 매번 객체가 생성되는 것을 방지한다.</li>\n</ul>\n\n<p><strong>(🤔 궁금증) servlet은 왜 생성만 하고 제거는 안하지?</strong>\n만약 사용이 끝날 때마다 제거한다면 다음과 같은 문제가 있다.</p>\n<ul>\n  <li>모든 요청에 대해 servlet을 생성하고 소멸하는 것은 OS 와 JVM 에게 필요없는 부하를 일으킨다.\n    <ul>\n      <li>JVM의 <strong>Garbage Collection</strong>과 <strong>메모리 할당/해제</strong>를 빈번하게 유발</li>\n    </ul>\n  </li>\n  <li>동시에 다수의 요청이 들어올 경우 CPU 또는 메모리 리소스 소모에 대한 제한이 어렵다. \n결국 순간적으로 서버가 다운되거나 동시 처리에 문제가 생길 수 있다.\n    <ul>\n      <li><em>(참고로 Tomcat 3.2 이전 버전은 실제 매번 생성과 제거를 했다.)</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p><strong>(✨해결) 해답은 Servlet의 특징과 관리 방식에 있다.</strong></p>\n<ul>\n  <li>수많은 클라이언트의 요청을 동시에 처리해야 하는 WAS의 특성상,\nServlet은 싱글톤 패턴으로 관리하게 되었다.\n    <ul>\n      <li>한 번 생성된 Servlet 인스턴스는 메모리에 계속 유지된다.</li>\n      <li>모든 요청은 동일한 Servlet 인스턴스를 공유한다.</li>\n      <li>init()은 최초 요청 시 한 번만 실행된다.</li>\n      <li>destroy()는 서버 종료나 재배포 시에만 실행된다.</li>\n    </ul>\n  </li>\n  <li><em>(Tomcat 3.2 부터는 디폴트로 <span class=\"post-highlight\">싱글톤 패턴 도입</span>와 <span class=\"post-highlight\">Thread Pool</span> 을 사용)</em></li>\n</ul>\n\n<p><br /></p>\n\n<h1 id=\"servlet-처리-구조의-발전\">Servlet 처리 구조의 발전</h1>\n\n<h2 id=\"기존-servlet-처리-방식\">기존 Servlet 처리 방식</h2>\n\n<p>Tomcat은 다음과 같은 역할을 한다고 하였다.</p>\n<ul>\n  <li>Servlet Container로서 HTTP 요청과 응답을 처리하는 환경 제공</li>\n  <li>Servlet 객체의 생성, 초기화, 요청 처리, 소멸 등 <strong>생명주기를 관리</strong>하는 역할</li>\n</ul>\n\n<p><strong>(🤔 문제점) Servlet은 요청마다 개별적으로 처리 로직을 구현해야 하므로,</strong><br />\n<strong>비슷한 요청을 처리하는 여러 Servlet에서 <span class=\"post-highlight\">중복된 코드가 발생</span>할 수 있다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/7c5e684e-cd0f-4167-8e55-f3d24172f58e\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 기존 서블릿 방식 - 각 URL마다 서블릿을 따로 만들어야 했습니다</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserServlet</span> <span class=\"kd\">extends</span> <span class=\"nc\">HttpServlet</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">doGet</span><span class=\"o\">(</span><span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"nc\">HttpServletResponse</span> <span class=\"n\">response</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 로깅 처리</span>\n        <span class=\"c1\">// 인증 처리</span>\n        <span class=\"c1\">// 공통 에러 처리</span>\n        <span class=\"c1\">// 실제 비즈니스 로직</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProductServlet</span> <span class=\"kd\">extends</span> <span class=\"nc\">HttpServlet</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">doGet</span><span class=\"o\">(</span><span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"nc\">HttpServletResponse</span> <span class=\"n\">response</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 위와 동일한 로깅, 인증, 에러 처리 코드가 반복됨</span>\n        <span class=\"c1\">// 실제 비즈니스 로직</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>이러한 방식은 다음과 같은 문제가 있다.</p>\n<ol>\n  <li>하나의 서블릿 클래스에 너무 많은 책임이 집중된다.</li>\n  <li>URL 매핑, 파라미터 처리, 뷰 선택 등을 모두 수동으로 처리해야 함</li>\n  <li>모든 서블릿에서 공통 로직(로깅, 인증, 에러 처리 등)이 반복됨</li>\n  <li>각각의 서블릿을 web.xml에 일일이 등록해야 함<br />\n (web.xml : 웹 애플리케이션의 <strong>구성 정보</strong>를 제공)</li>\n</ol>\n\n<ul>\n  <li>과거 web.xml은 다음과 같은 중요한 정보들을 담고 있었다.\n    <ul>\n      <li>어떤 서블릿이 존재하는지</li>\n      <li>각 서블릿이 어떤 URL 패턴을 처리하는지</li>\n      <li>어떤 필터들이 요청을 처리하는지</li>\n      <li>웹 애플리케이션의 시작과 종료 시 필요한 리스너는 무엇인지</li>\n    </ul>\n  </li>\n</ul>\n\n<p>⇒ 각 서블릿(요청을 처리하는 클래스)에 대한 정보를 등록해야 한다는 것이다… 😢</p>\n\n<p><br /></p>\n\n<h2 id=\"dispatcherservlet---spring-mvc--공통-로직의-중앙-집중화\"><strong>DispatcherServlet</strong> - Spring MVC : 공통 로직의 중앙 집중화</h2>\n\n<p><strong>(✨ 해결책) 공통 로직의 중앙 집중화</strong></p>\n\n<p>Spring Framework는 기존 서블릿 스펙의 장점을 활용하면서도 그 한계를 개선하는 방향으로 발전했다.</p>\n\n<p><span class=\"post-highlight\">DispatcherServlet이라는 Front Controller를 사용해 공통 로직을 처리하고 요청에 맞는 컨트롤러를 호출하는 특수한 Servlet</span>을 만들어 새로운 구조를 도입했다.</p>\n\n<ul>\n  <li><em>참고로 <strong>DispatcherServlet</strong> 도 <strong>Servlet이다.</strong></em>\n    <ul>\n      <li><em>(이쯤에서 Spring에서의 Controller의 역할이 아구 맞게 떠오른다.)</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/945895b9-66a2-4713-b7a4-8461f3a66075\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>Spring MVC는 이러한 문제를 DispatcherServlet이라는 하나의 Front Controller로 해결했다.</p>\n\n<ul>\n  <li><em>이제 우리가 아는 친숙한 코드가 나온다….</em></li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Spring MVC 방식</span>\n<span class=\"nd\">@Controller</span>  <span class=\"c1\">// 더 이상 HttpServlet을 상속할 필요가 없음</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserController</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@GetMapping</span><span class=\"o\">(</span><span class=\"s\">\"/users\"</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">handleUsers</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 비즈니스 로직에만 집중</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"userList\"</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"nd\">@Controller</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProductController</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@GetMapping</span><span class=\"o\">(</span><span class=\"s\">\"/products\"</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">handleProducts</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 비즈니스 로직에만 집중</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"productList\"</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p><strong>DispatcherServlet</strong>은 다음과 같은 일을 한다.</p>\n\n<ol>\n  <li><strong>DispatcherServlet</strong>은 웹 애플리케이션에 들어오는 모든 HTTP 요청을 먼저 받는다.</li>\n  <li>요청을 <strong>어떤 컨트롤러가 처리할지 결정</strong>하고, 해당 컨트롤러로 요청을 <strong>디스패치(위임)</strong> 한다.</li>\n  <li>요청에 대해 <strong>공통 처리</strong>(예: 인증, 로깅 등)를 먼저 한 후, 적절한 컨트롤러로 요청을 전달한다.</li>\n  <li><strong>DispatcherServlet</strong> 덕분에, 이제 다른 컨트롤러는 굳이 서블릿을 상속할 필요가 없다.</li>\n</ol>\n\n<p>4번에 대해 추가 설명을 하자면, <strong>Spring MVC</strong>에서는 <strong>DispatcherServlet</strong>만 서블릿으로 등록하고, 실제 비즈니스 로직을 처리하는 <strong>컨트롤러</strong>는 <strong>서블릿</strong>이 아니어도 된다는 뜻이다.</p>\n\n<ul>\n  <li><strong>Spring MVC</strong>에서는 <strong>DispatcherServlet</strong>만 서블릿으로 등록하고, 실제 비즈니스 로직을 처리하는 <strong>컨트롤러</strong>는 <strong>서블릿</strong>이 아니어도 된다는 뜻이다.</li>\n  <li>Spring MVC의 <strong>컨트롤러</strong>는 단순한 <strong>자바 클래스</strong>로, <strong>@Controller</strong> 어노테이션을 붙인 클래스를 만들어 요청을 처리할 수 있다.</li>\n  <li>이때, <strong>컨트롤러 클래스는 Servlet을 상속하지 않아도</strong> 된다.</li>\n  <li><strong>DispatcherServlet</strong>이 모든 요청을 처리하고, 요청을 <strong>컨트롤러</strong>로 전달하기 때문에, 실제로는 <strong>서블릿이 아닌 컨트롤러</strong>가 <strong>Servlet 객체를 상속</strong>하지 않아도 된다는 뜻이다.</li>\n</ul>\n\n<p>이렇듯 Spring 프레임워크는 Front Controller를 제공해주고 이를 Dispather Servlet 이라 부른다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/f5b5a218-c501-43c6-8869-c0ccd63acc77\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p><br /></p>\n\n<h2 id=\"servlet과-dispatcherservlet의-역할-분담의-의의\"><strong>Servlet</strong>과 DispatcherServlet의 역할 분담의 의의</h2>\n\n<p>Servlet 표준에서 중요한 점은 Servlet이 <span class=\"post-highlight\">전체 데이터 처리 과정에서 특정한 역할만 수행</span>한다는 것이다.</p>\n\n<p><strong><u>전통적인 서블릿 방식</u></strong>에서는 HTTP 요청/응답 처리부터 비즈니스 로직까지 모든 것을 책임져야했다.</p>\n\n<p>변화한 Spring MVC 구조에는 다음과 같은 장점이 있다.</p>\n\n<p>1) <strong>관심사의 분리(Separation of Concerns)</strong></p>\n<ol>\n  <li>DispatcherServlet이 모든 HTTP 요청을 먼저 받아서 적절한 Controller로 라우팅하는 역할을 담당하게 되었다.</li>\n  <li>이로 인해 Controller는 비즈니스 로직에만 집중할 수 있게 되었다.</li>\n</ol>\n\n<p>2) <strong>POJO(Plain Old Java Object) 기반 개발</strong></p>\n<ol>\n  <li>Controller가 더 이상 HttpServlet을 상속받지 않아도 된다는 것은 매우 중요한 의미를 가진다.</li>\n  <li>이는 일반적인 자바 클래스로 웹 개발이 가능해졌다는 뜻이다.</li>\n</ol>\n\n<p>3) <strong>각 엔드포인트가 명확하게 분리된다.</strong></p>\n\n<p><br /></p>\n\n<p>⇒ Spring Boot는 이러한 통합을 더욱 단순화했다.</p>\n\n<p>개발자는 복잡한 설정 없이도 Tomcat과 Spring이 자연스럽게 협력하는 환경에서 개발할 수 있게 되었다.</p>\n\n<p>web.xml 없이도 자동 구성을 통해 모든 것이 가능해졌다.</p>\n\n<p><em>@SpringBootApplication 어노테이션은 다음 3가지 핵심 어노테이션의 조합이다.</em></p>\n\n<ol>\n  <li>@SpringBootConfiguration</li>\n  <li><span class=\"post-highlight\">@EnableAutoConfiguration</span> [자동 구성]</li>\n  <li>@ComponentScan</li>\n</ol>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@SpringBootApplication</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">MyApplication</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// Spring Boot가 내장 Tomcat을 자동으로 구성하고 시작</span>\n        <span class=\"nc\">SpringApplication</span><span class=\"o\">.</span><span class=\"na\">run</span><span class=\"o\">(</span><span class=\"nc\">MyApplication</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">,</span> <span class=\"n\">args</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>즉, 현대에 와서 <strong>DispatcherServlet이 서블릿 역할을 하면서</strong> 요청을 <strong>Controller</strong>에 전달하고, <strong>Controller</strong>는 <strong>서비스</strong>를 호출하여 실제 비즈니스 로직을 처리하게 하는 방식으로 발전하였다.</p>\n\n<ul>\n  <li>단지 <strong>DispatcherServlet</strong>은 요청을 받아서 적절한 컨트롤러에게 넘겨주는 역할을 한다.</li>\n</ul>\n\n<p>지금까지 살펴본 WAS의 발전 과정을 보면 다음과 같다.</p>\n<ol>\n  <li>WAS는 동적 컨텐츠 처리를 위한 웹 애플리케이션 서버로 분리되며 시작됐다.</li>\n  <li>Tomcat은 Servlet Container로서 Java 기반 웹 애플리케이션을 실행시킨다.</li>\n  <li>초기 Servlet 방식의 한계(중복 코드, 복잡한 설정)를 Spring MVC가 해결했다.</li>\n  <li>DispatcherServlet의 도입으로 공통 로직 처리와 요청 위임이 체계화되었다.</li>\n</ol>\n\n<p>결국 DispatcherServlet이 모든 요청을 받아 적절한 Controller에 위임하므로\nController는 순수 비즈니스 로직에만 집중할 수 있게 되었다.</p>\n<ul>\n  <li>개발자는 반복적인 설정 없이 핵심 기능 개발에 집중 가능!</li>\n</ul>\n\n<p>이처럼 WAS와 Servlet, 그리고 Spring MVC로 이어지는 발전 과정은 더 나은 웹 개발 환경을 만들어왔다.</p>\n\n<p>더 나아가, 웹 애플리케이션 아키텍처는 계속해서 진화하고 있다.</p>\n<ul>\n  <li>Spring WebFlux를 통한 리액티브 프로그래밍 도입</li>\n  <li>클라우드 네이티브 환경 지원</li>\n  <li>마이크로서비스 아키텍처로의 전환</li>\n  <li>서버리스 아키텍처의 등장</li>\n</ul>\n",
                        "tags": ["WAS","Tomcat","Servlet","SpringMVC","Java","WebDevelopment","Architecture","DispatcherServlet","SpringBoot"]
                    },
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    }
                
            ],
        
            "Thread": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    }
                
            ],
        
            "Runnable": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    }
                
            ],
        
            "CompletableFuture": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    }
                
            ],
        
            "ThreadPool": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    }
                
            ],
        
            "ThreadPoolTaskExecutor": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    }
                
            ],
        
            "I/O": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    }
                
            ],
        
            "Performance": [
                
                    {
                        "title": "웹 서버(WS)의 진화",
                        "url": "/2025/01/27/ws-and-was.html",
                        "subtitle": "Apache vs NGINX",
                        "excerpt": "1. 웹서버(WS)에 대하여\n",
                        "author": "Jinho",
                        "date": "January 27, 2025",
                        "background": "/img/posts/apach_vs_nginx.jpeg",
                        "content": "<h1 id=\"1-웹서버ws에-대하여\">1. 웹서버(WS)에 대하여</h1>\n\n<h2 id=\"1-1-웹서버ws-란\">1-1. 웹서버(WS) 란?</h2>\n\n<p>NGINX, Apache 두 소프트웨어 모두 “<u>웹서버 소프트웨어</u>”이다.</p>\n\n<p>그렇다면 WS(웹서버)란 무엇일까?</p>\n\n<p>클라이언트의 HTTP 요청을 받아 <span class=\"post-highlight\">정적인 컨텐츠를 제공하는 서버 혹은 프로그램이다.</span></p>\n\n<p>이후에 다시 말하겠지만, WS는 정적인 컨텐츠를 서비스하는 데에 <strong>특화된</strong> 서버 소프트웨어이다.</p>\n<ul>\n  <li>동적인 콘텐츠를 처리 못한다는 것은 아니다.\n    <ul>\n      <li>참고로, Apache의 경우 자체적으로 동적인 컨텐츠 또한 처리가 가능하다.</li>\n    </ul>\n  </li>\n  <li>NGINX의 경우 불가능하다.\n    <ul>\n      <li>하지만, 동적 처리는 보통 WAS(Web Application Server)에서 주로 수행하므로, Web Server는 프록시 역할만 하면 충분하다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>여기서 주요한 점은 <span class=\"post-highlight\">“정적인 컨텐츠”</span>이다.</p>\n\n<p>html, JS 같은 정적인 컨텐츠들 정도는 웹서버를 구축한다면 웹서버 선에서 요청을 정리할 수 있다.</p>\n\n<h3 id=\"과거-2-tier-architecture\">과거 (2-tier Architecture)</h3>\n\n<p><img src=\"https://github.com/user-attachments/assets/a2d9a118-4b95-46ec-b303-a4b9c084f5eb\" alt=\"Image\" width=\"80%\" height=\"80%\" class=\"center\" /></p>\n\n<p>우선 과거의 버그가 많았던 초기의 웹서버(WS) 프로그램이 수정되고 개발된게 <strong>Apache</strong>이다.</p>\n\n<p>과거에 html, js, css 등과 같은 정적인 콘텐츠만을 주고 받는 구조에서는<br />\n<span class=\"post-highlight\">클라이언트 → WS [Apache] (정적 및 동적 요청 모두 처리) → DB</span> 만으로도 충분했다.</p>\n<ul>\n  <li>사실은 Apache의 경우, 정적/동적 모두 커버가 가능하기 때문에 기능적으로는 문제가 없었다.</li>\n  <li>하지만 다음과 같은 단점이 제기되었다.\n    <ul>\n      <li>동적 요청 처리가 필요할 경우, Apache가 너무 많은 부담을 가진다.</li>\n      <li>보안과 성능 측면에서 아쉬움이 있다.</li>\n      <li><em>그리고 이후에 다시 소개하겠다…</em></li>\n    </ul>\n  </li>\n  <li>그래서 앞단에 <u>정적 처리를 전문적으로 해주는 서버</u>가 있었으면 좋겠다는 생각을 하게 된다.</li>\n</ul>\n\n<p><br /></p>\n\n<h3 id=\"현재-3-tier-architecture\">현재 (3-tier Architecture)</h3>\n\n<p>정적/동적 컨텐츠에 대한 책임을 분리하고,<br />\n효율성과 확장성에 용이하기 위해 아키텍처가 발전했다.</p>\n\n<p><span class=\"post-highlight\">클라이언트 → [WS (정적 요청 처리) → WAS (동적 요청 처리)] → DB  </span><br />\n<em>(초기 발전 과정에서는 Apache가 WAS 역할로 동적 요청을 처리하고, 앞단에 정적 요청 처리를 NGINX가 붙는 방식으로 사용되었다.)</em></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/76082af9-7162-4a41-b5d4-be1d96020bfc\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>WAS는 동적 처리에 리소스 집중할 수 있게 되었고, 트래픽 증가에 유연한 대응이 가능하게 되었다.</p>\n<ul>\n  <li>소프트웨어 측면 말고, 개발자의 측면에서 보아도 효율적이다.\n    <ul>\n      <li>WS는 정적 파일, 보안, 로드밸런싱에만 집중하면 되고, WAS에서는 비즈니스 로직에만 집중하면 된다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><br /></p>\n\n<h1 id=\"2-apache와-nginx\">2. Apache와 NGINX</h1>\n\n<h2 id=\"2-1-apache-처리-방식-커넥션-기반\"><strong>2-1. Apache 처리 방식 (커넥션 기반)</strong></h2>\n\n<p>아파치는 <strong>Multi-Process Module</strong> 방식이다.<br />\n클라이언트가 요청 하나를 보내면, 하나의 process를 생성해서 연결한다.<br />\n요청당 프로세스/스레드 생성한다는 뜻이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/84ca44e3-a224-4f75-864d-f8f121f642da\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>이런 구조는 확장성 면에서 장점이 크다.<br />\n→ <span class=\"post-highlight\">이러한 측면에서 개발자들은 다양한 모듈을 만들어서 서버에 동적으로 빠르게 추가할 수 있는 장점이 있었다.</span></p>\n\n<p>하지만 다음과 같은 문제가 제기되었다.</p>\n\n<p>(🤔문제) <strong>프로세스 생성이 가벼운 작업이 아니기에, 매번 생성하기에는 너무 속도가 느려진다.</strong></p>\n\n<p>(✨발전 1) 요청 이전에 몇 개의 프로세스를 미리 만들어주는 prefork() 방식을 사용했다.</p>\n\n<p>(✨발전 2) 어찌됐든 매번 커넥션을 만드는 것은 비효율적이라고 판단했고, 이미 연결된 커넥션이 있다면 재활용하자는 생각을 한다.</p>\n<ul>\n  <li>http 헤더 종류 중에 keep-alive가 있다.</li>\n  <li><strong>→ Keep-Alive 옵션을 통해 일정 기간 동안 클라이언트와 Connection을 유지하는 방식</strong></li>\n</ul>\n\n<p><br /></p>\n\n<p>그러나 또 다른 문제가 제기되었다.</p>\n\n<p>(🤔또 다른 문제) <strong>클라이언트 수가 늘어나면서 결국 동시에 연결되어 있는 커넥션의 수도 매우 늘어나게 되었다.</strong></p>\n<ul>\n  <li>이렇게 동시 연결된 커넥션 수가 10,000개의 동시 연결을 넘어서는 순간, 서버는 더이상 커넥션을 형성하지 못하게 되는 현상이 발생했다. (<em>C10K 문제…</em>)</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/25bda5d5-aea5-4238-bc7b-3a499875a5e6\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>그런데 이 C10K 문제에서 하드웨어적으로 문제되는 것은 없었다.</li>\n  <li>이 당시 웹 페이지 용량 자체가 적었기 때문에 컴퓨터의 성능은 충분했지만,<br />\n비효율적인 서버의 구조 때문에 <strong>메모리 부족</strong> 현상이 일어난 것이다.</li>\n  <li>많은 커넥션에서 요청이 들어오기 시작하면, CPU 코어는 계속해서 프로세스를 바꿔가며 일을 해야 했다.</li>\n  <li>결론적으로, <strong>수 많은 동시 커넥션을 감당하기엔 아파치 서버의 구조가 적합하지 않았다.</strong></li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"2-2-nginx의-등장-이벤트-기반\"><strong>2-2. “NGINX”의 등장 (이벤트 기반)</strong></h2>\n\n<p>사실 NGINX는 Apache 를 대체하려고 나온 소프트웨어가 아니다.<br />\nNGINX는 Apache 앞 단에 붙여서 <span class=\"post-highlight\">보완하는 방식</span>으로 사용되었다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/c78538ef-1f3a-4e1a-b014-63afd34ca6c2\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>구조적으로 동시 커넥션을 많이 유지 못하는 아파치 서버의 부하를 nginx가 크게 줄일 수 있었다.</p>\n<ul>\n  <li><em>참고로,<br />\n[동시에 연결 가능한 커넥션 수(한 시점에 감당되는 동시 커넥션 수)] 와 초당 요청 처리 수는 다른 의미이다.</em></li>\n</ul>\n\n<p>이때 NGINX 가 정적인 페이지 처리를 모두 하고,<br />\nApache는 동적 파일 처리만 담당하는 (현대의 WAS 느낌) 구조로 바뀌게 되었다.</p>\n\n<p>그렇다면 어떻게 NGINX는 많은 동시 커넥션을 견뎌 낼 수 있을까?</p>\n\n<p><br /></p>\n\n<h3 id=\"nginx-처리-방식에-대해\">NGINX 처리 방식에 대해</h3>\n\n<p>Nginx는 Master-Worker 구조의 Process 방식을 채용했다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/a1d0bf67-8aca-4d49-8d74-690aaba06c50\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>Master Process는 설정파일에 맞게 실제 일하는 Worker Process를 만들어낸다.</p>\n\n<p>그리고 Worker가 만들어질 때 각자 지정된 Listen 소켓을 배정받는다.<br />\n(수신기를 받는다.)</p>\n\n<p>그리고 그 소켓에 새로운 클라이언트로부터 Request가 들어오면, 커넥션을 형성하고 요청을 처리한다.</p>\n<ul>\n  <li>마찬가지로 이 커넥션은 정해진 Keep-alive의 Timeout까지 연결을 유지하게 된다.</li>\n</ul>\n\n<p>하지만, Apache와의 차이는<br />\n<span class=\"post-highlight\">“그 커넥션이 형성되었다고 해서, Worker Process 1개가 그 커넥션 1개만을 담당하지는 않는다.”</span></p>\n<ul>\n  <li>형성된 커넥션에 아무런 요청이 없으면 새로운 커넥션을 형성하거나,<br />\n이미 만들어진 다른 커넥션으로부터 들어온 요청을 처리한다. (여러 커넥션을 쥐고 있는다.)</li>\n  <li>이런 <span class=\"post-highlight\">[커넥션 형성 / 커넥션 제거 / 새로운 요청 처리] 등을 모두 이벤트</span>라고 부른다.</li>\n</ul>\n\n<p>NGINX의 OS커널은 이러한 이벤트를 큐형식으로 줄세우고, Worker에게 전달한다.<br />\n<em>(멀티플레싱, epoll 에 대해 이해하면 어떻게 커널이 이벤트를 제공하는지 알 수 있다.)</em></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/26d73207-0e57-4358-894d-2f4450efcaf8\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">→ 는 커넥션 연결, O는 Request이며, 모두 “이벤트”이다.</em></p>\n\n<p>그리고 이 이벤트들은 큐에 담긴 채 비동기 방식으로 대기하고 있다.</p>\n\n<p>그리고 Worker Process는 하나의 스레드로 이벤트를 꺼내서 처리해 나간다.<br />\n이러면 Worker는 쉬지 않고 일을 계속 할 수 있다.</p>\n\n<p><span class=\"post-highlight\">요청이 없다면 방치되던 Apache의 구조보다 서버 자원을 훨씬 효율적으로 사용하는 셈</span>이다.</p>\n\n<p>(🤔문제) <strong>그런데 순서대로 꺼내서 쓰는 Queue에서 앞단에 들어오연 요청하나가 매우 시간이 오래걸리는 Disk I/O 작업이라면 어떨까..?</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d1abad7d-7b40-42be-9ff9-a293fe7a132b\" alt=\"Image\" width=\"60%\" height=\"100%\" class=\"center\" /></p>\n\n<p>매우 긴 IO 작업 중 큐에 대기하는 모든 이벤트들은 블로킹 될 것이다.</p>\n\n<p>(✨해결책) 오랜 기간 작업을 요하는 요청들을 위한 쓰레드 풀을 미리 만들어놓고,<br />\nWorker Process가 지금 처리하는 요청이 오래 걸린다고 판단되면,<br />\n해당 스레드 풀에 그 작업을 위임하고, 큐의 다른 이벤트를 처리하러 간다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/766c1772-fed9-4a42-b6ce-7fbbe7317f55\" alt=\"Image\" width=\"75%\" height=\"100%\" class=\"center\" /></p>\n\n<p>이러한 Worker Process 는 보통 Cpu의 코어 개수만큼 생성하고,<br />\n이러한 구조는 코어가 부담하는 Context Switch의 횟수를 대폭 줄일 수 있다.</p>\n\n<p>Apache와 비교하자면,</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/3e7909b6-7fd3-48df-b669-6b55a303b835\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>Apache\n    <ul>\n      <li>CPU가 여러 프로세스 간 스위칭</li>\n      <li>요청당 프로세스/스레드 필요</li>\n    </ul>\n  </li>\n  <li>Nginx\n    <ul>\n      <li>하나의 Worker Process가 이벤트 큐로 관리</li>\n      <li>단일 스레드로 여러 이벤트 처리</li>\n      <li>CPU 코어당 하나의 Worker 고정</li>\n      <li>이러한 <strong>Event-Driven Model이 Apache 구조와의 가장 큰 차이</strong>이다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"2-3-apache와-nginx\">2-3. Apache와 NGINX</h2>\n\n<p>항상 어떤 기술을 사용할 때에는 “최신 기술이여서”, “많이들 써서”가 이유가 될 수는 없다.</p>\n\n<p>어떤 기술, 어떤 아키텍처건 Trade-Off는 존재한다.</p>\n\n<p>과연 NGINX는 장점만 있을까?</p>\n\n<p>개발자가 <strong>기능(모듈) 추가를 시도했다가 돌아가고 있는 Worker Process를 종료해야 하는 상황</strong>이 생길 수 있다.</p>\n\n<p>그러면 <span class=\"post-highlight\">해당 Worker Process는 관리하고 있던 커넥션과 관려된 요청을 더이상 처리할 수 없다</span>는 문제가 발생한다.</p>\n<ul>\n  <li>그래서 NGINX는 개발자가 직접 모듈을 만들기에 좀 까다롭다.</li>\n</ul>\n\n<p>하지만, 단점보다 장점이 명확했다.</p>\n\n<p>수많은 동시 커넥션을 빠르게 처리하는 데에 있어 프로세스를 적게 만들다보니<br />\n(One Worker Process per CPU core)<br />\n⇒ 동시 커넥션 양 최소 10배 증가<br />\n⇒ 동일한 커넥션 수일 때 Apache에 비해 속도 2배 향상</p>\n\n<ul>\n  <li><strong>NGINX의 명확한 장점</strong>\n    <ol>\n      <li>One Worker Process per CPU core</li>\n      <li>Event-driven, asynchronous processing</li>\n      <li>Event Queue management</li>\n      <li>Thread Pool for long-running tasks</li>\n    </ol>\n  </li>\n</ul>\n\n<p>그리고 적은 프로세스는 관리가 쉽고, 새 Worker 생성 시 리소스 부담이 적다.</p>\n\n<p>이러한 구조는 “<span class=\"post-highlight\">NGINX가 설정을 동적으로 바꾸는 것</span>”을 가능하게 했다.</p>\n<ul>\n  <li>개발자가 설정 파일을 Runtime에 변경하고, NGINX에 적용하면,<br />\n이후부터는 Mater Process는 그 설정에 맞는 Worker Process를 찍어내게 된다.</li>\n  <li>그리고 기존 Worker Process에는 더이상 커넥션을 형성하지 못하게 막고,<br />\nQueue에 있는 이벤트들을 마저 처리한 뒤 기존 Worker들은 종료된다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/4f16c765-c2d8-44c2-850b-7c88a560dbb6\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>그런데 이러한 <strong>동적 설정 변경은 언제 사용</strong>할까?</p>\n<ul>\n  <li>대표적인 예로, NGINX가 여러 동시 커넥션을 관리하는 중에 뒷단에 새로운 서버를 추가하려는 상황이다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/b4f4191d-f32d-482f-a73c-6c14492350b2\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX는 이제부터 로드밸런싱 역할도 담당해야 한다.</p>\n\n<p>역할의 추가/변경이 의미하는 것은 무엇일까?</p>\n\n<ul>\n  <li>= Master Process가 찍어내야 하는 Worker Process의 역할의 추가/변경<br />\n= 기존 Connection 및 기존 Request들의 손실 없이 역할의 변경이 필요하다.</li>\n  <li>NGINX는 동시 커넥션을 유지한 채, 기존의 요청을 마저 처리하며, 뒷단의 서버를 추가할 수 있다.</li>\n  <li>이벤트 기반 구조이기 때문에 이러한 설정 변경을 초당 수십번 해도 무리없이 커넥션을 관리하고 요청을 서버에 전달할 수 있다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/842b0dc3-119e-4168-93f9-0e6b6f14b960\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : NetCraft Web Server Survey</em></p>\n\n<p>그런데 위 자료를 보면 의문이 든다.<br />\nNGINX가 탄생한 지 2004년부터 2007년 까지도 압도적으로 Apache가 1위를 차지하고 있다.</p>\n\n<p>이때까지만 해도 NIGNX는 소수의 문제 상황에 대한 해결책을 제시한 것 뿐이지,<br />\n대다수의 서비스를 가동하는 데에는 Apache로도 큰 문제가 없었다.</p>\n\n<h3 id=\"스마트폰의-탄생\">스마트폰의 탄생</h3>\n\n<p><img src=\"https://github.com/user-attachments/assets/2a75d845-635a-4d46-a0d2-68629d3fdd1f\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : NetCraft Web Server Survey</em></p>\n\n<p>2008년부터 급격하게 상황이 역전된다. 바로 <strong>스마트폰의 등장</strong> 때문이다.</p>\n\n<ul>\n  <li>단순히 ‘스마트폰의 등장 = 인터넷 사용자의 증가’의 이유가 아니다.</li>\n  <li>“<span class=\"post-highlight\">동시 커넥션을 훨씬 더 많이 생성한 계기</span>”로써 문제가 발생한다.</li>\n  <li>PC의 경우 클라이언트가 일정 시간 사용하고 전원을 끄는 방식으로 사용되었지만,<br />\n스마트폰은 실시간으로 정보를 받고 싶어하는 사용자의 니즈에 맞게 알림 등<br />\n<strong>동시 커넥션을 계속해서 유지</strong>하는 방식으로써 유용하게 사용되었다.</li>\n</ul>\n\n<p>이러다보니 “동시 커넥션 문제”가 현실로 다가온 것이다.</p>\n<ul>\n  <li>대규모 사이트들이 좋아할 만한 솔루션 이었고, NGINX는 급성장하게 된다.<br />\n(<em>현재 우리가 쿠버네티스고, 뭐고 배우는 이유도 이러한 문제의 솔루션으로써 대두된다는 것을 알고 넘어가자</em>)</li>\n</ul>\n\n<p>그렇다면 Apache는 가만히 있었을까?</p>\n\n<p>Apache도 MPM이라는 모듈을 추가해서 성능을 개선하기 시작한다.</p>\n\n<ul>\n  <li>Multi-Processing Module</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/acf7ede3-b612-417c-b4a5-82c352ba4c37\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>Apache 서버를 어떤 방식으로 운영할 지 선택할 수 있는 모듈이다.\n    <ul>\n      <li>안정성이나 소규모 프로젝트에서는 기존의 prefork 방식을</li>\n      <li>성능 향상이나 대규모 프로젝트에서는 worker라는 스레드를 만들어 worker가 요청을 처리하도록 했다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>그렇다면 왜 아직도 동시 커넥션 지표에서 NGINX가 Apache를 압도적으로 앞설까?</p>\n\n<div style=\"display: flex; justify-content: space-between; gap: 20px;\">\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/1b280974-4d15-4e5d-ac6c-c21e2093f673\" alt=\"Memory Usage\" style=\"width: 100%;\" />\n    </div>\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/6a787d51-fb2d-4c1f-a973-3f380a838d29\" alt=\"Requests Per Second\" style=\"width: 100%;\" />\n    </div>\n</div>\n<p style=\"text-align: center; color: #666;\">출처: dreamhost.com</p>\n\n<p>왼쪽 동시 커넥션 수당 메모리 사용률 지표를 보면,</p>\n<ul>\n  <li>NGINX는 동시 커넥션이 많아져도 메모리 사용률이 낮고 일정한 반면,<br />\nApache는 굉장히 많은 메모리 사용률을 요구한다.</li>\n</ul>\n\n<p>오른쪽 동시 커넥션 수가 많아졌을 때 처리하는 초당 요청 수 지표를 보아도,<br />\nNGINX가 Apache에 비해 압도적으로 많다.</p>\n<ul>\n  <li>NGINX가 커넥션 관리를 얼마나 잘하는 지 볼 수 있다.</li>\n</ul>\n\n<p>사실 지금까지 <strong>동시 커넥션</strong>이라는 포인트에만 집중해서 NGINX의 장점과 현재 많이 쓰이는 이유를 알아보았다.</p>\n\n<p><strong>그렇다면 Apache의 장점은 무엇이 있을까?</strong></p>\n\n<p><br /></p>\n\n<h2 id=\"2-4-apache가-아직-쓰이는-이유와-nginx의-단점\">2-4. Apache가 아직 쓰이는 이유와 NGINX의 단점</h2>\n\n<p>근본자체가 “NCSA HTTPd”라는 소프트웨어의 버그를 수정해오며 커온 Apache이기에,\n<span class=\"post-highlight\">호환성과 확장성의 측면</span>에서는 장점이 있다.</p>\n\n<p>아직도 오픈소스로써 활발한 수정과 개선이 이루어지고 있다. [<span class=\"post-highlight\">풍부한 모듈 생태계</span>]</p>\n<ul>\n  <li><a href=\"https://projects.apache.org/projects.html\">Apache는 현재에도 Apache Kafka, Apache Hadoop 등 시대에 발맞춰 발전 중이다</a>.</li>\n</ul>\n\n<p>또한, Apache는 여러 운영 체제(리눅스, 윈도우, 유닉스 등)에서 폭넓은 호환성과 안정성을 자랑한다.</p>\n\n<p>NGINX는 그렇지 않아서, Windows에서 성능이 매우 낮게 나온다.</p>\n<ul>\n  <li>NGINX는 원래 <strong>리눅스</strong> 환경에서 설계되었기 때문에, 리눅스 OS에서 최고의 성능이 나오며,</li>\n  <li>윈도우에서도 동작은 하지만,<br />\n윈도우의 <strong>비동기 I/O</strong> 시스템에 최적화되지 않았기 때문에 <strong>성능이 상대적으로 낮다</strong>.</li>\n</ul>\n\n<p>현재 서비스에서 큰 성능 문제 없이 잘 돌아가고 있고, 모듈을 계속해서 추가/제거할 일이 많다면 굳이 NGINX로 옮길 이유는 없는 것이다.</p>\n<ul>\n  <li>오해하면 안되는 것이 NGINX는 설정 변경과 이에 따른 Worker Process의 로직 변경이 무중단으로 이루어진다는 것이며,<br />\nNGINX는 모듈 자체를 동적으로 로드할 수 없으므로, 새 모듈을 추가하려면 재컴파일이 필요하다.</li>\n  <li>Apache는 설정 변경 없이 실행 중 동적 모듈 로드가 가능하므로, 특정 기능을 빠르게 추가하거나 제거할 때 더 유연하다.</li>\n</ul>\n\n<p><strong>둘은 서로 대립관계가 아니며, 목적이 다르게 탄생한 것이다.</strong></p>\n\n<p><br /></p>\n\n<h2 id=\"2-5-그렇다면-현재-nginx를-어떻게-이용해야-하는가\">2-5. 그렇다면 현재 NGINX를 어떻게 이용해야 하는가?</h2>\n\n<p>앞서 우리는 NGINX의 WS로써, 로드밸런싱으로서의 역할을 보았다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/04bf32c2-7d72-4229-a31e-2b3e639e6b2d\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>비동기 이벤트 기반 구조로 동시 커넥션 처리가 효율적이며, Reverse Proxy로써 서버 부하를 줄일 수 있다.</p>\n\n<p>이 자체로 웹 서버 가속(성능 개선) 역할을 한다.</p>\n\n<p>추가적으로 NGINX를 사용하며 고려해야할 관점이다.</p>\n\n<p><strong>1) SSL 터미네이션 역할을 한다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/baaa7488-05be-473f-8d84-27912891b0f3\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX가 앞단에서 SSL을 처리하여, 클라이언트와는 HTTPS로 통신하고, 뒷단 서버와는 HTTP로 통신하는 방식이다.</p>\n<ul>\n  <li>어차피, NGINX와 SERVER가 같은 네트워크 안에 있는 경우가 많기 떄문에,<br />\n이렇게 통신을 해도 보안 위험이 비교적 적다.</li>\n</ul>\n\n<p>이 방식은 뒷단 서버가 <span class=\"post-highlight\">복호화 과정에서 발생하는 부하를 줄이는 장점</span>이 있다.</p>\n\n<p><strong>2) 캐싱 역할을 한다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/6c43e842-cbfa-44fd-99e0-75b079dc4a20\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX는 &lt;span class=”post-highlight”HTTP 콘텐츠 캐싱&lt;/span&gt;을 지원하며,<br />\n이를 통해 서버 부하를 줄이고 클라이언트 요청에 빠르게 응답할 수 있습니다.</p>\n<ul>\n  <li>한 번 서버로부터 받은 응답을 스스로 보관하고 클라이언트에게 전달하므로 효율적이다.</li>\n</ul>\n\n<p>이러한 경우 1번과 달리 NGINX를 클라이언트와 가까운 곳(예: CDN이나 엣지 서버)에 배치하여<br />\n캐싱 효과를 극대화할 수 있다.</p>\n\n<p><strong>3)NGINX와 컨테이너화</strong></p>\n\n<p>현재 클라우드 네이티브와 컨테이너화가 대세인 환경에서, NGINX는 더욱 중요한 역할을 수행하고 있다.</p>\n\n<p>특히 Kubernetes의 Ingress Controller로서, 또는 마이크로서비스 아키텍처에서의 API Gateway로서 그 가치가 두드러진다.</p>\n\n<p>Kubernetes에서 Ingress Controller로 사용될 때, API Gateway로서의 설정 등등</p>\n<ul>\n  <li>이러한 설정들을 통해 NGINX는 현대적인 마이크로서비스 환경에서 트래픽 라우팅, 로드밸런싱, SSL 종료, API 게이트웨이 등 다양한 역할을 효율적으로 수행할 수 있다.</li>\n  <li>특히 컨테이너 환경에서는 가볍고 빠른 NGINX의 특성이 더욱 큰 장점으로 작용한다.</li>\n</ul>\n\n<p>이 외에도 HSTS, CORS 처리, TCP/UDP 커넥션 분산 부하, HTTP/2 지원 (최근에는 /3도 지원) 등 서버를 보완하는 역할을 할 수 있다.</p>\n\n<p>어떠한 기능이 있는지를 알아보고 상황에 따라 알맞는 기능을 적용하는 자세가 필요하다.</p>\n\n<hr />\n<p>참고: <a href=\"https://www.youtube.com/watch?v=mcnJcjbfjrs\" target=\"_blank\">우아한테크 [10분 테코톡] 알리의 Web Server vs WAS</a></p>\n\n<p><a href=\"https://www.youtube.com/watch?v=6FAwAXXj5N0\" target=\"_blank\">우아한테크 [10분 테코톡] 피케이의 Nginx</a></p>\n",
                        "tags": ["WebServer","Apache","NGINX","Architecture","DevOps","Network","Performance","LoadBalancing","ReverseProxy"]
                    },
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    }
                
            ],
        
            "WebFlux": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    }
                
            ],
        
            "WebServer": [
                
                    {
                        "title": "웹 서버(WS)의 진화",
                        "url": "/2025/01/27/ws-and-was.html",
                        "subtitle": "Apache vs NGINX",
                        "excerpt": "1. 웹서버(WS)에 대하여\n",
                        "author": "Jinho",
                        "date": "January 27, 2025",
                        "background": "/img/posts/apach_vs_nginx.jpeg",
                        "content": "<h1 id=\"1-웹서버ws에-대하여\">1. 웹서버(WS)에 대하여</h1>\n\n<h2 id=\"1-1-웹서버ws-란\">1-1. 웹서버(WS) 란?</h2>\n\n<p>NGINX, Apache 두 소프트웨어 모두 “<u>웹서버 소프트웨어</u>”이다.</p>\n\n<p>그렇다면 WS(웹서버)란 무엇일까?</p>\n\n<p>클라이언트의 HTTP 요청을 받아 <span class=\"post-highlight\">정적인 컨텐츠를 제공하는 서버 혹은 프로그램이다.</span></p>\n\n<p>이후에 다시 말하겠지만, WS는 정적인 컨텐츠를 서비스하는 데에 <strong>특화된</strong> 서버 소프트웨어이다.</p>\n<ul>\n  <li>동적인 콘텐츠를 처리 못한다는 것은 아니다.\n    <ul>\n      <li>참고로, Apache의 경우 자체적으로 동적인 컨텐츠 또한 처리가 가능하다.</li>\n    </ul>\n  </li>\n  <li>NGINX의 경우 불가능하다.\n    <ul>\n      <li>하지만, 동적 처리는 보통 WAS(Web Application Server)에서 주로 수행하므로, Web Server는 프록시 역할만 하면 충분하다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>여기서 주요한 점은 <span class=\"post-highlight\">“정적인 컨텐츠”</span>이다.</p>\n\n<p>html, JS 같은 정적인 컨텐츠들 정도는 웹서버를 구축한다면 웹서버 선에서 요청을 정리할 수 있다.</p>\n\n<h3 id=\"과거-2-tier-architecture\">과거 (2-tier Architecture)</h3>\n\n<p><img src=\"https://github.com/user-attachments/assets/a2d9a118-4b95-46ec-b303-a4b9c084f5eb\" alt=\"Image\" width=\"80%\" height=\"80%\" class=\"center\" /></p>\n\n<p>우선 과거의 버그가 많았던 초기의 웹서버(WS) 프로그램이 수정되고 개발된게 <strong>Apache</strong>이다.</p>\n\n<p>과거에 html, js, css 등과 같은 정적인 콘텐츠만을 주고 받는 구조에서는<br />\n<span class=\"post-highlight\">클라이언트 → WS [Apache] (정적 및 동적 요청 모두 처리) → DB</span> 만으로도 충분했다.</p>\n<ul>\n  <li>사실은 Apache의 경우, 정적/동적 모두 커버가 가능하기 때문에 기능적으로는 문제가 없었다.</li>\n  <li>하지만 다음과 같은 단점이 제기되었다.\n    <ul>\n      <li>동적 요청 처리가 필요할 경우, Apache가 너무 많은 부담을 가진다.</li>\n      <li>보안과 성능 측면에서 아쉬움이 있다.</li>\n      <li><em>그리고 이후에 다시 소개하겠다…</em></li>\n    </ul>\n  </li>\n  <li>그래서 앞단에 <u>정적 처리를 전문적으로 해주는 서버</u>가 있었으면 좋겠다는 생각을 하게 된다.</li>\n</ul>\n\n<p><br /></p>\n\n<h3 id=\"현재-3-tier-architecture\">현재 (3-tier Architecture)</h3>\n\n<p>정적/동적 컨텐츠에 대한 책임을 분리하고,<br />\n효율성과 확장성에 용이하기 위해 아키텍처가 발전했다.</p>\n\n<p><span class=\"post-highlight\">클라이언트 → [WS (정적 요청 처리) → WAS (동적 요청 처리)] → DB  </span><br />\n<em>(초기 발전 과정에서는 Apache가 WAS 역할로 동적 요청을 처리하고, 앞단에 정적 요청 처리를 NGINX가 붙는 방식으로 사용되었다.)</em></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/76082af9-7162-4a41-b5d4-be1d96020bfc\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>WAS는 동적 처리에 리소스 집중할 수 있게 되었고, 트래픽 증가에 유연한 대응이 가능하게 되었다.</p>\n<ul>\n  <li>소프트웨어 측면 말고, 개발자의 측면에서 보아도 효율적이다.\n    <ul>\n      <li>WS는 정적 파일, 보안, 로드밸런싱에만 집중하면 되고, WAS에서는 비즈니스 로직에만 집중하면 된다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><br /></p>\n\n<h1 id=\"2-apache와-nginx\">2. Apache와 NGINX</h1>\n\n<h2 id=\"2-1-apache-처리-방식-커넥션-기반\"><strong>2-1. Apache 처리 방식 (커넥션 기반)</strong></h2>\n\n<p>아파치는 <strong>Multi-Process Module</strong> 방식이다.<br />\n클라이언트가 요청 하나를 보내면, 하나의 process를 생성해서 연결한다.<br />\n요청당 프로세스/스레드 생성한다는 뜻이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/84ca44e3-a224-4f75-864d-f8f121f642da\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>이런 구조는 확장성 면에서 장점이 크다.<br />\n→ <span class=\"post-highlight\">이러한 측면에서 개발자들은 다양한 모듈을 만들어서 서버에 동적으로 빠르게 추가할 수 있는 장점이 있었다.</span></p>\n\n<p>하지만 다음과 같은 문제가 제기되었다.</p>\n\n<p>(🤔문제) <strong>프로세스 생성이 가벼운 작업이 아니기에, 매번 생성하기에는 너무 속도가 느려진다.</strong></p>\n\n<p>(✨발전 1) 요청 이전에 몇 개의 프로세스를 미리 만들어주는 prefork() 방식을 사용했다.</p>\n\n<p>(✨발전 2) 어찌됐든 매번 커넥션을 만드는 것은 비효율적이라고 판단했고, 이미 연결된 커넥션이 있다면 재활용하자는 생각을 한다.</p>\n<ul>\n  <li>http 헤더 종류 중에 keep-alive가 있다.</li>\n  <li><strong>→ Keep-Alive 옵션을 통해 일정 기간 동안 클라이언트와 Connection을 유지하는 방식</strong></li>\n</ul>\n\n<p><br /></p>\n\n<p>그러나 또 다른 문제가 제기되었다.</p>\n\n<p>(🤔또 다른 문제) <strong>클라이언트 수가 늘어나면서 결국 동시에 연결되어 있는 커넥션의 수도 매우 늘어나게 되었다.</strong></p>\n<ul>\n  <li>이렇게 동시 연결된 커넥션 수가 10,000개의 동시 연결을 넘어서는 순간, 서버는 더이상 커넥션을 형성하지 못하게 되는 현상이 발생했다. (<em>C10K 문제…</em>)</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/25bda5d5-aea5-4238-bc7b-3a499875a5e6\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>그런데 이 C10K 문제에서 하드웨어적으로 문제되는 것은 없었다.</li>\n  <li>이 당시 웹 페이지 용량 자체가 적었기 때문에 컴퓨터의 성능은 충분했지만,<br />\n비효율적인 서버의 구조 때문에 <strong>메모리 부족</strong> 현상이 일어난 것이다.</li>\n  <li>많은 커넥션에서 요청이 들어오기 시작하면, CPU 코어는 계속해서 프로세스를 바꿔가며 일을 해야 했다.</li>\n  <li>결론적으로, <strong>수 많은 동시 커넥션을 감당하기엔 아파치 서버의 구조가 적합하지 않았다.</strong></li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"2-2-nginx의-등장-이벤트-기반\"><strong>2-2. “NGINX”의 등장 (이벤트 기반)</strong></h2>\n\n<p>사실 NGINX는 Apache 를 대체하려고 나온 소프트웨어가 아니다.<br />\nNGINX는 Apache 앞 단에 붙여서 <span class=\"post-highlight\">보완하는 방식</span>으로 사용되었다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/c78538ef-1f3a-4e1a-b014-63afd34ca6c2\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>구조적으로 동시 커넥션을 많이 유지 못하는 아파치 서버의 부하를 nginx가 크게 줄일 수 있었다.</p>\n<ul>\n  <li><em>참고로,<br />\n[동시에 연결 가능한 커넥션 수(한 시점에 감당되는 동시 커넥션 수)] 와 초당 요청 처리 수는 다른 의미이다.</em></li>\n</ul>\n\n<p>이때 NGINX 가 정적인 페이지 처리를 모두 하고,<br />\nApache는 동적 파일 처리만 담당하는 (현대의 WAS 느낌) 구조로 바뀌게 되었다.</p>\n\n<p>그렇다면 어떻게 NGINX는 많은 동시 커넥션을 견뎌 낼 수 있을까?</p>\n\n<p><br /></p>\n\n<h3 id=\"nginx-처리-방식에-대해\">NGINX 처리 방식에 대해</h3>\n\n<p>Nginx는 Master-Worker 구조의 Process 방식을 채용했다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/a1d0bf67-8aca-4d49-8d74-690aaba06c50\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>Master Process는 설정파일에 맞게 실제 일하는 Worker Process를 만들어낸다.</p>\n\n<p>그리고 Worker가 만들어질 때 각자 지정된 Listen 소켓을 배정받는다.<br />\n(수신기를 받는다.)</p>\n\n<p>그리고 그 소켓에 새로운 클라이언트로부터 Request가 들어오면, 커넥션을 형성하고 요청을 처리한다.</p>\n<ul>\n  <li>마찬가지로 이 커넥션은 정해진 Keep-alive의 Timeout까지 연결을 유지하게 된다.</li>\n</ul>\n\n<p>하지만, Apache와의 차이는<br />\n<span class=\"post-highlight\">“그 커넥션이 형성되었다고 해서, Worker Process 1개가 그 커넥션 1개만을 담당하지는 않는다.”</span></p>\n<ul>\n  <li>형성된 커넥션에 아무런 요청이 없으면 새로운 커넥션을 형성하거나,<br />\n이미 만들어진 다른 커넥션으로부터 들어온 요청을 처리한다. (여러 커넥션을 쥐고 있는다.)</li>\n  <li>이런 <span class=\"post-highlight\">[커넥션 형성 / 커넥션 제거 / 새로운 요청 처리] 등을 모두 이벤트</span>라고 부른다.</li>\n</ul>\n\n<p>NGINX의 OS커널은 이러한 이벤트를 큐형식으로 줄세우고, Worker에게 전달한다.<br />\n<em>(멀티플레싱, epoll 에 대해 이해하면 어떻게 커널이 이벤트를 제공하는지 알 수 있다.)</em></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/26d73207-0e57-4358-894d-2f4450efcaf8\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">→ 는 커넥션 연결, O는 Request이며, 모두 “이벤트”이다.</em></p>\n\n<p>그리고 이 이벤트들은 큐에 담긴 채 비동기 방식으로 대기하고 있다.</p>\n\n<p>그리고 Worker Process는 하나의 스레드로 이벤트를 꺼내서 처리해 나간다.<br />\n이러면 Worker는 쉬지 않고 일을 계속 할 수 있다.</p>\n\n<p><span class=\"post-highlight\">요청이 없다면 방치되던 Apache의 구조보다 서버 자원을 훨씬 효율적으로 사용하는 셈</span>이다.</p>\n\n<p>(🤔문제) <strong>그런데 순서대로 꺼내서 쓰는 Queue에서 앞단에 들어오연 요청하나가 매우 시간이 오래걸리는 Disk I/O 작업이라면 어떨까..?</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d1abad7d-7b40-42be-9ff9-a293fe7a132b\" alt=\"Image\" width=\"60%\" height=\"100%\" class=\"center\" /></p>\n\n<p>매우 긴 IO 작업 중 큐에 대기하는 모든 이벤트들은 블로킹 될 것이다.</p>\n\n<p>(✨해결책) 오랜 기간 작업을 요하는 요청들을 위한 쓰레드 풀을 미리 만들어놓고,<br />\nWorker Process가 지금 처리하는 요청이 오래 걸린다고 판단되면,<br />\n해당 스레드 풀에 그 작업을 위임하고, 큐의 다른 이벤트를 처리하러 간다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/766c1772-fed9-4a42-b6ce-7fbbe7317f55\" alt=\"Image\" width=\"75%\" height=\"100%\" class=\"center\" /></p>\n\n<p>이러한 Worker Process 는 보통 Cpu의 코어 개수만큼 생성하고,<br />\n이러한 구조는 코어가 부담하는 Context Switch의 횟수를 대폭 줄일 수 있다.</p>\n\n<p>Apache와 비교하자면,</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/3e7909b6-7fd3-48df-b669-6b55a303b835\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>Apache\n    <ul>\n      <li>CPU가 여러 프로세스 간 스위칭</li>\n      <li>요청당 프로세스/스레드 필요</li>\n    </ul>\n  </li>\n  <li>Nginx\n    <ul>\n      <li>하나의 Worker Process가 이벤트 큐로 관리</li>\n      <li>단일 스레드로 여러 이벤트 처리</li>\n      <li>CPU 코어당 하나의 Worker 고정</li>\n      <li>이러한 <strong>Event-Driven Model이 Apache 구조와의 가장 큰 차이</strong>이다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"2-3-apache와-nginx\">2-3. Apache와 NGINX</h2>\n\n<p>항상 어떤 기술을 사용할 때에는 “최신 기술이여서”, “많이들 써서”가 이유가 될 수는 없다.</p>\n\n<p>어떤 기술, 어떤 아키텍처건 Trade-Off는 존재한다.</p>\n\n<p>과연 NGINX는 장점만 있을까?</p>\n\n<p>개발자가 <strong>기능(모듈) 추가를 시도했다가 돌아가고 있는 Worker Process를 종료해야 하는 상황</strong>이 생길 수 있다.</p>\n\n<p>그러면 <span class=\"post-highlight\">해당 Worker Process는 관리하고 있던 커넥션과 관려된 요청을 더이상 처리할 수 없다</span>는 문제가 발생한다.</p>\n<ul>\n  <li>그래서 NGINX는 개발자가 직접 모듈을 만들기에 좀 까다롭다.</li>\n</ul>\n\n<p>하지만, 단점보다 장점이 명확했다.</p>\n\n<p>수많은 동시 커넥션을 빠르게 처리하는 데에 있어 프로세스를 적게 만들다보니<br />\n(One Worker Process per CPU core)<br />\n⇒ 동시 커넥션 양 최소 10배 증가<br />\n⇒ 동일한 커넥션 수일 때 Apache에 비해 속도 2배 향상</p>\n\n<ul>\n  <li><strong>NGINX의 명확한 장점</strong>\n    <ol>\n      <li>One Worker Process per CPU core</li>\n      <li>Event-driven, asynchronous processing</li>\n      <li>Event Queue management</li>\n      <li>Thread Pool for long-running tasks</li>\n    </ol>\n  </li>\n</ul>\n\n<p>그리고 적은 프로세스는 관리가 쉽고, 새 Worker 생성 시 리소스 부담이 적다.</p>\n\n<p>이러한 구조는 “<span class=\"post-highlight\">NGINX가 설정을 동적으로 바꾸는 것</span>”을 가능하게 했다.</p>\n<ul>\n  <li>개발자가 설정 파일을 Runtime에 변경하고, NGINX에 적용하면,<br />\n이후부터는 Mater Process는 그 설정에 맞는 Worker Process를 찍어내게 된다.</li>\n  <li>그리고 기존 Worker Process에는 더이상 커넥션을 형성하지 못하게 막고,<br />\nQueue에 있는 이벤트들을 마저 처리한 뒤 기존 Worker들은 종료된다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/4f16c765-c2d8-44c2-850b-7c88a560dbb6\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>그런데 이러한 <strong>동적 설정 변경은 언제 사용</strong>할까?</p>\n<ul>\n  <li>대표적인 예로, NGINX가 여러 동시 커넥션을 관리하는 중에 뒷단에 새로운 서버를 추가하려는 상황이다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/b4f4191d-f32d-482f-a73c-6c14492350b2\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX는 이제부터 로드밸런싱 역할도 담당해야 한다.</p>\n\n<p>역할의 추가/변경이 의미하는 것은 무엇일까?</p>\n\n<ul>\n  <li>= Master Process가 찍어내야 하는 Worker Process의 역할의 추가/변경<br />\n= 기존 Connection 및 기존 Request들의 손실 없이 역할의 변경이 필요하다.</li>\n  <li>NGINX는 동시 커넥션을 유지한 채, 기존의 요청을 마저 처리하며, 뒷단의 서버를 추가할 수 있다.</li>\n  <li>이벤트 기반 구조이기 때문에 이러한 설정 변경을 초당 수십번 해도 무리없이 커넥션을 관리하고 요청을 서버에 전달할 수 있다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/842b0dc3-119e-4168-93f9-0e6b6f14b960\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : NetCraft Web Server Survey</em></p>\n\n<p>그런데 위 자료를 보면 의문이 든다.<br />\nNGINX가 탄생한 지 2004년부터 2007년 까지도 압도적으로 Apache가 1위를 차지하고 있다.</p>\n\n<p>이때까지만 해도 NIGNX는 소수의 문제 상황에 대한 해결책을 제시한 것 뿐이지,<br />\n대다수의 서비스를 가동하는 데에는 Apache로도 큰 문제가 없었다.</p>\n\n<h3 id=\"스마트폰의-탄생\">스마트폰의 탄생</h3>\n\n<p><img src=\"https://github.com/user-attachments/assets/2a75d845-635a-4d46-a0d2-68629d3fdd1f\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : NetCraft Web Server Survey</em></p>\n\n<p>2008년부터 급격하게 상황이 역전된다. 바로 <strong>스마트폰의 등장</strong> 때문이다.</p>\n\n<ul>\n  <li>단순히 ‘스마트폰의 등장 = 인터넷 사용자의 증가’의 이유가 아니다.</li>\n  <li>“<span class=\"post-highlight\">동시 커넥션을 훨씬 더 많이 생성한 계기</span>”로써 문제가 발생한다.</li>\n  <li>PC의 경우 클라이언트가 일정 시간 사용하고 전원을 끄는 방식으로 사용되었지만,<br />\n스마트폰은 실시간으로 정보를 받고 싶어하는 사용자의 니즈에 맞게 알림 등<br />\n<strong>동시 커넥션을 계속해서 유지</strong>하는 방식으로써 유용하게 사용되었다.</li>\n</ul>\n\n<p>이러다보니 “동시 커넥션 문제”가 현실로 다가온 것이다.</p>\n<ul>\n  <li>대규모 사이트들이 좋아할 만한 솔루션 이었고, NGINX는 급성장하게 된다.<br />\n(<em>현재 우리가 쿠버네티스고, 뭐고 배우는 이유도 이러한 문제의 솔루션으로써 대두된다는 것을 알고 넘어가자</em>)</li>\n</ul>\n\n<p>그렇다면 Apache는 가만히 있었을까?</p>\n\n<p>Apache도 MPM이라는 모듈을 추가해서 성능을 개선하기 시작한다.</p>\n\n<ul>\n  <li>Multi-Processing Module</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/acf7ede3-b612-417c-b4a5-82c352ba4c37\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>Apache 서버를 어떤 방식으로 운영할 지 선택할 수 있는 모듈이다.\n    <ul>\n      <li>안정성이나 소규모 프로젝트에서는 기존의 prefork 방식을</li>\n      <li>성능 향상이나 대규모 프로젝트에서는 worker라는 스레드를 만들어 worker가 요청을 처리하도록 했다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>그렇다면 왜 아직도 동시 커넥션 지표에서 NGINX가 Apache를 압도적으로 앞설까?</p>\n\n<div style=\"display: flex; justify-content: space-between; gap: 20px;\">\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/1b280974-4d15-4e5d-ac6c-c21e2093f673\" alt=\"Memory Usage\" style=\"width: 100%;\" />\n    </div>\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/6a787d51-fb2d-4c1f-a973-3f380a838d29\" alt=\"Requests Per Second\" style=\"width: 100%;\" />\n    </div>\n</div>\n<p style=\"text-align: center; color: #666;\">출처: dreamhost.com</p>\n\n<p>왼쪽 동시 커넥션 수당 메모리 사용률 지표를 보면,</p>\n<ul>\n  <li>NGINX는 동시 커넥션이 많아져도 메모리 사용률이 낮고 일정한 반면,<br />\nApache는 굉장히 많은 메모리 사용률을 요구한다.</li>\n</ul>\n\n<p>오른쪽 동시 커넥션 수가 많아졌을 때 처리하는 초당 요청 수 지표를 보아도,<br />\nNGINX가 Apache에 비해 압도적으로 많다.</p>\n<ul>\n  <li>NGINX가 커넥션 관리를 얼마나 잘하는 지 볼 수 있다.</li>\n</ul>\n\n<p>사실 지금까지 <strong>동시 커넥션</strong>이라는 포인트에만 집중해서 NGINX의 장점과 현재 많이 쓰이는 이유를 알아보았다.</p>\n\n<p><strong>그렇다면 Apache의 장점은 무엇이 있을까?</strong></p>\n\n<p><br /></p>\n\n<h2 id=\"2-4-apache가-아직-쓰이는-이유와-nginx의-단점\">2-4. Apache가 아직 쓰이는 이유와 NGINX의 단점</h2>\n\n<p>근본자체가 “NCSA HTTPd”라는 소프트웨어의 버그를 수정해오며 커온 Apache이기에,\n<span class=\"post-highlight\">호환성과 확장성의 측면</span>에서는 장점이 있다.</p>\n\n<p>아직도 오픈소스로써 활발한 수정과 개선이 이루어지고 있다. [<span class=\"post-highlight\">풍부한 모듈 생태계</span>]</p>\n<ul>\n  <li><a href=\"https://projects.apache.org/projects.html\">Apache는 현재에도 Apache Kafka, Apache Hadoop 등 시대에 발맞춰 발전 중이다</a>.</li>\n</ul>\n\n<p>또한, Apache는 여러 운영 체제(리눅스, 윈도우, 유닉스 등)에서 폭넓은 호환성과 안정성을 자랑한다.</p>\n\n<p>NGINX는 그렇지 않아서, Windows에서 성능이 매우 낮게 나온다.</p>\n<ul>\n  <li>NGINX는 원래 <strong>리눅스</strong> 환경에서 설계되었기 때문에, 리눅스 OS에서 최고의 성능이 나오며,</li>\n  <li>윈도우에서도 동작은 하지만,<br />\n윈도우의 <strong>비동기 I/O</strong> 시스템에 최적화되지 않았기 때문에 <strong>성능이 상대적으로 낮다</strong>.</li>\n</ul>\n\n<p>현재 서비스에서 큰 성능 문제 없이 잘 돌아가고 있고, 모듈을 계속해서 추가/제거할 일이 많다면 굳이 NGINX로 옮길 이유는 없는 것이다.</p>\n<ul>\n  <li>오해하면 안되는 것이 NGINX는 설정 변경과 이에 따른 Worker Process의 로직 변경이 무중단으로 이루어진다는 것이며,<br />\nNGINX는 모듈 자체를 동적으로 로드할 수 없으므로, 새 모듈을 추가하려면 재컴파일이 필요하다.</li>\n  <li>Apache는 설정 변경 없이 실행 중 동적 모듈 로드가 가능하므로, 특정 기능을 빠르게 추가하거나 제거할 때 더 유연하다.</li>\n</ul>\n\n<p><strong>둘은 서로 대립관계가 아니며, 목적이 다르게 탄생한 것이다.</strong></p>\n\n<p><br /></p>\n\n<h2 id=\"2-5-그렇다면-현재-nginx를-어떻게-이용해야-하는가\">2-5. 그렇다면 현재 NGINX를 어떻게 이용해야 하는가?</h2>\n\n<p>앞서 우리는 NGINX의 WS로써, 로드밸런싱으로서의 역할을 보았다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/04bf32c2-7d72-4229-a31e-2b3e639e6b2d\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>비동기 이벤트 기반 구조로 동시 커넥션 처리가 효율적이며, Reverse Proxy로써 서버 부하를 줄일 수 있다.</p>\n\n<p>이 자체로 웹 서버 가속(성능 개선) 역할을 한다.</p>\n\n<p>추가적으로 NGINX를 사용하며 고려해야할 관점이다.</p>\n\n<p><strong>1) SSL 터미네이션 역할을 한다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/baaa7488-05be-473f-8d84-27912891b0f3\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX가 앞단에서 SSL을 처리하여, 클라이언트와는 HTTPS로 통신하고, 뒷단 서버와는 HTTP로 통신하는 방식이다.</p>\n<ul>\n  <li>어차피, NGINX와 SERVER가 같은 네트워크 안에 있는 경우가 많기 떄문에,<br />\n이렇게 통신을 해도 보안 위험이 비교적 적다.</li>\n</ul>\n\n<p>이 방식은 뒷단 서버가 <span class=\"post-highlight\">복호화 과정에서 발생하는 부하를 줄이는 장점</span>이 있다.</p>\n\n<p><strong>2) 캐싱 역할을 한다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/6c43e842-cbfa-44fd-99e0-75b079dc4a20\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX는 &lt;span class=”post-highlight”HTTP 콘텐츠 캐싱&lt;/span&gt;을 지원하며,<br />\n이를 통해 서버 부하를 줄이고 클라이언트 요청에 빠르게 응답할 수 있습니다.</p>\n<ul>\n  <li>한 번 서버로부터 받은 응답을 스스로 보관하고 클라이언트에게 전달하므로 효율적이다.</li>\n</ul>\n\n<p>이러한 경우 1번과 달리 NGINX를 클라이언트와 가까운 곳(예: CDN이나 엣지 서버)에 배치하여<br />\n캐싱 효과를 극대화할 수 있다.</p>\n\n<p><strong>3)NGINX와 컨테이너화</strong></p>\n\n<p>현재 클라우드 네이티브와 컨테이너화가 대세인 환경에서, NGINX는 더욱 중요한 역할을 수행하고 있다.</p>\n\n<p>특히 Kubernetes의 Ingress Controller로서, 또는 마이크로서비스 아키텍처에서의 API Gateway로서 그 가치가 두드러진다.</p>\n\n<p>Kubernetes에서 Ingress Controller로 사용될 때, API Gateway로서의 설정 등등</p>\n<ul>\n  <li>이러한 설정들을 통해 NGINX는 현대적인 마이크로서비스 환경에서 트래픽 라우팅, 로드밸런싱, SSL 종료, API 게이트웨이 등 다양한 역할을 효율적으로 수행할 수 있다.</li>\n  <li>특히 컨테이너 환경에서는 가볍고 빠른 NGINX의 특성이 더욱 큰 장점으로 작용한다.</li>\n</ul>\n\n<p>이 외에도 HSTS, CORS 처리, TCP/UDP 커넥션 분산 부하, HTTP/2 지원 (최근에는 /3도 지원) 등 서버를 보완하는 역할을 할 수 있다.</p>\n\n<p>어떠한 기능이 있는지를 알아보고 상황에 따라 알맞는 기능을 적용하는 자세가 필요하다.</p>\n\n<hr />\n<p>참고: <a href=\"https://www.youtube.com/watch?v=mcnJcjbfjrs\" target=\"_blank\">우아한테크 [10분 테코톡] 알리의 Web Server vs WAS</a></p>\n\n<p><a href=\"https://www.youtube.com/watch?v=6FAwAXXj5N0\" target=\"_blank\">우아한테크 [10분 테코톡] 피케이의 Nginx</a></p>\n",
                        "tags": ["WebServer","Apache","NGINX","Architecture","DevOps","Network","Performance","LoadBalancing","ReverseProxy"]
                    }
                
            ],
        
            "Apache": [
                
                    {
                        "title": "웹 서버(WS)의 진화",
                        "url": "/2025/01/27/ws-and-was.html",
                        "subtitle": "Apache vs NGINX",
                        "excerpt": "1. 웹서버(WS)에 대하여\n",
                        "author": "Jinho",
                        "date": "January 27, 2025",
                        "background": "/img/posts/apach_vs_nginx.jpeg",
                        "content": "<h1 id=\"1-웹서버ws에-대하여\">1. 웹서버(WS)에 대하여</h1>\n\n<h2 id=\"1-1-웹서버ws-란\">1-1. 웹서버(WS) 란?</h2>\n\n<p>NGINX, Apache 두 소프트웨어 모두 “<u>웹서버 소프트웨어</u>”이다.</p>\n\n<p>그렇다면 WS(웹서버)란 무엇일까?</p>\n\n<p>클라이언트의 HTTP 요청을 받아 <span class=\"post-highlight\">정적인 컨텐츠를 제공하는 서버 혹은 프로그램이다.</span></p>\n\n<p>이후에 다시 말하겠지만, WS는 정적인 컨텐츠를 서비스하는 데에 <strong>특화된</strong> 서버 소프트웨어이다.</p>\n<ul>\n  <li>동적인 콘텐츠를 처리 못한다는 것은 아니다.\n    <ul>\n      <li>참고로, Apache의 경우 자체적으로 동적인 컨텐츠 또한 처리가 가능하다.</li>\n    </ul>\n  </li>\n  <li>NGINX의 경우 불가능하다.\n    <ul>\n      <li>하지만, 동적 처리는 보통 WAS(Web Application Server)에서 주로 수행하므로, Web Server는 프록시 역할만 하면 충분하다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>여기서 주요한 점은 <span class=\"post-highlight\">“정적인 컨텐츠”</span>이다.</p>\n\n<p>html, JS 같은 정적인 컨텐츠들 정도는 웹서버를 구축한다면 웹서버 선에서 요청을 정리할 수 있다.</p>\n\n<h3 id=\"과거-2-tier-architecture\">과거 (2-tier Architecture)</h3>\n\n<p><img src=\"https://github.com/user-attachments/assets/a2d9a118-4b95-46ec-b303-a4b9c084f5eb\" alt=\"Image\" width=\"80%\" height=\"80%\" class=\"center\" /></p>\n\n<p>우선 과거의 버그가 많았던 초기의 웹서버(WS) 프로그램이 수정되고 개발된게 <strong>Apache</strong>이다.</p>\n\n<p>과거에 html, js, css 등과 같은 정적인 콘텐츠만을 주고 받는 구조에서는<br />\n<span class=\"post-highlight\">클라이언트 → WS [Apache] (정적 및 동적 요청 모두 처리) → DB</span> 만으로도 충분했다.</p>\n<ul>\n  <li>사실은 Apache의 경우, 정적/동적 모두 커버가 가능하기 때문에 기능적으로는 문제가 없었다.</li>\n  <li>하지만 다음과 같은 단점이 제기되었다.\n    <ul>\n      <li>동적 요청 처리가 필요할 경우, Apache가 너무 많은 부담을 가진다.</li>\n      <li>보안과 성능 측면에서 아쉬움이 있다.</li>\n      <li><em>그리고 이후에 다시 소개하겠다…</em></li>\n    </ul>\n  </li>\n  <li>그래서 앞단에 <u>정적 처리를 전문적으로 해주는 서버</u>가 있었으면 좋겠다는 생각을 하게 된다.</li>\n</ul>\n\n<p><br /></p>\n\n<h3 id=\"현재-3-tier-architecture\">현재 (3-tier Architecture)</h3>\n\n<p>정적/동적 컨텐츠에 대한 책임을 분리하고,<br />\n효율성과 확장성에 용이하기 위해 아키텍처가 발전했다.</p>\n\n<p><span class=\"post-highlight\">클라이언트 → [WS (정적 요청 처리) → WAS (동적 요청 처리)] → DB  </span><br />\n<em>(초기 발전 과정에서는 Apache가 WAS 역할로 동적 요청을 처리하고, 앞단에 정적 요청 처리를 NGINX가 붙는 방식으로 사용되었다.)</em></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/76082af9-7162-4a41-b5d4-be1d96020bfc\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>WAS는 동적 처리에 리소스 집중할 수 있게 되었고, 트래픽 증가에 유연한 대응이 가능하게 되었다.</p>\n<ul>\n  <li>소프트웨어 측면 말고, 개발자의 측면에서 보아도 효율적이다.\n    <ul>\n      <li>WS는 정적 파일, 보안, 로드밸런싱에만 집중하면 되고, WAS에서는 비즈니스 로직에만 집중하면 된다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><br /></p>\n\n<h1 id=\"2-apache와-nginx\">2. Apache와 NGINX</h1>\n\n<h2 id=\"2-1-apache-처리-방식-커넥션-기반\"><strong>2-1. Apache 처리 방식 (커넥션 기반)</strong></h2>\n\n<p>아파치는 <strong>Multi-Process Module</strong> 방식이다.<br />\n클라이언트가 요청 하나를 보내면, 하나의 process를 생성해서 연결한다.<br />\n요청당 프로세스/스레드 생성한다는 뜻이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/84ca44e3-a224-4f75-864d-f8f121f642da\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>이런 구조는 확장성 면에서 장점이 크다.<br />\n→ <span class=\"post-highlight\">이러한 측면에서 개발자들은 다양한 모듈을 만들어서 서버에 동적으로 빠르게 추가할 수 있는 장점이 있었다.</span></p>\n\n<p>하지만 다음과 같은 문제가 제기되었다.</p>\n\n<p>(🤔문제) <strong>프로세스 생성이 가벼운 작업이 아니기에, 매번 생성하기에는 너무 속도가 느려진다.</strong></p>\n\n<p>(✨발전 1) 요청 이전에 몇 개의 프로세스를 미리 만들어주는 prefork() 방식을 사용했다.</p>\n\n<p>(✨발전 2) 어찌됐든 매번 커넥션을 만드는 것은 비효율적이라고 판단했고, 이미 연결된 커넥션이 있다면 재활용하자는 생각을 한다.</p>\n<ul>\n  <li>http 헤더 종류 중에 keep-alive가 있다.</li>\n  <li><strong>→ Keep-Alive 옵션을 통해 일정 기간 동안 클라이언트와 Connection을 유지하는 방식</strong></li>\n</ul>\n\n<p><br /></p>\n\n<p>그러나 또 다른 문제가 제기되었다.</p>\n\n<p>(🤔또 다른 문제) <strong>클라이언트 수가 늘어나면서 결국 동시에 연결되어 있는 커넥션의 수도 매우 늘어나게 되었다.</strong></p>\n<ul>\n  <li>이렇게 동시 연결된 커넥션 수가 10,000개의 동시 연결을 넘어서는 순간, 서버는 더이상 커넥션을 형성하지 못하게 되는 현상이 발생했다. (<em>C10K 문제…</em>)</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/25bda5d5-aea5-4238-bc7b-3a499875a5e6\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>그런데 이 C10K 문제에서 하드웨어적으로 문제되는 것은 없었다.</li>\n  <li>이 당시 웹 페이지 용량 자체가 적었기 때문에 컴퓨터의 성능은 충분했지만,<br />\n비효율적인 서버의 구조 때문에 <strong>메모리 부족</strong> 현상이 일어난 것이다.</li>\n  <li>많은 커넥션에서 요청이 들어오기 시작하면, CPU 코어는 계속해서 프로세스를 바꿔가며 일을 해야 했다.</li>\n  <li>결론적으로, <strong>수 많은 동시 커넥션을 감당하기엔 아파치 서버의 구조가 적합하지 않았다.</strong></li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"2-2-nginx의-등장-이벤트-기반\"><strong>2-2. “NGINX”의 등장 (이벤트 기반)</strong></h2>\n\n<p>사실 NGINX는 Apache 를 대체하려고 나온 소프트웨어가 아니다.<br />\nNGINX는 Apache 앞 단에 붙여서 <span class=\"post-highlight\">보완하는 방식</span>으로 사용되었다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/c78538ef-1f3a-4e1a-b014-63afd34ca6c2\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>구조적으로 동시 커넥션을 많이 유지 못하는 아파치 서버의 부하를 nginx가 크게 줄일 수 있었다.</p>\n<ul>\n  <li><em>참고로,<br />\n[동시에 연결 가능한 커넥션 수(한 시점에 감당되는 동시 커넥션 수)] 와 초당 요청 처리 수는 다른 의미이다.</em></li>\n</ul>\n\n<p>이때 NGINX 가 정적인 페이지 처리를 모두 하고,<br />\nApache는 동적 파일 처리만 담당하는 (현대의 WAS 느낌) 구조로 바뀌게 되었다.</p>\n\n<p>그렇다면 어떻게 NGINX는 많은 동시 커넥션을 견뎌 낼 수 있을까?</p>\n\n<p><br /></p>\n\n<h3 id=\"nginx-처리-방식에-대해\">NGINX 처리 방식에 대해</h3>\n\n<p>Nginx는 Master-Worker 구조의 Process 방식을 채용했다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/a1d0bf67-8aca-4d49-8d74-690aaba06c50\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>Master Process는 설정파일에 맞게 실제 일하는 Worker Process를 만들어낸다.</p>\n\n<p>그리고 Worker가 만들어질 때 각자 지정된 Listen 소켓을 배정받는다.<br />\n(수신기를 받는다.)</p>\n\n<p>그리고 그 소켓에 새로운 클라이언트로부터 Request가 들어오면, 커넥션을 형성하고 요청을 처리한다.</p>\n<ul>\n  <li>마찬가지로 이 커넥션은 정해진 Keep-alive의 Timeout까지 연결을 유지하게 된다.</li>\n</ul>\n\n<p>하지만, Apache와의 차이는<br />\n<span class=\"post-highlight\">“그 커넥션이 형성되었다고 해서, Worker Process 1개가 그 커넥션 1개만을 담당하지는 않는다.”</span></p>\n<ul>\n  <li>형성된 커넥션에 아무런 요청이 없으면 새로운 커넥션을 형성하거나,<br />\n이미 만들어진 다른 커넥션으로부터 들어온 요청을 처리한다. (여러 커넥션을 쥐고 있는다.)</li>\n  <li>이런 <span class=\"post-highlight\">[커넥션 형성 / 커넥션 제거 / 새로운 요청 처리] 등을 모두 이벤트</span>라고 부른다.</li>\n</ul>\n\n<p>NGINX의 OS커널은 이러한 이벤트를 큐형식으로 줄세우고, Worker에게 전달한다.<br />\n<em>(멀티플레싱, epoll 에 대해 이해하면 어떻게 커널이 이벤트를 제공하는지 알 수 있다.)</em></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/26d73207-0e57-4358-894d-2f4450efcaf8\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">→ 는 커넥션 연결, O는 Request이며, 모두 “이벤트”이다.</em></p>\n\n<p>그리고 이 이벤트들은 큐에 담긴 채 비동기 방식으로 대기하고 있다.</p>\n\n<p>그리고 Worker Process는 하나의 스레드로 이벤트를 꺼내서 처리해 나간다.<br />\n이러면 Worker는 쉬지 않고 일을 계속 할 수 있다.</p>\n\n<p><span class=\"post-highlight\">요청이 없다면 방치되던 Apache의 구조보다 서버 자원을 훨씬 효율적으로 사용하는 셈</span>이다.</p>\n\n<p>(🤔문제) <strong>그런데 순서대로 꺼내서 쓰는 Queue에서 앞단에 들어오연 요청하나가 매우 시간이 오래걸리는 Disk I/O 작업이라면 어떨까..?</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d1abad7d-7b40-42be-9ff9-a293fe7a132b\" alt=\"Image\" width=\"60%\" height=\"100%\" class=\"center\" /></p>\n\n<p>매우 긴 IO 작업 중 큐에 대기하는 모든 이벤트들은 블로킹 될 것이다.</p>\n\n<p>(✨해결책) 오랜 기간 작업을 요하는 요청들을 위한 쓰레드 풀을 미리 만들어놓고,<br />\nWorker Process가 지금 처리하는 요청이 오래 걸린다고 판단되면,<br />\n해당 스레드 풀에 그 작업을 위임하고, 큐의 다른 이벤트를 처리하러 간다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/766c1772-fed9-4a42-b6ce-7fbbe7317f55\" alt=\"Image\" width=\"75%\" height=\"100%\" class=\"center\" /></p>\n\n<p>이러한 Worker Process 는 보통 Cpu의 코어 개수만큼 생성하고,<br />\n이러한 구조는 코어가 부담하는 Context Switch의 횟수를 대폭 줄일 수 있다.</p>\n\n<p>Apache와 비교하자면,</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/3e7909b6-7fd3-48df-b669-6b55a303b835\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>Apache\n    <ul>\n      <li>CPU가 여러 프로세스 간 스위칭</li>\n      <li>요청당 프로세스/스레드 필요</li>\n    </ul>\n  </li>\n  <li>Nginx\n    <ul>\n      <li>하나의 Worker Process가 이벤트 큐로 관리</li>\n      <li>단일 스레드로 여러 이벤트 처리</li>\n      <li>CPU 코어당 하나의 Worker 고정</li>\n      <li>이러한 <strong>Event-Driven Model이 Apache 구조와의 가장 큰 차이</strong>이다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"2-3-apache와-nginx\">2-3. Apache와 NGINX</h2>\n\n<p>항상 어떤 기술을 사용할 때에는 “최신 기술이여서”, “많이들 써서”가 이유가 될 수는 없다.</p>\n\n<p>어떤 기술, 어떤 아키텍처건 Trade-Off는 존재한다.</p>\n\n<p>과연 NGINX는 장점만 있을까?</p>\n\n<p>개발자가 <strong>기능(모듈) 추가를 시도했다가 돌아가고 있는 Worker Process를 종료해야 하는 상황</strong>이 생길 수 있다.</p>\n\n<p>그러면 <span class=\"post-highlight\">해당 Worker Process는 관리하고 있던 커넥션과 관려된 요청을 더이상 처리할 수 없다</span>는 문제가 발생한다.</p>\n<ul>\n  <li>그래서 NGINX는 개발자가 직접 모듈을 만들기에 좀 까다롭다.</li>\n</ul>\n\n<p>하지만, 단점보다 장점이 명확했다.</p>\n\n<p>수많은 동시 커넥션을 빠르게 처리하는 데에 있어 프로세스를 적게 만들다보니<br />\n(One Worker Process per CPU core)<br />\n⇒ 동시 커넥션 양 최소 10배 증가<br />\n⇒ 동일한 커넥션 수일 때 Apache에 비해 속도 2배 향상</p>\n\n<ul>\n  <li><strong>NGINX의 명확한 장점</strong>\n    <ol>\n      <li>One Worker Process per CPU core</li>\n      <li>Event-driven, asynchronous processing</li>\n      <li>Event Queue management</li>\n      <li>Thread Pool for long-running tasks</li>\n    </ol>\n  </li>\n</ul>\n\n<p>그리고 적은 프로세스는 관리가 쉽고, 새 Worker 생성 시 리소스 부담이 적다.</p>\n\n<p>이러한 구조는 “<span class=\"post-highlight\">NGINX가 설정을 동적으로 바꾸는 것</span>”을 가능하게 했다.</p>\n<ul>\n  <li>개발자가 설정 파일을 Runtime에 변경하고, NGINX에 적용하면,<br />\n이후부터는 Mater Process는 그 설정에 맞는 Worker Process를 찍어내게 된다.</li>\n  <li>그리고 기존 Worker Process에는 더이상 커넥션을 형성하지 못하게 막고,<br />\nQueue에 있는 이벤트들을 마저 처리한 뒤 기존 Worker들은 종료된다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/4f16c765-c2d8-44c2-850b-7c88a560dbb6\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>그런데 이러한 <strong>동적 설정 변경은 언제 사용</strong>할까?</p>\n<ul>\n  <li>대표적인 예로, NGINX가 여러 동시 커넥션을 관리하는 중에 뒷단에 새로운 서버를 추가하려는 상황이다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/b4f4191d-f32d-482f-a73c-6c14492350b2\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX는 이제부터 로드밸런싱 역할도 담당해야 한다.</p>\n\n<p>역할의 추가/변경이 의미하는 것은 무엇일까?</p>\n\n<ul>\n  <li>= Master Process가 찍어내야 하는 Worker Process의 역할의 추가/변경<br />\n= 기존 Connection 및 기존 Request들의 손실 없이 역할의 변경이 필요하다.</li>\n  <li>NGINX는 동시 커넥션을 유지한 채, 기존의 요청을 마저 처리하며, 뒷단의 서버를 추가할 수 있다.</li>\n  <li>이벤트 기반 구조이기 때문에 이러한 설정 변경을 초당 수십번 해도 무리없이 커넥션을 관리하고 요청을 서버에 전달할 수 있다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/842b0dc3-119e-4168-93f9-0e6b6f14b960\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : NetCraft Web Server Survey</em></p>\n\n<p>그런데 위 자료를 보면 의문이 든다.<br />\nNGINX가 탄생한 지 2004년부터 2007년 까지도 압도적으로 Apache가 1위를 차지하고 있다.</p>\n\n<p>이때까지만 해도 NIGNX는 소수의 문제 상황에 대한 해결책을 제시한 것 뿐이지,<br />\n대다수의 서비스를 가동하는 데에는 Apache로도 큰 문제가 없었다.</p>\n\n<h3 id=\"스마트폰의-탄생\">스마트폰의 탄생</h3>\n\n<p><img src=\"https://github.com/user-attachments/assets/2a75d845-635a-4d46-a0d2-68629d3fdd1f\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : NetCraft Web Server Survey</em></p>\n\n<p>2008년부터 급격하게 상황이 역전된다. 바로 <strong>스마트폰의 등장</strong> 때문이다.</p>\n\n<ul>\n  <li>단순히 ‘스마트폰의 등장 = 인터넷 사용자의 증가’의 이유가 아니다.</li>\n  <li>“<span class=\"post-highlight\">동시 커넥션을 훨씬 더 많이 생성한 계기</span>”로써 문제가 발생한다.</li>\n  <li>PC의 경우 클라이언트가 일정 시간 사용하고 전원을 끄는 방식으로 사용되었지만,<br />\n스마트폰은 실시간으로 정보를 받고 싶어하는 사용자의 니즈에 맞게 알림 등<br />\n<strong>동시 커넥션을 계속해서 유지</strong>하는 방식으로써 유용하게 사용되었다.</li>\n</ul>\n\n<p>이러다보니 “동시 커넥션 문제”가 현실로 다가온 것이다.</p>\n<ul>\n  <li>대규모 사이트들이 좋아할 만한 솔루션 이었고, NGINX는 급성장하게 된다.<br />\n(<em>현재 우리가 쿠버네티스고, 뭐고 배우는 이유도 이러한 문제의 솔루션으로써 대두된다는 것을 알고 넘어가자</em>)</li>\n</ul>\n\n<p>그렇다면 Apache는 가만히 있었을까?</p>\n\n<p>Apache도 MPM이라는 모듈을 추가해서 성능을 개선하기 시작한다.</p>\n\n<ul>\n  <li>Multi-Processing Module</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/acf7ede3-b612-417c-b4a5-82c352ba4c37\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>Apache 서버를 어떤 방식으로 운영할 지 선택할 수 있는 모듈이다.\n    <ul>\n      <li>안정성이나 소규모 프로젝트에서는 기존의 prefork 방식을</li>\n      <li>성능 향상이나 대규모 프로젝트에서는 worker라는 스레드를 만들어 worker가 요청을 처리하도록 했다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>그렇다면 왜 아직도 동시 커넥션 지표에서 NGINX가 Apache를 압도적으로 앞설까?</p>\n\n<div style=\"display: flex; justify-content: space-between; gap: 20px;\">\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/1b280974-4d15-4e5d-ac6c-c21e2093f673\" alt=\"Memory Usage\" style=\"width: 100%;\" />\n    </div>\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/6a787d51-fb2d-4c1f-a973-3f380a838d29\" alt=\"Requests Per Second\" style=\"width: 100%;\" />\n    </div>\n</div>\n<p style=\"text-align: center; color: #666;\">출처: dreamhost.com</p>\n\n<p>왼쪽 동시 커넥션 수당 메모리 사용률 지표를 보면,</p>\n<ul>\n  <li>NGINX는 동시 커넥션이 많아져도 메모리 사용률이 낮고 일정한 반면,<br />\nApache는 굉장히 많은 메모리 사용률을 요구한다.</li>\n</ul>\n\n<p>오른쪽 동시 커넥션 수가 많아졌을 때 처리하는 초당 요청 수 지표를 보아도,<br />\nNGINX가 Apache에 비해 압도적으로 많다.</p>\n<ul>\n  <li>NGINX가 커넥션 관리를 얼마나 잘하는 지 볼 수 있다.</li>\n</ul>\n\n<p>사실 지금까지 <strong>동시 커넥션</strong>이라는 포인트에만 집중해서 NGINX의 장점과 현재 많이 쓰이는 이유를 알아보았다.</p>\n\n<p><strong>그렇다면 Apache의 장점은 무엇이 있을까?</strong></p>\n\n<p><br /></p>\n\n<h2 id=\"2-4-apache가-아직-쓰이는-이유와-nginx의-단점\">2-4. Apache가 아직 쓰이는 이유와 NGINX의 단점</h2>\n\n<p>근본자체가 “NCSA HTTPd”라는 소프트웨어의 버그를 수정해오며 커온 Apache이기에,\n<span class=\"post-highlight\">호환성과 확장성의 측면</span>에서는 장점이 있다.</p>\n\n<p>아직도 오픈소스로써 활발한 수정과 개선이 이루어지고 있다. [<span class=\"post-highlight\">풍부한 모듈 생태계</span>]</p>\n<ul>\n  <li><a href=\"https://projects.apache.org/projects.html\">Apache는 현재에도 Apache Kafka, Apache Hadoop 등 시대에 발맞춰 발전 중이다</a>.</li>\n</ul>\n\n<p>또한, Apache는 여러 운영 체제(리눅스, 윈도우, 유닉스 등)에서 폭넓은 호환성과 안정성을 자랑한다.</p>\n\n<p>NGINX는 그렇지 않아서, Windows에서 성능이 매우 낮게 나온다.</p>\n<ul>\n  <li>NGINX는 원래 <strong>리눅스</strong> 환경에서 설계되었기 때문에, 리눅스 OS에서 최고의 성능이 나오며,</li>\n  <li>윈도우에서도 동작은 하지만,<br />\n윈도우의 <strong>비동기 I/O</strong> 시스템에 최적화되지 않았기 때문에 <strong>성능이 상대적으로 낮다</strong>.</li>\n</ul>\n\n<p>현재 서비스에서 큰 성능 문제 없이 잘 돌아가고 있고, 모듈을 계속해서 추가/제거할 일이 많다면 굳이 NGINX로 옮길 이유는 없는 것이다.</p>\n<ul>\n  <li>오해하면 안되는 것이 NGINX는 설정 변경과 이에 따른 Worker Process의 로직 변경이 무중단으로 이루어진다는 것이며,<br />\nNGINX는 모듈 자체를 동적으로 로드할 수 없으므로, 새 모듈을 추가하려면 재컴파일이 필요하다.</li>\n  <li>Apache는 설정 변경 없이 실행 중 동적 모듈 로드가 가능하므로, 특정 기능을 빠르게 추가하거나 제거할 때 더 유연하다.</li>\n</ul>\n\n<p><strong>둘은 서로 대립관계가 아니며, 목적이 다르게 탄생한 것이다.</strong></p>\n\n<p><br /></p>\n\n<h2 id=\"2-5-그렇다면-현재-nginx를-어떻게-이용해야-하는가\">2-5. 그렇다면 현재 NGINX를 어떻게 이용해야 하는가?</h2>\n\n<p>앞서 우리는 NGINX의 WS로써, 로드밸런싱으로서의 역할을 보았다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/04bf32c2-7d72-4229-a31e-2b3e639e6b2d\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>비동기 이벤트 기반 구조로 동시 커넥션 처리가 효율적이며, Reverse Proxy로써 서버 부하를 줄일 수 있다.</p>\n\n<p>이 자체로 웹 서버 가속(성능 개선) 역할을 한다.</p>\n\n<p>추가적으로 NGINX를 사용하며 고려해야할 관점이다.</p>\n\n<p><strong>1) SSL 터미네이션 역할을 한다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/baaa7488-05be-473f-8d84-27912891b0f3\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX가 앞단에서 SSL을 처리하여, 클라이언트와는 HTTPS로 통신하고, 뒷단 서버와는 HTTP로 통신하는 방식이다.</p>\n<ul>\n  <li>어차피, NGINX와 SERVER가 같은 네트워크 안에 있는 경우가 많기 떄문에,<br />\n이렇게 통신을 해도 보안 위험이 비교적 적다.</li>\n</ul>\n\n<p>이 방식은 뒷단 서버가 <span class=\"post-highlight\">복호화 과정에서 발생하는 부하를 줄이는 장점</span>이 있다.</p>\n\n<p><strong>2) 캐싱 역할을 한다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/6c43e842-cbfa-44fd-99e0-75b079dc4a20\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX는 &lt;span class=”post-highlight”HTTP 콘텐츠 캐싱&lt;/span&gt;을 지원하며,<br />\n이를 통해 서버 부하를 줄이고 클라이언트 요청에 빠르게 응답할 수 있습니다.</p>\n<ul>\n  <li>한 번 서버로부터 받은 응답을 스스로 보관하고 클라이언트에게 전달하므로 효율적이다.</li>\n</ul>\n\n<p>이러한 경우 1번과 달리 NGINX를 클라이언트와 가까운 곳(예: CDN이나 엣지 서버)에 배치하여<br />\n캐싱 효과를 극대화할 수 있다.</p>\n\n<p><strong>3)NGINX와 컨테이너화</strong></p>\n\n<p>현재 클라우드 네이티브와 컨테이너화가 대세인 환경에서, NGINX는 더욱 중요한 역할을 수행하고 있다.</p>\n\n<p>특히 Kubernetes의 Ingress Controller로서, 또는 마이크로서비스 아키텍처에서의 API Gateway로서 그 가치가 두드러진다.</p>\n\n<p>Kubernetes에서 Ingress Controller로 사용될 때, API Gateway로서의 설정 등등</p>\n<ul>\n  <li>이러한 설정들을 통해 NGINX는 현대적인 마이크로서비스 환경에서 트래픽 라우팅, 로드밸런싱, SSL 종료, API 게이트웨이 등 다양한 역할을 효율적으로 수행할 수 있다.</li>\n  <li>특히 컨테이너 환경에서는 가볍고 빠른 NGINX의 특성이 더욱 큰 장점으로 작용한다.</li>\n</ul>\n\n<p>이 외에도 HSTS, CORS 처리, TCP/UDP 커넥션 분산 부하, HTTP/2 지원 (최근에는 /3도 지원) 등 서버를 보완하는 역할을 할 수 있다.</p>\n\n<p>어떠한 기능이 있는지를 알아보고 상황에 따라 알맞는 기능을 적용하는 자세가 필요하다.</p>\n\n<hr />\n<p>참고: <a href=\"https://www.youtube.com/watch?v=mcnJcjbfjrs\" target=\"_blank\">우아한테크 [10분 테코톡] 알리의 Web Server vs WAS</a></p>\n\n<p><a href=\"https://www.youtube.com/watch?v=6FAwAXXj5N0\" target=\"_blank\">우아한테크 [10분 테코톡] 피케이의 Nginx</a></p>\n",
                        "tags": ["WebServer","Apache","NGINX","Architecture","DevOps","Network","Performance","LoadBalancing","ReverseProxy"]
                    }
                
            ],
        
            "NGINX": [
                
                    {
                        "title": "웹 서버(WS)의 진화",
                        "url": "/2025/01/27/ws-and-was.html",
                        "subtitle": "Apache vs NGINX",
                        "excerpt": "1. 웹서버(WS)에 대하여\n",
                        "author": "Jinho",
                        "date": "January 27, 2025",
                        "background": "/img/posts/apach_vs_nginx.jpeg",
                        "content": "<h1 id=\"1-웹서버ws에-대하여\">1. 웹서버(WS)에 대하여</h1>\n\n<h2 id=\"1-1-웹서버ws-란\">1-1. 웹서버(WS) 란?</h2>\n\n<p>NGINX, Apache 두 소프트웨어 모두 “<u>웹서버 소프트웨어</u>”이다.</p>\n\n<p>그렇다면 WS(웹서버)란 무엇일까?</p>\n\n<p>클라이언트의 HTTP 요청을 받아 <span class=\"post-highlight\">정적인 컨텐츠를 제공하는 서버 혹은 프로그램이다.</span></p>\n\n<p>이후에 다시 말하겠지만, WS는 정적인 컨텐츠를 서비스하는 데에 <strong>특화된</strong> 서버 소프트웨어이다.</p>\n<ul>\n  <li>동적인 콘텐츠를 처리 못한다는 것은 아니다.\n    <ul>\n      <li>참고로, Apache의 경우 자체적으로 동적인 컨텐츠 또한 처리가 가능하다.</li>\n    </ul>\n  </li>\n  <li>NGINX의 경우 불가능하다.\n    <ul>\n      <li>하지만, 동적 처리는 보통 WAS(Web Application Server)에서 주로 수행하므로, Web Server는 프록시 역할만 하면 충분하다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>여기서 주요한 점은 <span class=\"post-highlight\">“정적인 컨텐츠”</span>이다.</p>\n\n<p>html, JS 같은 정적인 컨텐츠들 정도는 웹서버를 구축한다면 웹서버 선에서 요청을 정리할 수 있다.</p>\n\n<h3 id=\"과거-2-tier-architecture\">과거 (2-tier Architecture)</h3>\n\n<p><img src=\"https://github.com/user-attachments/assets/a2d9a118-4b95-46ec-b303-a4b9c084f5eb\" alt=\"Image\" width=\"80%\" height=\"80%\" class=\"center\" /></p>\n\n<p>우선 과거의 버그가 많았던 초기의 웹서버(WS) 프로그램이 수정되고 개발된게 <strong>Apache</strong>이다.</p>\n\n<p>과거에 html, js, css 등과 같은 정적인 콘텐츠만을 주고 받는 구조에서는<br />\n<span class=\"post-highlight\">클라이언트 → WS [Apache] (정적 및 동적 요청 모두 처리) → DB</span> 만으로도 충분했다.</p>\n<ul>\n  <li>사실은 Apache의 경우, 정적/동적 모두 커버가 가능하기 때문에 기능적으로는 문제가 없었다.</li>\n  <li>하지만 다음과 같은 단점이 제기되었다.\n    <ul>\n      <li>동적 요청 처리가 필요할 경우, Apache가 너무 많은 부담을 가진다.</li>\n      <li>보안과 성능 측면에서 아쉬움이 있다.</li>\n      <li><em>그리고 이후에 다시 소개하겠다…</em></li>\n    </ul>\n  </li>\n  <li>그래서 앞단에 <u>정적 처리를 전문적으로 해주는 서버</u>가 있었으면 좋겠다는 생각을 하게 된다.</li>\n</ul>\n\n<p><br /></p>\n\n<h3 id=\"현재-3-tier-architecture\">현재 (3-tier Architecture)</h3>\n\n<p>정적/동적 컨텐츠에 대한 책임을 분리하고,<br />\n효율성과 확장성에 용이하기 위해 아키텍처가 발전했다.</p>\n\n<p><span class=\"post-highlight\">클라이언트 → [WS (정적 요청 처리) → WAS (동적 요청 처리)] → DB  </span><br />\n<em>(초기 발전 과정에서는 Apache가 WAS 역할로 동적 요청을 처리하고, 앞단에 정적 요청 처리를 NGINX가 붙는 방식으로 사용되었다.)</em></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/76082af9-7162-4a41-b5d4-be1d96020bfc\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>WAS는 동적 처리에 리소스 집중할 수 있게 되었고, 트래픽 증가에 유연한 대응이 가능하게 되었다.</p>\n<ul>\n  <li>소프트웨어 측면 말고, 개발자의 측면에서 보아도 효율적이다.\n    <ul>\n      <li>WS는 정적 파일, 보안, 로드밸런싱에만 집중하면 되고, WAS에서는 비즈니스 로직에만 집중하면 된다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><br /></p>\n\n<h1 id=\"2-apache와-nginx\">2. Apache와 NGINX</h1>\n\n<h2 id=\"2-1-apache-처리-방식-커넥션-기반\"><strong>2-1. Apache 처리 방식 (커넥션 기반)</strong></h2>\n\n<p>아파치는 <strong>Multi-Process Module</strong> 방식이다.<br />\n클라이언트가 요청 하나를 보내면, 하나의 process를 생성해서 연결한다.<br />\n요청당 프로세스/스레드 생성한다는 뜻이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/84ca44e3-a224-4f75-864d-f8f121f642da\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>이런 구조는 확장성 면에서 장점이 크다.<br />\n→ <span class=\"post-highlight\">이러한 측면에서 개발자들은 다양한 모듈을 만들어서 서버에 동적으로 빠르게 추가할 수 있는 장점이 있었다.</span></p>\n\n<p>하지만 다음과 같은 문제가 제기되었다.</p>\n\n<p>(🤔문제) <strong>프로세스 생성이 가벼운 작업이 아니기에, 매번 생성하기에는 너무 속도가 느려진다.</strong></p>\n\n<p>(✨발전 1) 요청 이전에 몇 개의 프로세스를 미리 만들어주는 prefork() 방식을 사용했다.</p>\n\n<p>(✨발전 2) 어찌됐든 매번 커넥션을 만드는 것은 비효율적이라고 판단했고, 이미 연결된 커넥션이 있다면 재활용하자는 생각을 한다.</p>\n<ul>\n  <li>http 헤더 종류 중에 keep-alive가 있다.</li>\n  <li><strong>→ Keep-Alive 옵션을 통해 일정 기간 동안 클라이언트와 Connection을 유지하는 방식</strong></li>\n</ul>\n\n<p><br /></p>\n\n<p>그러나 또 다른 문제가 제기되었다.</p>\n\n<p>(🤔또 다른 문제) <strong>클라이언트 수가 늘어나면서 결국 동시에 연결되어 있는 커넥션의 수도 매우 늘어나게 되었다.</strong></p>\n<ul>\n  <li>이렇게 동시 연결된 커넥션 수가 10,000개의 동시 연결을 넘어서는 순간, 서버는 더이상 커넥션을 형성하지 못하게 되는 현상이 발생했다. (<em>C10K 문제…</em>)</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/25bda5d5-aea5-4238-bc7b-3a499875a5e6\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>그런데 이 C10K 문제에서 하드웨어적으로 문제되는 것은 없었다.</li>\n  <li>이 당시 웹 페이지 용량 자체가 적었기 때문에 컴퓨터의 성능은 충분했지만,<br />\n비효율적인 서버의 구조 때문에 <strong>메모리 부족</strong> 현상이 일어난 것이다.</li>\n  <li>많은 커넥션에서 요청이 들어오기 시작하면, CPU 코어는 계속해서 프로세스를 바꿔가며 일을 해야 했다.</li>\n  <li>결론적으로, <strong>수 많은 동시 커넥션을 감당하기엔 아파치 서버의 구조가 적합하지 않았다.</strong></li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"2-2-nginx의-등장-이벤트-기반\"><strong>2-2. “NGINX”의 등장 (이벤트 기반)</strong></h2>\n\n<p>사실 NGINX는 Apache 를 대체하려고 나온 소프트웨어가 아니다.<br />\nNGINX는 Apache 앞 단에 붙여서 <span class=\"post-highlight\">보완하는 방식</span>으로 사용되었다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/c78538ef-1f3a-4e1a-b014-63afd34ca6c2\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>구조적으로 동시 커넥션을 많이 유지 못하는 아파치 서버의 부하를 nginx가 크게 줄일 수 있었다.</p>\n<ul>\n  <li><em>참고로,<br />\n[동시에 연결 가능한 커넥션 수(한 시점에 감당되는 동시 커넥션 수)] 와 초당 요청 처리 수는 다른 의미이다.</em></li>\n</ul>\n\n<p>이때 NGINX 가 정적인 페이지 처리를 모두 하고,<br />\nApache는 동적 파일 처리만 담당하는 (현대의 WAS 느낌) 구조로 바뀌게 되었다.</p>\n\n<p>그렇다면 어떻게 NGINX는 많은 동시 커넥션을 견뎌 낼 수 있을까?</p>\n\n<p><br /></p>\n\n<h3 id=\"nginx-처리-방식에-대해\">NGINX 처리 방식에 대해</h3>\n\n<p>Nginx는 Master-Worker 구조의 Process 방식을 채용했다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/a1d0bf67-8aca-4d49-8d74-690aaba06c50\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>Master Process는 설정파일에 맞게 실제 일하는 Worker Process를 만들어낸다.</p>\n\n<p>그리고 Worker가 만들어질 때 각자 지정된 Listen 소켓을 배정받는다.<br />\n(수신기를 받는다.)</p>\n\n<p>그리고 그 소켓에 새로운 클라이언트로부터 Request가 들어오면, 커넥션을 형성하고 요청을 처리한다.</p>\n<ul>\n  <li>마찬가지로 이 커넥션은 정해진 Keep-alive의 Timeout까지 연결을 유지하게 된다.</li>\n</ul>\n\n<p>하지만, Apache와의 차이는<br />\n<span class=\"post-highlight\">“그 커넥션이 형성되었다고 해서, Worker Process 1개가 그 커넥션 1개만을 담당하지는 않는다.”</span></p>\n<ul>\n  <li>형성된 커넥션에 아무런 요청이 없으면 새로운 커넥션을 형성하거나,<br />\n이미 만들어진 다른 커넥션으로부터 들어온 요청을 처리한다. (여러 커넥션을 쥐고 있는다.)</li>\n  <li>이런 <span class=\"post-highlight\">[커넥션 형성 / 커넥션 제거 / 새로운 요청 처리] 등을 모두 이벤트</span>라고 부른다.</li>\n</ul>\n\n<p>NGINX의 OS커널은 이러한 이벤트를 큐형식으로 줄세우고, Worker에게 전달한다.<br />\n<em>(멀티플레싱, epoll 에 대해 이해하면 어떻게 커널이 이벤트를 제공하는지 알 수 있다.)</em></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/26d73207-0e57-4358-894d-2f4450efcaf8\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">→ 는 커넥션 연결, O는 Request이며, 모두 “이벤트”이다.</em></p>\n\n<p>그리고 이 이벤트들은 큐에 담긴 채 비동기 방식으로 대기하고 있다.</p>\n\n<p>그리고 Worker Process는 하나의 스레드로 이벤트를 꺼내서 처리해 나간다.<br />\n이러면 Worker는 쉬지 않고 일을 계속 할 수 있다.</p>\n\n<p><span class=\"post-highlight\">요청이 없다면 방치되던 Apache의 구조보다 서버 자원을 훨씬 효율적으로 사용하는 셈</span>이다.</p>\n\n<p>(🤔문제) <strong>그런데 순서대로 꺼내서 쓰는 Queue에서 앞단에 들어오연 요청하나가 매우 시간이 오래걸리는 Disk I/O 작업이라면 어떨까..?</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d1abad7d-7b40-42be-9ff9-a293fe7a132b\" alt=\"Image\" width=\"60%\" height=\"100%\" class=\"center\" /></p>\n\n<p>매우 긴 IO 작업 중 큐에 대기하는 모든 이벤트들은 블로킹 될 것이다.</p>\n\n<p>(✨해결책) 오랜 기간 작업을 요하는 요청들을 위한 쓰레드 풀을 미리 만들어놓고,<br />\nWorker Process가 지금 처리하는 요청이 오래 걸린다고 판단되면,<br />\n해당 스레드 풀에 그 작업을 위임하고, 큐의 다른 이벤트를 처리하러 간다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/766c1772-fed9-4a42-b6ce-7fbbe7317f55\" alt=\"Image\" width=\"75%\" height=\"100%\" class=\"center\" /></p>\n\n<p>이러한 Worker Process 는 보통 Cpu의 코어 개수만큼 생성하고,<br />\n이러한 구조는 코어가 부담하는 Context Switch의 횟수를 대폭 줄일 수 있다.</p>\n\n<p>Apache와 비교하자면,</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/3e7909b6-7fd3-48df-b669-6b55a303b835\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>Apache\n    <ul>\n      <li>CPU가 여러 프로세스 간 스위칭</li>\n      <li>요청당 프로세스/스레드 필요</li>\n    </ul>\n  </li>\n  <li>Nginx\n    <ul>\n      <li>하나의 Worker Process가 이벤트 큐로 관리</li>\n      <li>단일 스레드로 여러 이벤트 처리</li>\n      <li>CPU 코어당 하나의 Worker 고정</li>\n      <li>이러한 <strong>Event-Driven Model이 Apache 구조와의 가장 큰 차이</strong>이다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"2-3-apache와-nginx\">2-3. Apache와 NGINX</h2>\n\n<p>항상 어떤 기술을 사용할 때에는 “최신 기술이여서”, “많이들 써서”가 이유가 될 수는 없다.</p>\n\n<p>어떤 기술, 어떤 아키텍처건 Trade-Off는 존재한다.</p>\n\n<p>과연 NGINX는 장점만 있을까?</p>\n\n<p>개발자가 <strong>기능(모듈) 추가를 시도했다가 돌아가고 있는 Worker Process를 종료해야 하는 상황</strong>이 생길 수 있다.</p>\n\n<p>그러면 <span class=\"post-highlight\">해당 Worker Process는 관리하고 있던 커넥션과 관려된 요청을 더이상 처리할 수 없다</span>는 문제가 발생한다.</p>\n<ul>\n  <li>그래서 NGINX는 개발자가 직접 모듈을 만들기에 좀 까다롭다.</li>\n</ul>\n\n<p>하지만, 단점보다 장점이 명확했다.</p>\n\n<p>수많은 동시 커넥션을 빠르게 처리하는 데에 있어 프로세스를 적게 만들다보니<br />\n(One Worker Process per CPU core)<br />\n⇒ 동시 커넥션 양 최소 10배 증가<br />\n⇒ 동일한 커넥션 수일 때 Apache에 비해 속도 2배 향상</p>\n\n<ul>\n  <li><strong>NGINX의 명확한 장점</strong>\n    <ol>\n      <li>One Worker Process per CPU core</li>\n      <li>Event-driven, asynchronous processing</li>\n      <li>Event Queue management</li>\n      <li>Thread Pool for long-running tasks</li>\n    </ol>\n  </li>\n</ul>\n\n<p>그리고 적은 프로세스는 관리가 쉽고, 새 Worker 생성 시 리소스 부담이 적다.</p>\n\n<p>이러한 구조는 “<span class=\"post-highlight\">NGINX가 설정을 동적으로 바꾸는 것</span>”을 가능하게 했다.</p>\n<ul>\n  <li>개발자가 설정 파일을 Runtime에 변경하고, NGINX에 적용하면,<br />\n이후부터는 Mater Process는 그 설정에 맞는 Worker Process를 찍어내게 된다.</li>\n  <li>그리고 기존 Worker Process에는 더이상 커넥션을 형성하지 못하게 막고,<br />\nQueue에 있는 이벤트들을 마저 처리한 뒤 기존 Worker들은 종료된다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/4f16c765-c2d8-44c2-850b-7c88a560dbb6\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>그런데 이러한 <strong>동적 설정 변경은 언제 사용</strong>할까?</p>\n<ul>\n  <li>대표적인 예로, NGINX가 여러 동시 커넥션을 관리하는 중에 뒷단에 새로운 서버를 추가하려는 상황이다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/b4f4191d-f32d-482f-a73c-6c14492350b2\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX는 이제부터 로드밸런싱 역할도 담당해야 한다.</p>\n\n<p>역할의 추가/변경이 의미하는 것은 무엇일까?</p>\n\n<ul>\n  <li>= Master Process가 찍어내야 하는 Worker Process의 역할의 추가/변경<br />\n= 기존 Connection 및 기존 Request들의 손실 없이 역할의 변경이 필요하다.</li>\n  <li>NGINX는 동시 커넥션을 유지한 채, 기존의 요청을 마저 처리하며, 뒷단의 서버를 추가할 수 있다.</li>\n  <li>이벤트 기반 구조이기 때문에 이러한 설정 변경을 초당 수십번 해도 무리없이 커넥션을 관리하고 요청을 서버에 전달할 수 있다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/842b0dc3-119e-4168-93f9-0e6b6f14b960\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : NetCraft Web Server Survey</em></p>\n\n<p>그런데 위 자료를 보면 의문이 든다.<br />\nNGINX가 탄생한 지 2004년부터 2007년 까지도 압도적으로 Apache가 1위를 차지하고 있다.</p>\n\n<p>이때까지만 해도 NIGNX는 소수의 문제 상황에 대한 해결책을 제시한 것 뿐이지,<br />\n대다수의 서비스를 가동하는 데에는 Apache로도 큰 문제가 없었다.</p>\n\n<h3 id=\"스마트폰의-탄생\">스마트폰의 탄생</h3>\n\n<p><img src=\"https://github.com/user-attachments/assets/2a75d845-635a-4d46-a0d2-68629d3fdd1f\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : NetCraft Web Server Survey</em></p>\n\n<p>2008년부터 급격하게 상황이 역전된다. 바로 <strong>스마트폰의 등장</strong> 때문이다.</p>\n\n<ul>\n  <li>단순히 ‘스마트폰의 등장 = 인터넷 사용자의 증가’의 이유가 아니다.</li>\n  <li>“<span class=\"post-highlight\">동시 커넥션을 훨씬 더 많이 생성한 계기</span>”로써 문제가 발생한다.</li>\n  <li>PC의 경우 클라이언트가 일정 시간 사용하고 전원을 끄는 방식으로 사용되었지만,<br />\n스마트폰은 실시간으로 정보를 받고 싶어하는 사용자의 니즈에 맞게 알림 등<br />\n<strong>동시 커넥션을 계속해서 유지</strong>하는 방식으로써 유용하게 사용되었다.</li>\n</ul>\n\n<p>이러다보니 “동시 커넥션 문제”가 현실로 다가온 것이다.</p>\n<ul>\n  <li>대규모 사이트들이 좋아할 만한 솔루션 이었고, NGINX는 급성장하게 된다.<br />\n(<em>현재 우리가 쿠버네티스고, 뭐고 배우는 이유도 이러한 문제의 솔루션으로써 대두된다는 것을 알고 넘어가자</em>)</li>\n</ul>\n\n<p>그렇다면 Apache는 가만히 있었을까?</p>\n\n<p>Apache도 MPM이라는 모듈을 추가해서 성능을 개선하기 시작한다.</p>\n\n<ul>\n  <li>Multi-Processing Module</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/acf7ede3-b612-417c-b4a5-82c352ba4c37\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>Apache 서버를 어떤 방식으로 운영할 지 선택할 수 있는 모듈이다.\n    <ul>\n      <li>안정성이나 소규모 프로젝트에서는 기존의 prefork 방식을</li>\n      <li>성능 향상이나 대규모 프로젝트에서는 worker라는 스레드를 만들어 worker가 요청을 처리하도록 했다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>그렇다면 왜 아직도 동시 커넥션 지표에서 NGINX가 Apache를 압도적으로 앞설까?</p>\n\n<div style=\"display: flex; justify-content: space-between; gap: 20px;\">\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/1b280974-4d15-4e5d-ac6c-c21e2093f673\" alt=\"Memory Usage\" style=\"width: 100%;\" />\n    </div>\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/6a787d51-fb2d-4c1f-a973-3f380a838d29\" alt=\"Requests Per Second\" style=\"width: 100%;\" />\n    </div>\n</div>\n<p style=\"text-align: center; color: #666;\">출처: dreamhost.com</p>\n\n<p>왼쪽 동시 커넥션 수당 메모리 사용률 지표를 보면,</p>\n<ul>\n  <li>NGINX는 동시 커넥션이 많아져도 메모리 사용률이 낮고 일정한 반면,<br />\nApache는 굉장히 많은 메모리 사용률을 요구한다.</li>\n</ul>\n\n<p>오른쪽 동시 커넥션 수가 많아졌을 때 처리하는 초당 요청 수 지표를 보아도,<br />\nNGINX가 Apache에 비해 압도적으로 많다.</p>\n<ul>\n  <li>NGINX가 커넥션 관리를 얼마나 잘하는 지 볼 수 있다.</li>\n</ul>\n\n<p>사실 지금까지 <strong>동시 커넥션</strong>이라는 포인트에만 집중해서 NGINX의 장점과 현재 많이 쓰이는 이유를 알아보았다.</p>\n\n<p><strong>그렇다면 Apache의 장점은 무엇이 있을까?</strong></p>\n\n<p><br /></p>\n\n<h2 id=\"2-4-apache가-아직-쓰이는-이유와-nginx의-단점\">2-4. Apache가 아직 쓰이는 이유와 NGINX의 단점</h2>\n\n<p>근본자체가 “NCSA HTTPd”라는 소프트웨어의 버그를 수정해오며 커온 Apache이기에,\n<span class=\"post-highlight\">호환성과 확장성의 측면</span>에서는 장점이 있다.</p>\n\n<p>아직도 오픈소스로써 활발한 수정과 개선이 이루어지고 있다. [<span class=\"post-highlight\">풍부한 모듈 생태계</span>]</p>\n<ul>\n  <li><a href=\"https://projects.apache.org/projects.html\">Apache는 현재에도 Apache Kafka, Apache Hadoop 등 시대에 발맞춰 발전 중이다</a>.</li>\n</ul>\n\n<p>또한, Apache는 여러 운영 체제(리눅스, 윈도우, 유닉스 등)에서 폭넓은 호환성과 안정성을 자랑한다.</p>\n\n<p>NGINX는 그렇지 않아서, Windows에서 성능이 매우 낮게 나온다.</p>\n<ul>\n  <li>NGINX는 원래 <strong>리눅스</strong> 환경에서 설계되었기 때문에, 리눅스 OS에서 최고의 성능이 나오며,</li>\n  <li>윈도우에서도 동작은 하지만,<br />\n윈도우의 <strong>비동기 I/O</strong> 시스템에 최적화되지 않았기 때문에 <strong>성능이 상대적으로 낮다</strong>.</li>\n</ul>\n\n<p>현재 서비스에서 큰 성능 문제 없이 잘 돌아가고 있고, 모듈을 계속해서 추가/제거할 일이 많다면 굳이 NGINX로 옮길 이유는 없는 것이다.</p>\n<ul>\n  <li>오해하면 안되는 것이 NGINX는 설정 변경과 이에 따른 Worker Process의 로직 변경이 무중단으로 이루어진다는 것이며,<br />\nNGINX는 모듈 자체를 동적으로 로드할 수 없으므로, 새 모듈을 추가하려면 재컴파일이 필요하다.</li>\n  <li>Apache는 설정 변경 없이 실행 중 동적 모듈 로드가 가능하므로, 특정 기능을 빠르게 추가하거나 제거할 때 더 유연하다.</li>\n</ul>\n\n<p><strong>둘은 서로 대립관계가 아니며, 목적이 다르게 탄생한 것이다.</strong></p>\n\n<p><br /></p>\n\n<h2 id=\"2-5-그렇다면-현재-nginx를-어떻게-이용해야-하는가\">2-5. 그렇다면 현재 NGINX를 어떻게 이용해야 하는가?</h2>\n\n<p>앞서 우리는 NGINX의 WS로써, 로드밸런싱으로서의 역할을 보았다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/04bf32c2-7d72-4229-a31e-2b3e639e6b2d\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>비동기 이벤트 기반 구조로 동시 커넥션 처리가 효율적이며, Reverse Proxy로써 서버 부하를 줄일 수 있다.</p>\n\n<p>이 자체로 웹 서버 가속(성능 개선) 역할을 한다.</p>\n\n<p>추가적으로 NGINX를 사용하며 고려해야할 관점이다.</p>\n\n<p><strong>1) SSL 터미네이션 역할을 한다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/baaa7488-05be-473f-8d84-27912891b0f3\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX가 앞단에서 SSL을 처리하여, 클라이언트와는 HTTPS로 통신하고, 뒷단 서버와는 HTTP로 통신하는 방식이다.</p>\n<ul>\n  <li>어차피, NGINX와 SERVER가 같은 네트워크 안에 있는 경우가 많기 떄문에,<br />\n이렇게 통신을 해도 보안 위험이 비교적 적다.</li>\n</ul>\n\n<p>이 방식은 뒷단 서버가 <span class=\"post-highlight\">복호화 과정에서 발생하는 부하를 줄이는 장점</span>이 있다.</p>\n\n<p><strong>2) 캐싱 역할을 한다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/6c43e842-cbfa-44fd-99e0-75b079dc4a20\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX는 &lt;span class=”post-highlight”HTTP 콘텐츠 캐싱&lt;/span&gt;을 지원하며,<br />\n이를 통해 서버 부하를 줄이고 클라이언트 요청에 빠르게 응답할 수 있습니다.</p>\n<ul>\n  <li>한 번 서버로부터 받은 응답을 스스로 보관하고 클라이언트에게 전달하므로 효율적이다.</li>\n</ul>\n\n<p>이러한 경우 1번과 달리 NGINX를 클라이언트와 가까운 곳(예: CDN이나 엣지 서버)에 배치하여<br />\n캐싱 효과를 극대화할 수 있다.</p>\n\n<p><strong>3)NGINX와 컨테이너화</strong></p>\n\n<p>현재 클라우드 네이티브와 컨테이너화가 대세인 환경에서, NGINX는 더욱 중요한 역할을 수행하고 있다.</p>\n\n<p>특히 Kubernetes의 Ingress Controller로서, 또는 마이크로서비스 아키텍처에서의 API Gateway로서 그 가치가 두드러진다.</p>\n\n<p>Kubernetes에서 Ingress Controller로 사용될 때, API Gateway로서의 설정 등등</p>\n<ul>\n  <li>이러한 설정들을 통해 NGINX는 현대적인 마이크로서비스 환경에서 트래픽 라우팅, 로드밸런싱, SSL 종료, API 게이트웨이 등 다양한 역할을 효율적으로 수행할 수 있다.</li>\n  <li>특히 컨테이너 환경에서는 가볍고 빠른 NGINX의 특성이 더욱 큰 장점으로 작용한다.</li>\n</ul>\n\n<p>이 외에도 HSTS, CORS 처리, TCP/UDP 커넥션 분산 부하, HTTP/2 지원 (최근에는 /3도 지원) 등 서버를 보완하는 역할을 할 수 있다.</p>\n\n<p>어떠한 기능이 있는지를 알아보고 상황에 따라 알맞는 기능을 적용하는 자세가 필요하다.</p>\n\n<hr />\n<p>참고: <a href=\"https://www.youtube.com/watch?v=mcnJcjbfjrs\" target=\"_blank\">우아한테크 [10분 테코톡] 알리의 Web Server vs WAS</a></p>\n\n<p><a href=\"https://www.youtube.com/watch?v=6FAwAXXj5N0\" target=\"_blank\">우아한테크 [10분 테코톡] 피케이의 Nginx</a></p>\n",
                        "tags": ["WebServer","Apache","NGINX","Architecture","DevOps","Network","Performance","LoadBalancing","ReverseProxy"]
                    }
                
            ],
        
            "Architecture": [
                
                    {
                        "title": "WAS(Web Application Server)와 Servlet",
                        "url": "/2025/01/28/about-was.html",
                        "subtitle": "Tomcat부터 Spring Boot까지",
                        "excerpt": "웹 서버(WS)의 진화 : Apache vs NGINX\n위 post에 이어지는 내용입니다.\n",
                        "author": "Jinho",
                        "date": "January 28, 2025",
                        "background": "/img/posts/apache_tomcat.jpeg",
                        "content": "<p><a href=\"https://jinho7.github.io/2025/01/27/ws-and-was.html\" target=\"웹 서버(WS)의 진화 : Apache vs NGINX \">웹 서버(WS)의 진화 : Apache vs NGINX</a><br />\n<em>위 post에 이어지는 내용입니다.</em></p>\n\n<h1 id=\"was-란\">WAS 란?</h1>\n\n<h2 id=\"was의-정의\">WAS의 정의</h2>\n\n<p>먼저 WAS(Web Application Server)의 정의는 다음과 같다.</p>\n<blockquote>\n  <p><span class=\"post-highlight\">웹 애플리케이션과 서버 환경을 만들어 동작시키는 기능을 제공하는 소프트웨어 프레임워크</span></p>\n</blockquote>\n\n<p>대표적으로 Apache <span class=\"post-highlight\">Tomcat</span>이 있다.</p>\n<ul>\n  <li><em>참고로 Apache Tomcat는 WS 단계에서 계속 이야기했던 Apache와는 아예 별개의 소프트웨어이다.</em></li>\n</ul>\n\n<details>\n<summary>Apache와 Tomcat</summary>\nApache HTTP Server (보통 Apache라고 부름)\n<ul>\n    <li>웹 서버(WS) 역할을 담당</li>\n    <li>주로 정적 콘텐츠를 처리</li>\n    <li>HTTP 요청을 처리하며, 동적 콘텐츠를 처리할 경우에는 WAS(Tomcat)와 연동하여 작업을 나눕니다.</li>\n</ul>\nApache Tomcat (보통 Tomcat이라고 부름)\n<ul>\n    <li>WAS 역할을 담당</li>\n    <li>Servlet Container로서 동작하며, Servlet/JSP 기반의 동적 콘텐츠를 처리\n        <ul>\n            <li><em>정적 콘텐츠도 처리할 수는 있다.</em></li>\n            <li><em>정적 콘텐츠 처리 성능은 Apache HTTP Server보다 낮다.</em></li>\n        </ul>\n    </li>\n    <li>Java EE 표준의 일부인 Servlet/JSP 스펙을 구현하며, Spring MVC와 같은 프레임워크의 기반이 되는 동작을 지원한다.</li>\n</ul>\n</details>\n\n<p><br /></p>\n\n<p>그러나 이런 물음표가 떠오른다.</p>\n\n<p><strong>❓ WAS? TOMCAT? Servlet? Servlet Container? Spring MVC?</strong></p>\n\n<p>다음 기본 개념부터 인지하고 넘어가면 이해하기 쉽다.</p>\n\n<ol>\n  <li><strong>WAS</strong>는 클라이언트의 요청을 처리하여 <strong>동적인 웹 콘텐츠</strong>를 제공하는 서버를 말한다.</li>\n  <li><strong>Tomcat</strong>은 WAS의 대표적인 예시 중 하나이다.</li>\n  <li>Tomcat은 <strong>Servlet Container의 한 종류</strong>이며, <strong>Servlet/JSP 요청을 처리</strong>하는 역할을 한다.</li>\n  <li>Tomcat은 <strong>Servlet 표준</strong>에 맞춘 애플리케이션을 실행하는 데 최적화되어 있다.\n    <ol>\n      <li><strong>Servlet 표준</strong>은 <strong>Java EE</strong>(현재는 <strong>Jakarta EE</strong>) 명세의 일부로, <strong>Java 기반 동적 웹 콘텐츠 처리</strong>를 위한 규격이다.</li>\n      <li>즉, Tomcat은 <strong>Java 기반의 웹 애플리케이션</strong>을 실행하기 위한 서버이다.</li>\n    </ol>\n  </li>\n</ol>\n\n<p><strong>WS와 WAS의 차이의 핵심는 ‘동적 처리 여부’에 있다.</strong></p>\n<ul>\n  <li>현대 웹사이트는 스크롤에 따라 새로운 피드를 보여주거나,<br />\n사용자 맞춤 광고를 제공하는 등의 동적 기능을 포함한다.</li>\n  <li>이러한 <strong>“사용자 맞춤 가공 처리(동적 콘텐츠)”는 결국 서버가 특정 코드를 실행했다</strong>는 의미다.</li>\n  <li>결국 궁금한 것은 ‘<strong>서버가 어떻게 이 코드를 실행하고, 그 결과를 클라이언트에게 제공하는가</strong>’이다.</li>\n</ul>\n\n<div style=\"display: flex; justify-content: space-between; gap: 20px;\">\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/203ab158-60b0-4376-be93-1de497da3d19\" alt=\"Memory Usage\" style=\"width: 100%;\" />\n        <p style=\"text-align: center; color: #666;\">누구나에게 제공되는 “정적인” 컨텐츠이다.</p>\n    </div>\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/5795047e-ae12-4cda-a1f6-e2b3ab8dfd72\" alt=\"Requests Per Second\" style=\"width: 100%;\" />\n        <p style=\"text-align: center; color: #666;\">하지만 로그인하고 나면 “동적인” 컨텐츠가 로드된다.</p>\n    </div>\n</div>\n\n<p>아래는 동적 페이지를 로드하는 과정을 그림으로 표현한 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/ef604672-3c6c-4724-9f9a-9a226cc6e513\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>우리는 앞서 실제 운영/대규모 서비스는 <span class=\"post-highlight\">WS-WAS 분리 구조</span>를 선호한다고 말했다.</p>\n\n<p>나는 WAS의 한 종류인 Tomcat까지의 웹통신 흐름이 어떻게 이루어지는 지가 궁금해졌다.<br />\n그리고 <u>‘jvm, survlet, spring 등 어떤 개념이고 어떤 연관관계가 있고 어떻게 유동적으로 작동할까…?’</u> 가 궁금했다.</p>\n\n<p><br /></p>\n\n<h2 id=\"jvmjava-virtual-machine\">JVM(Java Virtual Machine)</h2>\n\n<p><img src=\"https://github.com/user-attachments/assets/f48a2ce2-5aa4-495c-a686-79e32ce7eed2\" alt=\"Image\" width=\"70%\" height=\"100%\" class=\"center\" /></p>\n\n<p><em>JVM 자체가 현재 내용에서 매우 중요한 내용은 아니라 짧게 이야기하면,</em></p>\n<ul>\n  <li>⇒ 그냥 JVM은 간단히 Java 코드를 실행시켜주는 놈이라고 생각하자.</li>\n  <li>WAS(Tomcat)는 Java로 작성된 웹 애플리케이션을 실행하는 컨테이너이므로,<br />\nWAS도 JVM 위에서 동작한다.</li>\n</ul>\n\n<details>\n<summary>JVM 이란?</summary>\nApache HTTP Server (보통 Apache라고 부름)\n<ul>\n    <li>JVM은 JVM은 Java 바이트코드(.class 파일)를 해석하고 실행하는 가상 머신</li>\n    <li>JRE는 Java 프로그램을 실행하는 데 필요한 모든 것을 포함한다. 라이브러리 등</li>\n        <ul>\n            <li><em>JRE은 JVM을 시작, 필요한 클래스 라이브러리 로드, main() 메서드를 실행한다.</em></li>\n        </ul>\n    <li>JDK는 Java 애플리케이션을 개발하는 데 필요한 모든 도구를 포함한다.</li>\n</ul>\n</details>\n\n<p><br /></p>\n\n<h2 id=\"servlet-container-tomcat\">Servlet Container [Tomcat]</h2>\n\n<p>위에서 “Tomcat은 <strong><u>Servlet Container의 한 종류</u></strong>이며, <strong><u>Servlet/JSP 요청을 처리</u></strong>하는 역할을 한다.” 라고 했다.</p>\n\n<p>1) <strong>Servlet Container</strong>는 Servlet<strong>의 생명 주기</strong>를 관리하는 곳이다.</p>\n<ul>\n  <li>Servlet과 Servlet Container의 관계를 Bean과 Bean Container의 관계와 흡사하다고 생각하면 된다. (“컨테이너와 관리 대상”의 관계로 이해)\n    <ul>\n      <li>Servlet Container는 HTTP 요청과 응답을 처리하는 Servlet을 관리</li>\n      <li>Bean Container는 Spring의 <strong>애플리케이션 내 객체(Bean)</strong>의 생명 주기와 의존성을 관리</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2) 또한, <strong>HTTP 요청 처리 및 응답 생성 과정</strong>은 Servlet Container의 핵심 기능 중 하나이다.</p>\n<ul>\n  <li>웹 브라우저에서 요청이 들어오면, Tomcat은 그 요청을 받아서 적절한 Java 코드(서블릿)로 전달하고, 그 결과를 다시 브라우저로 보내는 역할을 한다.</li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"servlet\">Servlet</h2>\n\n<p>Servlet은 <strong>HTTP 요청을 처리하고 응답을 생성하는 스펙을 정의한 인터페이스</strong>이다.</p>\n<ul>\n  <li>Servlet은 <strong>jakarta.servlet.Servlet</strong>을 최상위 인터페이스로 가진다. (Java API)</li>\n</ul>\n\n<p>Servlet은 <strong>Servlet Container</strong>에 의해 관리되며, 요청이 들어오면 컨테이너가 Servlet의 생명 주기를 관리하고 요청을 처리하기 위한 스레드를 생성한다.</p>\n\n<p>Servlet은 HTTP 요청을 처리하고, 그에 따른 적절한 응답을 생성하는 기본 단위이다. 이를 통해 <span class=\"post-highlight\">REST API의 엔드포인트</span>가 되거나 <span class=\"post-highlight\">동적 웹 페이지를 생성</span>하는 역할을 수행할 수 있다.</p>\n\n<ol>\n  <li>Servlet은 HTTP 요청을 받아 비즈니스 로직을 처리하고 JSON, XML 등의 형식으로 데이터를 응답할 수 있다.</li>\n  <li>동적인 HTML 콘텐츠를 생성할 때도 사용된다.\n    <ul>\n      <li>예를 들어, 비즈니스 로직 처리가 필요한 HTTP 요청이 Web Server로 들어오면, Web Server는 이를 Servlet Container가 실행하는 Servlet에 전달한다.</li>\n      <li>Servlet은 요청을 처리하고 동적인 웹 콘텐츠를 생성한 뒤, 결과를 Web Server를 통해 클라이언트로 반환한다.</li>\n    </ul>\n  </li>\n</ol>\n\n<p>전체적인 통신 흐름은 다음과 같다.</p>\n<ul>\n  <li>WS 는 HTTP 요청을 받아 정적 리소스를 처리하거나, 요청을 WAS에 전달한다.</li>\n  <li>WAS는 Servlet Container를 통해 요청을 처리하고, 처리 결과를 Web Server를 거쳐 클라이언트에 반환한다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/06d2213c-0f90-4a1b-a765-33531aeed39d\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p><br /></p>\n\n<h3 id=\"servlet의-생명주기\">Servlet의 생명주기</h3>\n\n<p>위 그림을 보면 알 수 있듯, Servlet은 다음과 같은 생명 주기를 가진다.</p>\n\n<p>1) <strong>초기화 단계</strong>:</p>\n<ul>\n  <li>최초 요청이 오면 Servlet 클래스(HelloServlet.class)가 로딩된다.</li>\n  <li>web.xml 설정을 참고하여 매핑할 Servlet을 확인한다.</li>\n  <li><span class=\"post-highlight\">해당 Servlet 인스턴스가 있다면 사용하고, 없다면 init()으로 초기화한다.</span></li>\n</ul>\n\n<p>2) <strong>서비스 단계</strong>:</p>\n<ul>\n  <li>Servlet Container는 각 요청마다 새로운 스레드를 생성한다.</li>\n  <li>새로운 Request/Response 객체를 생성하여 service() 메서드를 실행한다.</li>\n  <li>service()는 요청 방식(GET, POST 등)에 따라 적절한 do메서드를 호출한다.</li>\n  <li>요청 처리가 완료되면 해당 Request/Response 객체는 소멸된다.</li>\n</ul>\n\n<p>3) <strong>소멸 단계</strong>:</p>\n<ul>\n  <li><em>서버 종료나 애플리케이션 재배포 시에만 destroy()가 호출된다.</em></li>\n  <li><em>Servlet이 사용하던 리소스를 정리한다.</em></li>\n</ul>\n\n<p><br /></p>\n\n<p>정리하자면,</p>\n<ul>\n  <li>Tomcat은 Servlet 객체를 한 번 생성하면 메모리에 유지하고, 요청이 올 때마다 해당 객체의 <strong>service()</strong> 메서드를 호출한다.</li>\n  <li>따라서, <strong>init()</strong> 메서드는 <strong>최초 요청 시(또는 설정에 따라 애플리케이션 시작 시)</strong> 단 한 번 실행된다.</li>\n  <li>또 종료되기 전이나 reload 전에 destroy()를 호출하여 매번 객체가 생성되는 것을 방지한다.</li>\n</ul>\n\n<p><strong>(🤔 궁금증) servlet은 왜 생성만 하고 제거는 안하지?</strong>\n만약 사용이 끝날 때마다 제거한다면 다음과 같은 문제가 있다.</p>\n<ul>\n  <li>모든 요청에 대해 servlet을 생성하고 소멸하는 것은 OS 와 JVM 에게 필요없는 부하를 일으킨다.\n    <ul>\n      <li>JVM의 <strong>Garbage Collection</strong>과 <strong>메모리 할당/해제</strong>를 빈번하게 유발</li>\n    </ul>\n  </li>\n  <li>동시에 다수의 요청이 들어올 경우 CPU 또는 메모리 리소스 소모에 대한 제한이 어렵다. \n결국 순간적으로 서버가 다운되거나 동시 처리에 문제가 생길 수 있다.\n    <ul>\n      <li><em>(참고로 Tomcat 3.2 이전 버전은 실제 매번 생성과 제거를 했다.)</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p><strong>(✨해결) 해답은 Servlet의 특징과 관리 방식에 있다.</strong></p>\n<ul>\n  <li>수많은 클라이언트의 요청을 동시에 처리해야 하는 WAS의 특성상,\nServlet은 싱글톤 패턴으로 관리하게 되었다.\n    <ul>\n      <li>한 번 생성된 Servlet 인스턴스는 메모리에 계속 유지된다.</li>\n      <li>모든 요청은 동일한 Servlet 인스턴스를 공유한다.</li>\n      <li>init()은 최초 요청 시 한 번만 실행된다.</li>\n      <li>destroy()는 서버 종료나 재배포 시에만 실행된다.</li>\n    </ul>\n  </li>\n  <li><em>(Tomcat 3.2 부터는 디폴트로 <span class=\"post-highlight\">싱글톤 패턴 도입</span>와 <span class=\"post-highlight\">Thread Pool</span> 을 사용)</em></li>\n</ul>\n\n<p><br /></p>\n\n<h1 id=\"servlet-처리-구조의-발전\">Servlet 처리 구조의 발전</h1>\n\n<h2 id=\"기존-servlet-처리-방식\">기존 Servlet 처리 방식</h2>\n\n<p>Tomcat은 다음과 같은 역할을 한다고 하였다.</p>\n<ul>\n  <li>Servlet Container로서 HTTP 요청과 응답을 처리하는 환경 제공</li>\n  <li>Servlet 객체의 생성, 초기화, 요청 처리, 소멸 등 <strong>생명주기를 관리</strong>하는 역할</li>\n</ul>\n\n<p><strong>(🤔 문제점) Servlet은 요청마다 개별적으로 처리 로직을 구현해야 하므로,</strong><br />\n<strong>비슷한 요청을 처리하는 여러 Servlet에서 <span class=\"post-highlight\">중복된 코드가 발생</span>할 수 있다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/7c5e684e-cd0f-4167-8e55-f3d24172f58e\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 기존 서블릿 방식 - 각 URL마다 서블릿을 따로 만들어야 했습니다</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserServlet</span> <span class=\"kd\">extends</span> <span class=\"nc\">HttpServlet</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">doGet</span><span class=\"o\">(</span><span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"nc\">HttpServletResponse</span> <span class=\"n\">response</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 로깅 처리</span>\n        <span class=\"c1\">// 인증 처리</span>\n        <span class=\"c1\">// 공통 에러 처리</span>\n        <span class=\"c1\">// 실제 비즈니스 로직</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProductServlet</span> <span class=\"kd\">extends</span> <span class=\"nc\">HttpServlet</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">doGet</span><span class=\"o\">(</span><span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"nc\">HttpServletResponse</span> <span class=\"n\">response</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 위와 동일한 로깅, 인증, 에러 처리 코드가 반복됨</span>\n        <span class=\"c1\">// 실제 비즈니스 로직</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>이러한 방식은 다음과 같은 문제가 있다.</p>\n<ol>\n  <li>하나의 서블릿 클래스에 너무 많은 책임이 집중된다.</li>\n  <li>URL 매핑, 파라미터 처리, 뷰 선택 등을 모두 수동으로 처리해야 함</li>\n  <li>모든 서블릿에서 공통 로직(로깅, 인증, 에러 처리 등)이 반복됨</li>\n  <li>각각의 서블릿을 web.xml에 일일이 등록해야 함<br />\n (web.xml : 웹 애플리케이션의 <strong>구성 정보</strong>를 제공)</li>\n</ol>\n\n<ul>\n  <li>과거 web.xml은 다음과 같은 중요한 정보들을 담고 있었다.\n    <ul>\n      <li>어떤 서블릿이 존재하는지</li>\n      <li>각 서블릿이 어떤 URL 패턴을 처리하는지</li>\n      <li>어떤 필터들이 요청을 처리하는지</li>\n      <li>웹 애플리케이션의 시작과 종료 시 필요한 리스너는 무엇인지</li>\n    </ul>\n  </li>\n</ul>\n\n<p>⇒ 각 서블릿(요청을 처리하는 클래스)에 대한 정보를 등록해야 한다는 것이다… 😢</p>\n\n<p><br /></p>\n\n<h2 id=\"dispatcherservlet---spring-mvc--공통-로직의-중앙-집중화\"><strong>DispatcherServlet</strong> - Spring MVC : 공통 로직의 중앙 집중화</h2>\n\n<p><strong>(✨ 해결책) 공통 로직의 중앙 집중화</strong></p>\n\n<p>Spring Framework는 기존 서블릿 스펙의 장점을 활용하면서도 그 한계를 개선하는 방향으로 발전했다.</p>\n\n<p><span class=\"post-highlight\">DispatcherServlet이라는 Front Controller를 사용해 공통 로직을 처리하고 요청에 맞는 컨트롤러를 호출하는 특수한 Servlet</span>을 만들어 새로운 구조를 도입했다.</p>\n\n<ul>\n  <li><em>참고로 <strong>DispatcherServlet</strong> 도 <strong>Servlet이다.</strong></em>\n    <ul>\n      <li><em>(이쯤에서 Spring에서의 Controller의 역할이 아구 맞게 떠오른다.)</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/945895b9-66a2-4713-b7a4-8461f3a66075\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>Spring MVC는 이러한 문제를 DispatcherServlet이라는 하나의 Front Controller로 해결했다.</p>\n\n<ul>\n  <li><em>이제 우리가 아는 친숙한 코드가 나온다….</em></li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Spring MVC 방식</span>\n<span class=\"nd\">@Controller</span>  <span class=\"c1\">// 더 이상 HttpServlet을 상속할 필요가 없음</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserController</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@GetMapping</span><span class=\"o\">(</span><span class=\"s\">\"/users\"</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">handleUsers</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 비즈니스 로직에만 집중</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"userList\"</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"nd\">@Controller</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProductController</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@GetMapping</span><span class=\"o\">(</span><span class=\"s\">\"/products\"</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">handleProducts</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 비즈니스 로직에만 집중</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"productList\"</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p><strong>DispatcherServlet</strong>은 다음과 같은 일을 한다.</p>\n\n<ol>\n  <li><strong>DispatcherServlet</strong>은 웹 애플리케이션에 들어오는 모든 HTTP 요청을 먼저 받는다.</li>\n  <li>요청을 <strong>어떤 컨트롤러가 처리할지 결정</strong>하고, 해당 컨트롤러로 요청을 <strong>디스패치(위임)</strong> 한다.</li>\n  <li>요청에 대해 <strong>공통 처리</strong>(예: 인증, 로깅 등)를 먼저 한 후, 적절한 컨트롤러로 요청을 전달한다.</li>\n  <li><strong>DispatcherServlet</strong> 덕분에, 이제 다른 컨트롤러는 굳이 서블릿을 상속할 필요가 없다.</li>\n</ol>\n\n<p>4번에 대해 추가 설명을 하자면, <strong>Spring MVC</strong>에서는 <strong>DispatcherServlet</strong>만 서블릿으로 등록하고, 실제 비즈니스 로직을 처리하는 <strong>컨트롤러</strong>는 <strong>서블릿</strong>이 아니어도 된다는 뜻이다.</p>\n\n<ul>\n  <li><strong>Spring MVC</strong>에서는 <strong>DispatcherServlet</strong>만 서블릿으로 등록하고, 실제 비즈니스 로직을 처리하는 <strong>컨트롤러</strong>는 <strong>서블릿</strong>이 아니어도 된다는 뜻이다.</li>\n  <li>Spring MVC의 <strong>컨트롤러</strong>는 단순한 <strong>자바 클래스</strong>로, <strong>@Controller</strong> 어노테이션을 붙인 클래스를 만들어 요청을 처리할 수 있다.</li>\n  <li>이때, <strong>컨트롤러 클래스는 Servlet을 상속하지 않아도</strong> 된다.</li>\n  <li><strong>DispatcherServlet</strong>이 모든 요청을 처리하고, 요청을 <strong>컨트롤러</strong>로 전달하기 때문에, 실제로는 <strong>서블릿이 아닌 컨트롤러</strong>가 <strong>Servlet 객체를 상속</strong>하지 않아도 된다는 뜻이다.</li>\n</ul>\n\n<p>이렇듯 Spring 프레임워크는 Front Controller를 제공해주고 이를 Dispather Servlet 이라 부른다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/f5b5a218-c501-43c6-8869-c0ccd63acc77\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p><br /></p>\n\n<h2 id=\"servlet과-dispatcherservlet의-역할-분담의-의의\"><strong>Servlet</strong>과 DispatcherServlet의 역할 분담의 의의</h2>\n\n<p>Servlet 표준에서 중요한 점은 Servlet이 <span class=\"post-highlight\">전체 데이터 처리 과정에서 특정한 역할만 수행</span>한다는 것이다.</p>\n\n<p><strong><u>전통적인 서블릿 방식</u></strong>에서는 HTTP 요청/응답 처리부터 비즈니스 로직까지 모든 것을 책임져야했다.</p>\n\n<p>변화한 Spring MVC 구조에는 다음과 같은 장점이 있다.</p>\n\n<p>1) <strong>관심사의 분리(Separation of Concerns)</strong></p>\n<ol>\n  <li>DispatcherServlet이 모든 HTTP 요청을 먼저 받아서 적절한 Controller로 라우팅하는 역할을 담당하게 되었다.</li>\n  <li>이로 인해 Controller는 비즈니스 로직에만 집중할 수 있게 되었다.</li>\n</ol>\n\n<p>2) <strong>POJO(Plain Old Java Object) 기반 개발</strong></p>\n<ol>\n  <li>Controller가 더 이상 HttpServlet을 상속받지 않아도 된다는 것은 매우 중요한 의미를 가진다.</li>\n  <li>이는 일반적인 자바 클래스로 웹 개발이 가능해졌다는 뜻이다.</li>\n</ol>\n\n<p>3) <strong>각 엔드포인트가 명확하게 분리된다.</strong></p>\n\n<p><br /></p>\n\n<p>⇒ Spring Boot는 이러한 통합을 더욱 단순화했다.</p>\n\n<p>개발자는 복잡한 설정 없이도 Tomcat과 Spring이 자연스럽게 협력하는 환경에서 개발할 수 있게 되었다.</p>\n\n<p>web.xml 없이도 자동 구성을 통해 모든 것이 가능해졌다.</p>\n\n<p><em>@SpringBootApplication 어노테이션은 다음 3가지 핵심 어노테이션의 조합이다.</em></p>\n\n<ol>\n  <li>@SpringBootConfiguration</li>\n  <li><span class=\"post-highlight\">@EnableAutoConfiguration</span> [자동 구성]</li>\n  <li>@ComponentScan</li>\n</ol>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@SpringBootApplication</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">MyApplication</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// Spring Boot가 내장 Tomcat을 자동으로 구성하고 시작</span>\n        <span class=\"nc\">SpringApplication</span><span class=\"o\">.</span><span class=\"na\">run</span><span class=\"o\">(</span><span class=\"nc\">MyApplication</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">,</span> <span class=\"n\">args</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>즉, 현대에 와서 <strong>DispatcherServlet이 서블릿 역할을 하면서</strong> 요청을 <strong>Controller</strong>에 전달하고, <strong>Controller</strong>는 <strong>서비스</strong>를 호출하여 실제 비즈니스 로직을 처리하게 하는 방식으로 발전하였다.</p>\n\n<ul>\n  <li>단지 <strong>DispatcherServlet</strong>은 요청을 받아서 적절한 컨트롤러에게 넘겨주는 역할을 한다.</li>\n</ul>\n\n<p>지금까지 살펴본 WAS의 발전 과정을 보면 다음과 같다.</p>\n<ol>\n  <li>WAS는 동적 컨텐츠 처리를 위한 웹 애플리케이션 서버로 분리되며 시작됐다.</li>\n  <li>Tomcat은 Servlet Container로서 Java 기반 웹 애플리케이션을 실행시킨다.</li>\n  <li>초기 Servlet 방식의 한계(중복 코드, 복잡한 설정)를 Spring MVC가 해결했다.</li>\n  <li>DispatcherServlet의 도입으로 공통 로직 처리와 요청 위임이 체계화되었다.</li>\n</ol>\n\n<p>결국 DispatcherServlet이 모든 요청을 받아 적절한 Controller에 위임하므로\nController는 순수 비즈니스 로직에만 집중할 수 있게 되었다.</p>\n<ul>\n  <li>개발자는 반복적인 설정 없이 핵심 기능 개발에 집중 가능!</li>\n</ul>\n\n<p>이처럼 WAS와 Servlet, 그리고 Spring MVC로 이어지는 발전 과정은 더 나은 웹 개발 환경을 만들어왔다.</p>\n\n<p>더 나아가, 웹 애플리케이션 아키텍처는 계속해서 진화하고 있다.</p>\n<ul>\n  <li>Spring WebFlux를 통한 리액티브 프로그래밍 도입</li>\n  <li>클라우드 네이티브 환경 지원</li>\n  <li>마이크로서비스 아키텍처로의 전환</li>\n  <li>서버리스 아키텍처의 등장</li>\n</ul>\n",
                        "tags": ["WAS","Tomcat","Servlet","SpringMVC","Java","WebDevelopment","Architecture","DispatcherServlet","SpringBoot"]
                    },
                
                    {
                        "title": "웹 서버(WS)의 진화",
                        "url": "/2025/01/27/ws-and-was.html",
                        "subtitle": "Apache vs NGINX",
                        "excerpt": "1. 웹서버(WS)에 대하여\n",
                        "author": "Jinho",
                        "date": "January 27, 2025",
                        "background": "/img/posts/apach_vs_nginx.jpeg",
                        "content": "<h1 id=\"1-웹서버ws에-대하여\">1. 웹서버(WS)에 대하여</h1>\n\n<h2 id=\"1-1-웹서버ws-란\">1-1. 웹서버(WS) 란?</h2>\n\n<p>NGINX, Apache 두 소프트웨어 모두 “<u>웹서버 소프트웨어</u>”이다.</p>\n\n<p>그렇다면 WS(웹서버)란 무엇일까?</p>\n\n<p>클라이언트의 HTTP 요청을 받아 <span class=\"post-highlight\">정적인 컨텐츠를 제공하는 서버 혹은 프로그램이다.</span></p>\n\n<p>이후에 다시 말하겠지만, WS는 정적인 컨텐츠를 서비스하는 데에 <strong>특화된</strong> 서버 소프트웨어이다.</p>\n<ul>\n  <li>동적인 콘텐츠를 처리 못한다는 것은 아니다.\n    <ul>\n      <li>참고로, Apache의 경우 자체적으로 동적인 컨텐츠 또한 처리가 가능하다.</li>\n    </ul>\n  </li>\n  <li>NGINX의 경우 불가능하다.\n    <ul>\n      <li>하지만, 동적 처리는 보통 WAS(Web Application Server)에서 주로 수행하므로, Web Server는 프록시 역할만 하면 충분하다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>여기서 주요한 점은 <span class=\"post-highlight\">“정적인 컨텐츠”</span>이다.</p>\n\n<p>html, JS 같은 정적인 컨텐츠들 정도는 웹서버를 구축한다면 웹서버 선에서 요청을 정리할 수 있다.</p>\n\n<h3 id=\"과거-2-tier-architecture\">과거 (2-tier Architecture)</h3>\n\n<p><img src=\"https://github.com/user-attachments/assets/a2d9a118-4b95-46ec-b303-a4b9c084f5eb\" alt=\"Image\" width=\"80%\" height=\"80%\" class=\"center\" /></p>\n\n<p>우선 과거의 버그가 많았던 초기의 웹서버(WS) 프로그램이 수정되고 개발된게 <strong>Apache</strong>이다.</p>\n\n<p>과거에 html, js, css 등과 같은 정적인 콘텐츠만을 주고 받는 구조에서는<br />\n<span class=\"post-highlight\">클라이언트 → WS [Apache] (정적 및 동적 요청 모두 처리) → DB</span> 만으로도 충분했다.</p>\n<ul>\n  <li>사실은 Apache의 경우, 정적/동적 모두 커버가 가능하기 때문에 기능적으로는 문제가 없었다.</li>\n  <li>하지만 다음과 같은 단점이 제기되었다.\n    <ul>\n      <li>동적 요청 처리가 필요할 경우, Apache가 너무 많은 부담을 가진다.</li>\n      <li>보안과 성능 측면에서 아쉬움이 있다.</li>\n      <li><em>그리고 이후에 다시 소개하겠다…</em></li>\n    </ul>\n  </li>\n  <li>그래서 앞단에 <u>정적 처리를 전문적으로 해주는 서버</u>가 있었으면 좋겠다는 생각을 하게 된다.</li>\n</ul>\n\n<p><br /></p>\n\n<h3 id=\"현재-3-tier-architecture\">현재 (3-tier Architecture)</h3>\n\n<p>정적/동적 컨텐츠에 대한 책임을 분리하고,<br />\n효율성과 확장성에 용이하기 위해 아키텍처가 발전했다.</p>\n\n<p><span class=\"post-highlight\">클라이언트 → [WS (정적 요청 처리) → WAS (동적 요청 처리)] → DB  </span><br />\n<em>(초기 발전 과정에서는 Apache가 WAS 역할로 동적 요청을 처리하고, 앞단에 정적 요청 처리를 NGINX가 붙는 방식으로 사용되었다.)</em></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/76082af9-7162-4a41-b5d4-be1d96020bfc\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>WAS는 동적 처리에 리소스 집중할 수 있게 되었고, 트래픽 증가에 유연한 대응이 가능하게 되었다.</p>\n<ul>\n  <li>소프트웨어 측면 말고, 개발자의 측면에서 보아도 효율적이다.\n    <ul>\n      <li>WS는 정적 파일, 보안, 로드밸런싱에만 집중하면 되고, WAS에서는 비즈니스 로직에만 집중하면 된다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><br /></p>\n\n<h1 id=\"2-apache와-nginx\">2. Apache와 NGINX</h1>\n\n<h2 id=\"2-1-apache-처리-방식-커넥션-기반\"><strong>2-1. Apache 처리 방식 (커넥션 기반)</strong></h2>\n\n<p>아파치는 <strong>Multi-Process Module</strong> 방식이다.<br />\n클라이언트가 요청 하나를 보내면, 하나의 process를 생성해서 연결한다.<br />\n요청당 프로세스/스레드 생성한다는 뜻이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/84ca44e3-a224-4f75-864d-f8f121f642da\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>이런 구조는 확장성 면에서 장점이 크다.<br />\n→ <span class=\"post-highlight\">이러한 측면에서 개발자들은 다양한 모듈을 만들어서 서버에 동적으로 빠르게 추가할 수 있는 장점이 있었다.</span></p>\n\n<p>하지만 다음과 같은 문제가 제기되었다.</p>\n\n<p>(🤔문제) <strong>프로세스 생성이 가벼운 작업이 아니기에, 매번 생성하기에는 너무 속도가 느려진다.</strong></p>\n\n<p>(✨발전 1) 요청 이전에 몇 개의 프로세스를 미리 만들어주는 prefork() 방식을 사용했다.</p>\n\n<p>(✨발전 2) 어찌됐든 매번 커넥션을 만드는 것은 비효율적이라고 판단했고, 이미 연결된 커넥션이 있다면 재활용하자는 생각을 한다.</p>\n<ul>\n  <li>http 헤더 종류 중에 keep-alive가 있다.</li>\n  <li><strong>→ Keep-Alive 옵션을 통해 일정 기간 동안 클라이언트와 Connection을 유지하는 방식</strong></li>\n</ul>\n\n<p><br /></p>\n\n<p>그러나 또 다른 문제가 제기되었다.</p>\n\n<p>(🤔또 다른 문제) <strong>클라이언트 수가 늘어나면서 결국 동시에 연결되어 있는 커넥션의 수도 매우 늘어나게 되었다.</strong></p>\n<ul>\n  <li>이렇게 동시 연결된 커넥션 수가 10,000개의 동시 연결을 넘어서는 순간, 서버는 더이상 커넥션을 형성하지 못하게 되는 현상이 발생했다. (<em>C10K 문제…</em>)</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/25bda5d5-aea5-4238-bc7b-3a499875a5e6\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>그런데 이 C10K 문제에서 하드웨어적으로 문제되는 것은 없었다.</li>\n  <li>이 당시 웹 페이지 용량 자체가 적었기 때문에 컴퓨터의 성능은 충분했지만,<br />\n비효율적인 서버의 구조 때문에 <strong>메모리 부족</strong> 현상이 일어난 것이다.</li>\n  <li>많은 커넥션에서 요청이 들어오기 시작하면, CPU 코어는 계속해서 프로세스를 바꿔가며 일을 해야 했다.</li>\n  <li>결론적으로, <strong>수 많은 동시 커넥션을 감당하기엔 아파치 서버의 구조가 적합하지 않았다.</strong></li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"2-2-nginx의-등장-이벤트-기반\"><strong>2-2. “NGINX”의 등장 (이벤트 기반)</strong></h2>\n\n<p>사실 NGINX는 Apache 를 대체하려고 나온 소프트웨어가 아니다.<br />\nNGINX는 Apache 앞 단에 붙여서 <span class=\"post-highlight\">보완하는 방식</span>으로 사용되었다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/c78538ef-1f3a-4e1a-b014-63afd34ca6c2\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>구조적으로 동시 커넥션을 많이 유지 못하는 아파치 서버의 부하를 nginx가 크게 줄일 수 있었다.</p>\n<ul>\n  <li><em>참고로,<br />\n[동시에 연결 가능한 커넥션 수(한 시점에 감당되는 동시 커넥션 수)] 와 초당 요청 처리 수는 다른 의미이다.</em></li>\n</ul>\n\n<p>이때 NGINX 가 정적인 페이지 처리를 모두 하고,<br />\nApache는 동적 파일 처리만 담당하는 (현대의 WAS 느낌) 구조로 바뀌게 되었다.</p>\n\n<p>그렇다면 어떻게 NGINX는 많은 동시 커넥션을 견뎌 낼 수 있을까?</p>\n\n<p><br /></p>\n\n<h3 id=\"nginx-처리-방식에-대해\">NGINX 처리 방식에 대해</h3>\n\n<p>Nginx는 Master-Worker 구조의 Process 방식을 채용했다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/a1d0bf67-8aca-4d49-8d74-690aaba06c50\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>Master Process는 설정파일에 맞게 실제 일하는 Worker Process를 만들어낸다.</p>\n\n<p>그리고 Worker가 만들어질 때 각자 지정된 Listen 소켓을 배정받는다.<br />\n(수신기를 받는다.)</p>\n\n<p>그리고 그 소켓에 새로운 클라이언트로부터 Request가 들어오면, 커넥션을 형성하고 요청을 처리한다.</p>\n<ul>\n  <li>마찬가지로 이 커넥션은 정해진 Keep-alive의 Timeout까지 연결을 유지하게 된다.</li>\n</ul>\n\n<p>하지만, Apache와의 차이는<br />\n<span class=\"post-highlight\">“그 커넥션이 형성되었다고 해서, Worker Process 1개가 그 커넥션 1개만을 담당하지는 않는다.”</span></p>\n<ul>\n  <li>형성된 커넥션에 아무런 요청이 없으면 새로운 커넥션을 형성하거나,<br />\n이미 만들어진 다른 커넥션으로부터 들어온 요청을 처리한다. (여러 커넥션을 쥐고 있는다.)</li>\n  <li>이런 <span class=\"post-highlight\">[커넥션 형성 / 커넥션 제거 / 새로운 요청 처리] 등을 모두 이벤트</span>라고 부른다.</li>\n</ul>\n\n<p>NGINX의 OS커널은 이러한 이벤트를 큐형식으로 줄세우고, Worker에게 전달한다.<br />\n<em>(멀티플레싱, epoll 에 대해 이해하면 어떻게 커널이 이벤트를 제공하는지 알 수 있다.)</em></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/26d73207-0e57-4358-894d-2f4450efcaf8\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">→ 는 커넥션 연결, O는 Request이며, 모두 “이벤트”이다.</em></p>\n\n<p>그리고 이 이벤트들은 큐에 담긴 채 비동기 방식으로 대기하고 있다.</p>\n\n<p>그리고 Worker Process는 하나의 스레드로 이벤트를 꺼내서 처리해 나간다.<br />\n이러면 Worker는 쉬지 않고 일을 계속 할 수 있다.</p>\n\n<p><span class=\"post-highlight\">요청이 없다면 방치되던 Apache의 구조보다 서버 자원을 훨씬 효율적으로 사용하는 셈</span>이다.</p>\n\n<p>(🤔문제) <strong>그런데 순서대로 꺼내서 쓰는 Queue에서 앞단에 들어오연 요청하나가 매우 시간이 오래걸리는 Disk I/O 작업이라면 어떨까..?</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d1abad7d-7b40-42be-9ff9-a293fe7a132b\" alt=\"Image\" width=\"60%\" height=\"100%\" class=\"center\" /></p>\n\n<p>매우 긴 IO 작업 중 큐에 대기하는 모든 이벤트들은 블로킹 될 것이다.</p>\n\n<p>(✨해결책) 오랜 기간 작업을 요하는 요청들을 위한 쓰레드 풀을 미리 만들어놓고,<br />\nWorker Process가 지금 처리하는 요청이 오래 걸린다고 판단되면,<br />\n해당 스레드 풀에 그 작업을 위임하고, 큐의 다른 이벤트를 처리하러 간다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/766c1772-fed9-4a42-b6ce-7fbbe7317f55\" alt=\"Image\" width=\"75%\" height=\"100%\" class=\"center\" /></p>\n\n<p>이러한 Worker Process 는 보통 Cpu의 코어 개수만큼 생성하고,<br />\n이러한 구조는 코어가 부담하는 Context Switch의 횟수를 대폭 줄일 수 있다.</p>\n\n<p>Apache와 비교하자면,</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/3e7909b6-7fd3-48df-b669-6b55a303b835\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>Apache\n    <ul>\n      <li>CPU가 여러 프로세스 간 스위칭</li>\n      <li>요청당 프로세스/스레드 필요</li>\n    </ul>\n  </li>\n  <li>Nginx\n    <ul>\n      <li>하나의 Worker Process가 이벤트 큐로 관리</li>\n      <li>단일 스레드로 여러 이벤트 처리</li>\n      <li>CPU 코어당 하나의 Worker 고정</li>\n      <li>이러한 <strong>Event-Driven Model이 Apache 구조와의 가장 큰 차이</strong>이다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"2-3-apache와-nginx\">2-3. Apache와 NGINX</h2>\n\n<p>항상 어떤 기술을 사용할 때에는 “최신 기술이여서”, “많이들 써서”가 이유가 될 수는 없다.</p>\n\n<p>어떤 기술, 어떤 아키텍처건 Trade-Off는 존재한다.</p>\n\n<p>과연 NGINX는 장점만 있을까?</p>\n\n<p>개발자가 <strong>기능(모듈) 추가를 시도했다가 돌아가고 있는 Worker Process를 종료해야 하는 상황</strong>이 생길 수 있다.</p>\n\n<p>그러면 <span class=\"post-highlight\">해당 Worker Process는 관리하고 있던 커넥션과 관려된 요청을 더이상 처리할 수 없다</span>는 문제가 발생한다.</p>\n<ul>\n  <li>그래서 NGINX는 개발자가 직접 모듈을 만들기에 좀 까다롭다.</li>\n</ul>\n\n<p>하지만, 단점보다 장점이 명확했다.</p>\n\n<p>수많은 동시 커넥션을 빠르게 처리하는 데에 있어 프로세스를 적게 만들다보니<br />\n(One Worker Process per CPU core)<br />\n⇒ 동시 커넥션 양 최소 10배 증가<br />\n⇒ 동일한 커넥션 수일 때 Apache에 비해 속도 2배 향상</p>\n\n<ul>\n  <li><strong>NGINX의 명확한 장점</strong>\n    <ol>\n      <li>One Worker Process per CPU core</li>\n      <li>Event-driven, asynchronous processing</li>\n      <li>Event Queue management</li>\n      <li>Thread Pool for long-running tasks</li>\n    </ol>\n  </li>\n</ul>\n\n<p>그리고 적은 프로세스는 관리가 쉽고, 새 Worker 생성 시 리소스 부담이 적다.</p>\n\n<p>이러한 구조는 “<span class=\"post-highlight\">NGINX가 설정을 동적으로 바꾸는 것</span>”을 가능하게 했다.</p>\n<ul>\n  <li>개발자가 설정 파일을 Runtime에 변경하고, NGINX에 적용하면,<br />\n이후부터는 Mater Process는 그 설정에 맞는 Worker Process를 찍어내게 된다.</li>\n  <li>그리고 기존 Worker Process에는 더이상 커넥션을 형성하지 못하게 막고,<br />\nQueue에 있는 이벤트들을 마저 처리한 뒤 기존 Worker들은 종료된다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/4f16c765-c2d8-44c2-850b-7c88a560dbb6\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>그런데 이러한 <strong>동적 설정 변경은 언제 사용</strong>할까?</p>\n<ul>\n  <li>대표적인 예로, NGINX가 여러 동시 커넥션을 관리하는 중에 뒷단에 새로운 서버를 추가하려는 상황이다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/b4f4191d-f32d-482f-a73c-6c14492350b2\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX는 이제부터 로드밸런싱 역할도 담당해야 한다.</p>\n\n<p>역할의 추가/변경이 의미하는 것은 무엇일까?</p>\n\n<ul>\n  <li>= Master Process가 찍어내야 하는 Worker Process의 역할의 추가/변경<br />\n= 기존 Connection 및 기존 Request들의 손실 없이 역할의 변경이 필요하다.</li>\n  <li>NGINX는 동시 커넥션을 유지한 채, 기존의 요청을 마저 처리하며, 뒷단의 서버를 추가할 수 있다.</li>\n  <li>이벤트 기반 구조이기 때문에 이러한 설정 변경을 초당 수십번 해도 무리없이 커넥션을 관리하고 요청을 서버에 전달할 수 있다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/842b0dc3-119e-4168-93f9-0e6b6f14b960\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : NetCraft Web Server Survey</em></p>\n\n<p>그런데 위 자료를 보면 의문이 든다.<br />\nNGINX가 탄생한 지 2004년부터 2007년 까지도 압도적으로 Apache가 1위를 차지하고 있다.</p>\n\n<p>이때까지만 해도 NIGNX는 소수의 문제 상황에 대한 해결책을 제시한 것 뿐이지,<br />\n대다수의 서비스를 가동하는 데에는 Apache로도 큰 문제가 없었다.</p>\n\n<h3 id=\"스마트폰의-탄생\">스마트폰의 탄생</h3>\n\n<p><img src=\"https://github.com/user-attachments/assets/2a75d845-635a-4d46-a0d2-68629d3fdd1f\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : NetCraft Web Server Survey</em></p>\n\n<p>2008년부터 급격하게 상황이 역전된다. 바로 <strong>스마트폰의 등장</strong> 때문이다.</p>\n\n<ul>\n  <li>단순히 ‘스마트폰의 등장 = 인터넷 사용자의 증가’의 이유가 아니다.</li>\n  <li>“<span class=\"post-highlight\">동시 커넥션을 훨씬 더 많이 생성한 계기</span>”로써 문제가 발생한다.</li>\n  <li>PC의 경우 클라이언트가 일정 시간 사용하고 전원을 끄는 방식으로 사용되었지만,<br />\n스마트폰은 실시간으로 정보를 받고 싶어하는 사용자의 니즈에 맞게 알림 등<br />\n<strong>동시 커넥션을 계속해서 유지</strong>하는 방식으로써 유용하게 사용되었다.</li>\n</ul>\n\n<p>이러다보니 “동시 커넥션 문제”가 현실로 다가온 것이다.</p>\n<ul>\n  <li>대규모 사이트들이 좋아할 만한 솔루션 이었고, NGINX는 급성장하게 된다.<br />\n(<em>현재 우리가 쿠버네티스고, 뭐고 배우는 이유도 이러한 문제의 솔루션으로써 대두된다는 것을 알고 넘어가자</em>)</li>\n</ul>\n\n<p>그렇다면 Apache는 가만히 있었을까?</p>\n\n<p>Apache도 MPM이라는 모듈을 추가해서 성능을 개선하기 시작한다.</p>\n\n<ul>\n  <li>Multi-Processing Module</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/acf7ede3-b612-417c-b4a5-82c352ba4c37\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>Apache 서버를 어떤 방식으로 운영할 지 선택할 수 있는 모듈이다.\n    <ul>\n      <li>안정성이나 소규모 프로젝트에서는 기존의 prefork 방식을</li>\n      <li>성능 향상이나 대규모 프로젝트에서는 worker라는 스레드를 만들어 worker가 요청을 처리하도록 했다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>그렇다면 왜 아직도 동시 커넥션 지표에서 NGINX가 Apache를 압도적으로 앞설까?</p>\n\n<div style=\"display: flex; justify-content: space-between; gap: 20px;\">\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/1b280974-4d15-4e5d-ac6c-c21e2093f673\" alt=\"Memory Usage\" style=\"width: 100%;\" />\n    </div>\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/6a787d51-fb2d-4c1f-a973-3f380a838d29\" alt=\"Requests Per Second\" style=\"width: 100%;\" />\n    </div>\n</div>\n<p style=\"text-align: center; color: #666;\">출처: dreamhost.com</p>\n\n<p>왼쪽 동시 커넥션 수당 메모리 사용률 지표를 보면,</p>\n<ul>\n  <li>NGINX는 동시 커넥션이 많아져도 메모리 사용률이 낮고 일정한 반면,<br />\nApache는 굉장히 많은 메모리 사용률을 요구한다.</li>\n</ul>\n\n<p>오른쪽 동시 커넥션 수가 많아졌을 때 처리하는 초당 요청 수 지표를 보아도,<br />\nNGINX가 Apache에 비해 압도적으로 많다.</p>\n<ul>\n  <li>NGINX가 커넥션 관리를 얼마나 잘하는 지 볼 수 있다.</li>\n</ul>\n\n<p>사실 지금까지 <strong>동시 커넥션</strong>이라는 포인트에만 집중해서 NGINX의 장점과 현재 많이 쓰이는 이유를 알아보았다.</p>\n\n<p><strong>그렇다면 Apache의 장점은 무엇이 있을까?</strong></p>\n\n<p><br /></p>\n\n<h2 id=\"2-4-apache가-아직-쓰이는-이유와-nginx의-단점\">2-4. Apache가 아직 쓰이는 이유와 NGINX의 단점</h2>\n\n<p>근본자체가 “NCSA HTTPd”라는 소프트웨어의 버그를 수정해오며 커온 Apache이기에,\n<span class=\"post-highlight\">호환성과 확장성의 측면</span>에서는 장점이 있다.</p>\n\n<p>아직도 오픈소스로써 활발한 수정과 개선이 이루어지고 있다. [<span class=\"post-highlight\">풍부한 모듈 생태계</span>]</p>\n<ul>\n  <li><a href=\"https://projects.apache.org/projects.html\">Apache는 현재에도 Apache Kafka, Apache Hadoop 등 시대에 발맞춰 발전 중이다</a>.</li>\n</ul>\n\n<p>또한, Apache는 여러 운영 체제(리눅스, 윈도우, 유닉스 등)에서 폭넓은 호환성과 안정성을 자랑한다.</p>\n\n<p>NGINX는 그렇지 않아서, Windows에서 성능이 매우 낮게 나온다.</p>\n<ul>\n  <li>NGINX는 원래 <strong>리눅스</strong> 환경에서 설계되었기 때문에, 리눅스 OS에서 최고의 성능이 나오며,</li>\n  <li>윈도우에서도 동작은 하지만,<br />\n윈도우의 <strong>비동기 I/O</strong> 시스템에 최적화되지 않았기 때문에 <strong>성능이 상대적으로 낮다</strong>.</li>\n</ul>\n\n<p>현재 서비스에서 큰 성능 문제 없이 잘 돌아가고 있고, 모듈을 계속해서 추가/제거할 일이 많다면 굳이 NGINX로 옮길 이유는 없는 것이다.</p>\n<ul>\n  <li>오해하면 안되는 것이 NGINX는 설정 변경과 이에 따른 Worker Process의 로직 변경이 무중단으로 이루어진다는 것이며,<br />\nNGINX는 모듈 자체를 동적으로 로드할 수 없으므로, 새 모듈을 추가하려면 재컴파일이 필요하다.</li>\n  <li>Apache는 설정 변경 없이 실행 중 동적 모듈 로드가 가능하므로, 특정 기능을 빠르게 추가하거나 제거할 때 더 유연하다.</li>\n</ul>\n\n<p><strong>둘은 서로 대립관계가 아니며, 목적이 다르게 탄생한 것이다.</strong></p>\n\n<p><br /></p>\n\n<h2 id=\"2-5-그렇다면-현재-nginx를-어떻게-이용해야-하는가\">2-5. 그렇다면 현재 NGINX를 어떻게 이용해야 하는가?</h2>\n\n<p>앞서 우리는 NGINX의 WS로써, 로드밸런싱으로서의 역할을 보았다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/04bf32c2-7d72-4229-a31e-2b3e639e6b2d\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>비동기 이벤트 기반 구조로 동시 커넥션 처리가 효율적이며, Reverse Proxy로써 서버 부하를 줄일 수 있다.</p>\n\n<p>이 자체로 웹 서버 가속(성능 개선) 역할을 한다.</p>\n\n<p>추가적으로 NGINX를 사용하며 고려해야할 관점이다.</p>\n\n<p><strong>1) SSL 터미네이션 역할을 한다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/baaa7488-05be-473f-8d84-27912891b0f3\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX가 앞단에서 SSL을 처리하여, 클라이언트와는 HTTPS로 통신하고, 뒷단 서버와는 HTTP로 통신하는 방식이다.</p>\n<ul>\n  <li>어차피, NGINX와 SERVER가 같은 네트워크 안에 있는 경우가 많기 떄문에,<br />\n이렇게 통신을 해도 보안 위험이 비교적 적다.</li>\n</ul>\n\n<p>이 방식은 뒷단 서버가 <span class=\"post-highlight\">복호화 과정에서 발생하는 부하를 줄이는 장점</span>이 있다.</p>\n\n<p><strong>2) 캐싱 역할을 한다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/6c43e842-cbfa-44fd-99e0-75b079dc4a20\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX는 &lt;span class=”post-highlight”HTTP 콘텐츠 캐싱&lt;/span&gt;을 지원하며,<br />\n이를 통해 서버 부하를 줄이고 클라이언트 요청에 빠르게 응답할 수 있습니다.</p>\n<ul>\n  <li>한 번 서버로부터 받은 응답을 스스로 보관하고 클라이언트에게 전달하므로 효율적이다.</li>\n</ul>\n\n<p>이러한 경우 1번과 달리 NGINX를 클라이언트와 가까운 곳(예: CDN이나 엣지 서버)에 배치하여<br />\n캐싱 효과를 극대화할 수 있다.</p>\n\n<p><strong>3)NGINX와 컨테이너화</strong></p>\n\n<p>현재 클라우드 네이티브와 컨테이너화가 대세인 환경에서, NGINX는 더욱 중요한 역할을 수행하고 있다.</p>\n\n<p>특히 Kubernetes의 Ingress Controller로서, 또는 마이크로서비스 아키텍처에서의 API Gateway로서 그 가치가 두드러진다.</p>\n\n<p>Kubernetes에서 Ingress Controller로 사용될 때, API Gateway로서의 설정 등등</p>\n<ul>\n  <li>이러한 설정들을 통해 NGINX는 현대적인 마이크로서비스 환경에서 트래픽 라우팅, 로드밸런싱, SSL 종료, API 게이트웨이 등 다양한 역할을 효율적으로 수행할 수 있다.</li>\n  <li>특히 컨테이너 환경에서는 가볍고 빠른 NGINX의 특성이 더욱 큰 장점으로 작용한다.</li>\n</ul>\n\n<p>이 외에도 HSTS, CORS 처리, TCP/UDP 커넥션 분산 부하, HTTP/2 지원 (최근에는 /3도 지원) 등 서버를 보완하는 역할을 할 수 있다.</p>\n\n<p>어떠한 기능이 있는지를 알아보고 상황에 따라 알맞는 기능을 적용하는 자세가 필요하다.</p>\n\n<hr />\n<p>참고: <a href=\"https://www.youtube.com/watch?v=mcnJcjbfjrs\" target=\"_blank\">우아한테크 [10분 테코톡] 알리의 Web Server vs WAS</a></p>\n\n<p><a href=\"https://www.youtube.com/watch?v=6FAwAXXj5N0\" target=\"_blank\">우아한테크 [10분 테코톡] 피케이의 Nginx</a></p>\n",
                        "tags": ["WebServer","Apache","NGINX","Architecture","DevOps","Network","Performance","LoadBalancing","ReverseProxy"]
                    }
                
            ],
        
            "DevOps": [
                
                    {
                        "title": "웹 서버(WS)의 진화",
                        "url": "/2025/01/27/ws-and-was.html",
                        "subtitle": "Apache vs NGINX",
                        "excerpt": "1. 웹서버(WS)에 대하여\n",
                        "author": "Jinho",
                        "date": "January 27, 2025",
                        "background": "/img/posts/apach_vs_nginx.jpeg",
                        "content": "<h1 id=\"1-웹서버ws에-대하여\">1. 웹서버(WS)에 대하여</h1>\n\n<h2 id=\"1-1-웹서버ws-란\">1-1. 웹서버(WS) 란?</h2>\n\n<p>NGINX, Apache 두 소프트웨어 모두 “<u>웹서버 소프트웨어</u>”이다.</p>\n\n<p>그렇다면 WS(웹서버)란 무엇일까?</p>\n\n<p>클라이언트의 HTTP 요청을 받아 <span class=\"post-highlight\">정적인 컨텐츠를 제공하는 서버 혹은 프로그램이다.</span></p>\n\n<p>이후에 다시 말하겠지만, WS는 정적인 컨텐츠를 서비스하는 데에 <strong>특화된</strong> 서버 소프트웨어이다.</p>\n<ul>\n  <li>동적인 콘텐츠를 처리 못한다는 것은 아니다.\n    <ul>\n      <li>참고로, Apache의 경우 자체적으로 동적인 컨텐츠 또한 처리가 가능하다.</li>\n    </ul>\n  </li>\n  <li>NGINX의 경우 불가능하다.\n    <ul>\n      <li>하지만, 동적 처리는 보통 WAS(Web Application Server)에서 주로 수행하므로, Web Server는 프록시 역할만 하면 충분하다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>여기서 주요한 점은 <span class=\"post-highlight\">“정적인 컨텐츠”</span>이다.</p>\n\n<p>html, JS 같은 정적인 컨텐츠들 정도는 웹서버를 구축한다면 웹서버 선에서 요청을 정리할 수 있다.</p>\n\n<h3 id=\"과거-2-tier-architecture\">과거 (2-tier Architecture)</h3>\n\n<p><img src=\"https://github.com/user-attachments/assets/a2d9a118-4b95-46ec-b303-a4b9c084f5eb\" alt=\"Image\" width=\"80%\" height=\"80%\" class=\"center\" /></p>\n\n<p>우선 과거의 버그가 많았던 초기의 웹서버(WS) 프로그램이 수정되고 개발된게 <strong>Apache</strong>이다.</p>\n\n<p>과거에 html, js, css 등과 같은 정적인 콘텐츠만을 주고 받는 구조에서는<br />\n<span class=\"post-highlight\">클라이언트 → WS [Apache] (정적 및 동적 요청 모두 처리) → DB</span> 만으로도 충분했다.</p>\n<ul>\n  <li>사실은 Apache의 경우, 정적/동적 모두 커버가 가능하기 때문에 기능적으로는 문제가 없었다.</li>\n  <li>하지만 다음과 같은 단점이 제기되었다.\n    <ul>\n      <li>동적 요청 처리가 필요할 경우, Apache가 너무 많은 부담을 가진다.</li>\n      <li>보안과 성능 측면에서 아쉬움이 있다.</li>\n      <li><em>그리고 이후에 다시 소개하겠다…</em></li>\n    </ul>\n  </li>\n  <li>그래서 앞단에 <u>정적 처리를 전문적으로 해주는 서버</u>가 있었으면 좋겠다는 생각을 하게 된다.</li>\n</ul>\n\n<p><br /></p>\n\n<h3 id=\"현재-3-tier-architecture\">현재 (3-tier Architecture)</h3>\n\n<p>정적/동적 컨텐츠에 대한 책임을 분리하고,<br />\n효율성과 확장성에 용이하기 위해 아키텍처가 발전했다.</p>\n\n<p><span class=\"post-highlight\">클라이언트 → [WS (정적 요청 처리) → WAS (동적 요청 처리)] → DB  </span><br />\n<em>(초기 발전 과정에서는 Apache가 WAS 역할로 동적 요청을 처리하고, 앞단에 정적 요청 처리를 NGINX가 붙는 방식으로 사용되었다.)</em></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/76082af9-7162-4a41-b5d4-be1d96020bfc\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>WAS는 동적 처리에 리소스 집중할 수 있게 되었고, 트래픽 증가에 유연한 대응이 가능하게 되었다.</p>\n<ul>\n  <li>소프트웨어 측면 말고, 개발자의 측면에서 보아도 효율적이다.\n    <ul>\n      <li>WS는 정적 파일, 보안, 로드밸런싱에만 집중하면 되고, WAS에서는 비즈니스 로직에만 집중하면 된다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><br /></p>\n\n<h1 id=\"2-apache와-nginx\">2. Apache와 NGINX</h1>\n\n<h2 id=\"2-1-apache-처리-방식-커넥션-기반\"><strong>2-1. Apache 처리 방식 (커넥션 기반)</strong></h2>\n\n<p>아파치는 <strong>Multi-Process Module</strong> 방식이다.<br />\n클라이언트가 요청 하나를 보내면, 하나의 process를 생성해서 연결한다.<br />\n요청당 프로세스/스레드 생성한다는 뜻이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/84ca44e3-a224-4f75-864d-f8f121f642da\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>이런 구조는 확장성 면에서 장점이 크다.<br />\n→ <span class=\"post-highlight\">이러한 측면에서 개발자들은 다양한 모듈을 만들어서 서버에 동적으로 빠르게 추가할 수 있는 장점이 있었다.</span></p>\n\n<p>하지만 다음과 같은 문제가 제기되었다.</p>\n\n<p>(🤔문제) <strong>프로세스 생성이 가벼운 작업이 아니기에, 매번 생성하기에는 너무 속도가 느려진다.</strong></p>\n\n<p>(✨발전 1) 요청 이전에 몇 개의 프로세스를 미리 만들어주는 prefork() 방식을 사용했다.</p>\n\n<p>(✨발전 2) 어찌됐든 매번 커넥션을 만드는 것은 비효율적이라고 판단했고, 이미 연결된 커넥션이 있다면 재활용하자는 생각을 한다.</p>\n<ul>\n  <li>http 헤더 종류 중에 keep-alive가 있다.</li>\n  <li><strong>→ Keep-Alive 옵션을 통해 일정 기간 동안 클라이언트와 Connection을 유지하는 방식</strong></li>\n</ul>\n\n<p><br /></p>\n\n<p>그러나 또 다른 문제가 제기되었다.</p>\n\n<p>(🤔또 다른 문제) <strong>클라이언트 수가 늘어나면서 결국 동시에 연결되어 있는 커넥션의 수도 매우 늘어나게 되었다.</strong></p>\n<ul>\n  <li>이렇게 동시 연결된 커넥션 수가 10,000개의 동시 연결을 넘어서는 순간, 서버는 더이상 커넥션을 형성하지 못하게 되는 현상이 발생했다. (<em>C10K 문제…</em>)</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/25bda5d5-aea5-4238-bc7b-3a499875a5e6\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>그런데 이 C10K 문제에서 하드웨어적으로 문제되는 것은 없었다.</li>\n  <li>이 당시 웹 페이지 용량 자체가 적었기 때문에 컴퓨터의 성능은 충분했지만,<br />\n비효율적인 서버의 구조 때문에 <strong>메모리 부족</strong> 현상이 일어난 것이다.</li>\n  <li>많은 커넥션에서 요청이 들어오기 시작하면, CPU 코어는 계속해서 프로세스를 바꿔가며 일을 해야 했다.</li>\n  <li>결론적으로, <strong>수 많은 동시 커넥션을 감당하기엔 아파치 서버의 구조가 적합하지 않았다.</strong></li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"2-2-nginx의-등장-이벤트-기반\"><strong>2-2. “NGINX”의 등장 (이벤트 기반)</strong></h2>\n\n<p>사실 NGINX는 Apache 를 대체하려고 나온 소프트웨어가 아니다.<br />\nNGINX는 Apache 앞 단에 붙여서 <span class=\"post-highlight\">보완하는 방식</span>으로 사용되었다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/c78538ef-1f3a-4e1a-b014-63afd34ca6c2\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>구조적으로 동시 커넥션을 많이 유지 못하는 아파치 서버의 부하를 nginx가 크게 줄일 수 있었다.</p>\n<ul>\n  <li><em>참고로,<br />\n[동시에 연결 가능한 커넥션 수(한 시점에 감당되는 동시 커넥션 수)] 와 초당 요청 처리 수는 다른 의미이다.</em></li>\n</ul>\n\n<p>이때 NGINX 가 정적인 페이지 처리를 모두 하고,<br />\nApache는 동적 파일 처리만 담당하는 (현대의 WAS 느낌) 구조로 바뀌게 되었다.</p>\n\n<p>그렇다면 어떻게 NGINX는 많은 동시 커넥션을 견뎌 낼 수 있을까?</p>\n\n<p><br /></p>\n\n<h3 id=\"nginx-처리-방식에-대해\">NGINX 처리 방식에 대해</h3>\n\n<p>Nginx는 Master-Worker 구조의 Process 방식을 채용했다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/a1d0bf67-8aca-4d49-8d74-690aaba06c50\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>Master Process는 설정파일에 맞게 실제 일하는 Worker Process를 만들어낸다.</p>\n\n<p>그리고 Worker가 만들어질 때 각자 지정된 Listen 소켓을 배정받는다.<br />\n(수신기를 받는다.)</p>\n\n<p>그리고 그 소켓에 새로운 클라이언트로부터 Request가 들어오면, 커넥션을 형성하고 요청을 처리한다.</p>\n<ul>\n  <li>마찬가지로 이 커넥션은 정해진 Keep-alive의 Timeout까지 연결을 유지하게 된다.</li>\n</ul>\n\n<p>하지만, Apache와의 차이는<br />\n<span class=\"post-highlight\">“그 커넥션이 형성되었다고 해서, Worker Process 1개가 그 커넥션 1개만을 담당하지는 않는다.”</span></p>\n<ul>\n  <li>형성된 커넥션에 아무런 요청이 없으면 새로운 커넥션을 형성하거나,<br />\n이미 만들어진 다른 커넥션으로부터 들어온 요청을 처리한다. (여러 커넥션을 쥐고 있는다.)</li>\n  <li>이런 <span class=\"post-highlight\">[커넥션 형성 / 커넥션 제거 / 새로운 요청 처리] 등을 모두 이벤트</span>라고 부른다.</li>\n</ul>\n\n<p>NGINX의 OS커널은 이러한 이벤트를 큐형식으로 줄세우고, Worker에게 전달한다.<br />\n<em>(멀티플레싱, epoll 에 대해 이해하면 어떻게 커널이 이벤트를 제공하는지 알 수 있다.)</em></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/26d73207-0e57-4358-894d-2f4450efcaf8\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">→ 는 커넥션 연결, O는 Request이며, 모두 “이벤트”이다.</em></p>\n\n<p>그리고 이 이벤트들은 큐에 담긴 채 비동기 방식으로 대기하고 있다.</p>\n\n<p>그리고 Worker Process는 하나의 스레드로 이벤트를 꺼내서 처리해 나간다.<br />\n이러면 Worker는 쉬지 않고 일을 계속 할 수 있다.</p>\n\n<p><span class=\"post-highlight\">요청이 없다면 방치되던 Apache의 구조보다 서버 자원을 훨씬 효율적으로 사용하는 셈</span>이다.</p>\n\n<p>(🤔문제) <strong>그런데 순서대로 꺼내서 쓰는 Queue에서 앞단에 들어오연 요청하나가 매우 시간이 오래걸리는 Disk I/O 작업이라면 어떨까..?</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d1abad7d-7b40-42be-9ff9-a293fe7a132b\" alt=\"Image\" width=\"60%\" height=\"100%\" class=\"center\" /></p>\n\n<p>매우 긴 IO 작업 중 큐에 대기하는 모든 이벤트들은 블로킹 될 것이다.</p>\n\n<p>(✨해결책) 오랜 기간 작업을 요하는 요청들을 위한 쓰레드 풀을 미리 만들어놓고,<br />\nWorker Process가 지금 처리하는 요청이 오래 걸린다고 판단되면,<br />\n해당 스레드 풀에 그 작업을 위임하고, 큐의 다른 이벤트를 처리하러 간다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/766c1772-fed9-4a42-b6ce-7fbbe7317f55\" alt=\"Image\" width=\"75%\" height=\"100%\" class=\"center\" /></p>\n\n<p>이러한 Worker Process 는 보통 Cpu의 코어 개수만큼 생성하고,<br />\n이러한 구조는 코어가 부담하는 Context Switch의 횟수를 대폭 줄일 수 있다.</p>\n\n<p>Apache와 비교하자면,</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/3e7909b6-7fd3-48df-b669-6b55a303b835\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>Apache\n    <ul>\n      <li>CPU가 여러 프로세스 간 스위칭</li>\n      <li>요청당 프로세스/스레드 필요</li>\n    </ul>\n  </li>\n  <li>Nginx\n    <ul>\n      <li>하나의 Worker Process가 이벤트 큐로 관리</li>\n      <li>단일 스레드로 여러 이벤트 처리</li>\n      <li>CPU 코어당 하나의 Worker 고정</li>\n      <li>이러한 <strong>Event-Driven Model이 Apache 구조와의 가장 큰 차이</strong>이다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"2-3-apache와-nginx\">2-3. Apache와 NGINX</h2>\n\n<p>항상 어떤 기술을 사용할 때에는 “최신 기술이여서”, “많이들 써서”가 이유가 될 수는 없다.</p>\n\n<p>어떤 기술, 어떤 아키텍처건 Trade-Off는 존재한다.</p>\n\n<p>과연 NGINX는 장점만 있을까?</p>\n\n<p>개발자가 <strong>기능(모듈) 추가를 시도했다가 돌아가고 있는 Worker Process를 종료해야 하는 상황</strong>이 생길 수 있다.</p>\n\n<p>그러면 <span class=\"post-highlight\">해당 Worker Process는 관리하고 있던 커넥션과 관려된 요청을 더이상 처리할 수 없다</span>는 문제가 발생한다.</p>\n<ul>\n  <li>그래서 NGINX는 개발자가 직접 모듈을 만들기에 좀 까다롭다.</li>\n</ul>\n\n<p>하지만, 단점보다 장점이 명확했다.</p>\n\n<p>수많은 동시 커넥션을 빠르게 처리하는 데에 있어 프로세스를 적게 만들다보니<br />\n(One Worker Process per CPU core)<br />\n⇒ 동시 커넥션 양 최소 10배 증가<br />\n⇒ 동일한 커넥션 수일 때 Apache에 비해 속도 2배 향상</p>\n\n<ul>\n  <li><strong>NGINX의 명확한 장점</strong>\n    <ol>\n      <li>One Worker Process per CPU core</li>\n      <li>Event-driven, asynchronous processing</li>\n      <li>Event Queue management</li>\n      <li>Thread Pool for long-running tasks</li>\n    </ol>\n  </li>\n</ul>\n\n<p>그리고 적은 프로세스는 관리가 쉽고, 새 Worker 생성 시 리소스 부담이 적다.</p>\n\n<p>이러한 구조는 “<span class=\"post-highlight\">NGINX가 설정을 동적으로 바꾸는 것</span>”을 가능하게 했다.</p>\n<ul>\n  <li>개발자가 설정 파일을 Runtime에 변경하고, NGINX에 적용하면,<br />\n이후부터는 Mater Process는 그 설정에 맞는 Worker Process를 찍어내게 된다.</li>\n  <li>그리고 기존 Worker Process에는 더이상 커넥션을 형성하지 못하게 막고,<br />\nQueue에 있는 이벤트들을 마저 처리한 뒤 기존 Worker들은 종료된다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/4f16c765-c2d8-44c2-850b-7c88a560dbb6\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>그런데 이러한 <strong>동적 설정 변경은 언제 사용</strong>할까?</p>\n<ul>\n  <li>대표적인 예로, NGINX가 여러 동시 커넥션을 관리하는 중에 뒷단에 새로운 서버를 추가하려는 상황이다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/b4f4191d-f32d-482f-a73c-6c14492350b2\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX는 이제부터 로드밸런싱 역할도 담당해야 한다.</p>\n\n<p>역할의 추가/변경이 의미하는 것은 무엇일까?</p>\n\n<ul>\n  <li>= Master Process가 찍어내야 하는 Worker Process의 역할의 추가/변경<br />\n= 기존 Connection 및 기존 Request들의 손실 없이 역할의 변경이 필요하다.</li>\n  <li>NGINX는 동시 커넥션을 유지한 채, 기존의 요청을 마저 처리하며, 뒷단의 서버를 추가할 수 있다.</li>\n  <li>이벤트 기반 구조이기 때문에 이러한 설정 변경을 초당 수십번 해도 무리없이 커넥션을 관리하고 요청을 서버에 전달할 수 있다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/842b0dc3-119e-4168-93f9-0e6b6f14b960\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : NetCraft Web Server Survey</em></p>\n\n<p>그런데 위 자료를 보면 의문이 든다.<br />\nNGINX가 탄생한 지 2004년부터 2007년 까지도 압도적으로 Apache가 1위를 차지하고 있다.</p>\n\n<p>이때까지만 해도 NIGNX는 소수의 문제 상황에 대한 해결책을 제시한 것 뿐이지,<br />\n대다수의 서비스를 가동하는 데에는 Apache로도 큰 문제가 없었다.</p>\n\n<h3 id=\"스마트폰의-탄생\">스마트폰의 탄생</h3>\n\n<p><img src=\"https://github.com/user-attachments/assets/2a75d845-635a-4d46-a0d2-68629d3fdd1f\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : NetCraft Web Server Survey</em></p>\n\n<p>2008년부터 급격하게 상황이 역전된다. 바로 <strong>스마트폰의 등장</strong> 때문이다.</p>\n\n<ul>\n  <li>단순히 ‘스마트폰의 등장 = 인터넷 사용자의 증가’의 이유가 아니다.</li>\n  <li>“<span class=\"post-highlight\">동시 커넥션을 훨씬 더 많이 생성한 계기</span>”로써 문제가 발생한다.</li>\n  <li>PC의 경우 클라이언트가 일정 시간 사용하고 전원을 끄는 방식으로 사용되었지만,<br />\n스마트폰은 실시간으로 정보를 받고 싶어하는 사용자의 니즈에 맞게 알림 등<br />\n<strong>동시 커넥션을 계속해서 유지</strong>하는 방식으로써 유용하게 사용되었다.</li>\n</ul>\n\n<p>이러다보니 “동시 커넥션 문제”가 현실로 다가온 것이다.</p>\n<ul>\n  <li>대규모 사이트들이 좋아할 만한 솔루션 이었고, NGINX는 급성장하게 된다.<br />\n(<em>현재 우리가 쿠버네티스고, 뭐고 배우는 이유도 이러한 문제의 솔루션으로써 대두된다는 것을 알고 넘어가자</em>)</li>\n</ul>\n\n<p>그렇다면 Apache는 가만히 있었을까?</p>\n\n<p>Apache도 MPM이라는 모듈을 추가해서 성능을 개선하기 시작한다.</p>\n\n<ul>\n  <li>Multi-Processing Module</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/acf7ede3-b612-417c-b4a5-82c352ba4c37\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>Apache 서버를 어떤 방식으로 운영할 지 선택할 수 있는 모듈이다.\n    <ul>\n      <li>안정성이나 소규모 프로젝트에서는 기존의 prefork 방식을</li>\n      <li>성능 향상이나 대규모 프로젝트에서는 worker라는 스레드를 만들어 worker가 요청을 처리하도록 했다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>그렇다면 왜 아직도 동시 커넥션 지표에서 NGINX가 Apache를 압도적으로 앞설까?</p>\n\n<div style=\"display: flex; justify-content: space-between; gap: 20px;\">\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/1b280974-4d15-4e5d-ac6c-c21e2093f673\" alt=\"Memory Usage\" style=\"width: 100%;\" />\n    </div>\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/6a787d51-fb2d-4c1f-a973-3f380a838d29\" alt=\"Requests Per Second\" style=\"width: 100%;\" />\n    </div>\n</div>\n<p style=\"text-align: center; color: #666;\">출처: dreamhost.com</p>\n\n<p>왼쪽 동시 커넥션 수당 메모리 사용률 지표를 보면,</p>\n<ul>\n  <li>NGINX는 동시 커넥션이 많아져도 메모리 사용률이 낮고 일정한 반면,<br />\nApache는 굉장히 많은 메모리 사용률을 요구한다.</li>\n</ul>\n\n<p>오른쪽 동시 커넥션 수가 많아졌을 때 처리하는 초당 요청 수 지표를 보아도,<br />\nNGINX가 Apache에 비해 압도적으로 많다.</p>\n<ul>\n  <li>NGINX가 커넥션 관리를 얼마나 잘하는 지 볼 수 있다.</li>\n</ul>\n\n<p>사실 지금까지 <strong>동시 커넥션</strong>이라는 포인트에만 집중해서 NGINX의 장점과 현재 많이 쓰이는 이유를 알아보았다.</p>\n\n<p><strong>그렇다면 Apache의 장점은 무엇이 있을까?</strong></p>\n\n<p><br /></p>\n\n<h2 id=\"2-4-apache가-아직-쓰이는-이유와-nginx의-단점\">2-4. Apache가 아직 쓰이는 이유와 NGINX의 단점</h2>\n\n<p>근본자체가 “NCSA HTTPd”라는 소프트웨어의 버그를 수정해오며 커온 Apache이기에,\n<span class=\"post-highlight\">호환성과 확장성의 측면</span>에서는 장점이 있다.</p>\n\n<p>아직도 오픈소스로써 활발한 수정과 개선이 이루어지고 있다. [<span class=\"post-highlight\">풍부한 모듈 생태계</span>]</p>\n<ul>\n  <li><a href=\"https://projects.apache.org/projects.html\">Apache는 현재에도 Apache Kafka, Apache Hadoop 등 시대에 발맞춰 발전 중이다</a>.</li>\n</ul>\n\n<p>또한, Apache는 여러 운영 체제(리눅스, 윈도우, 유닉스 등)에서 폭넓은 호환성과 안정성을 자랑한다.</p>\n\n<p>NGINX는 그렇지 않아서, Windows에서 성능이 매우 낮게 나온다.</p>\n<ul>\n  <li>NGINX는 원래 <strong>리눅스</strong> 환경에서 설계되었기 때문에, 리눅스 OS에서 최고의 성능이 나오며,</li>\n  <li>윈도우에서도 동작은 하지만,<br />\n윈도우의 <strong>비동기 I/O</strong> 시스템에 최적화되지 않았기 때문에 <strong>성능이 상대적으로 낮다</strong>.</li>\n</ul>\n\n<p>현재 서비스에서 큰 성능 문제 없이 잘 돌아가고 있고, 모듈을 계속해서 추가/제거할 일이 많다면 굳이 NGINX로 옮길 이유는 없는 것이다.</p>\n<ul>\n  <li>오해하면 안되는 것이 NGINX는 설정 변경과 이에 따른 Worker Process의 로직 변경이 무중단으로 이루어진다는 것이며,<br />\nNGINX는 모듈 자체를 동적으로 로드할 수 없으므로, 새 모듈을 추가하려면 재컴파일이 필요하다.</li>\n  <li>Apache는 설정 변경 없이 실행 중 동적 모듈 로드가 가능하므로, 특정 기능을 빠르게 추가하거나 제거할 때 더 유연하다.</li>\n</ul>\n\n<p><strong>둘은 서로 대립관계가 아니며, 목적이 다르게 탄생한 것이다.</strong></p>\n\n<p><br /></p>\n\n<h2 id=\"2-5-그렇다면-현재-nginx를-어떻게-이용해야-하는가\">2-5. 그렇다면 현재 NGINX를 어떻게 이용해야 하는가?</h2>\n\n<p>앞서 우리는 NGINX의 WS로써, 로드밸런싱으로서의 역할을 보았다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/04bf32c2-7d72-4229-a31e-2b3e639e6b2d\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>비동기 이벤트 기반 구조로 동시 커넥션 처리가 효율적이며, Reverse Proxy로써 서버 부하를 줄일 수 있다.</p>\n\n<p>이 자체로 웹 서버 가속(성능 개선) 역할을 한다.</p>\n\n<p>추가적으로 NGINX를 사용하며 고려해야할 관점이다.</p>\n\n<p><strong>1) SSL 터미네이션 역할을 한다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/baaa7488-05be-473f-8d84-27912891b0f3\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX가 앞단에서 SSL을 처리하여, 클라이언트와는 HTTPS로 통신하고, 뒷단 서버와는 HTTP로 통신하는 방식이다.</p>\n<ul>\n  <li>어차피, NGINX와 SERVER가 같은 네트워크 안에 있는 경우가 많기 떄문에,<br />\n이렇게 통신을 해도 보안 위험이 비교적 적다.</li>\n</ul>\n\n<p>이 방식은 뒷단 서버가 <span class=\"post-highlight\">복호화 과정에서 발생하는 부하를 줄이는 장점</span>이 있다.</p>\n\n<p><strong>2) 캐싱 역할을 한다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/6c43e842-cbfa-44fd-99e0-75b079dc4a20\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX는 &lt;span class=”post-highlight”HTTP 콘텐츠 캐싱&lt;/span&gt;을 지원하며,<br />\n이를 통해 서버 부하를 줄이고 클라이언트 요청에 빠르게 응답할 수 있습니다.</p>\n<ul>\n  <li>한 번 서버로부터 받은 응답을 스스로 보관하고 클라이언트에게 전달하므로 효율적이다.</li>\n</ul>\n\n<p>이러한 경우 1번과 달리 NGINX를 클라이언트와 가까운 곳(예: CDN이나 엣지 서버)에 배치하여<br />\n캐싱 효과를 극대화할 수 있다.</p>\n\n<p><strong>3)NGINX와 컨테이너화</strong></p>\n\n<p>현재 클라우드 네이티브와 컨테이너화가 대세인 환경에서, NGINX는 더욱 중요한 역할을 수행하고 있다.</p>\n\n<p>특히 Kubernetes의 Ingress Controller로서, 또는 마이크로서비스 아키텍처에서의 API Gateway로서 그 가치가 두드러진다.</p>\n\n<p>Kubernetes에서 Ingress Controller로 사용될 때, API Gateway로서의 설정 등등</p>\n<ul>\n  <li>이러한 설정들을 통해 NGINX는 현대적인 마이크로서비스 환경에서 트래픽 라우팅, 로드밸런싱, SSL 종료, API 게이트웨이 등 다양한 역할을 효율적으로 수행할 수 있다.</li>\n  <li>특히 컨테이너 환경에서는 가볍고 빠른 NGINX의 특성이 더욱 큰 장점으로 작용한다.</li>\n</ul>\n\n<p>이 외에도 HSTS, CORS 처리, TCP/UDP 커넥션 분산 부하, HTTP/2 지원 (최근에는 /3도 지원) 등 서버를 보완하는 역할을 할 수 있다.</p>\n\n<p>어떠한 기능이 있는지를 알아보고 상황에 따라 알맞는 기능을 적용하는 자세가 필요하다.</p>\n\n<hr />\n<p>참고: <a href=\"https://www.youtube.com/watch?v=mcnJcjbfjrs\" target=\"_blank\">우아한테크 [10분 테코톡] 알리의 Web Server vs WAS</a></p>\n\n<p><a href=\"https://www.youtube.com/watch?v=6FAwAXXj5N0\" target=\"_blank\">우아한테크 [10분 테코톡] 피케이의 Nginx</a></p>\n",
                        "tags": ["WebServer","Apache","NGINX","Architecture","DevOps","Network","Performance","LoadBalancing","ReverseProxy"]
                    }
                
            ],
        
            "Network": [
                
                    {
                        "title": "Packet Tracer로 네트워크 이해하기",
                        "url": "/2025/02/08/packet-tracer-network.html",
                        "subtitle": "LAN 토폴로지, 스위치, 라우터, 방화벽",
                        "excerpt": "LAN 토폴로지와 스위치\n",
                        "author": "Jinho",
                        "date": "February 08, 2025",
                        "background": "/img/posts/network_topology.jpeg",
                        "content": "<h1 id=\"lan-토폴로지와-스위치\">LAN 토폴로지와 스위치</h1>\n\n<hr />\n\n<h2 id=\"packet-tracer에-들어가기-전\">Packet Tracer에 들어가기 전</h2>\n\n<p>먼저 네트워크의 기본 구성 요소부터 이해해보자.</p>\n\n<p><strong>라우터, 스위치, 엔드 디바이스(PC, 서버 등)가 어떻게 상호 작용</strong>하는지 알아보자.</p>\n\n<ul>\n  <li>가장 기본적인 두 대의 디바이스(<code class=\"language-plaintext highlighter-rouge\">PC</code>)가 있다고 가정해보자.</li>\n  <li>두 PC를 연결하고, IP 주소 설정, 서브넷 마스크 설정을 하고 ping 테스트를 통해 연결.\n    <ul>\n      <li>이 과정에서 TCP/IP의 기본 개념을 이해해보자.</li>\n    </ul>\n  </li>\n  <li>그 다음 단계로 <code class=\"language-plaintext highlighter-rouge\">스위치</code>를 추가하여 여러 대의 <code class=\"language-plaintext highlighter-rouge\">PC</code>를 연결.\n    <ul>\n      <li>L2 통신의 개념과 MAC 주소의 역할을 이해해보자.</li>\n    </ul>\n  </li>\n  <li>마지막으로 <code class=\"language-plaintext highlighter-rouge\">라우터</code>를 추가하여 서로 다른 네트워크 간의 통신을 구현.\n    <ul>\n      <li>라우팅 테이블, 게이트웨이 등의 개념을 학습해보자.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"사용법\">사용법</h2>\n\n<h2 id=\"pc\">PC</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@tdMGa/btsMchWsAbo/pXUJ5sc1Jn5zlePiDz1mrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:264,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>장치 타입 → End Devices → PC / LAPTOP 등 Drag &amp; Drop</li>\n</ul>\n\n<h2 id=\"switch\">Switch</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bdJ1mb/btsMedLRoGJ/cpMkbVJahG5gP3qwnew9Uk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:194,”originHeight”:256,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"router\">Router</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@A02nQ/btsMeKJcj9q/usIeZ7q3BDrYQHVk4TpOuk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:208,”originHeight”:276,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"connection\">Connection</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@rOlnO/btsMdkEVmv0/U1xgvAbp826OCElZjbp2Sk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:280,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>실선은 Copper Straight [PC - Switch/Router]</li>\n  <li>점선은 Copper Cross - Over [Switch/Router … Switch/Router]</li>\n  <li>번개 모양은 Automatic</li>\n</ul>\n\n<h2 id=\"기본-사용-방법\">기본 사용 방법</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@mamWH/btsMdM8WmZV/J6Eve21yZP8cKJkdv8KQrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:666,”originHeight”:558,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>장치(PC 와 Laptop)들을 놓는다.</li>\n  <li>각 디바이스 개수만큼 연결한 스위치 추가</li>\n  <li>실선과 점선으로 연결</li>\n  <li>스위치 0 → 메뉴에서 FastEthernet0/1 선택</li>\n  <li>PC 0 → 메뉴에서 FastEthernet0 선택</li>\n  <li>(나머지도 동일하게 연결)</li>\n  <li>왼쪽 스위치 : <code class=\"language-plaintext highlighter-rouge\">FastEthernet0/2</code> 오른쪽 스위치 : <code class=\"language-plaintext highlighter-rouge\">FastEthernet0/3</code></li>\n  <li>PC 클릭 → Desktop → IP Configuration → IP Address에 <code class=\"language-plaintext highlighter-rouge\">198.168.0.1</code><br />\nSubnet Mask에 <code class=\"language-plaintext highlighter-rouge\">255.255.255.0</code>\n    <ul>\n      <li>나머지 장치는 IP 주소 ~0.2, ~0.3 순으로 입력</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dhy2rZ/btsMczo0VIn/LHz5KS8UijOguFkFqLdSSk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:338,”style”:”alignCenter”,”width”:780,”height”:206}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Desktop → Command Prompt로 ping 테스트</li>\n  <li>작업 공간에서 Simulation 가능 [실제 이동 경로 &amp; 헤더 정보 등을 볼 수 있다.]</li>\n</ul>\n\n<h2 id=\"lan-topology\">LAN Topology</h2>\n\n<ul>\n  <li>같은 로컬 에이리어 네트워크 (LAN) 내에서 네트워크 장비와 디바이스들이 어떻게 물리적 혹은 논리적으로 연결되어 있는지 나타내는 구조</li>\n</ul>\n\n<h2 id=\"lan과-wan\">LAN과 WAN</h2>\n\n<ul>\n  <li><strong>LAN (로컬 영역 네트워크)</strong>:\n    <ul>\n      <li>제한된 지역 내에서 연결된 네트워크</li>\n      <li><strong>스위치</strong>는 MAC 주소를 사용하여 네트워크 내 장치들 간에 데이터를 전달합니다. 스위치는 <strong>MAC 주소 테이블</strong>을 사용해 데이터를 해당 장치로 정확하게 전달</li>\n    </ul>\n  </li>\n  <li><strong>WAN (광역 네트워크)</strong>:\n    <ul>\n      <li>더 넓은 지역, 심지어 전 세계적으로 연결된 네트워크\n        <ul>\n          <li>인터넷이 대표적인 WAN 예시</li>\n        </ul>\n      </li>\n      <li>WAN에서는 서로 MAC 주소를 알 수 없음</li>\n      <li>WAN에서 라우터는 <strong>IP 주소</strong>를 기반으로 데이터를 전달하는데, 각 네트워크 간의 경로를 찾기 위해 <strong>라우팅 테이블</strong>을 사용\n        <ul>\n          <li>NAT / PAT</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cyma1b/btsMcdGGX7j/3HjkxSXXuguLBaXiMCtKp1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:933,”style”:”alignCenter”,”width”:757,”height”:552}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"1-bus-형\">1) Bus 형</h2>\n\n<ul>\n  <li>하나의 메인 케이블(백본)에 모든 노드가 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>구조가 단순하고 설치 비용이 저렴</li>\n      <li>노드 추가/제거가 쉽고 유연함</li>\n      <li>케이블 길이가 짧아 경제적</li>\n      <li>소규모 네트워크에 적합</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>트래픽 증가 시 성능 저하</li>\n      <li>메인 케이블 장애 시 전체 영향</li>\n      <li>데이터 충돌 발생 가능</li>\n      <li>보안 취약점 존재</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cdwQWE/btsMctoZGjP/YoLinRs4T7sWM3Iv3xCkfK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1138,”originHeight”:650,”style”:”alignCenter”,”width”:690,”height”:394}_#][#_Image</td>\n      <td>kage@XghRi/btsMc2doIc4/cDKKGHIAwzkFizYIthmvX1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:978,”originHeight”:456,”style”:”alignCenter”,”width”:620,”height”:289}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"2-ring-형\">2) Ring 형</h2>\n\n<ul>\n  <li>각 노드가 양옆의 두 노드와 연결되어 원형을 이루는 구조</li>\n  <li>자동선택 기능을 사용한 링</li>\n  <li>장점 :\n    <ul>\n      <li>데이터 흐름이 일정하고 예측 가능</li>\n      <li>충돌이 적고 전송이 안정적</li>\n      <li>각 노드가 리피터 역할 수행</li>\n      <li>장거리 전송에 유리</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>단일 노드 장애가 전체에 영향</li>\n      <li>네트워크 확장이 제한적</li>\n      <li>설치/제거 시 네트워크 중단</li>\n      <li>양방향 링 구성 시 비용 증가</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@lYUdr/btsMetVb0e8/23KtOkSs1PeRKuNml0S2AK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1108,”originHeight”:642,”style”:”alignCenter”,”width”:598,”height”:346}_#][#_Image</td>\n      <td>kage@rYlFs/btsMeKWHZEC/wFs32hn23rG7rKA9WFyKxK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:982,”originHeight”:460,”style”:”alignCenter”,”width”:621,”height”:291}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"3-star-형\">3) Star 형</h2>\n\n<ul>\n  <li>중앙에 허브가 있고 모든 노드가 이 허브에 직접 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>구현과 유지보수가 단순하고 직관적</li>\n      <li>개별 노드 장애가 다른 노드에 영향 없음</li>\n      <li>높은 성능과 데이터 전송 속도</li>\n      <li>중앙 집중적 보안 관리 용이</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>중앙 허브 장애 시 전체 네트워크 마비 - 단일 장애 지점 (SPOF)</li>\n      <li>허브에 과부하 발생 가능</li>\n      <li>케이블 설치 비용이 높음</li>\n      <li>허브 용량에 따른 확장성 제한</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@NJ0T7/btsMdF26Hzf/aEmXKMDwoG1TwsmUekA04K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1088,”originHeight”:678,”style”:”alignCenter”,”width”:627,”height”:391}_#][#_Image</td>\n      <td>kage@vFDga/btsMcTgvpqn/IDhAPb27H9xt3kN9pDOB7k/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:456,”style”:”alignCenter”,”width”:585,”height”:277}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"4-mesh-형\">4) Mesh 형</h2>\n\n<ul>\n  <li>모든 노드가 서로 직접 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>높은 안정성과 이중화 구성</li>\n      <li>효율적인 트래픽 분산</li>\n      <li>우회 경로 확보로 신뢰성 높음</li>\n      <li>뛰어난 보안성</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>설치/유지보수 비용이 매우 높음</li>\n      <li>구현과 설정이 매우 복잡</li>\n      <li>케이블 연결 관리가 어려움</li>\n      <li>노드 수 증가에 따른 복잡도 급증</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bb9BX4/btsMeahgXHL/gVJ4LgKjyCG8M1I6DkkbP0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1070,”originHeight”:674,”style”:”alignCenter”,”width”:628,”height”:396}_#][#_Image</td>\n      <td>kage@ovOWb/btsMb2rFLwg/Qi0orK06gCRkfnrkBXhvyK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:432,”style”:”alignCenter”,”width”:677,”height”:303}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"5-tree-형\">5) Tree 형</h2>\n\n<ul>\n  <li>계층적 구조로, 상위 노드에서 하위 노드로 분기되는 형태</li>\n  <li>장점 :\n    <ul>\n      <li>네트워크 확장이 용이</li>\n      <li>체계적인 계층 구조 관리</li>\n      <li>하위 네트워크 독립성</li>\n      <li>효율적인 트래픽 관리</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>루트 노드 장애 시 전체 영향</li>\n      <li>계층 증가에 따른 관리 복잡성</li>\n      <li>상위 노드 병목 현상 가능</li>\n      <li>깊이가 깊어질수록 지연 증가</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@wounf/btsMcywRCH9/2KnaYgagHLQKp4cBdcumy0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:985,”style”:”alignCenter”,”width”:765,”height”:589}_#][#_Image</td>\n      <td>kage@dI6An5/btsMd4hh7vI/Gxr1Nv7uKXeDV0vrZs1qT0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:960,”originHeight”:458,”style”:”alignCenter”,”width”:642,”height”:306}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>192.168.0.1 to 192.168.0.12</li>\n</ul>\n\n<h2 id=\"vlanvirtual-lan-case-1--switch-1개\">VLAN(Virtual LAN) (case 1 : Switch 1개)</h2>\n\n<h2 id=\"vlan이란\">VLAN이란?</h2>\n\n<p>“<strong>논리적인 구조의 속임수로 같은 물리적 공간에 있는 네트워크를 다른 네트워크에 있는 것처럼 속이는 기술</strong>”</p>\n\n<ul>\n  <li>먼저, 물리적인 LAN을 먼저 생각해보면, 같은 건물이나 같은 층에 있는 컴퓨터들이 하나의 네트워크로 연결되어 있는 구조이다.</li>\n  <li>그런데 예를 들면, 마케팅팀과 개발팀이 다른 네트워크에 있어야 한다고 가정해보자.\n    <ul>\n      <li>전통적인 방식이라면 물리적으로 별도의 네트워크 장비와 케이블을 설치해야 했다.</li>\n      <li>하지만, VLAN은 이런 물리적 제약을 소프트웨어적으로 해결한다.</li>\n    </ul>\n  </li>\n  <li>하나의 물리적인 스위치를 마치 여러 개의 독립된 스위치처럼 동작하게 만드는 기술이다.</li>\n  <li>예를 들어, 같은 스위치에 연결된 컴퓨터라도 서로 다른 VLAN에 속하면 마치 다른 네트워크에 있는 것처럼 통신이 분리된다.</li>\n</ul>\n\n<h2 id=\"초기-default-vlan-설정\">초기 default VLAN 설정</h2>\n\n<ul>\n  <li>show vlan으로 확인해보자.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bTHrGF/btsMea2FcPL/VagNQtcNTnfvH7OWzcKevk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1250,”originHeight”:974,”style”:”alignCenter”,”width”:670,”height”:522}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>처음 VLAN 1은 ‘기본 VLAN’이다.</li>\n  <li>모든 스위치 포트는 처음에 이 VLAN 1에 속하도록 설정되어 있다.\n    <ul>\n      <li>그래서 별다른 설정 없이는 같은 물리적인 공간에 있다면 한 네트워크에 속하도록 설정이 된다.</li>\n    </ul>\n  </li>\n  <li>그리고 VLAN 1002부터 1005까지는 특별한 목적으로 예약된 VLAN이다. (사용 불가)\n    <ul>\n      <li>FDDI, 토큰링 등으로 고정되어 있다.</li>\n    </ul>\n  </li>\n  <li>우리가 새로운 VLAN을 할당하려고 하면 “2 ~ 1001” 의 VLAN을 사용해서 나누면 된다.</li>\n</ul>\n\n<h2 id=\"vlan-구성하기\">VLAN 구성하기</h2>\n\n<ul>\n  <li>먼저 VLAN 2개를 생성한다.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch#enable\nSwitch#config terminal\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#vlan 2\nSwitch(config-if)#name VLAN_2\nSwitch(config-if)#exit\n</code></pre></div></div>\n\n<ul>\n  <li>enable : 관리자 모드 진입</li>\n  <li>config terminal : 글로벌 모드 진입</li>\n  <li>vlan 2 : vlan 모드 진입</li>\n  <li>name <이름> : 진입되어 있는 vlan의 이름 설정</이름></li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dsQlbd/btsMdqdX0ps/kPhix6BIWT0KDKtVJzq3NK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1185,”originHeight”:1000,”style”:”alignCenter”,”width”:734,”height”:619}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>결과</p>\n\n<ul>\n  <li>그리고, <code class=\"language-plaintext highlighter-rouge\">VLAN_2</code>엔 <code class=\"language-plaintext highlighter-rouge\">Fa0/1</code> 과 <code class=\"language-plaintext highlighter-rouge\">Fa0/2</code>, <code class=\"language-plaintext highlighter-rouge\">VLAN_3</code>엔 <code class=\"language-plaintext highlighter-rouge\">Fa0/3</code> 과 <code class=\"language-plaintext highlighter-rouge\">Fa0/4</code> 포트를 배정시킨다.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch#enable\nSwitch#config terminal\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#interface fa0/1\nSwitch(config-if)#switchport mode access\nSwitch(config-if)#switchport access vlan 2\n</code></pre></div></div>\n\n<ul>\n  <li>inteface fa0/1 : 인터페이스 모드 진입</li>\n  <li>switchport mode access : 해당 포트를 VLAN 전용으로 사용함을 선언</li>\n  <li>switchport access vlan 2 : 해당 포트가 속한 VLAN 번호 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@GEPhJ/btsMcd0ZUA9/NJfHXH7fr603Pozrp0XUN1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:779,”style”:”alignCenter”,”width”:697,”height”:424,”caption”:”결과”}_#][#_Image</td>\n      <td>kage@ZktHy/btsMceFDArB/GmkkKk7xrFmJK5XI7GNxS1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:975,”style”:”alignCenter”,”width”:686,”height”:523}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"vlan-통신-테스트\">VLAN 통신 테스트</h2>\n\n<ol>\n  <li><code class=\"language-plaintext highlighter-rouge\">192.168.0.1</code> to <code class=\"language-plaintext highlighter-rouge\">192.168.0.2</code>\n    <ul>\n      <li>같은 VLAN 내에서는 통신 가능</li>\n    </ul>\n  </li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@BqqF9/btsMceevW1X/38cHtm9y7VtBM8yRsEMKb1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:742,”originHeight”:340,”style”:”alignCenter”,”width”:653,”height”:299}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li><code class=\"language-plaintext highlighter-rouge\">192.168.0.1</code> to <code class=\"language-plaintext highlighter-rouge\">192.168.0.2</code></li>\n</ol>\n\n<ul>\n  <li>다른 VLAN 끼리는 통신 불가능</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@905VT/btsMcKD1XhO/HVQpVtHJXEQCpfTAUkHWYk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1060,”originHeight”:502,”style”:”alignCenter”,”width”:668,”height”:316}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"vlanvirtual-lan-case-2--switch-여러-개\">VLAN(Virtual LAN) (case 2 : Switch 여러 개)</h2>\n\n<ul>\n  <li>그렇다면 네트워크를 확장하고 좀 더 현실적인 아키텍쳐로 바뀌면 어떨까?</li>\n  <li>먼저 Switch를 하나 더 두어보자.</li>\n  <li><em>들어가기전</em>\n    <ul>\n      <li>VLAN 설정 자체는 IP 주소를 직접 변경하지 않는다.\n        <ul>\n          <li>VLAN은 Layer 2(데이터 링크 계층)에서 작동하는 반면,<br />\nIP 주소는 Layer 3(네트워크 계층)에서 작동하기 때문.</li>\n        </ul>\n      </li>\n      <li>그러나, 실제 네트워크 운영에서는 일반적으로 각 VLAN마다 서로 다른 IP 대역을 할당한다.\n        <ul>\n          <li>네트워크 관리와 보안을 위한 설계</li>\n        </ul>\n      </li>\n      <li>그러므로 VLAN 별로 다른 대역을 할당해보자.\n        <ul>\n          <li>VLAN 2: 203.237.20.nnn</li>\n          <li>VLAN 3: 203.237.30.nnn</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@pcw1H/btsMc0NoTlz/v9c56wkkpb2qWxKk6BEsq0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1031,”originHeight”:1000,”style”:”alignCenter”,”width”:680,”height”:660}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 0 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@d5TDWZ/btsMekcZbAx/1meC8Kjg2Niht4JKNpWjE1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:325,”style”:”alignCenter”,”width”:757,”height”:192}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 1 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bxI7Ez/btsMcsXSPgC/McV65YvUN8ELGhZbpqxaEK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:336,”style”:”alignCenter”,”width”:750,”height”:197}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>여기서 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>🤔 과연 PC2는 PC0과 통신이 가능할까?\n    <ul>\n      <li>결과를 보면, PC1과는 통신이 가능하지만, 다른 스위치로 넘어가면서 통신이 불가능해진다</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cdqmkw/btsMeSmNMeI/jnvpXenhi6dV8W4U8oGWaK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:994,”originHeight”:806,”style”:”alignCenter”,”width”:664,”height”:538}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>이런 논리적인 흐름의 질문이 든다.\n    <ol>\n      <li>오히려 VLAN 설정하기 전에 그냥 여러 스위치를 건너 뛰어도 통신이 됐음.</li>\n      <li>그리고 같은 VLAN 끼리는 통신이 된다고 했다.</li>\n      <li>그런데 갑자기 같은 VLAN에서 여러 스위치를 건너뛰면 왜 통신이 안될까?</li>\n    </ol>\n  </li>\n  <li>여기서 <strong>VLAN 태그</strong>라는 개념이 등장한다.\n    <ul>\n      <li>VLAN을 설정하면 각 패킷에는 특별한 VLAN ID가 붙게 된다.\n        <ul>\n          <li>(마치 우편물에 부서명을 적는 것과 같다.)</li>\n        </ul>\n      </li>\n      <li>일반적인 스위치의 Port(Access Port)는 VLAN 태그를 처리하는 방법에 대해 1가지 밖에 모른다.\n        <ul>\n          <li>PACKET 들어올 때 : 자신의 VLAN 번호를 태그로 붙인다.</li>\n          <li>PACKET 나갈 때 : 태그를 제거하고 보낸다.</li>\n        </ul>\n      </li>\n      <li>그럼 여기서 문제가 발생한다.\n        <ul>\n          <li>PC2에서 나온 패킷\n            <ul>\n              <li>Switch 0으로 들어올 때 : fa0/2에서 VLAN 2 태그를 붙임</li>\n            </ul>\n          </li>\n          <li>이 패킷이 fa0/5로 가면서 VLAN 1의 통신으로 취급됨 [VLAN 2 태그가 떨어짐]</li>\n          <li>다른 스위치의 fa0/3에 도착했을 때도 VLAN 1의 통신으로 인식됨</li>\n          <li>결과적으로 원래의 VLAN 2 통신이 의도대로 전달되지 못함.</li>\n        </ul>\n      </li>\n      <li>[즉, <strong>Switch0의 fa0/와 Switch1의 fa0/3이 VLAN 1이기 때문</strong>]</li>\n    </ul>\n  </li>\n</ul>\n\n<p>→ <strong>스위치 간 VLAN 전용 통로가 필요하다!</strong></p>\n\n<h2 id=\"트렁크trunk\">트렁크(Trunk)</h2>\n\n<p>[먼저 PC2가 PC0과 통신이 가능하도록 해결해보자]</p>\n\n<ul>\n  <li>Switch0과 Switch1간에 VLAN 2,3 전용 포트 따로 설정!</li>\n  <li>switch0의 fa0/5, fa0/6을 각각 VLAN 2,3 전용으로 설정</li>\n  <li>switch1의 fa0/3, fa0/4를 각각 VLAN 2,3 전용으로 설정</li>\n  <li>Switch 0 포트의 VLAN 상태</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b3x84T/btsMei0AEyD/DYcMw88NkSnY9eQ8B22zcK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1154,”originHeight”:64,”style”:”alignCenter”,”width”:699,”height”:39}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 1 포트의 VLAN 상태</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@URbjM/btsMdIyMTr2/uZ7hOtRQPSYbugPuyZe3s1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1064,”originHeight”:74,”style”:”alignCenter”,”width”:731,”height”:51}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC2에서 PC0로 통신이 가능하다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@AcI9Y/btsMeveoKpG/MRkQDsbDHXP76MV9pLzZR0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:956,”originHeight”:432,”style”:”alignCenter”,”width”:727,”height”:329}_#][#_Image</td>\n      <td>kage@cav9Br/btsMdpMVs7n/kO9tRv5kLVsRKP9bNXqDuK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:714,”originHeight”:510,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>그런데 또 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>🤔 과연 VLAN 별 통신 라인 추가가 바람직한 해결인가?\n    <ul>\n      <li>만약 VLAN이 수백개라면..?</li>\n      <li>일일이 연결해줄 수 없다</li>\n      <li>또한 추가 가능한 VLAN ID는 1000개.\n        <ul>\n          <li>→ <strong>Trunk</strong> 가 해결책</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"트렁크란\">트렁크란?</h2>\n\n<ul>\n  <li><strong>트렁크는 모든 VLAN 패킷을 하나의 포트로 통과시키는 것</strong></li>\n  <li>스위치 간 프레임 전달에 하나의 물리적 연결(포트)를 공유하는 것.</li>\n  <li>VLAN 트렁킹된 스위치들 간에 여러 VLAN에서 나온 프레임들을 이 트렁크를 통해 전달한다.</li>\n  <li>즉, 스위치와 스위치 간 프레임 전달 시 하나의 포트에 다수의 VLAN이 지나갈 수 있도록하는 링크.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch(config)#interface fa0/5\nSwitch(config-if)#switchport mode trunk\n\nSwitch(config-if)#\n%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to down\n\n%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to up\nexit\nSwitch(config)#exit\nSwitch#\n%SYS-5-CONFIG_I: Configured from console by console\nshow interface trunk\nPort        Mode         Encapsulation  Status        Native vlan\nFa0/5       on           802.1q         trunking      1\n\nPort        Vlans allowed on trunk\nFa0/5       1-1005\n\nPort        Vlans allowed and active in management domain\nFa0/5       1,2,3\n\nPort        Vlans in spanning tree forwarding state and not pruned\nFa0/5       none\n</code></pre></div></div>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cj9Kft/btsMcrLrqjC/NZkK8P615yIbq5LWFeBswk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:839,”style”:”alignCenter”,”caption”:”Switch0의 Fa0/5 포트 Trunk 설정”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li>Fa0/5가 트렁크 포트로 on (강제로 트렁크 모드로 설정) 되었다.</li>\n  <li>1~1005는 이론적으로 모든 VLAN 범위가 통과 가능하다.</li>\n  <li>실제 현재 사용 중인 VLAN : 1, 2, 3이 현재 활성화되어 있다.</li>\n  <li>Vlans in spanning tree forwarding state and not pruned : None<br />\n(활성화된 VLAN들이 여기 나타나야 한다. - 없다.)</li>\n</ol>\n\n<ul>\n  <li>Fa0/5 포트는 Native VLAN이 1로 설정됨</li>\n  <li>반대편 Fa0/3 포트는 Native VLAN이 2로 설정됨\n    <ul>\n      <li>Switch1의 Fa0/3 포트도 Trunk로 설정해준다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@kzW3S/btsMec7cVIK/IBXxcLCh7BYeCYd9J2nScK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1136,”originHeight”:414,”style”:”alignCenter”,”width”:654,”height”:238}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>물론 PC2에서 PC0로 통신이 가능해졌다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bryfWp/btsMcPE65aP/UGX9KHYfm1QMvME24buAtk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:956,”originHeight”:428,”style”:”alignCenter”,”width”:706,”height”:316}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"inter-vlan\">Inter-VLAN</h2>\n\n<ul>\n  <li>놓치면 안되는 것의 “<strong>기술의 도입에 대한 목적</strong>”이다.\n    <ul>\n      <li>VLAN의 목적은 가상의 LAN으로서 관리의 편리성 추구이며,<br />\n다른 VLAN과의 통신 제한이 아니다.</li>\n    </ul>\n  </li>\n  <li>그럼, 서로 다른 VLAN 간의 통신이 가능하도록 하는 방법은 없을까?</li>\n  <li>VLAN 간 통신을 하려면 라우터(게이트웨이)가 있어야 한다.\n    <ul>\n      <li>라우터를 경유하여 마치 다른 LAN으로 통신하는 것처럼 동작한다.</li>\n    </ul>\n  </li>\n  <li>[다른 네트워크 영역은 라우터가 필요!!!]</li>\n</ul>\n\n<h2 id=\"서브-인터페이스\">서브 인터페이스</h2>\n\n<ul>\n  <li>단순히 생각하면 이런 생각이 든다.</li>\n  <li>전통적인 라우터 방식: 각 VLAN마다 라우터의 물리적 인터페이스를 하나씩 사용</li>\n  <li>그러나 이런 생각의 전환을 해본다.\n    <ul>\n      <li><strong>하나의 물리적 라우터 인터페이스에 여러 개의 논리적 인터페이스를 생성하여 각각 다른 VLAN을 처리할 수 있도록 할 수 있다면?</strong></li>\n      <li>그런데, Fa0/0이라는 물리적 라우터 인터페이스에 어떻게 여러 개의 논리적 인터페이스를 생성할까?</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@Y1VKx/btsMeSUECM4/0Qz0wbAb4G4UBmT0SLhXYk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:260,”originHeight”:298,”style”:”alignCenter”,”width”:167,”height”:191}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>서브 인터페이스: 하나의 인터페이스에 여러 VLAN들의 인터페이스를 논리적으로 나누는 것</li>\n  <li>2811 모델을 추가해준다!\n    <ul>\n      <li>참고 :</li>\n      <li><em>2811 라우터는 Cisco의 중급 라우터로, Inter-VLAN 라우팅을 위한 서브인터페이스 구성을 지원합니다. 서브인터페이스란 하나의 물리적 인터페이스를 여러 개의 논리적 인터페이스로 나누어 사용할 수 있게 해주는 기능입니다. 이는 마치 하나의 도로를 여러 개의 차선으로 나누어 서로 다른 목적지로 가는 차들을 효율적으로 처리하는 것과 비슷합니다.</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p>1. fa0/0 활성화</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dysMoj/btsMcdzWje7/FkpECQDsjzhv7gtsA3SGI1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:846,”originHeight”:200,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>2. fa0/0.2 생성, VLAN2 연결, IP주소 할당 &amp; fa0/0.3 생성, VLAN3 연결, IP주소 할당</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b2QZaS/btsMb1M28tD/PwRCtfFGc9U9WdizCjU6pk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:691,”style”:”alignCenter”,”width”:790,”height”:426}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>3. switch1 fa0/4를 트렁크 모드로 설정</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bGoCk8/btsMdHT860Z/dwqr98u0ihaJDerscGQ7j1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1248,”originHeight”:546,”style”:”alignCenter”,”width”:718,”height”:314}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>4. Router의 서브 인터페이스 상태 확인</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bnyTgA/btsMevrWYog/pDkKHGHiWCNLKzR85a7Qn1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:219,”style”:”alignCenter”,”width”:819,”height”:140}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>5. 게이트웨이 설정</p>\n\n<p>- VLAN 2 (PC0, 1, 2) → 203.237.20.254</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bjr2GX/btsMey9WnrP/zNHfPdHwYlhyUSeIwsz6n0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:384,”style”:”alignCenter”,”width”:767,”height”:230}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>- VLAN 3 (Laptop0, 1, 2) → 203.237.30.254</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@9Pp8f/btsMcxY6pxv/toN6xYeoWLuqsvp1xIlJ90/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:606,”style”:”alignCenter”,”width”:773,”height”:366}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h1 id=\"스위치\">스위치</h1>\n\n<hr />\n\n<h2 id=\"스위치의-동작-원리\">스위치의 동작 원리</h2>\n\n<h2 id=\"mac-주소-테이블-동작-원리\">MAC 주소 테이블 동작 원리</h2>\n\n<ul>\n  <li>스위치와 노드들이 <strong>ARP</strong>를 통해 MAC 주소 정보를 지속적으로 교환한다.\n    <ul>\n      <li>ARP 프로토콜에 포함된 MAC 주소 정보를 기반으로 스위치의 MAC 주소 테이블이 구축된다.</li>\n      <li>실제 데이터 전송 (ping 등)이 발생하면, 이 MAC 주소 테이블을 참조하여 패킷을 적절한 포트로 전달</li>\n    </ul>\n  </li>\n  <li>MAC 주소 테이블은 네트워크 토폴리지 변화를 반영하기 위해 일정 주기로 초기화되며, 최신 정보로 동적 갱신된다.</li>\n</ul>\n\n<h2 id=\"arp란\">ARP란?</h2>\n\n<ul>\n  <li>IP 네트워크에서 IP 주소를 물리적인 MAC 주소로 변환하는 핵심 프로토콜</li>\n  <li>컴퓨터가 같은 네트워크 상의 다른 장치와 통신하려면 반드시 상대방의 MAC 주소를 알아야 하는데,<br />\nARP가 이 주소 변환 과정을 자동으로 처리해준다.</li>\n</ul>\n\n<h2 id=\"arp를-활용한-동작-원리\">ARP를 활용한 동작 원리</h2>\n\n<p><em>PC0에서 Laptop0으로 ping을 보낸다고 가정</em></p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cDoPQ4/btsMdLhTSuP/NdTWBqnwp8pAXYoKUrWZrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:988,”originHeight”:436,”style”:”alignCenter”,”width”:742,”height”:327}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li>ARP Request (PC0 → Switch0)\n    <ul>\n      <li>PC0이 Laptop0의 MAC 주소를 알아내기 위해 ARP 요청 패킷 전송</li>\n      <li>패킷 내용:\n        <ul>\n          <li>출발지: PC0의 IP 주소와 MAC 주소</li>\n          <li>목적지: Laptop0의 IP 주소 (MAC 주소는 미확인 상태)</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>스위치 <strong>브로드캐스트</strong> (Switch0 → 모든 노드)\n    <ul>\n      <li>Switch0은 PC0의 <strong>MAC 주소를 자신의 테이블에 기록</strong></li>\n      <li>수신한 ARP 요청 패킷을 모든 포트로 브로드캐스트</li>\n    </ul>\n  </li>\n  <li>ARP reply (Laptop0 → Switch0)\n    <ul>\n      <li>Laptop0이 자신의 IP 주소를 확인하고 ARP 응답 패킷 생성</li>\n      <li>패킷 내용:\n        <ul>\n          <li>출발지: Laptop0의 IP 주소와 MAC 주소</li>\n          <li>목적지: PC0의 IP 주소와 MAC 주소</li>\n        </ul>\n      </li>\n      <li>Laptop0은 PC0의 MAC 주소를 자신의 ARP 캐시에 저장</li>\n    </ul>\n  </li>\n  <li>스위치 전달 단계 (Switch0 → PC0)\n    <ul>\n      <li>Switch0은 수신한 응답 패킷을 PC0에게 전달</li>\n      <li>PC0과 Laptop0의 MAC 주소 정보를 MAC 주소 테이블에 저장</li>\n    </ul>\n  </li>\n  <li>통신 시작\n    <ul>\n      <li>PC0이 Laptop0의 MAC 주소를 획득하여 실제 데이터 통신 가능</li>\n    </ul>\n  </li>\n</ol>\n\n<h2 id=\"시뮬레이션\">시뮬레이션</h2>\n\n<ul>\n  <li>시뮬레이션을 눌러서 이벤트 목록창을 볼 수 있다.</li>\n  <li>편지봉투 모양의 [Add Simple PDU] → ICMP 패킷 전송 시뮬레이션</li>\n  <li>송신노드와 수신 노드를 클릭하고 Show All/None 클릭 후 ARP, ICMP 패킷만 클릭한다.</li>\n  <li><em>PC0에서 Laptop0으로 편지를 보낸다.</em></li>\n  <li>ARP - ICMP 순으로 통신이 이루어진다.</li>\n</ul>\n\n<h2 id=\"1-arp-패킷-분석\">1) ARP 패킷 분석</h2>\n\n<p>1. PC0 → Switch0 ARP Request</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cwVj4Z/btsMcHN0AZ1/QtiRKPTAkw5cwMHngIJq5K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:900,”originHeight”:1158,”style”:”alignCenter”,”width”:522,”height”:672}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>ARP\n    <ul>\n      <li>Source MAC<br />\n= PC0 의 MAC 주소</li>\n      <li>Source IP<br />\n= PC0의 IP 주소</li>\n      <li>Target MAC<br />\n= Laptop 의 MAC 주소 [모르는 주소]</li>\n      <li>Target IP<br />\n= Laptop0의 IP주소</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2. Switch0 → 모든 노드 (브로드캐스트)</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dvlpX3/btsMdr43c4X/YNHxFWmjmqgayudoXkG1l0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:818,”originHeight”:124,”style”:”alignCenter”,”width”:594,”height”:90}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch0은 수신한 ARP Request를 모든 포트로 전달</li>\n  <li>Switch0의 MAC 주소 테이블에 PC0의 정보 기록\n    <ul>\n      <li>포트 번호와 PC0의 MAC 주소 매핑</li>\n    </ul>\n  </li>\n</ul>\n\n<p>3. Laptop0→ Switch0 ARP Reply</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@K4KvV/btsMcdUawiw/VpUysCPR5W9T4yYTKTcqJK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1002,”originHeight”:1242,”style”:”alignCenter”,”width”:627,”height”:777}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>ARP\n    <ul>\n      <li>Source MAC<br />\n= Laptop0 의 MAC 주소</li>\n      <li>Source IP<br />\n= Laptop0의 IP 주소</li>\n      <li>Target MAC<br />\n= PC0 의 MAC 주소</li>\n      <li>Target IP<br />\n= Laptop0의 IP주소</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"2-icmp-패킷-분석\">2. ICMP 패킷 분석</h2>\n\n<ol>\n  <li>PC → Laptop</li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@6AWAV/btsMdMA4Jmh/dd2ilCfmHRbqRt9DFVNWhK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2056,”originHeight”:1186,”style”:”alignCenter”,”width”:690,”height”:398}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>SRC ADDR = PC0의 MAC 주소</li>\n  <li>DEST ADDR = Laptop0의 MAC 주소</li>\n</ul>\n\n<h2 id=\"3-switch0의-mac-주소-테이블-변화\">3) Switch0의 MAC 주소 테이블 변화</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dEbxME/btsMdnn7IXG/koFfWfejqCW9bxxbzaYPb0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1080,”originHeight”:611,”style”:”alignCenter”,”width”:747,”height”:423}_#][#_Image</td>\n      <td>kage@WjEAg/btsMdmbIixx/in3AqgZZ7OkLwPpGkcb270/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1080,”originHeight”:734,”style”:”alignCenter”,”width”:727,”height”:494}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>위를 보니 Fa0/1 Fa0/4에 연결된 PC0과 Laptop0의 MAC 주소가 테이블에 기재되었다.</li>\n</ul>\n\n<p>🤔 갑자기 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>Switch0 → 모든 노드로 BroadCast할 때 각자의 MAC 주소 받아오면 되는거 아닌가?</li>\n  <li>해답은 ARP를 이용해 MAC 주소 테이블이 어떻게 유지하는지의 방법에 있다.\n    <ul>\n      <li>스위치의 MAC 주소 학습은 ‘출발지(Source) MAC 주소’만을 대상으로 한다.\n        <ul>\n          <li>PC0이 ARP Request를 보낼 때</li>\n          <li>Laptop0이 ARP Reply를 보낼 때</li>\n        </ul>\n      </li>\n      <li>모든 노드로 전달된 ARP-Request 패킷에 대해 수신 노드가 아니면 응답하지 않는다.</li>\n      <li>PC1과 Laptop1은 Swtich0이 전달한 ARP-Request에 대해 Reply 하지 않는다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>그런데 이런 ‘고민’도 떠오른다.</p>\n\n<p>1.효율성</p>\n\n<ul>\n  <li>ARP는 매우 짧은 시간 간격으로 반복 실행한다.\n    <ul>\n      <li>노드들이 많은 네트워크에서는 통신량으로 부하 가중</li>\n      <li>특히 스위치가 모든 노드에게 BroadCast하는 ARP-Request에서</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2. 보안상의 문제</p>\n\n<ul>\n  <li>Laptop1이 악의적인 공격자라고 가정해보자.\n    <ul>\n      <li>ARP Reply가 실제로 해당 IP 주소를 가진 정당한 장치에서 온 것인지 확인하지 않는다. (보안 X)</li>\n      <li>이 때 Laptop0의 IP에 Laptop1 MAC 주소를 실어서 Reply한다면?</li>\n      <li>테이블이 제대로 갱신되기 전까지 PC0은 Laptop0인 줄 알고 모든 패킷을 보낸다.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"vlan을-통한-해결\">VLAN을 통한 해결</h2>\n\n<ul>\n  <li>MAC 주소를 이용한 라우팅\n    <ul>\n      <li>동일한 네트워크(LAN)에서 스위치를 통해서만 발생한다.</li>\n      <li>라우터를 통한 외부 네트워크로의 통신에는 사용되지 않는다.\n        <ul>\n          <li>ARP 패킷은 하나의 네트워크에서만 송수신한다.</li>\n          <li>LAN을 논리적으로 분리된 가상의 VLAN으로 관리한다.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h1 id=\"라우터\">라우터</h1>\n\n<hr />\n\n<h2 id=\"라우터란\">라우터란?</h2>\n\n<ul>\n  <li>라우터는 서로 다른 네트워크를 연결하는 3계층 장비.</li>\n  <li>IP 주소를 기반으로 패킷의 최적 경로를 결정하고 전달한다.\n    <ul>\n      <li>스위치가 같은 네트워크 내에서 MAC 주소를 기반으로 통신을 담당한다면,</li>\n      <li>라우터는 서로 다른 네트워크 간의 통신을 가능하게 만드는 일종의 ‘네트워크 간의 다리’ 역할을 한다.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"라우터의-mode\">라우터의 Mode</h2>\n\n<ul>\n  <li><strong>사용자 모드(User EXEC Mode)</strong>\n    <ul>\n      <li>기본적인 정보 조회만 가능, 설정 변경 불가</li>\n      <li>&gt; 로 표시</li>\n    </ul>\n  </li>\n  <li><strong>관리자 모드(Privileged EXEC Mode)</strong>\n    <ul>\n      <li>라우터 설정을 변경할 순 없지만 시스템 정보 상세조회 가능</li>\n      <li># 으로 표시</li>\n    </ul>\n  </li>\n  <li><strong>글로벌 모드(Global Configuration Mode)</strong>\n    <ul>\n      <li>라우터 설정(이름, 보안, 인터페이스 등)을 변경</li>\n      <li>(config)# 로 표시</li>\n      <li><strong>라인 모드(Line Configuration Mode)</strong>\n        <ul>\n          <li>콘솔, 원격 접속(Telnet, SSH 등) 관련 설정 변경</li>\n          <li>(config-line)# 로 표시</li>\n        </ul>\n      </li>\n      <li><strong>인터페이스 모드(Interface Configuration Mode)</strong>\n        <ul>\n          <li>라우터의 네트워크 인터페이스(이더넷, 시리얼 등) 설정을 변경</li>\n          <li>라우터의 인터페이스에 IP 주소를 설정하고 활성화/비활성화</li>\n          <li>(config-if)# 로 표시</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"목표-네트워크-구성\">목표 네트워크 구성</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@FrASQ/btsMeLVCXVC/1wKsZjYPW9BikRxL7DFtC1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:813,”originHeight”:495,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"기본-설정\">기본 설정</h2>\n\n<ul>\n  <li>라우터 3대: [Network Devices] → [Routers] → [2811]</li>\n  <li>스위치 1대 : [Network Devices] → [Switches] → [2960]</li>\n  <li>PC 3대, 노트북 1대, 서버 1대 : [End Devices] → [PC], [Laptop], [Server]</li>\n</ul>\n\n<h2 id=\"라우터---시리얼-인터페이스-장착\">라우터 - 시리얼 인터페이스 장착</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@zgPDU/btsMd3bDPMR/E6TXH94lrMz3OrUR6TF5hK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:1293,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC와 달리 두 라우터 간에 데이터를 주고받기 위한 동기화가 필요</li>\n  <li>FastEthernet이 아닌 Serial 인터페이스를 사용하므로 모듈을 추가해야 한다.\n    <ul>\n      <li>HWIC-2T 추가</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"노드-간-연결하기\">노드 간 연결하기</h2>\n\n<ul>\n  <li>Laptop0은 통신용이 아니라 Router0을 설정하기 위한 콘솔\n    <ul>\n      <li>FastEthernet 케이블이 아닌 RS232(하늘색) 케이블로 연결</li>\n    </ul>\n  </li>\n  <li>라우더들끼리 Serial DCE 연결\n    <ul>\n      <li>먼저 클릭한 쪽에 시계 모양 - 두 라우터 간 데이터를 주고받기 위한 동기화가 필요</li>\n      <li>Serial DCE(Data Communication Equipment): 시간 동기화를 주도하는 노드 (시계 있는 쪽)</li>\n      <li>Serial DTE(Data Terminal Equipment): 그에 따라 동기화하는 노드 (시계 없는 쪽)</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@evpmpX/btsMdMnzPql/PLX7aieEhAKMJ6N99C2j5K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2184,”originHeight”:1246,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"ip-설정\">IP 설정</h2>\n\n<ul>\n  <li>컴퓨터들은 203.237.nnn.nnn/24 사용(C클래스)\n    <ul>\n      <li>1번부터 시작</li>\n    </ul>\n  </li>\n  <li>원격 관리가 필요한 스위치나 서버는 100번 부터</li>\n  <li>라우터는 광역의 랜들을 연결하므로 A클래스 IP 사용\n    <ul>\n      <li>규모가 작아 30비트 서브넷 마스크를 사용하여 최대 4개의 라우터를 묶을 수 있도록</li>\n    </ul>\n  </li>\n  <li>스위치는 2계층 장비\n    <ul>\n      <li>IP 주소 설정 불필요</li>\n      <li>원격 접속으로 스위치 관리\n        <ul>\n          <li>IP 주소 할당 필요</li>\n          <li>VLAN1에 할당</li>\n        </ul>\n      </li>\n      <li>스위치 IP 주소 설정</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bk8xpK/btsMd7Sxxul/dQMOVhudaYmzsa519EoeQK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1374,”originHeight”:164,”style”:”alignCenter”,”width”:635,”height”:76}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>총 6개의 LAN</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@UGTSj/btsMcKRyRRh/QFOQKnpr0nm0a6K8eUWWKk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1762,”originHeight”:1000,”style”:”alignCenter”,”width”:698,”height”:396}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"연결-확인\">연결 확인</h2>\n\n<ul>\n  <li>PC0에서 테스트</li>\n</ul>\n\n<ol>\n  <li>PC0 로컬 호스트(127.0.0.1)</li>\n  <li>PC0 → Switch1(VLAN1, 203.237.10.100)</li>\n  <li>PC0 → Server0(203.237.10.101)</li>\n  <li>PC0 → Router0(203.237.10.254)\n    <ul>\n      <li>모두 통신 성공</li>\n    </ul>\n  </li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@s9v2J/btsMcYPw7T1/QedNlAylJ9wAnApW81hp3K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1000,”originHeight”:1605,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>5. PC0 → PC2(203.237.30.1)</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@mi021/btsMdHGFlHG/cChGsiN9Pw0rWY0kG0w7q1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:996,”originHeight”:374,”style”:”alignCenter”,”width”:684,”height”:257}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><strong>unreachable</strong> 이 발생한다\n    <ul>\n      <li>PC0으로 부터 받은 패킷을 Router0이 어느 인터페이스로 보내야할지 모르기 때문</li>\n      <li>→ <strong>라우팅 테이블</strong>이 필요하다</li>\n      <li>아래는 Router0의 라우팅 정보</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@beagrf/btsMdMujNSG/uzGad36EzxcCPqRZ3PJy21/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1260,”originHeight”:698,”style”:”alignCenter”,”width”:746,”height”:413}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"정적-라우팅-설정\">정적 라우팅 설정</h2>\n\n<ul>\n  <li>정적 라우팅 대상\n    <ul>\n      <li>1번 PC0 입장에서 목적지가\n        <ul>\n          <li><strong>2번</strong> 네트워크(203.237.20.nnn/24)인 패킷 : serial0/3/0 (혹은 1.1.1.2)</li>\n          <li><strong>3번</strong> 네트워크(203.237.30.nnn/24)인 패킷 : serial0/3/1 (혹은 2.2.2.2)</li>\n          <li>6번 네트워크(3.3.3.nnn/30)인 패킷 : serial0/3/0 혹은 serial0/3/1</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>Router1의 정적 라우팅 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@JLnX1/btsMckFDkMJ/ik8vROKAHLaZQPxINyMSmK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1226,”originHeight”:442,”style”:”alignCenter”,”width”:694,”height”:250}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Router2의 정적 라우팅 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@k4yPj/btsMexiTcvl/Ewo59hWdxO2tOqMp9GTtNK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1248,”originHeight”:504,”style”:”alignCenter”,”width”:736,”height”:297}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Router3의 정적 라우팅 설정 + route 확인</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cnu0SN/btsMdH0043d/jjkekr1KEkmqtXM0E7LRUK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1270,”originHeight”:1186,”style”:”alignCenter”,”width”:756,”height”:706}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"통신테스트-by-ping\">통신테스트 by ping</h2>\n\n<ul>\n  <li>PC0 ↔ PC1</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dD0uXu/btsMb0Hnvj9/50DKkNchVlTaBfBiYNEMiK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:962,”originHeight”:422,”style”:”alignCenter”,”width”:730,”height”:320}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC0 ↔ PC2</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cEoaLU/btsMdGgIz36/93lJ36D1HjrKK9gQaOKvb1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:432,”style”:”alignCenter”,”width”:780,”height”:350}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h1 id=\"방화벽---네트워크-구성\">방화벽 - 네트워크 구성</h1>\n\n<hr />\n\n<h2 id=\"망구성\">망구성</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@kO9qL/btsMengxOIb/FFIVXRjKkeW6JnSOKHGXqk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:524,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"asa0-구성-설정\">ASA0 구성 설정</h2>\n\n<p>1. 인터페이스 통신 상태</p>\n\n<ul>\n  <li>내부망 : 통신 가능</li>\n  <li>외부망 : 통신 불가\n    <ul>\n      <li>inPC → outPC 불가능</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bh2bBN/btsMd7rqkl0/g4AYl1hwkqpXZ1NDwCwO30/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1278,”originHeight”:266,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>2. IP 주소 설정</p>\n\n<ul>\n  <li>Inside : 설정됨</li>\n  <li>outside : 설정되어있지 않음\n    <ul>\n      <li>→ VLAN에서 203.237.20.253으로 설정</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cormPm/btsMc1r1E8A/LKXIkkQ8YcBwbHGgFGWQIk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1406,”originHeight”:342,”style”:”alignCenter”,”width”:807,”height”:196}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>3. Config 확인</p>\n\n<ul>\n  <li>내부망 Security-level : 100</li>\n  <li>외부망 Security-level : 0</li>\n  <li>보안 레벨이 높은 곳 → 낮은 곳 : 허용 (반대는 불가능)</li>\n  <li>내부망 노드들은 DHCP를 이용하여 IP 할당받는다.</li>\n</ul>\n\n<h2 id=\"inpc-dhcp-설정\">inPC DHCP 설정</h2>\n\n<ul>\n  <li>inPC는 ASA가 DHCP로 주소를 할당해준다고 했다.\n    <ul>\n      <li>게이트웨이는 ASA0 inside의 ip 주소로 고정된다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@HAypL/btsMemIHLU2/tcja6hVK1aurUDoEGiKLAK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1388,”originHeight”:636,”style”:”alignCenter”,”width”:703,”height”:322}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>outPC는 고정 주소 사용 중</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@lNS8u/btsMdHzVPu4/iHvbzNmifAq1gElLiDlpW1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1304,”originHeight”:546,”style”:”alignCenter”,”width”:707,”height”:296}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"router0-설정\">Router0 설정</h2>\n\n<ul>\n  <li>fa0/0 IP 설정 &amp; 활성화\n    <ul>\n      <li>203.237.10.254/24</li>\n    </ul>\n  </li>\n  <li>fa0/0 IP 설정 &amp; 활성화\n    <ul>\n      <li>203.237.20.253/24</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"rna-설정\">RNA 설정</h2>\n\n<h2 id=\"routing\">Routing</h2>\n\n<ul>\n  <li>라우터의 정적라우팅\n    <ul>\n      <li>네트워크 디바이스들이 서로 다른 네트워크에 있을 때, 그들 사이의 통신 경로를 명확히 지정해줘야 한다.</li>\n      <li>예를 들어, 내부 네트워크의 PC가 다른 네트워크의 서버와 통신하려면, 그 경로를 알아야 한다.</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">ip route &lt;목적지 네트워크 주소&gt; &lt;목적지 서브넷 마스크&gt; &lt;다음 홉 IP 주소/출구 인터페이스&gt;</code></li>\n    </ul>\n  </li>\n  <li>방화벽의 정적라우팅\n    <ul>\n      <li>트래픽이 반드시 방화벽을 통과하도록 하여 보안 정책을 적용할 수 있게 한다.</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">route &lt;VLAN명&gt; &lt;외부망 네트워크 주소&gt; &lt;외부망 서브넷마스크&gt; &lt;다음 홉 IP 주소&gt;</code></li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@UMo4w/btsMemPruKw/su6TBN30w2NLPGdTiu8nN0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2110,”originHeight”:1000,”style”:”alignCenter”,”width”:734,”height”:348}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>→ 어떤 목적지 주소를 갖는 패킷이든 외부망의 Router0인 203.207.20.254로 전송한다.</p>\n\n<ul>\n  <li>통신확인</li>\n  <li>inPC ↔ ASA0</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@ea7sUx/btsMcHURKDV/D3ikyzQhpSkEa8QCBP2sK1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:972,”originHeight”:428,”style”:”alignCenter”,”width”:708,”height”:312}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>inPC ↔ outPC</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b7mUIE/btsMcfqYrdM/SvtR3wkJNdKRzXgHMUMtIK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:986,”originHeight”:368,”style”:”alignCenter”,”width”:702,”height”:262}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"nat\">NAT</h2>\n\n<ul>\n  <li>inPC → outPC 까지는 패킷 전달이 잘 되지만,</li>\n  <li>Router0 → ASA0으로 전달이 되지 않는다.</li>\n</ul>\n\n<p><strong>outPC → Router1로 전달되는 패킷</strong></p>\n\n<ul>\n  <li>outPC(203.237.10.10)가 inPC(192.168.1.5)로 통신을 시도할 때, Router는 문제에 직면한다.\n    <ul>\n      <li>목적지 주소가 사설IP이기 때문에 외부에서 인식이 불가능하다.</li>\n      <li>→ Rotuer 입장에서 어디로 보내야 할 지 모른다.\n        <ul>\n          <li>(마치 동 호수만 알고, 택배 기사가 서울에서 배달을 하려는 상황과 마찬가지)</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@xD2B6/btsMeR9g8xQ/eG7q1kOXNaBGJdcSFREQoK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2080,”originHeight”:1270,”style”:”alignCenter”,”width”:783,”height”:478}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>⇒ ASA가 사설 IP를 공인 IP로 변경해서 보내줘야 한다.</li>\n  <li>ASA의 <strong>NAT</strong></li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@tUl9o/btsMeRVJT2O/PJFvZxKK7bVxaO8Vexhkt0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:414,”originHeight”:143,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>들어오는 패킷의 처리\n    <ul>\n      <li>외부 노드들은 내부 네트워크의 실제 사설 IP를 알 필요가 없다.\n        <ul>\n          <li>대신 ASA의 공인 IP 주소로 통신을 시도</li>\n        </ul>\n      </li>\n      <li>ASA는 NAT 테이블을 유지하면서, 어떤 외부 통신이 어떤 내부 노드를 위한 것인지 추적</li>\n      <li>수신된 패킷의 목적지 주소를 적절한 내부 사설 IP로 변환하여 전달</li>\n    </ul>\n  </li>\n  <li>나가는 패킷의 처리\n    <ul>\n      <li>내부 노드가 외부로 통신을 시도할 때, ASA는 출발지의 사설 IP를 자신의 공인 IP로 변환</li>\n      <li>이 과정에서 ASA는 어떤 내부 노드가 어떤 통신을 시작했는지 NAT 테이블에 기록</li>\n      <li>나중에 응답이 돌아오면, 이 테이블을 참조하여 올바른 내부 노드에게 전달</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"nat-설정\">NAT 설정</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@czZH5n/btsMc0fu60D/gU0ev4kVhViqehGSDDt6K0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1220,”originHeight”:196,”style”:”alignCenter”,”width”:742,”height”:119}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>in2out 객체 생성 (네트워크 객체 모드)</li>\n  <li>대상 서브넷을 지정해준다.</li>\n  <li>NAT 지정\n    <ul>\n      <li>내외부망을 연결하는 (inside, outside)를 동적 매핑</li>\n      <li>공인 Ip 주소는 인터페이스에 할당된 IP 주소를 사용한다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@ccZXOd/btsMcjzZe4x/9s6nimQ80LBoH1dkmToAWK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:942,”originHeight”:138,”style”:”alignCenter”,”width”:676,”height”:99}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>그래도 inPC → outPC의 통신이 실패하게 된다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bajXRR/btsMcZgFpCY/BFAnMrFdvAP1aAJVnNh9z0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:600,”originHeight”:157,”style”:”alignCenter”,”width”:524,”height”:137}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"acl\">ACL</h2>\n\n<ul>\n  <li>패킷을 보면 목적지 주소는 공인 IP 주소로 정확히 설정되어 있으나,</li>\n  <li>외부망에서 내부망으로 들어오는 트래픽의 흐름을 방화벽이 모두 Block하고 있기 때문</li>\n  <li><strong>즉, 인터페이스마다 어떤 출발지 &amp; 어떤 목적지 를 가지는 트래픽을 허용 / 거부 할 것인지 정의해줘야 한다.</strong></li>\n  <li>→ ACL : 이러한 Allow/Deny 접근 제어 목록</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>access-list &lt;ACL명&gt; &lt;타입&gt; &lt;동작&gt; &lt;프로토콜&gt; &lt;출발지&gt; &lt;목적지&gt;\naccess-group &lt;ACL명&gt; &lt;트래픽&gt; &lt;인터페이스 키워드&gt; &lt;VLAN 명&gt;\n</code></pre></div></div>\n\n<ul>\n  <li>ACL 설정\n    <ul>\n      <li>모든 출발지에서 모든 목적지로 가는 ICMP(ping) 트래픽을 허용하는 규칙을 만든다.</li>\n      <li>만든 규칙을 외부 인터페이스의 인바운드 방향에 적용</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@eklCj3/btsMeUZeeor/0St67walf4cyejJZvVb2N0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1224,”originHeight”:300,”style”:”alignCenter”,”width”:767,”height”:188}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>inPC → outPC Ping 확인</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bMTQzA/btsMeyozeji/a8vxJ4pw0kExxZ6GUmDnRk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:962,”originHeight”:434,”style”:”alignCenter”,”width”:749,”height”:338}_#]</td>\n    </tr>\n  </tbody>\n</table>\n",
                        "tags": ["Network","PacketTracer","LAN","Switch","Router","Firewall","VLAN","Topology"]
                    },
                
                    {
                        "title": "웹 서버(WS)의 진화",
                        "url": "/2025/01/27/ws-and-was.html",
                        "subtitle": "Apache vs NGINX",
                        "excerpt": "1. 웹서버(WS)에 대하여\n",
                        "author": "Jinho",
                        "date": "January 27, 2025",
                        "background": "/img/posts/apach_vs_nginx.jpeg",
                        "content": "<h1 id=\"1-웹서버ws에-대하여\">1. 웹서버(WS)에 대하여</h1>\n\n<h2 id=\"1-1-웹서버ws-란\">1-1. 웹서버(WS) 란?</h2>\n\n<p>NGINX, Apache 두 소프트웨어 모두 “<u>웹서버 소프트웨어</u>”이다.</p>\n\n<p>그렇다면 WS(웹서버)란 무엇일까?</p>\n\n<p>클라이언트의 HTTP 요청을 받아 <span class=\"post-highlight\">정적인 컨텐츠를 제공하는 서버 혹은 프로그램이다.</span></p>\n\n<p>이후에 다시 말하겠지만, WS는 정적인 컨텐츠를 서비스하는 데에 <strong>특화된</strong> 서버 소프트웨어이다.</p>\n<ul>\n  <li>동적인 콘텐츠를 처리 못한다는 것은 아니다.\n    <ul>\n      <li>참고로, Apache의 경우 자체적으로 동적인 컨텐츠 또한 처리가 가능하다.</li>\n    </ul>\n  </li>\n  <li>NGINX의 경우 불가능하다.\n    <ul>\n      <li>하지만, 동적 처리는 보통 WAS(Web Application Server)에서 주로 수행하므로, Web Server는 프록시 역할만 하면 충분하다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>여기서 주요한 점은 <span class=\"post-highlight\">“정적인 컨텐츠”</span>이다.</p>\n\n<p>html, JS 같은 정적인 컨텐츠들 정도는 웹서버를 구축한다면 웹서버 선에서 요청을 정리할 수 있다.</p>\n\n<h3 id=\"과거-2-tier-architecture\">과거 (2-tier Architecture)</h3>\n\n<p><img src=\"https://github.com/user-attachments/assets/a2d9a118-4b95-46ec-b303-a4b9c084f5eb\" alt=\"Image\" width=\"80%\" height=\"80%\" class=\"center\" /></p>\n\n<p>우선 과거의 버그가 많았던 초기의 웹서버(WS) 프로그램이 수정되고 개발된게 <strong>Apache</strong>이다.</p>\n\n<p>과거에 html, js, css 등과 같은 정적인 콘텐츠만을 주고 받는 구조에서는<br />\n<span class=\"post-highlight\">클라이언트 → WS [Apache] (정적 및 동적 요청 모두 처리) → DB</span> 만으로도 충분했다.</p>\n<ul>\n  <li>사실은 Apache의 경우, 정적/동적 모두 커버가 가능하기 때문에 기능적으로는 문제가 없었다.</li>\n  <li>하지만 다음과 같은 단점이 제기되었다.\n    <ul>\n      <li>동적 요청 처리가 필요할 경우, Apache가 너무 많은 부담을 가진다.</li>\n      <li>보안과 성능 측면에서 아쉬움이 있다.</li>\n      <li><em>그리고 이후에 다시 소개하겠다…</em></li>\n    </ul>\n  </li>\n  <li>그래서 앞단에 <u>정적 처리를 전문적으로 해주는 서버</u>가 있었으면 좋겠다는 생각을 하게 된다.</li>\n</ul>\n\n<p><br /></p>\n\n<h3 id=\"현재-3-tier-architecture\">현재 (3-tier Architecture)</h3>\n\n<p>정적/동적 컨텐츠에 대한 책임을 분리하고,<br />\n효율성과 확장성에 용이하기 위해 아키텍처가 발전했다.</p>\n\n<p><span class=\"post-highlight\">클라이언트 → [WS (정적 요청 처리) → WAS (동적 요청 처리)] → DB  </span><br />\n<em>(초기 발전 과정에서는 Apache가 WAS 역할로 동적 요청을 처리하고, 앞단에 정적 요청 처리를 NGINX가 붙는 방식으로 사용되었다.)</em></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/76082af9-7162-4a41-b5d4-be1d96020bfc\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>WAS는 동적 처리에 리소스 집중할 수 있게 되었고, 트래픽 증가에 유연한 대응이 가능하게 되었다.</p>\n<ul>\n  <li>소프트웨어 측면 말고, 개발자의 측면에서 보아도 효율적이다.\n    <ul>\n      <li>WS는 정적 파일, 보안, 로드밸런싱에만 집중하면 되고, WAS에서는 비즈니스 로직에만 집중하면 된다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><br /></p>\n\n<h1 id=\"2-apache와-nginx\">2. Apache와 NGINX</h1>\n\n<h2 id=\"2-1-apache-처리-방식-커넥션-기반\"><strong>2-1. Apache 처리 방식 (커넥션 기반)</strong></h2>\n\n<p>아파치는 <strong>Multi-Process Module</strong> 방식이다.<br />\n클라이언트가 요청 하나를 보내면, 하나의 process를 생성해서 연결한다.<br />\n요청당 프로세스/스레드 생성한다는 뜻이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/84ca44e3-a224-4f75-864d-f8f121f642da\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>이런 구조는 확장성 면에서 장점이 크다.<br />\n→ <span class=\"post-highlight\">이러한 측면에서 개발자들은 다양한 모듈을 만들어서 서버에 동적으로 빠르게 추가할 수 있는 장점이 있었다.</span></p>\n\n<p>하지만 다음과 같은 문제가 제기되었다.</p>\n\n<p>(🤔문제) <strong>프로세스 생성이 가벼운 작업이 아니기에, 매번 생성하기에는 너무 속도가 느려진다.</strong></p>\n\n<p>(✨발전 1) 요청 이전에 몇 개의 프로세스를 미리 만들어주는 prefork() 방식을 사용했다.</p>\n\n<p>(✨발전 2) 어찌됐든 매번 커넥션을 만드는 것은 비효율적이라고 판단했고, 이미 연결된 커넥션이 있다면 재활용하자는 생각을 한다.</p>\n<ul>\n  <li>http 헤더 종류 중에 keep-alive가 있다.</li>\n  <li><strong>→ Keep-Alive 옵션을 통해 일정 기간 동안 클라이언트와 Connection을 유지하는 방식</strong></li>\n</ul>\n\n<p><br /></p>\n\n<p>그러나 또 다른 문제가 제기되었다.</p>\n\n<p>(🤔또 다른 문제) <strong>클라이언트 수가 늘어나면서 결국 동시에 연결되어 있는 커넥션의 수도 매우 늘어나게 되었다.</strong></p>\n<ul>\n  <li>이렇게 동시 연결된 커넥션 수가 10,000개의 동시 연결을 넘어서는 순간, 서버는 더이상 커넥션을 형성하지 못하게 되는 현상이 발생했다. (<em>C10K 문제…</em>)</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/25bda5d5-aea5-4238-bc7b-3a499875a5e6\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>그런데 이 C10K 문제에서 하드웨어적으로 문제되는 것은 없었다.</li>\n  <li>이 당시 웹 페이지 용량 자체가 적었기 때문에 컴퓨터의 성능은 충분했지만,<br />\n비효율적인 서버의 구조 때문에 <strong>메모리 부족</strong> 현상이 일어난 것이다.</li>\n  <li>많은 커넥션에서 요청이 들어오기 시작하면, CPU 코어는 계속해서 프로세스를 바꿔가며 일을 해야 했다.</li>\n  <li>결론적으로, <strong>수 많은 동시 커넥션을 감당하기엔 아파치 서버의 구조가 적합하지 않았다.</strong></li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"2-2-nginx의-등장-이벤트-기반\"><strong>2-2. “NGINX”의 등장 (이벤트 기반)</strong></h2>\n\n<p>사실 NGINX는 Apache 를 대체하려고 나온 소프트웨어가 아니다.<br />\nNGINX는 Apache 앞 단에 붙여서 <span class=\"post-highlight\">보완하는 방식</span>으로 사용되었다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/c78538ef-1f3a-4e1a-b014-63afd34ca6c2\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>구조적으로 동시 커넥션을 많이 유지 못하는 아파치 서버의 부하를 nginx가 크게 줄일 수 있었다.</p>\n<ul>\n  <li><em>참고로,<br />\n[동시에 연결 가능한 커넥션 수(한 시점에 감당되는 동시 커넥션 수)] 와 초당 요청 처리 수는 다른 의미이다.</em></li>\n</ul>\n\n<p>이때 NGINX 가 정적인 페이지 처리를 모두 하고,<br />\nApache는 동적 파일 처리만 담당하는 (현대의 WAS 느낌) 구조로 바뀌게 되었다.</p>\n\n<p>그렇다면 어떻게 NGINX는 많은 동시 커넥션을 견뎌 낼 수 있을까?</p>\n\n<p><br /></p>\n\n<h3 id=\"nginx-처리-방식에-대해\">NGINX 처리 방식에 대해</h3>\n\n<p>Nginx는 Master-Worker 구조의 Process 방식을 채용했다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/a1d0bf67-8aca-4d49-8d74-690aaba06c50\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>Master Process는 설정파일에 맞게 실제 일하는 Worker Process를 만들어낸다.</p>\n\n<p>그리고 Worker가 만들어질 때 각자 지정된 Listen 소켓을 배정받는다.<br />\n(수신기를 받는다.)</p>\n\n<p>그리고 그 소켓에 새로운 클라이언트로부터 Request가 들어오면, 커넥션을 형성하고 요청을 처리한다.</p>\n<ul>\n  <li>마찬가지로 이 커넥션은 정해진 Keep-alive의 Timeout까지 연결을 유지하게 된다.</li>\n</ul>\n\n<p>하지만, Apache와의 차이는<br />\n<span class=\"post-highlight\">“그 커넥션이 형성되었다고 해서, Worker Process 1개가 그 커넥션 1개만을 담당하지는 않는다.”</span></p>\n<ul>\n  <li>형성된 커넥션에 아무런 요청이 없으면 새로운 커넥션을 형성하거나,<br />\n이미 만들어진 다른 커넥션으로부터 들어온 요청을 처리한다. (여러 커넥션을 쥐고 있는다.)</li>\n  <li>이런 <span class=\"post-highlight\">[커넥션 형성 / 커넥션 제거 / 새로운 요청 처리] 등을 모두 이벤트</span>라고 부른다.</li>\n</ul>\n\n<p>NGINX의 OS커널은 이러한 이벤트를 큐형식으로 줄세우고, Worker에게 전달한다.<br />\n<em>(멀티플레싱, epoll 에 대해 이해하면 어떻게 커널이 이벤트를 제공하는지 알 수 있다.)</em></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/26d73207-0e57-4358-894d-2f4450efcaf8\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">→ 는 커넥션 연결, O는 Request이며, 모두 “이벤트”이다.</em></p>\n\n<p>그리고 이 이벤트들은 큐에 담긴 채 비동기 방식으로 대기하고 있다.</p>\n\n<p>그리고 Worker Process는 하나의 스레드로 이벤트를 꺼내서 처리해 나간다.<br />\n이러면 Worker는 쉬지 않고 일을 계속 할 수 있다.</p>\n\n<p><span class=\"post-highlight\">요청이 없다면 방치되던 Apache의 구조보다 서버 자원을 훨씬 효율적으로 사용하는 셈</span>이다.</p>\n\n<p>(🤔문제) <strong>그런데 순서대로 꺼내서 쓰는 Queue에서 앞단에 들어오연 요청하나가 매우 시간이 오래걸리는 Disk I/O 작업이라면 어떨까..?</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d1abad7d-7b40-42be-9ff9-a293fe7a132b\" alt=\"Image\" width=\"60%\" height=\"100%\" class=\"center\" /></p>\n\n<p>매우 긴 IO 작업 중 큐에 대기하는 모든 이벤트들은 블로킹 될 것이다.</p>\n\n<p>(✨해결책) 오랜 기간 작업을 요하는 요청들을 위한 쓰레드 풀을 미리 만들어놓고,<br />\nWorker Process가 지금 처리하는 요청이 오래 걸린다고 판단되면,<br />\n해당 스레드 풀에 그 작업을 위임하고, 큐의 다른 이벤트를 처리하러 간다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/766c1772-fed9-4a42-b6ce-7fbbe7317f55\" alt=\"Image\" width=\"75%\" height=\"100%\" class=\"center\" /></p>\n\n<p>이러한 Worker Process 는 보통 Cpu의 코어 개수만큼 생성하고,<br />\n이러한 구조는 코어가 부담하는 Context Switch의 횟수를 대폭 줄일 수 있다.</p>\n\n<p>Apache와 비교하자면,</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/3e7909b6-7fd3-48df-b669-6b55a303b835\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>Apache\n    <ul>\n      <li>CPU가 여러 프로세스 간 스위칭</li>\n      <li>요청당 프로세스/스레드 필요</li>\n    </ul>\n  </li>\n  <li>Nginx\n    <ul>\n      <li>하나의 Worker Process가 이벤트 큐로 관리</li>\n      <li>단일 스레드로 여러 이벤트 처리</li>\n      <li>CPU 코어당 하나의 Worker 고정</li>\n      <li>이러한 <strong>Event-Driven Model이 Apache 구조와의 가장 큰 차이</strong>이다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"2-3-apache와-nginx\">2-3. Apache와 NGINX</h2>\n\n<p>항상 어떤 기술을 사용할 때에는 “최신 기술이여서”, “많이들 써서”가 이유가 될 수는 없다.</p>\n\n<p>어떤 기술, 어떤 아키텍처건 Trade-Off는 존재한다.</p>\n\n<p>과연 NGINX는 장점만 있을까?</p>\n\n<p>개발자가 <strong>기능(모듈) 추가를 시도했다가 돌아가고 있는 Worker Process를 종료해야 하는 상황</strong>이 생길 수 있다.</p>\n\n<p>그러면 <span class=\"post-highlight\">해당 Worker Process는 관리하고 있던 커넥션과 관려된 요청을 더이상 처리할 수 없다</span>는 문제가 발생한다.</p>\n<ul>\n  <li>그래서 NGINX는 개발자가 직접 모듈을 만들기에 좀 까다롭다.</li>\n</ul>\n\n<p>하지만, 단점보다 장점이 명확했다.</p>\n\n<p>수많은 동시 커넥션을 빠르게 처리하는 데에 있어 프로세스를 적게 만들다보니<br />\n(One Worker Process per CPU core)<br />\n⇒ 동시 커넥션 양 최소 10배 증가<br />\n⇒ 동일한 커넥션 수일 때 Apache에 비해 속도 2배 향상</p>\n\n<ul>\n  <li><strong>NGINX의 명확한 장점</strong>\n    <ol>\n      <li>One Worker Process per CPU core</li>\n      <li>Event-driven, asynchronous processing</li>\n      <li>Event Queue management</li>\n      <li>Thread Pool for long-running tasks</li>\n    </ol>\n  </li>\n</ul>\n\n<p>그리고 적은 프로세스는 관리가 쉽고, 새 Worker 생성 시 리소스 부담이 적다.</p>\n\n<p>이러한 구조는 “<span class=\"post-highlight\">NGINX가 설정을 동적으로 바꾸는 것</span>”을 가능하게 했다.</p>\n<ul>\n  <li>개발자가 설정 파일을 Runtime에 변경하고, NGINX에 적용하면,<br />\n이후부터는 Mater Process는 그 설정에 맞는 Worker Process를 찍어내게 된다.</li>\n  <li>그리고 기존 Worker Process에는 더이상 커넥션을 형성하지 못하게 막고,<br />\nQueue에 있는 이벤트들을 마저 처리한 뒤 기존 Worker들은 종료된다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/4f16c765-c2d8-44c2-850b-7c88a560dbb6\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>그런데 이러한 <strong>동적 설정 변경은 언제 사용</strong>할까?</p>\n<ul>\n  <li>대표적인 예로, NGINX가 여러 동시 커넥션을 관리하는 중에 뒷단에 새로운 서버를 추가하려는 상황이다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/b4f4191d-f32d-482f-a73c-6c14492350b2\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX는 이제부터 로드밸런싱 역할도 담당해야 한다.</p>\n\n<p>역할의 추가/변경이 의미하는 것은 무엇일까?</p>\n\n<ul>\n  <li>= Master Process가 찍어내야 하는 Worker Process의 역할의 추가/변경<br />\n= 기존 Connection 및 기존 Request들의 손실 없이 역할의 변경이 필요하다.</li>\n  <li>NGINX는 동시 커넥션을 유지한 채, 기존의 요청을 마저 처리하며, 뒷단의 서버를 추가할 수 있다.</li>\n  <li>이벤트 기반 구조이기 때문에 이러한 설정 변경을 초당 수십번 해도 무리없이 커넥션을 관리하고 요청을 서버에 전달할 수 있다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/842b0dc3-119e-4168-93f9-0e6b6f14b960\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : NetCraft Web Server Survey</em></p>\n\n<p>그런데 위 자료를 보면 의문이 든다.<br />\nNGINX가 탄생한 지 2004년부터 2007년 까지도 압도적으로 Apache가 1위를 차지하고 있다.</p>\n\n<p>이때까지만 해도 NIGNX는 소수의 문제 상황에 대한 해결책을 제시한 것 뿐이지,<br />\n대다수의 서비스를 가동하는 데에는 Apache로도 큰 문제가 없었다.</p>\n\n<h3 id=\"스마트폰의-탄생\">스마트폰의 탄생</h3>\n\n<p><img src=\"https://github.com/user-attachments/assets/2a75d845-635a-4d46-a0d2-68629d3fdd1f\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : NetCraft Web Server Survey</em></p>\n\n<p>2008년부터 급격하게 상황이 역전된다. 바로 <strong>스마트폰의 등장</strong> 때문이다.</p>\n\n<ul>\n  <li>단순히 ‘스마트폰의 등장 = 인터넷 사용자의 증가’의 이유가 아니다.</li>\n  <li>“<span class=\"post-highlight\">동시 커넥션을 훨씬 더 많이 생성한 계기</span>”로써 문제가 발생한다.</li>\n  <li>PC의 경우 클라이언트가 일정 시간 사용하고 전원을 끄는 방식으로 사용되었지만,<br />\n스마트폰은 실시간으로 정보를 받고 싶어하는 사용자의 니즈에 맞게 알림 등<br />\n<strong>동시 커넥션을 계속해서 유지</strong>하는 방식으로써 유용하게 사용되었다.</li>\n</ul>\n\n<p>이러다보니 “동시 커넥션 문제”가 현실로 다가온 것이다.</p>\n<ul>\n  <li>대규모 사이트들이 좋아할 만한 솔루션 이었고, NGINX는 급성장하게 된다.<br />\n(<em>현재 우리가 쿠버네티스고, 뭐고 배우는 이유도 이러한 문제의 솔루션으로써 대두된다는 것을 알고 넘어가자</em>)</li>\n</ul>\n\n<p>그렇다면 Apache는 가만히 있었을까?</p>\n\n<p>Apache도 MPM이라는 모듈을 추가해서 성능을 개선하기 시작한다.</p>\n\n<ul>\n  <li>Multi-Processing Module</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/acf7ede3-b612-417c-b4a5-82c352ba4c37\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>Apache 서버를 어떤 방식으로 운영할 지 선택할 수 있는 모듈이다.\n    <ul>\n      <li>안정성이나 소규모 프로젝트에서는 기존의 prefork 방식을</li>\n      <li>성능 향상이나 대규모 프로젝트에서는 worker라는 스레드를 만들어 worker가 요청을 처리하도록 했다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>그렇다면 왜 아직도 동시 커넥션 지표에서 NGINX가 Apache를 압도적으로 앞설까?</p>\n\n<div style=\"display: flex; justify-content: space-between; gap: 20px;\">\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/1b280974-4d15-4e5d-ac6c-c21e2093f673\" alt=\"Memory Usage\" style=\"width: 100%;\" />\n    </div>\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/6a787d51-fb2d-4c1f-a973-3f380a838d29\" alt=\"Requests Per Second\" style=\"width: 100%;\" />\n    </div>\n</div>\n<p style=\"text-align: center; color: #666;\">출처: dreamhost.com</p>\n\n<p>왼쪽 동시 커넥션 수당 메모리 사용률 지표를 보면,</p>\n<ul>\n  <li>NGINX는 동시 커넥션이 많아져도 메모리 사용률이 낮고 일정한 반면,<br />\nApache는 굉장히 많은 메모리 사용률을 요구한다.</li>\n</ul>\n\n<p>오른쪽 동시 커넥션 수가 많아졌을 때 처리하는 초당 요청 수 지표를 보아도,<br />\nNGINX가 Apache에 비해 압도적으로 많다.</p>\n<ul>\n  <li>NGINX가 커넥션 관리를 얼마나 잘하는 지 볼 수 있다.</li>\n</ul>\n\n<p>사실 지금까지 <strong>동시 커넥션</strong>이라는 포인트에만 집중해서 NGINX의 장점과 현재 많이 쓰이는 이유를 알아보았다.</p>\n\n<p><strong>그렇다면 Apache의 장점은 무엇이 있을까?</strong></p>\n\n<p><br /></p>\n\n<h2 id=\"2-4-apache가-아직-쓰이는-이유와-nginx의-단점\">2-4. Apache가 아직 쓰이는 이유와 NGINX의 단점</h2>\n\n<p>근본자체가 “NCSA HTTPd”라는 소프트웨어의 버그를 수정해오며 커온 Apache이기에,\n<span class=\"post-highlight\">호환성과 확장성의 측면</span>에서는 장점이 있다.</p>\n\n<p>아직도 오픈소스로써 활발한 수정과 개선이 이루어지고 있다. [<span class=\"post-highlight\">풍부한 모듈 생태계</span>]</p>\n<ul>\n  <li><a href=\"https://projects.apache.org/projects.html\">Apache는 현재에도 Apache Kafka, Apache Hadoop 등 시대에 발맞춰 발전 중이다</a>.</li>\n</ul>\n\n<p>또한, Apache는 여러 운영 체제(리눅스, 윈도우, 유닉스 등)에서 폭넓은 호환성과 안정성을 자랑한다.</p>\n\n<p>NGINX는 그렇지 않아서, Windows에서 성능이 매우 낮게 나온다.</p>\n<ul>\n  <li>NGINX는 원래 <strong>리눅스</strong> 환경에서 설계되었기 때문에, 리눅스 OS에서 최고의 성능이 나오며,</li>\n  <li>윈도우에서도 동작은 하지만,<br />\n윈도우의 <strong>비동기 I/O</strong> 시스템에 최적화되지 않았기 때문에 <strong>성능이 상대적으로 낮다</strong>.</li>\n</ul>\n\n<p>현재 서비스에서 큰 성능 문제 없이 잘 돌아가고 있고, 모듈을 계속해서 추가/제거할 일이 많다면 굳이 NGINX로 옮길 이유는 없는 것이다.</p>\n<ul>\n  <li>오해하면 안되는 것이 NGINX는 설정 변경과 이에 따른 Worker Process의 로직 변경이 무중단으로 이루어진다는 것이며,<br />\nNGINX는 모듈 자체를 동적으로 로드할 수 없으므로, 새 모듈을 추가하려면 재컴파일이 필요하다.</li>\n  <li>Apache는 설정 변경 없이 실행 중 동적 모듈 로드가 가능하므로, 특정 기능을 빠르게 추가하거나 제거할 때 더 유연하다.</li>\n</ul>\n\n<p><strong>둘은 서로 대립관계가 아니며, 목적이 다르게 탄생한 것이다.</strong></p>\n\n<p><br /></p>\n\n<h2 id=\"2-5-그렇다면-현재-nginx를-어떻게-이용해야-하는가\">2-5. 그렇다면 현재 NGINX를 어떻게 이용해야 하는가?</h2>\n\n<p>앞서 우리는 NGINX의 WS로써, 로드밸런싱으로서의 역할을 보았다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/04bf32c2-7d72-4229-a31e-2b3e639e6b2d\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>비동기 이벤트 기반 구조로 동시 커넥션 처리가 효율적이며, Reverse Proxy로써 서버 부하를 줄일 수 있다.</p>\n\n<p>이 자체로 웹 서버 가속(성능 개선) 역할을 한다.</p>\n\n<p>추가적으로 NGINX를 사용하며 고려해야할 관점이다.</p>\n\n<p><strong>1) SSL 터미네이션 역할을 한다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/baaa7488-05be-473f-8d84-27912891b0f3\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX가 앞단에서 SSL을 처리하여, 클라이언트와는 HTTPS로 통신하고, 뒷단 서버와는 HTTP로 통신하는 방식이다.</p>\n<ul>\n  <li>어차피, NGINX와 SERVER가 같은 네트워크 안에 있는 경우가 많기 떄문에,<br />\n이렇게 통신을 해도 보안 위험이 비교적 적다.</li>\n</ul>\n\n<p>이 방식은 뒷단 서버가 <span class=\"post-highlight\">복호화 과정에서 발생하는 부하를 줄이는 장점</span>이 있다.</p>\n\n<p><strong>2) 캐싱 역할을 한다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/6c43e842-cbfa-44fd-99e0-75b079dc4a20\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX는 &lt;span class=”post-highlight”HTTP 콘텐츠 캐싱&lt;/span&gt;을 지원하며,<br />\n이를 통해 서버 부하를 줄이고 클라이언트 요청에 빠르게 응답할 수 있습니다.</p>\n<ul>\n  <li>한 번 서버로부터 받은 응답을 스스로 보관하고 클라이언트에게 전달하므로 효율적이다.</li>\n</ul>\n\n<p>이러한 경우 1번과 달리 NGINX를 클라이언트와 가까운 곳(예: CDN이나 엣지 서버)에 배치하여<br />\n캐싱 효과를 극대화할 수 있다.</p>\n\n<p><strong>3)NGINX와 컨테이너화</strong></p>\n\n<p>현재 클라우드 네이티브와 컨테이너화가 대세인 환경에서, NGINX는 더욱 중요한 역할을 수행하고 있다.</p>\n\n<p>특히 Kubernetes의 Ingress Controller로서, 또는 마이크로서비스 아키텍처에서의 API Gateway로서 그 가치가 두드러진다.</p>\n\n<p>Kubernetes에서 Ingress Controller로 사용될 때, API Gateway로서의 설정 등등</p>\n<ul>\n  <li>이러한 설정들을 통해 NGINX는 현대적인 마이크로서비스 환경에서 트래픽 라우팅, 로드밸런싱, SSL 종료, API 게이트웨이 등 다양한 역할을 효율적으로 수행할 수 있다.</li>\n  <li>특히 컨테이너 환경에서는 가볍고 빠른 NGINX의 특성이 더욱 큰 장점으로 작용한다.</li>\n</ul>\n\n<p>이 외에도 HSTS, CORS 처리, TCP/UDP 커넥션 분산 부하, HTTP/2 지원 (최근에는 /3도 지원) 등 서버를 보완하는 역할을 할 수 있다.</p>\n\n<p>어떠한 기능이 있는지를 알아보고 상황에 따라 알맞는 기능을 적용하는 자세가 필요하다.</p>\n\n<hr />\n<p>참고: <a href=\"https://www.youtube.com/watch?v=mcnJcjbfjrs\" target=\"_blank\">우아한테크 [10분 테코톡] 알리의 Web Server vs WAS</a></p>\n\n<p><a href=\"https://www.youtube.com/watch?v=6FAwAXXj5N0\" target=\"_blank\">우아한테크 [10분 테코톡] 피케이의 Nginx</a></p>\n",
                        "tags": ["WebServer","Apache","NGINX","Architecture","DevOps","Network","Performance","LoadBalancing","ReverseProxy"]
                    }
                
            ],
        
            "LoadBalancing": [
                
                    {
                        "title": "웹 서버(WS)의 진화",
                        "url": "/2025/01/27/ws-and-was.html",
                        "subtitle": "Apache vs NGINX",
                        "excerpt": "1. 웹서버(WS)에 대하여\n",
                        "author": "Jinho",
                        "date": "January 27, 2025",
                        "background": "/img/posts/apach_vs_nginx.jpeg",
                        "content": "<h1 id=\"1-웹서버ws에-대하여\">1. 웹서버(WS)에 대하여</h1>\n\n<h2 id=\"1-1-웹서버ws-란\">1-1. 웹서버(WS) 란?</h2>\n\n<p>NGINX, Apache 두 소프트웨어 모두 “<u>웹서버 소프트웨어</u>”이다.</p>\n\n<p>그렇다면 WS(웹서버)란 무엇일까?</p>\n\n<p>클라이언트의 HTTP 요청을 받아 <span class=\"post-highlight\">정적인 컨텐츠를 제공하는 서버 혹은 프로그램이다.</span></p>\n\n<p>이후에 다시 말하겠지만, WS는 정적인 컨텐츠를 서비스하는 데에 <strong>특화된</strong> 서버 소프트웨어이다.</p>\n<ul>\n  <li>동적인 콘텐츠를 처리 못한다는 것은 아니다.\n    <ul>\n      <li>참고로, Apache의 경우 자체적으로 동적인 컨텐츠 또한 처리가 가능하다.</li>\n    </ul>\n  </li>\n  <li>NGINX의 경우 불가능하다.\n    <ul>\n      <li>하지만, 동적 처리는 보통 WAS(Web Application Server)에서 주로 수행하므로, Web Server는 프록시 역할만 하면 충분하다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>여기서 주요한 점은 <span class=\"post-highlight\">“정적인 컨텐츠”</span>이다.</p>\n\n<p>html, JS 같은 정적인 컨텐츠들 정도는 웹서버를 구축한다면 웹서버 선에서 요청을 정리할 수 있다.</p>\n\n<h3 id=\"과거-2-tier-architecture\">과거 (2-tier Architecture)</h3>\n\n<p><img src=\"https://github.com/user-attachments/assets/a2d9a118-4b95-46ec-b303-a4b9c084f5eb\" alt=\"Image\" width=\"80%\" height=\"80%\" class=\"center\" /></p>\n\n<p>우선 과거의 버그가 많았던 초기의 웹서버(WS) 프로그램이 수정되고 개발된게 <strong>Apache</strong>이다.</p>\n\n<p>과거에 html, js, css 등과 같은 정적인 콘텐츠만을 주고 받는 구조에서는<br />\n<span class=\"post-highlight\">클라이언트 → WS [Apache] (정적 및 동적 요청 모두 처리) → DB</span> 만으로도 충분했다.</p>\n<ul>\n  <li>사실은 Apache의 경우, 정적/동적 모두 커버가 가능하기 때문에 기능적으로는 문제가 없었다.</li>\n  <li>하지만 다음과 같은 단점이 제기되었다.\n    <ul>\n      <li>동적 요청 처리가 필요할 경우, Apache가 너무 많은 부담을 가진다.</li>\n      <li>보안과 성능 측면에서 아쉬움이 있다.</li>\n      <li><em>그리고 이후에 다시 소개하겠다…</em></li>\n    </ul>\n  </li>\n  <li>그래서 앞단에 <u>정적 처리를 전문적으로 해주는 서버</u>가 있었으면 좋겠다는 생각을 하게 된다.</li>\n</ul>\n\n<p><br /></p>\n\n<h3 id=\"현재-3-tier-architecture\">현재 (3-tier Architecture)</h3>\n\n<p>정적/동적 컨텐츠에 대한 책임을 분리하고,<br />\n효율성과 확장성에 용이하기 위해 아키텍처가 발전했다.</p>\n\n<p><span class=\"post-highlight\">클라이언트 → [WS (정적 요청 처리) → WAS (동적 요청 처리)] → DB  </span><br />\n<em>(초기 발전 과정에서는 Apache가 WAS 역할로 동적 요청을 처리하고, 앞단에 정적 요청 처리를 NGINX가 붙는 방식으로 사용되었다.)</em></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/76082af9-7162-4a41-b5d4-be1d96020bfc\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>WAS는 동적 처리에 리소스 집중할 수 있게 되었고, 트래픽 증가에 유연한 대응이 가능하게 되었다.</p>\n<ul>\n  <li>소프트웨어 측면 말고, 개발자의 측면에서 보아도 효율적이다.\n    <ul>\n      <li>WS는 정적 파일, 보안, 로드밸런싱에만 집중하면 되고, WAS에서는 비즈니스 로직에만 집중하면 된다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><br /></p>\n\n<h1 id=\"2-apache와-nginx\">2. Apache와 NGINX</h1>\n\n<h2 id=\"2-1-apache-처리-방식-커넥션-기반\"><strong>2-1. Apache 처리 방식 (커넥션 기반)</strong></h2>\n\n<p>아파치는 <strong>Multi-Process Module</strong> 방식이다.<br />\n클라이언트가 요청 하나를 보내면, 하나의 process를 생성해서 연결한다.<br />\n요청당 프로세스/스레드 생성한다는 뜻이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/84ca44e3-a224-4f75-864d-f8f121f642da\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>이런 구조는 확장성 면에서 장점이 크다.<br />\n→ <span class=\"post-highlight\">이러한 측면에서 개발자들은 다양한 모듈을 만들어서 서버에 동적으로 빠르게 추가할 수 있는 장점이 있었다.</span></p>\n\n<p>하지만 다음과 같은 문제가 제기되었다.</p>\n\n<p>(🤔문제) <strong>프로세스 생성이 가벼운 작업이 아니기에, 매번 생성하기에는 너무 속도가 느려진다.</strong></p>\n\n<p>(✨발전 1) 요청 이전에 몇 개의 프로세스를 미리 만들어주는 prefork() 방식을 사용했다.</p>\n\n<p>(✨발전 2) 어찌됐든 매번 커넥션을 만드는 것은 비효율적이라고 판단했고, 이미 연결된 커넥션이 있다면 재활용하자는 생각을 한다.</p>\n<ul>\n  <li>http 헤더 종류 중에 keep-alive가 있다.</li>\n  <li><strong>→ Keep-Alive 옵션을 통해 일정 기간 동안 클라이언트와 Connection을 유지하는 방식</strong></li>\n</ul>\n\n<p><br /></p>\n\n<p>그러나 또 다른 문제가 제기되었다.</p>\n\n<p>(🤔또 다른 문제) <strong>클라이언트 수가 늘어나면서 결국 동시에 연결되어 있는 커넥션의 수도 매우 늘어나게 되었다.</strong></p>\n<ul>\n  <li>이렇게 동시 연결된 커넥션 수가 10,000개의 동시 연결을 넘어서는 순간, 서버는 더이상 커넥션을 형성하지 못하게 되는 현상이 발생했다. (<em>C10K 문제…</em>)</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/25bda5d5-aea5-4238-bc7b-3a499875a5e6\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>그런데 이 C10K 문제에서 하드웨어적으로 문제되는 것은 없었다.</li>\n  <li>이 당시 웹 페이지 용량 자체가 적었기 때문에 컴퓨터의 성능은 충분했지만,<br />\n비효율적인 서버의 구조 때문에 <strong>메모리 부족</strong> 현상이 일어난 것이다.</li>\n  <li>많은 커넥션에서 요청이 들어오기 시작하면, CPU 코어는 계속해서 프로세스를 바꿔가며 일을 해야 했다.</li>\n  <li>결론적으로, <strong>수 많은 동시 커넥션을 감당하기엔 아파치 서버의 구조가 적합하지 않았다.</strong></li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"2-2-nginx의-등장-이벤트-기반\"><strong>2-2. “NGINX”의 등장 (이벤트 기반)</strong></h2>\n\n<p>사실 NGINX는 Apache 를 대체하려고 나온 소프트웨어가 아니다.<br />\nNGINX는 Apache 앞 단에 붙여서 <span class=\"post-highlight\">보완하는 방식</span>으로 사용되었다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/c78538ef-1f3a-4e1a-b014-63afd34ca6c2\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>구조적으로 동시 커넥션을 많이 유지 못하는 아파치 서버의 부하를 nginx가 크게 줄일 수 있었다.</p>\n<ul>\n  <li><em>참고로,<br />\n[동시에 연결 가능한 커넥션 수(한 시점에 감당되는 동시 커넥션 수)] 와 초당 요청 처리 수는 다른 의미이다.</em></li>\n</ul>\n\n<p>이때 NGINX 가 정적인 페이지 처리를 모두 하고,<br />\nApache는 동적 파일 처리만 담당하는 (현대의 WAS 느낌) 구조로 바뀌게 되었다.</p>\n\n<p>그렇다면 어떻게 NGINX는 많은 동시 커넥션을 견뎌 낼 수 있을까?</p>\n\n<p><br /></p>\n\n<h3 id=\"nginx-처리-방식에-대해\">NGINX 처리 방식에 대해</h3>\n\n<p>Nginx는 Master-Worker 구조의 Process 방식을 채용했다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/a1d0bf67-8aca-4d49-8d74-690aaba06c50\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>Master Process는 설정파일에 맞게 실제 일하는 Worker Process를 만들어낸다.</p>\n\n<p>그리고 Worker가 만들어질 때 각자 지정된 Listen 소켓을 배정받는다.<br />\n(수신기를 받는다.)</p>\n\n<p>그리고 그 소켓에 새로운 클라이언트로부터 Request가 들어오면, 커넥션을 형성하고 요청을 처리한다.</p>\n<ul>\n  <li>마찬가지로 이 커넥션은 정해진 Keep-alive의 Timeout까지 연결을 유지하게 된다.</li>\n</ul>\n\n<p>하지만, Apache와의 차이는<br />\n<span class=\"post-highlight\">“그 커넥션이 형성되었다고 해서, Worker Process 1개가 그 커넥션 1개만을 담당하지는 않는다.”</span></p>\n<ul>\n  <li>형성된 커넥션에 아무런 요청이 없으면 새로운 커넥션을 형성하거나,<br />\n이미 만들어진 다른 커넥션으로부터 들어온 요청을 처리한다. (여러 커넥션을 쥐고 있는다.)</li>\n  <li>이런 <span class=\"post-highlight\">[커넥션 형성 / 커넥션 제거 / 새로운 요청 처리] 등을 모두 이벤트</span>라고 부른다.</li>\n</ul>\n\n<p>NGINX의 OS커널은 이러한 이벤트를 큐형식으로 줄세우고, Worker에게 전달한다.<br />\n<em>(멀티플레싱, epoll 에 대해 이해하면 어떻게 커널이 이벤트를 제공하는지 알 수 있다.)</em></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/26d73207-0e57-4358-894d-2f4450efcaf8\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">→ 는 커넥션 연결, O는 Request이며, 모두 “이벤트”이다.</em></p>\n\n<p>그리고 이 이벤트들은 큐에 담긴 채 비동기 방식으로 대기하고 있다.</p>\n\n<p>그리고 Worker Process는 하나의 스레드로 이벤트를 꺼내서 처리해 나간다.<br />\n이러면 Worker는 쉬지 않고 일을 계속 할 수 있다.</p>\n\n<p><span class=\"post-highlight\">요청이 없다면 방치되던 Apache의 구조보다 서버 자원을 훨씬 효율적으로 사용하는 셈</span>이다.</p>\n\n<p>(🤔문제) <strong>그런데 순서대로 꺼내서 쓰는 Queue에서 앞단에 들어오연 요청하나가 매우 시간이 오래걸리는 Disk I/O 작업이라면 어떨까..?</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d1abad7d-7b40-42be-9ff9-a293fe7a132b\" alt=\"Image\" width=\"60%\" height=\"100%\" class=\"center\" /></p>\n\n<p>매우 긴 IO 작업 중 큐에 대기하는 모든 이벤트들은 블로킹 될 것이다.</p>\n\n<p>(✨해결책) 오랜 기간 작업을 요하는 요청들을 위한 쓰레드 풀을 미리 만들어놓고,<br />\nWorker Process가 지금 처리하는 요청이 오래 걸린다고 판단되면,<br />\n해당 스레드 풀에 그 작업을 위임하고, 큐의 다른 이벤트를 처리하러 간다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/766c1772-fed9-4a42-b6ce-7fbbe7317f55\" alt=\"Image\" width=\"75%\" height=\"100%\" class=\"center\" /></p>\n\n<p>이러한 Worker Process 는 보통 Cpu의 코어 개수만큼 생성하고,<br />\n이러한 구조는 코어가 부담하는 Context Switch의 횟수를 대폭 줄일 수 있다.</p>\n\n<p>Apache와 비교하자면,</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/3e7909b6-7fd3-48df-b669-6b55a303b835\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>Apache\n    <ul>\n      <li>CPU가 여러 프로세스 간 스위칭</li>\n      <li>요청당 프로세스/스레드 필요</li>\n    </ul>\n  </li>\n  <li>Nginx\n    <ul>\n      <li>하나의 Worker Process가 이벤트 큐로 관리</li>\n      <li>단일 스레드로 여러 이벤트 처리</li>\n      <li>CPU 코어당 하나의 Worker 고정</li>\n      <li>이러한 <strong>Event-Driven Model이 Apache 구조와의 가장 큰 차이</strong>이다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"2-3-apache와-nginx\">2-3. Apache와 NGINX</h2>\n\n<p>항상 어떤 기술을 사용할 때에는 “최신 기술이여서”, “많이들 써서”가 이유가 될 수는 없다.</p>\n\n<p>어떤 기술, 어떤 아키텍처건 Trade-Off는 존재한다.</p>\n\n<p>과연 NGINX는 장점만 있을까?</p>\n\n<p>개발자가 <strong>기능(모듈) 추가를 시도했다가 돌아가고 있는 Worker Process를 종료해야 하는 상황</strong>이 생길 수 있다.</p>\n\n<p>그러면 <span class=\"post-highlight\">해당 Worker Process는 관리하고 있던 커넥션과 관려된 요청을 더이상 처리할 수 없다</span>는 문제가 발생한다.</p>\n<ul>\n  <li>그래서 NGINX는 개발자가 직접 모듈을 만들기에 좀 까다롭다.</li>\n</ul>\n\n<p>하지만, 단점보다 장점이 명확했다.</p>\n\n<p>수많은 동시 커넥션을 빠르게 처리하는 데에 있어 프로세스를 적게 만들다보니<br />\n(One Worker Process per CPU core)<br />\n⇒ 동시 커넥션 양 최소 10배 증가<br />\n⇒ 동일한 커넥션 수일 때 Apache에 비해 속도 2배 향상</p>\n\n<ul>\n  <li><strong>NGINX의 명확한 장점</strong>\n    <ol>\n      <li>One Worker Process per CPU core</li>\n      <li>Event-driven, asynchronous processing</li>\n      <li>Event Queue management</li>\n      <li>Thread Pool for long-running tasks</li>\n    </ol>\n  </li>\n</ul>\n\n<p>그리고 적은 프로세스는 관리가 쉽고, 새 Worker 생성 시 리소스 부담이 적다.</p>\n\n<p>이러한 구조는 “<span class=\"post-highlight\">NGINX가 설정을 동적으로 바꾸는 것</span>”을 가능하게 했다.</p>\n<ul>\n  <li>개발자가 설정 파일을 Runtime에 변경하고, NGINX에 적용하면,<br />\n이후부터는 Mater Process는 그 설정에 맞는 Worker Process를 찍어내게 된다.</li>\n  <li>그리고 기존 Worker Process에는 더이상 커넥션을 형성하지 못하게 막고,<br />\nQueue에 있는 이벤트들을 마저 처리한 뒤 기존 Worker들은 종료된다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/4f16c765-c2d8-44c2-850b-7c88a560dbb6\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>그런데 이러한 <strong>동적 설정 변경은 언제 사용</strong>할까?</p>\n<ul>\n  <li>대표적인 예로, NGINX가 여러 동시 커넥션을 관리하는 중에 뒷단에 새로운 서버를 추가하려는 상황이다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/b4f4191d-f32d-482f-a73c-6c14492350b2\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX는 이제부터 로드밸런싱 역할도 담당해야 한다.</p>\n\n<p>역할의 추가/변경이 의미하는 것은 무엇일까?</p>\n\n<ul>\n  <li>= Master Process가 찍어내야 하는 Worker Process의 역할의 추가/변경<br />\n= 기존 Connection 및 기존 Request들의 손실 없이 역할의 변경이 필요하다.</li>\n  <li>NGINX는 동시 커넥션을 유지한 채, 기존의 요청을 마저 처리하며, 뒷단의 서버를 추가할 수 있다.</li>\n  <li>이벤트 기반 구조이기 때문에 이러한 설정 변경을 초당 수십번 해도 무리없이 커넥션을 관리하고 요청을 서버에 전달할 수 있다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/842b0dc3-119e-4168-93f9-0e6b6f14b960\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : NetCraft Web Server Survey</em></p>\n\n<p>그런데 위 자료를 보면 의문이 든다.<br />\nNGINX가 탄생한 지 2004년부터 2007년 까지도 압도적으로 Apache가 1위를 차지하고 있다.</p>\n\n<p>이때까지만 해도 NIGNX는 소수의 문제 상황에 대한 해결책을 제시한 것 뿐이지,<br />\n대다수의 서비스를 가동하는 데에는 Apache로도 큰 문제가 없었다.</p>\n\n<h3 id=\"스마트폰의-탄생\">스마트폰의 탄생</h3>\n\n<p><img src=\"https://github.com/user-attachments/assets/2a75d845-635a-4d46-a0d2-68629d3fdd1f\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : NetCraft Web Server Survey</em></p>\n\n<p>2008년부터 급격하게 상황이 역전된다. 바로 <strong>스마트폰의 등장</strong> 때문이다.</p>\n\n<ul>\n  <li>단순히 ‘스마트폰의 등장 = 인터넷 사용자의 증가’의 이유가 아니다.</li>\n  <li>“<span class=\"post-highlight\">동시 커넥션을 훨씬 더 많이 생성한 계기</span>”로써 문제가 발생한다.</li>\n  <li>PC의 경우 클라이언트가 일정 시간 사용하고 전원을 끄는 방식으로 사용되었지만,<br />\n스마트폰은 실시간으로 정보를 받고 싶어하는 사용자의 니즈에 맞게 알림 등<br />\n<strong>동시 커넥션을 계속해서 유지</strong>하는 방식으로써 유용하게 사용되었다.</li>\n</ul>\n\n<p>이러다보니 “동시 커넥션 문제”가 현실로 다가온 것이다.</p>\n<ul>\n  <li>대규모 사이트들이 좋아할 만한 솔루션 이었고, NGINX는 급성장하게 된다.<br />\n(<em>현재 우리가 쿠버네티스고, 뭐고 배우는 이유도 이러한 문제의 솔루션으로써 대두된다는 것을 알고 넘어가자</em>)</li>\n</ul>\n\n<p>그렇다면 Apache는 가만히 있었을까?</p>\n\n<p>Apache도 MPM이라는 모듈을 추가해서 성능을 개선하기 시작한다.</p>\n\n<ul>\n  <li>Multi-Processing Module</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/acf7ede3-b612-417c-b4a5-82c352ba4c37\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>Apache 서버를 어떤 방식으로 운영할 지 선택할 수 있는 모듈이다.\n    <ul>\n      <li>안정성이나 소규모 프로젝트에서는 기존의 prefork 방식을</li>\n      <li>성능 향상이나 대규모 프로젝트에서는 worker라는 스레드를 만들어 worker가 요청을 처리하도록 했다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>그렇다면 왜 아직도 동시 커넥션 지표에서 NGINX가 Apache를 압도적으로 앞설까?</p>\n\n<div style=\"display: flex; justify-content: space-between; gap: 20px;\">\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/1b280974-4d15-4e5d-ac6c-c21e2093f673\" alt=\"Memory Usage\" style=\"width: 100%;\" />\n    </div>\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/6a787d51-fb2d-4c1f-a973-3f380a838d29\" alt=\"Requests Per Second\" style=\"width: 100%;\" />\n    </div>\n</div>\n<p style=\"text-align: center; color: #666;\">출처: dreamhost.com</p>\n\n<p>왼쪽 동시 커넥션 수당 메모리 사용률 지표를 보면,</p>\n<ul>\n  <li>NGINX는 동시 커넥션이 많아져도 메모리 사용률이 낮고 일정한 반면,<br />\nApache는 굉장히 많은 메모리 사용률을 요구한다.</li>\n</ul>\n\n<p>오른쪽 동시 커넥션 수가 많아졌을 때 처리하는 초당 요청 수 지표를 보아도,<br />\nNGINX가 Apache에 비해 압도적으로 많다.</p>\n<ul>\n  <li>NGINX가 커넥션 관리를 얼마나 잘하는 지 볼 수 있다.</li>\n</ul>\n\n<p>사실 지금까지 <strong>동시 커넥션</strong>이라는 포인트에만 집중해서 NGINX의 장점과 현재 많이 쓰이는 이유를 알아보았다.</p>\n\n<p><strong>그렇다면 Apache의 장점은 무엇이 있을까?</strong></p>\n\n<p><br /></p>\n\n<h2 id=\"2-4-apache가-아직-쓰이는-이유와-nginx의-단점\">2-4. Apache가 아직 쓰이는 이유와 NGINX의 단점</h2>\n\n<p>근본자체가 “NCSA HTTPd”라는 소프트웨어의 버그를 수정해오며 커온 Apache이기에,\n<span class=\"post-highlight\">호환성과 확장성의 측면</span>에서는 장점이 있다.</p>\n\n<p>아직도 오픈소스로써 활발한 수정과 개선이 이루어지고 있다. [<span class=\"post-highlight\">풍부한 모듈 생태계</span>]</p>\n<ul>\n  <li><a href=\"https://projects.apache.org/projects.html\">Apache는 현재에도 Apache Kafka, Apache Hadoop 등 시대에 발맞춰 발전 중이다</a>.</li>\n</ul>\n\n<p>또한, Apache는 여러 운영 체제(리눅스, 윈도우, 유닉스 등)에서 폭넓은 호환성과 안정성을 자랑한다.</p>\n\n<p>NGINX는 그렇지 않아서, Windows에서 성능이 매우 낮게 나온다.</p>\n<ul>\n  <li>NGINX는 원래 <strong>리눅스</strong> 환경에서 설계되었기 때문에, 리눅스 OS에서 최고의 성능이 나오며,</li>\n  <li>윈도우에서도 동작은 하지만,<br />\n윈도우의 <strong>비동기 I/O</strong> 시스템에 최적화되지 않았기 때문에 <strong>성능이 상대적으로 낮다</strong>.</li>\n</ul>\n\n<p>현재 서비스에서 큰 성능 문제 없이 잘 돌아가고 있고, 모듈을 계속해서 추가/제거할 일이 많다면 굳이 NGINX로 옮길 이유는 없는 것이다.</p>\n<ul>\n  <li>오해하면 안되는 것이 NGINX는 설정 변경과 이에 따른 Worker Process의 로직 변경이 무중단으로 이루어진다는 것이며,<br />\nNGINX는 모듈 자체를 동적으로 로드할 수 없으므로, 새 모듈을 추가하려면 재컴파일이 필요하다.</li>\n  <li>Apache는 설정 변경 없이 실행 중 동적 모듈 로드가 가능하므로, 특정 기능을 빠르게 추가하거나 제거할 때 더 유연하다.</li>\n</ul>\n\n<p><strong>둘은 서로 대립관계가 아니며, 목적이 다르게 탄생한 것이다.</strong></p>\n\n<p><br /></p>\n\n<h2 id=\"2-5-그렇다면-현재-nginx를-어떻게-이용해야-하는가\">2-5. 그렇다면 현재 NGINX를 어떻게 이용해야 하는가?</h2>\n\n<p>앞서 우리는 NGINX의 WS로써, 로드밸런싱으로서의 역할을 보았다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/04bf32c2-7d72-4229-a31e-2b3e639e6b2d\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>비동기 이벤트 기반 구조로 동시 커넥션 처리가 효율적이며, Reverse Proxy로써 서버 부하를 줄일 수 있다.</p>\n\n<p>이 자체로 웹 서버 가속(성능 개선) 역할을 한다.</p>\n\n<p>추가적으로 NGINX를 사용하며 고려해야할 관점이다.</p>\n\n<p><strong>1) SSL 터미네이션 역할을 한다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/baaa7488-05be-473f-8d84-27912891b0f3\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX가 앞단에서 SSL을 처리하여, 클라이언트와는 HTTPS로 통신하고, 뒷단 서버와는 HTTP로 통신하는 방식이다.</p>\n<ul>\n  <li>어차피, NGINX와 SERVER가 같은 네트워크 안에 있는 경우가 많기 떄문에,<br />\n이렇게 통신을 해도 보안 위험이 비교적 적다.</li>\n</ul>\n\n<p>이 방식은 뒷단 서버가 <span class=\"post-highlight\">복호화 과정에서 발생하는 부하를 줄이는 장점</span>이 있다.</p>\n\n<p><strong>2) 캐싱 역할을 한다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/6c43e842-cbfa-44fd-99e0-75b079dc4a20\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX는 &lt;span class=”post-highlight”HTTP 콘텐츠 캐싱&lt;/span&gt;을 지원하며,<br />\n이를 통해 서버 부하를 줄이고 클라이언트 요청에 빠르게 응답할 수 있습니다.</p>\n<ul>\n  <li>한 번 서버로부터 받은 응답을 스스로 보관하고 클라이언트에게 전달하므로 효율적이다.</li>\n</ul>\n\n<p>이러한 경우 1번과 달리 NGINX를 클라이언트와 가까운 곳(예: CDN이나 엣지 서버)에 배치하여<br />\n캐싱 효과를 극대화할 수 있다.</p>\n\n<p><strong>3)NGINX와 컨테이너화</strong></p>\n\n<p>현재 클라우드 네이티브와 컨테이너화가 대세인 환경에서, NGINX는 더욱 중요한 역할을 수행하고 있다.</p>\n\n<p>특히 Kubernetes의 Ingress Controller로서, 또는 마이크로서비스 아키텍처에서의 API Gateway로서 그 가치가 두드러진다.</p>\n\n<p>Kubernetes에서 Ingress Controller로 사용될 때, API Gateway로서의 설정 등등</p>\n<ul>\n  <li>이러한 설정들을 통해 NGINX는 현대적인 마이크로서비스 환경에서 트래픽 라우팅, 로드밸런싱, SSL 종료, API 게이트웨이 등 다양한 역할을 효율적으로 수행할 수 있다.</li>\n  <li>특히 컨테이너 환경에서는 가볍고 빠른 NGINX의 특성이 더욱 큰 장점으로 작용한다.</li>\n</ul>\n\n<p>이 외에도 HSTS, CORS 처리, TCP/UDP 커넥션 분산 부하, HTTP/2 지원 (최근에는 /3도 지원) 등 서버를 보완하는 역할을 할 수 있다.</p>\n\n<p>어떠한 기능이 있는지를 알아보고 상황에 따라 알맞는 기능을 적용하는 자세가 필요하다.</p>\n\n<hr />\n<p>참고: <a href=\"https://www.youtube.com/watch?v=mcnJcjbfjrs\" target=\"_blank\">우아한테크 [10분 테코톡] 알리의 Web Server vs WAS</a></p>\n\n<p><a href=\"https://www.youtube.com/watch?v=6FAwAXXj5N0\" target=\"_blank\">우아한테크 [10분 테코톡] 피케이의 Nginx</a></p>\n",
                        "tags": ["WebServer","Apache","NGINX","Architecture","DevOps","Network","Performance","LoadBalancing","ReverseProxy"]
                    }
                
            ],
        
            "ReverseProxy": [
                
                    {
                        "title": "웹 서버(WS)의 진화",
                        "url": "/2025/01/27/ws-and-was.html",
                        "subtitle": "Apache vs NGINX",
                        "excerpt": "1. 웹서버(WS)에 대하여\n",
                        "author": "Jinho",
                        "date": "January 27, 2025",
                        "background": "/img/posts/apach_vs_nginx.jpeg",
                        "content": "<h1 id=\"1-웹서버ws에-대하여\">1. 웹서버(WS)에 대하여</h1>\n\n<h2 id=\"1-1-웹서버ws-란\">1-1. 웹서버(WS) 란?</h2>\n\n<p>NGINX, Apache 두 소프트웨어 모두 “<u>웹서버 소프트웨어</u>”이다.</p>\n\n<p>그렇다면 WS(웹서버)란 무엇일까?</p>\n\n<p>클라이언트의 HTTP 요청을 받아 <span class=\"post-highlight\">정적인 컨텐츠를 제공하는 서버 혹은 프로그램이다.</span></p>\n\n<p>이후에 다시 말하겠지만, WS는 정적인 컨텐츠를 서비스하는 데에 <strong>특화된</strong> 서버 소프트웨어이다.</p>\n<ul>\n  <li>동적인 콘텐츠를 처리 못한다는 것은 아니다.\n    <ul>\n      <li>참고로, Apache의 경우 자체적으로 동적인 컨텐츠 또한 처리가 가능하다.</li>\n    </ul>\n  </li>\n  <li>NGINX의 경우 불가능하다.\n    <ul>\n      <li>하지만, 동적 처리는 보통 WAS(Web Application Server)에서 주로 수행하므로, Web Server는 프록시 역할만 하면 충분하다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>여기서 주요한 점은 <span class=\"post-highlight\">“정적인 컨텐츠”</span>이다.</p>\n\n<p>html, JS 같은 정적인 컨텐츠들 정도는 웹서버를 구축한다면 웹서버 선에서 요청을 정리할 수 있다.</p>\n\n<h3 id=\"과거-2-tier-architecture\">과거 (2-tier Architecture)</h3>\n\n<p><img src=\"https://github.com/user-attachments/assets/a2d9a118-4b95-46ec-b303-a4b9c084f5eb\" alt=\"Image\" width=\"80%\" height=\"80%\" class=\"center\" /></p>\n\n<p>우선 과거의 버그가 많았던 초기의 웹서버(WS) 프로그램이 수정되고 개발된게 <strong>Apache</strong>이다.</p>\n\n<p>과거에 html, js, css 등과 같은 정적인 콘텐츠만을 주고 받는 구조에서는<br />\n<span class=\"post-highlight\">클라이언트 → WS [Apache] (정적 및 동적 요청 모두 처리) → DB</span> 만으로도 충분했다.</p>\n<ul>\n  <li>사실은 Apache의 경우, 정적/동적 모두 커버가 가능하기 때문에 기능적으로는 문제가 없었다.</li>\n  <li>하지만 다음과 같은 단점이 제기되었다.\n    <ul>\n      <li>동적 요청 처리가 필요할 경우, Apache가 너무 많은 부담을 가진다.</li>\n      <li>보안과 성능 측면에서 아쉬움이 있다.</li>\n      <li><em>그리고 이후에 다시 소개하겠다…</em></li>\n    </ul>\n  </li>\n  <li>그래서 앞단에 <u>정적 처리를 전문적으로 해주는 서버</u>가 있었으면 좋겠다는 생각을 하게 된다.</li>\n</ul>\n\n<p><br /></p>\n\n<h3 id=\"현재-3-tier-architecture\">현재 (3-tier Architecture)</h3>\n\n<p>정적/동적 컨텐츠에 대한 책임을 분리하고,<br />\n효율성과 확장성에 용이하기 위해 아키텍처가 발전했다.</p>\n\n<p><span class=\"post-highlight\">클라이언트 → [WS (정적 요청 처리) → WAS (동적 요청 처리)] → DB  </span><br />\n<em>(초기 발전 과정에서는 Apache가 WAS 역할로 동적 요청을 처리하고, 앞단에 정적 요청 처리를 NGINX가 붙는 방식으로 사용되었다.)</em></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/76082af9-7162-4a41-b5d4-be1d96020bfc\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>WAS는 동적 처리에 리소스 집중할 수 있게 되었고, 트래픽 증가에 유연한 대응이 가능하게 되었다.</p>\n<ul>\n  <li>소프트웨어 측면 말고, 개발자의 측면에서 보아도 효율적이다.\n    <ul>\n      <li>WS는 정적 파일, 보안, 로드밸런싱에만 집중하면 되고, WAS에서는 비즈니스 로직에만 집중하면 된다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><br /></p>\n\n<h1 id=\"2-apache와-nginx\">2. Apache와 NGINX</h1>\n\n<h2 id=\"2-1-apache-처리-방식-커넥션-기반\"><strong>2-1. Apache 처리 방식 (커넥션 기반)</strong></h2>\n\n<p>아파치는 <strong>Multi-Process Module</strong> 방식이다.<br />\n클라이언트가 요청 하나를 보내면, 하나의 process를 생성해서 연결한다.<br />\n요청당 프로세스/스레드 생성한다는 뜻이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/84ca44e3-a224-4f75-864d-f8f121f642da\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>이런 구조는 확장성 면에서 장점이 크다.<br />\n→ <span class=\"post-highlight\">이러한 측면에서 개발자들은 다양한 모듈을 만들어서 서버에 동적으로 빠르게 추가할 수 있는 장점이 있었다.</span></p>\n\n<p>하지만 다음과 같은 문제가 제기되었다.</p>\n\n<p>(🤔문제) <strong>프로세스 생성이 가벼운 작업이 아니기에, 매번 생성하기에는 너무 속도가 느려진다.</strong></p>\n\n<p>(✨발전 1) 요청 이전에 몇 개의 프로세스를 미리 만들어주는 prefork() 방식을 사용했다.</p>\n\n<p>(✨발전 2) 어찌됐든 매번 커넥션을 만드는 것은 비효율적이라고 판단했고, 이미 연결된 커넥션이 있다면 재활용하자는 생각을 한다.</p>\n<ul>\n  <li>http 헤더 종류 중에 keep-alive가 있다.</li>\n  <li><strong>→ Keep-Alive 옵션을 통해 일정 기간 동안 클라이언트와 Connection을 유지하는 방식</strong></li>\n</ul>\n\n<p><br /></p>\n\n<p>그러나 또 다른 문제가 제기되었다.</p>\n\n<p>(🤔또 다른 문제) <strong>클라이언트 수가 늘어나면서 결국 동시에 연결되어 있는 커넥션의 수도 매우 늘어나게 되었다.</strong></p>\n<ul>\n  <li>이렇게 동시 연결된 커넥션 수가 10,000개의 동시 연결을 넘어서는 순간, 서버는 더이상 커넥션을 형성하지 못하게 되는 현상이 발생했다. (<em>C10K 문제…</em>)</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/25bda5d5-aea5-4238-bc7b-3a499875a5e6\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>그런데 이 C10K 문제에서 하드웨어적으로 문제되는 것은 없었다.</li>\n  <li>이 당시 웹 페이지 용량 자체가 적었기 때문에 컴퓨터의 성능은 충분했지만,<br />\n비효율적인 서버의 구조 때문에 <strong>메모리 부족</strong> 현상이 일어난 것이다.</li>\n  <li>많은 커넥션에서 요청이 들어오기 시작하면, CPU 코어는 계속해서 프로세스를 바꿔가며 일을 해야 했다.</li>\n  <li>결론적으로, <strong>수 많은 동시 커넥션을 감당하기엔 아파치 서버의 구조가 적합하지 않았다.</strong></li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"2-2-nginx의-등장-이벤트-기반\"><strong>2-2. “NGINX”의 등장 (이벤트 기반)</strong></h2>\n\n<p>사실 NGINX는 Apache 를 대체하려고 나온 소프트웨어가 아니다.<br />\nNGINX는 Apache 앞 단에 붙여서 <span class=\"post-highlight\">보완하는 방식</span>으로 사용되었다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/c78538ef-1f3a-4e1a-b014-63afd34ca6c2\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>구조적으로 동시 커넥션을 많이 유지 못하는 아파치 서버의 부하를 nginx가 크게 줄일 수 있었다.</p>\n<ul>\n  <li><em>참고로,<br />\n[동시에 연결 가능한 커넥션 수(한 시점에 감당되는 동시 커넥션 수)] 와 초당 요청 처리 수는 다른 의미이다.</em></li>\n</ul>\n\n<p>이때 NGINX 가 정적인 페이지 처리를 모두 하고,<br />\nApache는 동적 파일 처리만 담당하는 (현대의 WAS 느낌) 구조로 바뀌게 되었다.</p>\n\n<p>그렇다면 어떻게 NGINX는 많은 동시 커넥션을 견뎌 낼 수 있을까?</p>\n\n<p><br /></p>\n\n<h3 id=\"nginx-처리-방식에-대해\">NGINX 처리 방식에 대해</h3>\n\n<p>Nginx는 Master-Worker 구조의 Process 방식을 채용했다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/a1d0bf67-8aca-4d49-8d74-690aaba06c50\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>Master Process는 설정파일에 맞게 실제 일하는 Worker Process를 만들어낸다.</p>\n\n<p>그리고 Worker가 만들어질 때 각자 지정된 Listen 소켓을 배정받는다.<br />\n(수신기를 받는다.)</p>\n\n<p>그리고 그 소켓에 새로운 클라이언트로부터 Request가 들어오면, 커넥션을 형성하고 요청을 처리한다.</p>\n<ul>\n  <li>마찬가지로 이 커넥션은 정해진 Keep-alive의 Timeout까지 연결을 유지하게 된다.</li>\n</ul>\n\n<p>하지만, Apache와의 차이는<br />\n<span class=\"post-highlight\">“그 커넥션이 형성되었다고 해서, Worker Process 1개가 그 커넥션 1개만을 담당하지는 않는다.”</span></p>\n<ul>\n  <li>형성된 커넥션에 아무런 요청이 없으면 새로운 커넥션을 형성하거나,<br />\n이미 만들어진 다른 커넥션으로부터 들어온 요청을 처리한다. (여러 커넥션을 쥐고 있는다.)</li>\n  <li>이런 <span class=\"post-highlight\">[커넥션 형성 / 커넥션 제거 / 새로운 요청 처리] 등을 모두 이벤트</span>라고 부른다.</li>\n</ul>\n\n<p>NGINX의 OS커널은 이러한 이벤트를 큐형식으로 줄세우고, Worker에게 전달한다.<br />\n<em>(멀티플레싱, epoll 에 대해 이해하면 어떻게 커널이 이벤트를 제공하는지 알 수 있다.)</em></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/26d73207-0e57-4358-894d-2f4450efcaf8\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">→ 는 커넥션 연결, O는 Request이며, 모두 “이벤트”이다.</em></p>\n\n<p>그리고 이 이벤트들은 큐에 담긴 채 비동기 방식으로 대기하고 있다.</p>\n\n<p>그리고 Worker Process는 하나의 스레드로 이벤트를 꺼내서 처리해 나간다.<br />\n이러면 Worker는 쉬지 않고 일을 계속 할 수 있다.</p>\n\n<p><span class=\"post-highlight\">요청이 없다면 방치되던 Apache의 구조보다 서버 자원을 훨씬 효율적으로 사용하는 셈</span>이다.</p>\n\n<p>(🤔문제) <strong>그런데 순서대로 꺼내서 쓰는 Queue에서 앞단에 들어오연 요청하나가 매우 시간이 오래걸리는 Disk I/O 작업이라면 어떨까..?</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d1abad7d-7b40-42be-9ff9-a293fe7a132b\" alt=\"Image\" width=\"60%\" height=\"100%\" class=\"center\" /></p>\n\n<p>매우 긴 IO 작업 중 큐에 대기하는 모든 이벤트들은 블로킹 될 것이다.</p>\n\n<p>(✨해결책) 오랜 기간 작업을 요하는 요청들을 위한 쓰레드 풀을 미리 만들어놓고,<br />\nWorker Process가 지금 처리하는 요청이 오래 걸린다고 판단되면,<br />\n해당 스레드 풀에 그 작업을 위임하고, 큐의 다른 이벤트를 처리하러 간다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/766c1772-fed9-4a42-b6ce-7fbbe7317f55\" alt=\"Image\" width=\"75%\" height=\"100%\" class=\"center\" /></p>\n\n<p>이러한 Worker Process 는 보통 Cpu의 코어 개수만큼 생성하고,<br />\n이러한 구조는 코어가 부담하는 Context Switch의 횟수를 대폭 줄일 수 있다.</p>\n\n<p>Apache와 비교하자면,</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/3e7909b6-7fd3-48df-b669-6b55a303b835\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>Apache\n    <ul>\n      <li>CPU가 여러 프로세스 간 스위칭</li>\n      <li>요청당 프로세스/스레드 필요</li>\n    </ul>\n  </li>\n  <li>Nginx\n    <ul>\n      <li>하나의 Worker Process가 이벤트 큐로 관리</li>\n      <li>단일 스레드로 여러 이벤트 처리</li>\n      <li>CPU 코어당 하나의 Worker 고정</li>\n      <li>이러한 <strong>Event-Driven Model이 Apache 구조와의 가장 큰 차이</strong>이다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"2-3-apache와-nginx\">2-3. Apache와 NGINX</h2>\n\n<p>항상 어떤 기술을 사용할 때에는 “최신 기술이여서”, “많이들 써서”가 이유가 될 수는 없다.</p>\n\n<p>어떤 기술, 어떤 아키텍처건 Trade-Off는 존재한다.</p>\n\n<p>과연 NGINX는 장점만 있을까?</p>\n\n<p>개발자가 <strong>기능(모듈) 추가를 시도했다가 돌아가고 있는 Worker Process를 종료해야 하는 상황</strong>이 생길 수 있다.</p>\n\n<p>그러면 <span class=\"post-highlight\">해당 Worker Process는 관리하고 있던 커넥션과 관려된 요청을 더이상 처리할 수 없다</span>는 문제가 발생한다.</p>\n<ul>\n  <li>그래서 NGINX는 개발자가 직접 모듈을 만들기에 좀 까다롭다.</li>\n</ul>\n\n<p>하지만, 단점보다 장점이 명확했다.</p>\n\n<p>수많은 동시 커넥션을 빠르게 처리하는 데에 있어 프로세스를 적게 만들다보니<br />\n(One Worker Process per CPU core)<br />\n⇒ 동시 커넥션 양 최소 10배 증가<br />\n⇒ 동일한 커넥션 수일 때 Apache에 비해 속도 2배 향상</p>\n\n<ul>\n  <li><strong>NGINX의 명확한 장점</strong>\n    <ol>\n      <li>One Worker Process per CPU core</li>\n      <li>Event-driven, asynchronous processing</li>\n      <li>Event Queue management</li>\n      <li>Thread Pool for long-running tasks</li>\n    </ol>\n  </li>\n</ul>\n\n<p>그리고 적은 프로세스는 관리가 쉽고, 새 Worker 생성 시 리소스 부담이 적다.</p>\n\n<p>이러한 구조는 “<span class=\"post-highlight\">NGINX가 설정을 동적으로 바꾸는 것</span>”을 가능하게 했다.</p>\n<ul>\n  <li>개발자가 설정 파일을 Runtime에 변경하고, NGINX에 적용하면,<br />\n이후부터는 Mater Process는 그 설정에 맞는 Worker Process를 찍어내게 된다.</li>\n  <li>그리고 기존 Worker Process에는 더이상 커넥션을 형성하지 못하게 막고,<br />\nQueue에 있는 이벤트들을 마저 처리한 뒤 기존 Worker들은 종료된다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/4f16c765-c2d8-44c2-850b-7c88a560dbb6\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>그런데 이러한 <strong>동적 설정 변경은 언제 사용</strong>할까?</p>\n<ul>\n  <li>대표적인 예로, NGINX가 여러 동시 커넥션을 관리하는 중에 뒷단에 새로운 서버를 추가하려는 상황이다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/b4f4191d-f32d-482f-a73c-6c14492350b2\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX는 이제부터 로드밸런싱 역할도 담당해야 한다.</p>\n\n<p>역할의 추가/변경이 의미하는 것은 무엇일까?</p>\n\n<ul>\n  <li>= Master Process가 찍어내야 하는 Worker Process의 역할의 추가/변경<br />\n= 기존 Connection 및 기존 Request들의 손실 없이 역할의 변경이 필요하다.</li>\n  <li>NGINX는 동시 커넥션을 유지한 채, 기존의 요청을 마저 처리하며, 뒷단의 서버를 추가할 수 있다.</li>\n  <li>이벤트 기반 구조이기 때문에 이러한 설정 변경을 초당 수십번 해도 무리없이 커넥션을 관리하고 요청을 서버에 전달할 수 있다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/842b0dc3-119e-4168-93f9-0e6b6f14b960\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : NetCraft Web Server Survey</em></p>\n\n<p>그런데 위 자료를 보면 의문이 든다.<br />\nNGINX가 탄생한 지 2004년부터 2007년 까지도 압도적으로 Apache가 1위를 차지하고 있다.</p>\n\n<p>이때까지만 해도 NIGNX는 소수의 문제 상황에 대한 해결책을 제시한 것 뿐이지,<br />\n대다수의 서비스를 가동하는 데에는 Apache로도 큰 문제가 없었다.</p>\n\n<h3 id=\"스마트폰의-탄생\">스마트폰의 탄생</h3>\n\n<p><img src=\"https://github.com/user-attachments/assets/2a75d845-635a-4d46-a0d2-68629d3fdd1f\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : NetCraft Web Server Survey</em></p>\n\n<p>2008년부터 급격하게 상황이 역전된다. 바로 <strong>스마트폰의 등장</strong> 때문이다.</p>\n\n<ul>\n  <li>단순히 ‘스마트폰의 등장 = 인터넷 사용자의 증가’의 이유가 아니다.</li>\n  <li>“<span class=\"post-highlight\">동시 커넥션을 훨씬 더 많이 생성한 계기</span>”로써 문제가 발생한다.</li>\n  <li>PC의 경우 클라이언트가 일정 시간 사용하고 전원을 끄는 방식으로 사용되었지만,<br />\n스마트폰은 실시간으로 정보를 받고 싶어하는 사용자의 니즈에 맞게 알림 등<br />\n<strong>동시 커넥션을 계속해서 유지</strong>하는 방식으로써 유용하게 사용되었다.</li>\n</ul>\n\n<p>이러다보니 “동시 커넥션 문제”가 현실로 다가온 것이다.</p>\n<ul>\n  <li>대규모 사이트들이 좋아할 만한 솔루션 이었고, NGINX는 급성장하게 된다.<br />\n(<em>현재 우리가 쿠버네티스고, 뭐고 배우는 이유도 이러한 문제의 솔루션으로써 대두된다는 것을 알고 넘어가자</em>)</li>\n</ul>\n\n<p>그렇다면 Apache는 가만히 있었을까?</p>\n\n<p>Apache도 MPM이라는 모듈을 추가해서 성능을 개선하기 시작한다.</p>\n\n<ul>\n  <li>Multi-Processing Module</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/acf7ede3-b612-417c-b4a5-82c352ba4c37\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<ul>\n  <li>Apache 서버를 어떤 방식으로 운영할 지 선택할 수 있는 모듈이다.\n    <ul>\n      <li>안정성이나 소규모 프로젝트에서는 기존의 prefork 방식을</li>\n      <li>성능 향상이나 대규모 프로젝트에서는 worker라는 스레드를 만들어 worker가 요청을 처리하도록 했다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>그렇다면 왜 아직도 동시 커넥션 지표에서 NGINX가 Apache를 압도적으로 앞설까?</p>\n\n<div style=\"display: flex; justify-content: space-between; gap: 20px;\">\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/1b280974-4d15-4e5d-ac6c-c21e2093f673\" alt=\"Memory Usage\" style=\"width: 100%;\" />\n    </div>\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/6a787d51-fb2d-4c1f-a973-3f380a838d29\" alt=\"Requests Per Second\" style=\"width: 100%;\" />\n    </div>\n</div>\n<p style=\"text-align: center; color: #666;\">출처: dreamhost.com</p>\n\n<p>왼쪽 동시 커넥션 수당 메모리 사용률 지표를 보면,</p>\n<ul>\n  <li>NGINX는 동시 커넥션이 많아져도 메모리 사용률이 낮고 일정한 반면,<br />\nApache는 굉장히 많은 메모리 사용률을 요구한다.</li>\n</ul>\n\n<p>오른쪽 동시 커넥션 수가 많아졌을 때 처리하는 초당 요청 수 지표를 보아도,<br />\nNGINX가 Apache에 비해 압도적으로 많다.</p>\n<ul>\n  <li>NGINX가 커넥션 관리를 얼마나 잘하는 지 볼 수 있다.</li>\n</ul>\n\n<p>사실 지금까지 <strong>동시 커넥션</strong>이라는 포인트에만 집중해서 NGINX의 장점과 현재 많이 쓰이는 이유를 알아보았다.</p>\n\n<p><strong>그렇다면 Apache의 장점은 무엇이 있을까?</strong></p>\n\n<p><br /></p>\n\n<h2 id=\"2-4-apache가-아직-쓰이는-이유와-nginx의-단점\">2-4. Apache가 아직 쓰이는 이유와 NGINX의 단점</h2>\n\n<p>근본자체가 “NCSA HTTPd”라는 소프트웨어의 버그를 수정해오며 커온 Apache이기에,\n<span class=\"post-highlight\">호환성과 확장성의 측면</span>에서는 장점이 있다.</p>\n\n<p>아직도 오픈소스로써 활발한 수정과 개선이 이루어지고 있다. [<span class=\"post-highlight\">풍부한 모듈 생태계</span>]</p>\n<ul>\n  <li><a href=\"https://projects.apache.org/projects.html\">Apache는 현재에도 Apache Kafka, Apache Hadoop 등 시대에 발맞춰 발전 중이다</a>.</li>\n</ul>\n\n<p>또한, Apache는 여러 운영 체제(리눅스, 윈도우, 유닉스 등)에서 폭넓은 호환성과 안정성을 자랑한다.</p>\n\n<p>NGINX는 그렇지 않아서, Windows에서 성능이 매우 낮게 나온다.</p>\n<ul>\n  <li>NGINX는 원래 <strong>리눅스</strong> 환경에서 설계되었기 때문에, 리눅스 OS에서 최고의 성능이 나오며,</li>\n  <li>윈도우에서도 동작은 하지만,<br />\n윈도우의 <strong>비동기 I/O</strong> 시스템에 최적화되지 않았기 때문에 <strong>성능이 상대적으로 낮다</strong>.</li>\n</ul>\n\n<p>현재 서비스에서 큰 성능 문제 없이 잘 돌아가고 있고, 모듈을 계속해서 추가/제거할 일이 많다면 굳이 NGINX로 옮길 이유는 없는 것이다.</p>\n<ul>\n  <li>오해하면 안되는 것이 NGINX는 설정 변경과 이에 따른 Worker Process의 로직 변경이 무중단으로 이루어진다는 것이며,<br />\nNGINX는 모듈 자체를 동적으로 로드할 수 없으므로, 새 모듈을 추가하려면 재컴파일이 필요하다.</li>\n  <li>Apache는 설정 변경 없이 실행 중 동적 모듈 로드가 가능하므로, 특정 기능을 빠르게 추가하거나 제거할 때 더 유연하다.</li>\n</ul>\n\n<p><strong>둘은 서로 대립관계가 아니며, 목적이 다르게 탄생한 것이다.</strong></p>\n\n<p><br /></p>\n\n<h2 id=\"2-5-그렇다면-현재-nginx를-어떻게-이용해야-하는가\">2-5. 그렇다면 현재 NGINX를 어떻게 이용해야 하는가?</h2>\n\n<p>앞서 우리는 NGINX의 WS로써, 로드밸런싱으로서의 역할을 보았다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/04bf32c2-7d72-4229-a31e-2b3e639e6b2d\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>비동기 이벤트 기반 구조로 동시 커넥션 처리가 효율적이며, Reverse Proxy로써 서버 부하를 줄일 수 있다.</p>\n\n<p>이 자체로 웹 서버 가속(성능 개선) 역할을 한다.</p>\n\n<p>추가적으로 NGINX를 사용하며 고려해야할 관점이다.</p>\n\n<p><strong>1) SSL 터미네이션 역할을 한다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/baaa7488-05be-473f-8d84-27912891b0f3\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX가 앞단에서 SSL을 처리하여, 클라이언트와는 HTTPS로 통신하고, 뒷단 서버와는 HTTP로 통신하는 방식이다.</p>\n<ul>\n  <li>어차피, NGINX와 SERVER가 같은 네트워크 안에 있는 경우가 많기 떄문에,<br />\n이렇게 통신을 해도 보안 위험이 비교적 적다.</li>\n</ul>\n\n<p>이 방식은 뒷단 서버가 <span class=\"post-highlight\">복호화 과정에서 발생하는 부하를 줄이는 장점</span>이 있다.</p>\n\n<p><strong>2) 캐싱 역할을 한다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/6c43e842-cbfa-44fd-99e0-75b079dc4a20\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>NGINX는 &lt;span class=”post-highlight”HTTP 콘텐츠 캐싱&lt;/span&gt;을 지원하며,<br />\n이를 통해 서버 부하를 줄이고 클라이언트 요청에 빠르게 응답할 수 있습니다.</p>\n<ul>\n  <li>한 번 서버로부터 받은 응답을 스스로 보관하고 클라이언트에게 전달하므로 효율적이다.</li>\n</ul>\n\n<p>이러한 경우 1번과 달리 NGINX를 클라이언트와 가까운 곳(예: CDN이나 엣지 서버)에 배치하여<br />\n캐싱 효과를 극대화할 수 있다.</p>\n\n<p><strong>3)NGINX와 컨테이너화</strong></p>\n\n<p>현재 클라우드 네이티브와 컨테이너화가 대세인 환경에서, NGINX는 더욱 중요한 역할을 수행하고 있다.</p>\n\n<p>특히 Kubernetes의 Ingress Controller로서, 또는 마이크로서비스 아키텍처에서의 API Gateway로서 그 가치가 두드러진다.</p>\n\n<p>Kubernetes에서 Ingress Controller로 사용될 때, API Gateway로서의 설정 등등</p>\n<ul>\n  <li>이러한 설정들을 통해 NGINX는 현대적인 마이크로서비스 환경에서 트래픽 라우팅, 로드밸런싱, SSL 종료, API 게이트웨이 등 다양한 역할을 효율적으로 수행할 수 있다.</li>\n  <li>특히 컨테이너 환경에서는 가볍고 빠른 NGINX의 특성이 더욱 큰 장점으로 작용한다.</li>\n</ul>\n\n<p>이 외에도 HSTS, CORS 처리, TCP/UDP 커넥션 분산 부하, HTTP/2 지원 (최근에는 /3도 지원) 등 서버를 보완하는 역할을 할 수 있다.</p>\n\n<p>어떠한 기능이 있는지를 알아보고 상황에 따라 알맞는 기능을 적용하는 자세가 필요하다.</p>\n\n<hr />\n<p>참고: <a href=\"https://www.youtube.com/watch?v=mcnJcjbfjrs\" target=\"_blank\">우아한테크 [10분 테코톡] 알리의 Web Server vs WAS</a></p>\n\n<p><a href=\"https://www.youtube.com/watch?v=6FAwAXXj5N0\" target=\"_blank\">우아한테크 [10분 테코톡] 피케이의 Nginx</a></p>\n",
                        "tags": ["WebServer","Apache","NGINX","Architecture","DevOps","Network","Performance","LoadBalancing","ReverseProxy"]
                    }
                
            ],
        
            "WAS": [
                
                    {
                        "title": "WAS(Web Application Server)와 Servlet",
                        "url": "/2025/01/28/about-was.html",
                        "subtitle": "Tomcat부터 Spring Boot까지",
                        "excerpt": "웹 서버(WS)의 진화 : Apache vs NGINX\n위 post에 이어지는 내용입니다.\n",
                        "author": "Jinho",
                        "date": "January 28, 2025",
                        "background": "/img/posts/apache_tomcat.jpeg",
                        "content": "<p><a href=\"https://jinho7.github.io/2025/01/27/ws-and-was.html\" target=\"웹 서버(WS)의 진화 : Apache vs NGINX \">웹 서버(WS)의 진화 : Apache vs NGINX</a><br />\n<em>위 post에 이어지는 내용입니다.</em></p>\n\n<h1 id=\"was-란\">WAS 란?</h1>\n\n<h2 id=\"was의-정의\">WAS의 정의</h2>\n\n<p>먼저 WAS(Web Application Server)의 정의는 다음과 같다.</p>\n<blockquote>\n  <p><span class=\"post-highlight\">웹 애플리케이션과 서버 환경을 만들어 동작시키는 기능을 제공하는 소프트웨어 프레임워크</span></p>\n</blockquote>\n\n<p>대표적으로 Apache <span class=\"post-highlight\">Tomcat</span>이 있다.</p>\n<ul>\n  <li><em>참고로 Apache Tomcat는 WS 단계에서 계속 이야기했던 Apache와는 아예 별개의 소프트웨어이다.</em></li>\n</ul>\n\n<details>\n<summary>Apache와 Tomcat</summary>\nApache HTTP Server (보통 Apache라고 부름)\n<ul>\n    <li>웹 서버(WS) 역할을 담당</li>\n    <li>주로 정적 콘텐츠를 처리</li>\n    <li>HTTP 요청을 처리하며, 동적 콘텐츠를 처리할 경우에는 WAS(Tomcat)와 연동하여 작업을 나눕니다.</li>\n</ul>\nApache Tomcat (보통 Tomcat이라고 부름)\n<ul>\n    <li>WAS 역할을 담당</li>\n    <li>Servlet Container로서 동작하며, Servlet/JSP 기반의 동적 콘텐츠를 처리\n        <ul>\n            <li><em>정적 콘텐츠도 처리할 수는 있다.</em></li>\n            <li><em>정적 콘텐츠 처리 성능은 Apache HTTP Server보다 낮다.</em></li>\n        </ul>\n    </li>\n    <li>Java EE 표준의 일부인 Servlet/JSP 스펙을 구현하며, Spring MVC와 같은 프레임워크의 기반이 되는 동작을 지원한다.</li>\n</ul>\n</details>\n\n<p><br /></p>\n\n<p>그러나 이런 물음표가 떠오른다.</p>\n\n<p><strong>❓ WAS? TOMCAT? Servlet? Servlet Container? Spring MVC?</strong></p>\n\n<p>다음 기본 개념부터 인지하고 넘어가면 이해하기 쉽다.</p>\n\n<ol>\n  <li><strong>WAS</strong>는 클라이언트의 요청을 처리하여 <strong>동적인 웹 콘텐츠</strong>를 제공하는 서버를 말한다.</li>\n  <li><strong>Tomcat</strong>은 WAS의 대표적인 예시 중 하나이다.</li>\n  <li>Tomcat은 <strong>Servlet Container의 한 종류</strong>이며, <strong>Servlet/JSP 요청을 처리</strong>하는 역할을 한다.</li>\n  <li>Tomcat은 <strong>Servlet 표준</strong>에 맞춘 애플리케이션을 실행하는 데 최적화되어 있다.\n    <ol>\n      <li><strong>Servlet 표준</strong>은 <strong>Java EE</strong>(현재는 <strong>Jakarta EE</strong>) 명세의 일부로, <strong>Java 기반 동적 웹 콘텐츠 처리</strong>를 위한 규격이다.</li>\n      <li>즉, Tomcat은 <strong>Java 기반의 웹 애플리케이션</strong>을 실행하기 위한 서버이다.</li>\n    </ol>\n  </li>\n</ol>\n\n<p><strong>WS와 WAS의 차이의 핵심는 ‘동적 처리 여부’에 있다.</strong></p>\n<ul>\n  <li>현대 웹사이트는 스크롤에 따라 새로운 피드를 보여주거나,<br />\n사용자 맞춤 광고를 제공하는 등의 동적 기능을 포함한다.</li>\n  <li>이러한 <strong>“사용자 맞춤 가공 처리(동적 콘텐츠)”는 결국 서버가 특정 코드를 실행했다</strong>는 의미다.</li>\n  <li>결국 궁금한 것은 ‘<strong>서버가 어떻게 이 코드를 실행하고, 그 결과를 클라이언트에게 제공하는가</strong>’이다.</li>\n</ul>\n\n<div style=\"display: flex; justify-content: space-between; gap: 20px;\">\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/203ab158-60b0-4376-be93-1de497da3d19\" alt=\"Memory Usage\" style=\"width: 100%;\" />\n        <p style=\"text-align: center; color: #666;\">누구나에게 제공되는 “정적인” 컨텐츠이다.</p>\n    </div>\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/5795047e-ae12-4cda-a1f6-e2b3ab8dfd72\" alt=\"Requests Per Second\" style=\"width: 100%;\" />\n        <p style=\"text-align: center; color: #666;\">하지만 로그인하고 나면 “동적인” 컨텐츠가 로드된다.</p>\n    </div>\n</div>\n\n<p>아래는 동적 페이지를 로드하는 과정을 그림으로 표현한 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/ef604672-3c6c-4724-9f9a-9a226cc6e513\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>우리는 앞서 실제 운영/대규모 서비스는 <span class=\"post-highlight\">WS-WAS 분리 구조</span>를 선호한다고 말했다.</p>\n\n<p>나는 WAS의 한 종류인 Tomcat까지의 웹통신 흐름이 어떻게 이루어지는 지가 궁금해졌다.<br />\n그리고 <u>‘jvm, survlet, spring 등 어떤 개념이고 어떤 연관관계가 있고 어떻게 유동적으로 작동할까…?’</u> 가 궁금했다.</p>\n\n<p><br /></p>\n\n<h2 id=\"jvmjava-virtual-machine\">JVM(Java Virtual Machine)</h2>\n\n<p><img src=\"https://github.com/user-attachments/assets/f48a2ce2-5aa4-495c-a686-79e32ce7eed2\" alt=\"Image\" width=\"70%\" height=\"100%\" class=\"center\" /></p>\n\n<p><em>JVM 자체가 현재 내용에서 매우 중요한 내용은 아니라 짧게 이야기하면,</em></p>\n<ul>\n  <li>⇒ 그냥 JVM은 간단히 Java 코드를 실행시켜주는 놈이라고 생각하자.</li>\n  <li>WAS(Tomcat)는 Java로 작성된 웹 애플리케이션을 실행하는 컨테이너이므로,<br />\nWAS도 JVM 위에서 동작한다.</li>\n</ul>\n\n<details>\n<summary>JVM 이란?</summary>\nApache HTTP Server (보통 Apache라고 부름)\n<ul>\n    <li>JVM은 JVM은 Java 바이트코드(.class 파일)를 해석하고 실행하는 가상 머신</li>\n    <li>JRE는 Java 프로그램을 실행하는 데 필요한 모든 것을 포함한다. 라이브러리 등</li>\n        <ul>\n            <li><em>JRE은 JVM을 시작, 필요한 클래스 라이브러리 로드, main() 메서드를 실행한다.</em></li>\n        </ul>\n    <li>JDK는 Java 애플리케이션을 개발하는 데 필요한 모든 도구를 포함한다.</li>\n</ul>\n</details>\n\n<p><br /></p>\n\n<h2 id=\"servlet-container-tomcat\">Servlet Container [Tomcat]</h2>\n\n<p>위에서 “Tomcat은 <strong><u>Servlet Container의 한 종류</u></strong>이며, <strong><u>Servlet/JSP 요청을 처리</u></strong>하는 역할을 한다.” 라고 했다.</p>\n\n<p>1) <strong>Servlet Container</strong>는 Servlet<strong>의 생명 주기</strong>를 관리하는 곳이다.</p>\n<ul>\n  <li>Servlet과 Servlet Container의 관계를 Bean과 Bean Container의 관계와 흡사하다고 생각하면 된다. (“컨테이너와 관리 대상”의 관계로 이해)\n    <ul>\n      <li>Servlet Container는 HTTP 요청과 응답을 처리하는 Servlet을 관리</li>\n      <li>Bean Container는 Spring의 <strong>애플리케이션 내 객체(Bean)</strong>의 생명 주기와 의존성을 관리</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2) 또한, <strong>HTTP 요청 처리 및 응답 생성 과정</strong>은 Servlet Container의 핵심 기능 중 하나이다.</p>\n<ul>\n  <li>웹 브라우저에서 요청이 들어오면, Tomcat은 그 요청을 받아서 적절한 Java 코드(서블릿)로 전달하고, 그 결과를 다시 브라우저로 보내는 역할을 한다.</li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"servlet\">Servlet</h2>\n\n<p>Servlet은 <strong>HTTP 요청을 처리하고 응답을 생성하는 스펙을 정의한 인터페이스</strong>이다.</p>\n<ul>\n  <li>Servlet은 <strong>jakarta.servlet.Servlet</strong>을 최상위 인터페이스로 가진다. (Java API)</li>\n</ul>\n\n<p>Servlet은 <strong>Servlet Container</strong>에 의해 관리되며, 요청이 들어오면 컨테이너가 Servlet의 생명 주기를 관리하고 요청을 처리하기 위한 스레드를 생성한다.</p>\n\n<p>Servlet은 HTTP 요청을 처리하고, 그에 따른 적절한 응답을 생성하는 기본 단위이다. 이를 통해 <span class=\"post-highlight\">REST API의 엔드포인트</span>가 되거나 <span class=\"post-highlight\">동적 웹 페이지를 생성</span>하는 역할을 수행할 수 있다.</p>\n\n<ol>\n  <li>Servlet은 HTTP 요청을 받아 비즈니스 로직을 처리하고 JSON, XML 등의 형식으로 데이터를 응답할 수 있다.</li>\n  <li>동적인 HTML 콘텐츠를 생성할 때도 사용된다.\n    <ul>\n      <li>예를 들어, 비즈니스 로직 처리가 필요한 HTTP 요청이 Web Server로 들어오면, Web Server는 이를 Servlet Container가 실행하는 Servlet에 전달한다.</li>\n      <li>Servlet은 요청을 처리하고 동적인 웹 콘텐츠를 생성한 뒤, 결과를 Web Server를 통해 클라이언트로 반환한다.</li>\n    </ul>\n  </li>\n</ol>\n\n<p>전체적인 통신 흐름은 다음과 같다.</p>\n<ul>\n  <li>WS 는 HTTP 요청을 받아 정적 리소스를 처리하거나, 요청을 WAS에 전달한다.</li>\n  <li>WAS는 Servlet Container를 통해 요청을 처리하고, 처리 결과를 Web Server를 거쳐 클라이언트에 반환한다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/06d2213c-0f90-4a1b-a765-33531aeed39d\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p><br /></p>\n\n<h3 id=\"servlet의-생명주기\">Servlet의 생명주기</h3>\n\n<p>위 그림을 보면 알 수 있듯, Servlet은 다음과 같은 생명 주기를 가진다.</p>\n\n<p>1) <strong>초기화 단계</strong>:</p>\n<ul>\n  <li>최초 요청이 오면 Servlet 클래스(HelloServlet.class)가 로딩된다.</li>\n  <li>web.xml 설정을 참고하여 매핑할 Servlet을 확인한다.</li>\n  <li><span class=\"post-highlight\">해당 Servlet 인스턴스가 있다면 사용하고, 없다면 init()으로 초기화한다.</span></li>\n</ul>\n\n<p>2) <strong>서비스 단계</strong>:</p>\n<ul>\n  <li>Servlet Container는 각 요청마다 새로운 스레드를 생성한다.</li>\n  <li>새로운 Request/Response 객체를 생성하여 service() 메서드를 실행한다.</li>\n  <li>service()는 요청 방식(GET, POST 등)에 따라 적절한 do메서드를 호출한다.</li>\n  <li>요청 처리가 완료되면 해당 Request/Response 객체는 소멸된다.</li>\n</ul>\n\n<p>3) <strong>소멸 단계</strong>:</p>\n<ul>\n  <li><em>서버 종료나 애플리케이션 재배포 시에만 destroy()가 호출된다.</em></li>\n  <li><em>Servlet이 사용하던 리소스를 정리한다.</em></li>\n</ul>\n\n<p><br /></p>\n\n<p>정리하자면,</p>\n<ul>\n  <li>Tomcat은 Servlet 객체를 한 번 생성하면 메모리에 유지하고, 요청이 올 때마다 해당 객체의 <strong>service()</strong> 메서드를 호출한다.</li>\n  <li>따라서, <strong>init()</strong> 메서드는 <strong>최초 요청 시(또는 설정에 따라 애플리케이션 시작 시)</strong> 단 한 번 실행된다.</li>\n  <li>또 종료되기 전이나 reload 전에 destroy()를 호출하여 매번 객체가 생성되는 것을 방지한다.</li>\n</ul>\n\n<p><strong>(🤔 궁금증) servlet은 왜 생성만 하고 제거는 안하지?</strong>\n만약 사용이 끝날 때마다 제거한다면 다음과 같은 문제가 있다.</p>\n<ul>\n  <li>모든 요청에 대해 servlet을 생성하고 소멸하는 것은 OS 와 JVM 에게 필요없는 부하를 일으킨다.\n    <ul>\n      <li>JVM의 <strong>Garbage Collection</strong>과 <strong>메모리 할당/해제</strong>를 빈번하게 유발</li>\n    </ul>\n  </li>\n  <li>동시에 다수의 요청이 들어올 경우 CPU 또는 메모리 리소스 소모에 대한 제한이 어렵다. \n결국 순간적으로 서버가 다운되거나 동시 처리에 문제가 생길 수 있다.\n    <ul>\n      <li><em>(참고로 Tomcat 3.2 이전 버전은 실제 매번 생성과 제거를 했다.)</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p><strong>(✨해결) 해답은 Servlet의 특징과 관리 방식에 있다.</strong></p>\n<ul>\n  <li>수많은 클라이언트의 요청을 동시에 처리해야 하는 WAS의 특성상,\nServlet은 싱글톤 패턴으로 관리하게 되었다.\n    <ul>\n      <li>한 번 생성된 Servlet 인스턴스는 메모리에 계속 유지된다.</li>\n      <li>모든 요청은 동일한 Servlet 인스턴스를 공유한다.</li>\n      <li>init()은 최초 요청 시 한 번만 실행된다.</li>\n      <li>destroy()는 서버 종료나 재배포 시에만 실행된다.</li>\n    </ul>\n  </li>\n  <li><em>(Tomcat 3.2 부터는 디폴트로 <span class=\"post-highlight\">싱글톤 패턴 도입</span>와 <span class=\"post-highlight\">Thread Pool</span> 을 사용)</em></li>\n</ul>\n\n<p><br /></p>\n\n<h1 id=\"servlet-처리-구조의-발전\">Servlet 처리 구조의 발전</h1>\n\n<h2 id=\"기존-servlet-처리-방식\">기존 Servlet 처리 방식</h2>\n\n<p>Tomcat은 다음과 같은 역할을 한다고 하였다.</p>\n<ul>\n  <li>Servlet Container로서 HTTP 요청과 응답을 처리하는 환경 제공</li>\n  <li>Servlet 객체의 생성, 초기화, 요청 처리, 소멸 등 <strong>생명주기를 관리</strong>하는 역할</li>\n</ul>\n\n<p><strong>(🤔 문제점) Servlet은 요청마다 개별적으로 처리 로직을 구현해야 하므로,</strong><br />\n<strong>비슷한 요청을 처리하는 여러 Servlet에서 <span class=\"post-highlight\">중복된 코드가 발생</span>할 수 있다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/7c5e684e-cd0f-4167-8e55-f3d24172f58e\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 기존 서블릿 방식 - 각 URL마다 서블릿을 따로 만들어야 했습니다</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserServlet</span> <span class=\"kd\">extends</span> <span class=\"nc\">HttpServlet</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">doGet</span><span class=\"o\">(</span><span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"nc\">HttpServletResponse</span> <span class=\"n\">response</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 로깅 처리</span>\n        <span class=\"c1\">// 인증 처리</span>\n        <span class=\"c1\">// 공통 에러 처리</span>\n        <span class=\"c1\">// 실제 비즈니스 로직</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProductServlet</span> <span class=\"kd\">extends</span> <span class=\"nc\">HttpServlet</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">doGet</span><span class=\"o\">(</span><span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"nc\">HttpServletResponse</span> <span class=\"n\">response</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 위와 동일한 로깅, 인증, 에러 처리 코드가 반복됨</span>\n        <span class=\"c1\">// 실제 비즈니스 로직</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>이러한 방식은 다음과 같은 문제가 있다.</p>\n<ol>\n  <li>하나의 서블릿 클래스에 너무 많은 책임이 집중된다.</li>\n  <li>URL 매핑, 파라미터 처리, 뷰 선택 등을 모두 수동으로 처리해야 함</li>\n  <li>모든 서블릿에서 공통 로직(로깅, 인증, 에러 처리 등)이 반복됨</li>\n  <li>각각의 서블릿을 web.xml에 일일이 등록해야 함<br />\n (web.xml : 웹 애플리케이션의 <strong>구성 정보</strong>를 제공)</li>\n</ol>\n\n<ul>\n  <li>과거 web.xml은 다음과 같은 중요한 정보들을 담고 있었다.\n    <ul>\n      <li>어떤 서블릿이 존재하는지</li>\n      <li>각 서블릿이 어떤 URL 패턴을 처리하는지</li>\n      <li>어떤 필터들이 요청을 처리하는지</li>\n      <li>웹 애플리케이션의 시작과 종료 시 필요한 리스너는 무엇인지</li>\n    </ul>\n  </li>\n</ul>\n\n<p>⇒ 각 서블릿(요청을 처리하는 클래스)에 대한 정보를 등록해야 한다는 것이다… 😢</p>\n\n<p><br /></p>\n\n<h2 id=\"dispatcherservlet---spring-mvc--공통-로직의-중앙-집중화\"><strong>DispatcherServlet</strong> - Spring MVC : 공통 로직의 중앙 집중화</h2>\n\n<p><strong>(✨ 해결책) 공통 로직의 중앙 집중화</strong></p>\n\n<p>Spring Framework는 기존 서블릿 스펙의 장점을 활용하면서도 그 한계를 개선하는 방향으로 발전했다.</p>\n\n<p><span class=\"post-highlight\">DispatcherServlet이라는 Front Controller를 사용해 공통 로직을 처리하고 요청에 맞는 컨트롤러를 호출하는 특수한 Servlet</span>을 만들어 새로운 구조를 도입했다.</p>\n\n<ul>\n  <li><em>참고로 <strong>DispatcherServlet</strong> 도 <strong>Servlet이다.</strong></em>\n    <ul>\n      <li><em>(이쯤에서 Spring에서의 Controller의 역할이 아구 맞게 떠오른다.)</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/945895b9-66a2-4713-b7a4-8461f3a66075\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>Spring MVC는 이러한 문제를 DispatcherServlet이라는 하나의 Front Controller로 해결했다.</p>\n\n<ul>\n  <li><em>이제 우리가 아는 친숙한 코드가 나온다….</em></li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Spring MVC 방식</span>\n<span class=\"nd\">@Controller</span>  <span class=\"c1\">// 더 이상 HttpServlet을 상속할 필요가 없음</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserController</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@GetMapping</span><span class=\"o\">(</span><span class=\"s\">\"/users\"</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">handleUsers</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 비즈니스 로직에만 집중</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"userList\"</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"nd\">@Controller</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProductController</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@GetMapping</span><span class=\"o\">(</span><span class=\"s\">\"/products\"</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">handleProducts</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 비즈니스 로직에만 집중</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"productList\"</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p><strong>DispatcherServlet</strong>은 다음과 같은 일을 한다.</p>\n\n<ol>\n  <li><strong>DispatcherServlet</strong>은 웹 애플리케이션에 들어오는 모든 HTTP 요청을 먼저 받는다.</li>\n  <li>요청을 <strong>어떤 컨트롤러가 처리할지 결정</strong>하고, 해당 컨트롤러로 요청을 <strong>디스패치(위임)</strong> 한다.</li>\n  <li>요청에 대해 <strong>공통 처리</strong>(예: 인증, 로깅 등)를 먼저 한 후, 적절한 컨트롤러로 요청을 전달한다.</li>\n  <li><strong>DispatcherServlet</strong> 덕분에, 이제 다른 컨트롤러는 굳이 서블릿을 상속할 필요가 없다.</li>\n</ol>\n\n<p>4번에 대해 추가 설명을 하자면, <strong>Spring MVC</strong>에서는 <strong>DispatcherServlet</strong>만 서블릿으로 등록하고, 실제 비즈니스 로직을 처리하는 <strong>컨트롤러</strong>는 <strong>서블릿</strong>이 아니어도 된다는 뜻이다.</p>\n\n<ul>\n  <li><strong>Spring MVC</strong>에서는 <strong>DispatcherServlet</strong>만 서블릿으로 등록하고, 실제 비즈니스 로직을 처리하는 <strong>컨트롤러</strong>는 <strong>서블릿</strong>이 아니어도 된다는 뜻이다.</li>\n  <li>Spring MVC의 <strong>컨트롤러</strong>는 단순한 <strong>자바 클래스</strong>로, <strong>@Controller</strong> 어노테이션을 붙인 클래스를 만들어 요청을 처리할 수 있다.</li>\n  <li>이때, <strong>컨트롤러 클래스는 Servlet을 상속하지 않아도</strong> 된다.</li>\n  <li><strong>DispatcherServlet</strong>이 모든 요청을 처리하고, 요청을 <strong>컨트롤러</strong>로 전달하기 때문에, 실제로는 <strong>서블릿이 아닌 컨트롤러</strong>가 <strong>Servlet 객체를 상속</strong>하지 않아도 된다는 뜻이다.</li>\n</ul>\n\n<p>이렇듯 Spring 프레임워크는 Front Controller를 제공해주고 이를 Dispather Servlet 이라 부른다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/f5b5a218-c501-43c6-8869-c0ccd63acc77\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p><br /></p>\n\n<h2 id=\"servlet과-dispatcherservlet의-역할-분담의-의의\"><strong>Servlet</strong>과 DispatcherServlet의 역할 분담의 의의</h2>\n\n<p>Servlet 표준에서 중요한 점은 Servlet이 <span class=\"post-highlight\">전체 데이터 처리 과정에서 특정한 역할만 수행</span>한다는 것이다.</p>\n\n<p><strong><u>전통적인 서블릿 방식</u></strong>에서는 HTTP 요청/응답 처리부터 비즈니스 로직까지 모든 것을 책임져야했다.</p>\n\n<p>변화한 Spring MVC 구조에는 다음과 같은 장점이 있다.</p>\n\n<p>1) <strong>관심사의 분리(Separation of Concerns)</strong></p>\n<ol>\n  <li>DispatcherServlet이 모든 HTTP 요청을 먼저 받아서 적절한 Controller로 라우팅하는 역할을 담당하게 되었다.</li>\n  <li>이로 인해 Controller는 비즈니스 로직에만 집중할 수 있게 되었다.</li>\n</ol>\n\n<p>2) <strong>POJO(Plain Old Java Object) 기반 개발</strong></p>\n<ol>\n  <li>Controller가 더 이상 HttpServlet을 상속받지 않아도 된다는 것은 매우 중요한 의미를 가진다.</li>\n  <li>이는 일반적인 자바 클래스로 웹 개발이 가능해졌다는 뜻이다.</li>\n</ol>\n\n<p>3) <strong>각 엔드포인트가 명확하게 분리된다.</strong></p>\n\n<p><br /></p>\n\n<p>⇒ Spring Boot는 이러한 통합을 더욱 단순화했다.</p>\n\n<p>개발자는 복잡한 설정 없이도 Tomcat과 Spring이 자연스럽게 협력하는 환경에서 개발할 수 있게 되었다.</p>\n\n<p>web.xml 없이도 자동 구성을 통해 모든 것이 가능해졌다.</p>\n\n<p><em>@SpringBootApplication 어노테이션은 다음 3가지 핵심 어노테이션의 조합이다.</em></p>\n\n<ol>\n  <li>@SpringBootConfiguration</li>\n  <li><span class=\"post-highlight\">@EnableAutoConfiguration</span> [자동 구성]</li>\n  <li>@ComponentScan</li>\n</ol>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@SpringBootApplication</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">MyApplication</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// Spring Boot가 내장 Tomcat을 자동으로 구성하고 시작</span>\n        <span class=\"nc\">SpringApplication</span><span class=\"o\">.</span><span class=\"na\">run</span><span class=\"o\">(</span><span class=\"nc\">MyApplication</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">,</span> <span class=\"n\">args</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>즉, 현대에 와서 <strong>DispatcherServlet이 서블릿 역할을 하면서</strong> 요청을 <strong>Controller</strong>에 전달하고, <strong>Controller</strong>는 <strong>서비스</strong>를 호출하여 실제 비즈니스 로직을 처리하게 하는 방식으로 발전하였다.</p>\n\n<ul>\n  <li>단지 <strong>DispatcherServlet</strong>은 요청을 받아서 적절한 컨트롤러에게 넘겨주는 역할을 한다.</li>\n</ul>\n\n<p>지금까지 살펴본 WAS의 발전 과정을 보면 다음과 같다.</p>\n<ol>\n  <li>WAS는 동적 컨텐츠 처리를 위한 웹 애플리케이션 서버로 분리되며 시작됐다.</li>\n  <li>Tomcat은 Servlet Container로서 Java 기반 웹 애플리케이션을 실행시킨다.</li>\n  <li>초기 Servlet 방식의 한계(중복 코드, 복잡한 설정)를 Spring MVC가 해결했다.</li>\n  <li>DispatcherServlet의 도입으로 공통 로직 처리와 요청 위임이 체계화되었다.</li>\n</ol>\n\n<p>결국 DispatcherServlet이 모든 요청을 받아 적절한 Controller에 위임하므로\nController는 순수 비즈니스 로직에만 집중할 수 있게 되었다.</p>\n<ul>\n  <li>개발자는 반복적인 설정 없이 핵심 기능 개발에 집중 가능!</li>\n</ul>\n\n<p>이처럼 WAS와 Servlet, 그리고 Spring MVC로 이어지는 발전 과정은 더 나은 웹 개발 환경을 만들어왔다.</p>\n\n<p>더 나아가, 웹 애플리케이션 아키텍처는 계속해서 진화하고 있다.</p>\n<ul>\n  <li>Spring WebFlux를 통한 리액티브 프로그래밍 도입</li>\n  <li>클라우드 네이티브 환경 지원</li>\n  <li>마이크로서비스 아키텍처로의 전환</li>\n  <li>서버리스 아키텍처의 등장</li>\n</ul>\n",
                        "tags": ["WAS","Tomcat","Servlet","SpringMVC","Java","WebDevelopment","Architecture","DispatcherServlet","SpringBoot"]
                    }
                
            ],
        
            "Tomcat": [
                
                    {
                        "title": "WAS(Web Application Server)와 Servlet",
                        "url": "/2025/01/28/about-was.html",
                        "subtitle": "Tomcat부터 Spring Boot까지",
                        "excerpt": "웹 서버(WS)의 진화 : Apache vs NGINX\n위 post에 이어지는 내용입니다.\n",
                        "author": "Jinho",
                        "date": "January 28, 2025",
                        "background": "/img/posts/apache_tomcat.jpeg",
                        "content": "<p><a href=\"https://jinho7.github.io/2025/01/27/ws-and-was.html\" target=\"웹 서버(WS)의 진화 : Apache vs NGINX \">웹 서버(WS)의 진화 : Apache vs NGINX</a><br />\n<em>위 post에 이어지는 내용입니다.</em></p>\n\n<h1 id=\"was-란\">WAS 란?</h1>\n\n<h2 id=\"was의-정의\">WAS의 정의</h2>\n\n<p>먼저 WAS(Web Application Server)의 정의는 다음과 같다.</p>\n<blockquote>\n  <p><span class=\"post-highlight\">웹 애플리케이션과 서버 환경을 만들어 동작시키는 기능을 제공하는 소프트웨어 프레임워크</span></p>\n</blockquote>\n\n<p>대표적으로 Apache <span class=\"post-highlight\">Tomcat</span>이 있다.</p>\n<ul>\n  <li><em>참고로 Apache Tomcat는 WS 단계에서 계속 이야기했던 Apache와는 아예 별개의 소프트웨어이다.</em></li>\n</ul>\n\n<details>\n<summary>Apache와 Tomcat</summary>\nApache HTTP Server (보통 Apache라고 부름)\n<ul>\n    <li>웹 서버(WS) 역할을 담당</li>\n    <li>주로 정적 콘텐츠를 처리</li>\n    <li>HTTP 요청을 처리하며, 동적 콘텐츠를 처리할 경우에는 WAS(Tomcat)와 연동하여 작업을 나눕니다.</li>\n</ul>\nApache Tomcat (보통 Tomcat이라고 부름)\n<ul>\n    <li>WAS 역할을 담당</li>\n    <li>Servlet Container로서 동작하며, Servlet/JSP 기반의 동적 콘텐츠를 처리\n        <ul>\n            <li><em>정적 콘텐츠도 처리할 수는 있다.</em></li>\n            <li><em>정적 콘텐츠 처리 성능은 Apache HTTP Server보다 낮다.</em></li>\n        </ul>\n    </li>\n    <li>Java EE 표준의 일부인 Servlet/JSP 스펙을 구현하며, Spring MVC와 같은 프레임워크의 기반이 되는 동작을 지원한다.</li>\n</ul>\n</details>\n\n<p><br /></p>\n\n<p>그러나 이런 물음표가 떠오른다.</p>\n\n<p><strong>❓ WAS? TOMCAT? Servlet? Servlet Container? Spring MVC?</strong></p>\n\n<p>다음 기본 개념부터 인지하고 넘어가면 이해하기 쉽다.</p>\n\n<ol>\n  <li><strong>WAS</strong>는 클라이언트의 요청을 처리하여 <strong>동적인 웹 콘텐츠</strong>를 제공하는 서버를 말한다.</li>\n  <li><strong>Tomcat</strong>은 WAS의 대표적인 예시 중 하나이다.</li>\n  <li>Tomcat은 <strong>Servlet Container의 한 종류</strong>이며, <strong>Servlet/JSP 요청을 처리</strong>하는 역할을 한다.</li>\n  <li>Tomcat은 <strong>Servlet 표준</strong>에 맞춘 애플리케이션을 실행하는 데 최적화되어 있다.\n    <ol>\n      <li><strong>Servlet 표준</strong>은 <strong>Java EE</strong>(현재는 <strong>Jakarta EE</strong>) 명세의 일부로, <strong>Java 기반 동적 웹 콘텐츠 처리</strong>를 위한 규격이다.</li>\n      <li>즉, Tomcat은 <strong>Java 기반의 웹 애플리케이션</strong>을 실행하기 위한 서버이다.</li>\n    </ol>\n  </li>\n</ol>\n\n<p><strong>WS와 WAS의 차이의 핵심는 ‘동적 처리 여부’에 있다.</strong></p>\n<ul>\n  <li>현대 웹사이트는 스크롤에 따라 새로운 피드를 보여주거나,<br />\n사용자 맞춤 광고를 제공하는 등의 동적 기능을 포함한다.</li>\n  <li>이러한 <strong>“사용자 맞춤 가공 처리(동적 콘텐츠)”는 결국 서버가 특정 코드를 실행했다</strong>는 의미다.</li>\n  <li>결국 궁금한 것은 ‘<strong>서버가 어떻게 이 코드를 실행하고, 그 결과를 클라이언트에게 제공하는가</strong>’이다.</li>\n</ul>\n\n<div style=\"display: flex; justify-content: space-between; gap: 20px;\">\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/203ab158-60b0-4376-be93-1de497da3d19\" alt=\"Memory Usage\" style=\"width: 100%;\" />\n        <p style=\"text-align: center; color: #666;\">누구나에게 제공되는 “정적인” 컨텐츠이다.</p>\n    </div>\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/5795047e-ae12-4cda-a1f6-e2b3ab8dfd72\" alt=\"Requests Per Second\" style=\"width: 100%;\" />\n        <p style=\"text-align: center; color: #666;\">하지만 로그인하고 나면 “동적인” 컨텐츠가 로드된다.</p>\n    </div>\n</div>\n\n<p>아래는 동적 페이지를 로드하는 과정을 그림으로 표현한 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/ef604672-3c6c-4724-9f9a-9a226cc6e513\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>우리는 앞서 실제 운영/대규모 서비스는 <span class=\"post-highlight\">WS-WAS 분리 구조</span>를 선호한다고 말했다.</p>\n\n<p>나는 WAS의 한 종류인 Tomcat까지의 웹통신 흐름이 어떻게 이루어지는 지가 궁금해졌다.<br />\n그리고 <u>‘jvm, survlet, spring 등 어떤 개념이고 어떤 연관관계가 있고 어떻게 유동적으로 작동할까…?’</u> 가 궁금했다.</p>\n\n<p><br /></p>\n\n<h2 id=\"jvmjava-virtual-machine\">JVM(Java Virtual Machine)</h2>\n\n<p><img src=\"https://github.com/user-attachments/assets/f48a2ce2-5aa4-495c-a686-79e32ce7eed2\" alt=\"Image\" width=\"70%\" height=\"100%\" class=\"center\" /></p>\n\n<p><em>JVM 자체가 현재 내용에서 매우 중요한 내용은 아니라 짧게 이야기하면,</em></p>\n<ul>\n  <li>⇒ 그냥 JVM은 간단히 Java 코드를 실행시켜주는 놈이라고 생각하자.</li>\n  <li>WAS(Tomcat)는 Java로 작성된 웹 애플리케이션을 실행하는 컨테이너이므로,<br />\nWAS도 JVM 위에서 동작한다.</li>\n</ul>\n\n<details>\n<summary>JVM 이란?</summary>\nApache HTTP Server (보통 Apache라고 부름)\n<ul>\n    <li>JVM은 JVM은 Java 바이트코드(.class 파일)를 해석하고 실행하는 가상 머신</li>\n    <li>JRE는 Java 프로그램을 실행하는 데 필요한 모든 것을 포함한다. 라이브러리 등</li>\n        <ul>\n            <li><em>JRE은 JVM을 시작, 필요한 클래스 라이브러리 로드, main() 메서드를 실행한다.</em></li>\n        </ul>\n    <li>JDK는 Java 애플리케이션을 개발하는 데 필요한 모든 도구를 포함한다.</li>\n</ul>\n</details>\n\n<p><br /></p>\n\n<h2 id=\"servlet-container-tomcat\">Servlet Container [Tomcat]</h2>\n\n<p>위에서 “Tomcat은 <strong><u>Servlet Container의 한 종류</u></strong>이며, <strong><u>Servlet/JSP 요청을 처리</u></strong>하는 역할을 한다.” 라고 했다.</p>\n\n<p>1) <strong>Servlet Container</strong>는 Servlet<strong>의 생명 주기</strong>를 관리하는 곳이다.</p>\n<ul>\n  <li>Servlet과 Servlet Container의 관계를 Bean과 Bean Container의 관계와 흡사하다고 생각하면 된다. (“컨테이너와 관리 대상”의 관계로 이해)\n    <ul>\n      <li>Servlet Container는 HTTP 요청과 응답을 처리하는 Servlet을 관리</li>\n      <li>Bean Container는 Spring의 <strong>애플리케이션 내 객체(Bean)</strong>의 생명 주기와 의존성을 관리</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2) 또한, <strong>HTTP 요청 처리 및 응답 생성 과정</strong>은 Servlet Container의 핵심 기능 중 하나이다.</p>\n<ul>\n  <li>웹 브라우저에서 요청이 들어오면, Tomcat은 그 요청을 받아서 적절한 Java 코드(서블릿)로 전달하고, 그 결과를 다시 브라우저로 보내는 역할을 한다.</li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"servlet\">Servlet</h2>\n\n<p>Servlet은 <strong>HTTP 요청을 처리하고 응답을 생성하는 스펙을 정의한 인터페이스</strong>이다.</p>\n<ul>\n  <li>Servlet은 <strong>jakarta.servlet.Servlet</strong>을 최상위 인터페이스로 가진다. (Java API)</li>\n</ul>\n\n<p>Servlet은 <strong>Servlet Container</strong>에 의해 관리되며, 요청이 들어오면 컨테이너가 Servlet의 생명 주기를 관리하고 요청을 처리하기 위한 스레드를 생성한다.</p>\n\n<p>Servlet은 HTTP 요청을 처리하고, 그에 따른 적절한 응답을 생성하는 기본 단위이다. 이를 통해 <span class=\"post-highlight\">REST API의 엔드포인트</span>가 되거나 <span class=\"post-highlight\">동적 웹 페이지를 생성</span>하는 역할을 수행할 수 있다.</p>\n\n<ol>\n  <li>Servlet은 HTTP 요청을 받아 비즈니스 로직을 처리하고 JSON, XML 등의 형식으로 데이터를 응답할 수 있다.</li>\n  <li>동적인 HTML 콘텐츠를 생성할 때도 사용된다.\n    <ul>\n      <li>예를 들어, 비즈니스 로직 처리가 필요한 HTTP 요청이 Web Server로 들어오면, Web Server는 이를 Servlet Container가 실행하는 Servlet에 전달한다.</li>\n      <li>Servlet은 요청을 처리하고 동적인 웹 콘텐츠를 생성한 뒤, 결과를 Web Server를 통해 클라이언트로 반환한다.</li>\n    </ul>\n  </li>\n</ol>\n\n<p>전체적인 통신 흐름은 다음과 같다.</p>\n<ul>\n  <li>WS 는 HTTP 요청을 받아 정적 리소스를 처리하거나, 요청을 WAS에 전달한다.</li>\n  <li>WAS는 Servlet Container를 통해 요청을 처리하고, 처리 결과를 Web Server를 거쳐 클라이언트에 반환한다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/06d2213c-0f90-4a1b-a765-33531aeed39d\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p><br /></p>\n\n<h3 id=\"servlet의-생명주기\">Servlet의 생명주기</h3>\n\n<p>위 그림을 보면 알 수 있듯, Servlet은 다음과 같은 생명 주기를 가진다.</p>\n\n<p>1) <strong>초기화 단계</strong>:</p>\n<ul>\n  <li>최초 요청이 오면 Servlet 클래스(HelloServlet.class)가 로딩된다.</li>\n  <li>web.xml 설정을 참고하여 매핑할 Servlet을 확인한다.</li>\n  <li><span class=\"post-highlight\">해당 Servlet 인스턴스가 있다면 사용하고, 없다면 init()으로 초기화한다.</span></li>\n</ul>\n\n<p>2) <strong>서비스 단계</strong>:</p>\n<ul>\n  <li>Servlet Container는 각 요청마다 새로운 스레드를 생성한다.</li>\n  <li>새로운 Request/Response 객체를 생성하여 service() 메서드를 실행한다.</li>\n  <li>service()는 요청 방식(GET, POST 등)에 따라 적절한 do메서드를 호출한다.</li>\n  <li>요청 처리가 완료되면 해당 Request/Response 객체는 소멸된다.</li>\n</ul>\n\n<p>3) <strong>소멸 단계</strong>:</p>\n<ul>\n  <li><em>서버 종료나 애플리케이션 재배포 시에만 destroy()가 호출된다.</em></li>\n  <li><em>Servlet이 사용하던 리소스를 정리한다.</em></li>\n</ul>\n\n<p><br /></p>\n\n<p>정리하자면,</p>\n<ul>\n  <li>Tomcat은 Servlet 객체를 한 번 생성하면 메모리에 유지하고, 요청이 올 때마다 해당 객체의 <strong>service()</strong> 메서드를 호출한다.</li>\n  <li>따라서, <strong>init()</strong> 메서드는 <strong>최초 요청 시(또는 설정에 따라 애플리케이션 시작 시)</strong> 단 한 번 실행된다.</li>\n  <li>또 종료되기 전이나 reload 전에 destroy()를 호출하여 매번 객체가 생성되는 것을 방지한다.</li>\n</ul>\n\n<p><strong>(🤔 궁금증) servlet은 왜 생성만 하고 제거는 안하지?</strong>\n만약 사용이 끝날 때마다 제거한다면 다음과 같은 문제가 있다.</p>\n<ul>\n  <li>모든 요청에 대해 servlet을 생성하고 소멸하는 것은 OS 와 JVM 에게 필요없는 부하를 일으킨다.\n    <ul>\n      <li>JVM의 <strong>Garbage Collection</strong>과 <strong>메모리 할당/해제</strong>를 빈번하게 유발</li>\n    </ul>\n  </li>\n  <li>동시에 다수의 요청이 들어올 경우 CPU 또는 메모리 리소스 소모에 대한 제한이 어렵다. \n결국 순간적으로 서버가 다운되거나 동시 처리에 문제가 생길 수 있다.\n    <ul>\n      <li><em>(참고로 Tomcat 3.2 이전 버전은 실제 매번 생성과 제거를 했다.)</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p><strong>(✨해결) 해답은 Servlet의 특징과 관리 방식에 있다.</strong></p>\n<ul>\n  <li>수많은 클라이언트의 요청을 동시에 처리해야 하는 WAS의 특성상,\nServlet은 싱글톤 패턴으로 관리하게 되었다.\n    <ul>\n      <li>한 번 생성된 Servlet 인스턴스는 메모리에 계속 유지된다.</li>\n      <li>모든 요청은 동일한 Servlet 인스턴스를 공유한다.</li>\n      <li>init()은 최초 요청 시 한 번만 실행된다.</li>\n      <li>destroy()는 서버 종료나 재배포 시에만 실행된다.</li>\n    </ul>\n  </li>\n  <li><em>(Tomcat 3.2 부터는 디폴트로 <span class=\"post-highlight\">싱글톤 패턴 도입</span>와 <span class=\"post-highlight\">Thread Pool</span> 을 사용)</em></li>\n</ul>\n\n<p><br /></p>\n\n<h1 id=\"servlet-처리-구조의-발전\">Servlet 처리 구조의 발전</h1>\n\n<h2 id=\"기존-servlet-처리-방식\">기존 Servlet 처리 방식</h2>\n\n<p>Tomcat은 다음과 같은 역할을 한다고 하였다.</p>\n<ul>\n  <li>Servlet Container로서 HTTP 요청과 응답을 처리하는 환경 제공</li>\n  <li>Servlet 객체의 생성, 초기화, 요청 처리, 소멸 등 <strong>생명주기를 관리</strong>하는 역할</li>\n</ul>\n\n<p><strong>(🤔 문제점) Servlet은 요청마다 개별적으로 처리 로직을 구현해야 하므로,</strong><br />\n<strong>비슷한 요청을 처리하는 여러 Servlet에서 <span class=\"post-highlight\">중복된 코드가 발생</span>할 수 있다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/7c5e684e-cd0f-4167-8e55-f3d24172f58e\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 기존 서블릿 방식 - 각 URL마다 서블릿을 따로 만들어야 했습니다</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserServlet</span> <span class=\"kd\">extends</span> <span class=\"nc\">HttpServlet</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">doGet</span><span class=\"o\">(</span><span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"nc\">HttpServletResponse</span> <span class=\"n\">response</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 로깅 처리</span>\n        <span class=\"c1\">// 인증 처리</span>\n        <span class=\"c1\">// 공통 에러 처리</span>\n        <span class=\"c1\">// 실제 비즈니스 로직</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProductServlet</span> <span class=\"kd\">extends</span> <span class=\"nc\">HttpServlet</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">doGet</span><span class=\"o\">(</span><span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"nc\">HttpServletResponse</span> <span class=\"n\">response</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 위와 동일한 로깅, 인증, 에러 처리 코드가 반복됨</span>\n        <span class=\"c1\">// 실제 비즈니스 로직</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>이러한 방식은 다음과 같은 문제가 있다.</p>\n<ol>\n  <li>하나의 서블릿 클래스에 너무 많은 책임이 집중된다.</li>\n  <li>URL 매핑, 파라미터 처리, 뷰 선택 등을 모두 수동으로 처리해야 함</li>\n  <li>모든 서블릿에서 공통 로직(로깅, 인증, 에러 처리 등)이 반복됨</li>\n  <li>각각의 서블릿을 web.xml에 일일이 등록해야 함<br />\n (web.xml : 웹 애플리케이션의 <strong>구성 정보</strong>를 제공)</li>\n</ol>\n\n<ul>\n  <li>과거 web.xml은 다음과 같은 중요한 정보들을 담고 있었다.\n    <ul>\n      <li>어떤 서블릿이 존재하는지</li>\n      <li>각 서블릿이 어떤 URL 패턴을 처리하는지</li>\n      <li>어떤 필터들이 요청을 처리하는지</li>\n      <li>웹 애플리케이션의 시작과 종료 시 필요한 리스너는 무엇인지</li>\n    </ul>\n  </li>\n</ul>\n\n<p>⇒ 각 서블릿(요청을 처리하는 클래스)에 대한 정보를 등록해야 한다는 것이다… 😢</p>\n\n<p><br /></p>\n\n<h2 id=\"dispatcherservlet---spring-mvc--공통-로직의-중앙-집중화\"><strong>DispatcherServlet</strong> - Spring MVC : 공통 로직의 중앙 집중화</h2>\n\n<p><strong>(✨ 해결책) 공통 로직의 중앙 집중화</strong></p>\n\n<p>Spring Framework는 기존 서블릿 스펙의 장점을 활용하면서도 그 한계를 개선하는 방향으로 발전했다.</p>\n\n<p><span class=\"post-highlight\">DispatcherServlet이라는 Front Controller를 사용해 공통 로직을 처리하고 요청에 맞는 컨트롤러를 호출하는 특수한 Servlet</span>을 만들어 새로운 구조를 도입했다.</p>\n\n<ul>\n  <li><em>참고로 <strong>DispatcherServlet</strong> 도 <strong>Servlet이다.</strong></em>\n    <ul>\n      <li><em>(이쯤에서 Spring에서의 Controller의 역할이 아구 맞게 떠오른다.)</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/945895b9-66a2-4713-b7a4-8461f3a66075\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>Spring MVC는 이러한 문제를 DispatcherServlet이라는 하나의 Front Controller로 해결했다.</p>\n\n<ul>\n  <li><em>이제 우리가 아는 친숙한 코드가 나온다….</em></li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Spring MVC 방식</span>\n<span class=\"nd\">@Controller</span>  <span class=\"c1\">// 더 이상 HttpServlet을 상속할 필요가 없음</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserController</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@GetMapping</span><span class=\"o\">(</span><span class=\"s\">\"/users\"</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">handleUsers</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 비즈니스 로직에만 집중</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"userList\"</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"nd\">@Controller</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProductController</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@GetMapping</span><span class=\"o\">(</span><span class=\"s\">\"/products\"</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">handleProducts</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 비즈니스 로직에만 집중</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"productList\"</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p><strong>DispatcherServlet</strong>은 다음과 같은 일을 한다.</p>\n\n<ol>\n  <li><strong>DispatcherServlet</strong>은 웹 애플리케이션에 들어오는 모든 HTTP 요청을 먼저 받는다.</li>\n  <li>요청을 <strong>어떤 컨트롤러가 처리할지 결정</strong>하고, 해당 컨트롤러로 요청을 <strong>디스패치(위임)</strong> 한다.</li>\n  <li>요청에 대해 <strong>공통 처리</strong>(예: 인증, 로깅 등)를 먼저 한 후, 적절한 컨트롤러로 요청을 전달한다.</li>\n  <li><strong>DispatcherServlet</strong> 덕분에, 이제 다른 컨트롤러는 굳이 서블릿을 상속할 필요가 없다.</li>\n</ol>\n\n<p>4번에 대해 추가 설명을 하자면, <strong>Spring MVC</strong>에서는 <strong>DispatcherServlet</strong>만 서블릿으로 등록하고, 실제 비즈니스 로직을 처리하는 <strong>컨트롤러</strong>는 <strong>서블릿</strong>이 아니어도 된다는 뜻이다.</p>\n\n<ul>\n  <li><strong>Spring MVC</strong>에서는 <strong>DispatcherServlet</strong>만 서블릿으로 등록하고, 실제 비즈니스 로직을 처리하는 <strong>컨트롤러</strong>는 <strong>서블릿</strong>이 아니어도 된다는 뜻이다.</li>\n  <li>Spring MVC의 <strong>컨트롤러</strong>는 단순한 <strong>자바 클래스</strong>로, <strong>@Controller</strong> 어노테이션을 붙인 클래스를 만들어 요청을 처리할 수 있다.</li>\n  <li>이때, <strong>컨트롤러 클래스는 Servlet을 상속하지 않아도</strong> 된다.</li>\n  <li><strong>DispatcherServlet</strong>이 모든 요청을 처리하고, 요청을 <strong>컨트롤러</strong>로 전달하기 때문에, 실제로는 <strong>서블릿이 아닌 컨트롤러</strong>가 <strong>Servlet 객체를 상속</strong>하지 않아도 된다는 뜻이다.</li>\n</ul>\n\n<p>이렇듯 Spring 프레임워크는 Front Controller를 제공해주고 이를 Dispather Servlet 이라 부른다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/f5b5a218-c501-43c6-8869-c0ccd63acc77\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p><br /></p>\n\n<h2 id=\"servlet과-dispatcherservlet의-역할-분담의-의의\"><strong>Servlet</strong>과 DispatcherServlet의 역할 분담의 의의</h2>\n\n<p>Servlet 표준에서 중요한 점은 Servlet이 <span class=\"post-highlight\">전체 데이터 처리 과정에서 특정한 역할만 수행</span>한다는 것이다.</p>\n\n<p><strong><u>전통적인 서블릿 방식</u></strong>에서는 HTTP 요청/응답 처리부터 비즈니스 로직까지 모든 것을 책임져야했다.</p>\n\n<p>변화한 Spring MVC 구조에는 다음과 같은 장점이 있다.</p>\n\n<p>1) <strong>관심사의 분리(Separation of Concerns)</strong></p>\n<ol>\n  <li>DispatcherServlet이 모든 HTTP 요청을 먼저 받아서 적절한 Controller로 라우팅하는 역할을 담당하게 되었다.</li>\n  <li>이로 인해 Controller는 비즈니스 로직에만 집중할 수 있게 되었다.</li>\n</ol>\n\n<p>2) <strong>POJO(Plain Old Java Object) 기반 개발</strong></p>\n<ol>\n  <li>Controller가 더 이상 HttpServlet을 상속받지 않아도 된다는 것은 매우 중요한 의미를 가진다.</li>\n  <li>이는 일반적인 자바 클래스로 웹 개발이 가능해졌다는 뜻이다.</li>\n</ol>\n\n<p>3) <strong>각 엔드포인트가 명확하게 분리된다.</strong></p>\n\n<p><br /></p>\n\n<p>⇒ Spring Boot는 이러한 통합을 더욱 단순화했다.</p>\n\n<p>개발자는 복잡한 설정 없이도 Tomcat과 Spring이 자연스럽게 협력하는 환경에서 개발할 수 있게 되었다.</p>\n\n<p>web.xml 없이도 자동 구성을 통해 모든 것이 가능해졌다.</p>\n\n<p><em>@SpringBootApplication 어노테이션은 다음 3가지 핵심 어노테이션의 조합이다.</em></p>\n\n<ol>\n  <li>@SpringBootConfiguration</li>\n  <li><span class=\"post-highlight\">@EnableAutoConfiguration</span> [자동 구성]</li>\n  <li>@ComponentScan</li>\n</ol>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@SpringBootApplication</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">MyApplication</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// Spring Boot가 내장 Tomcat을 자동으로 구성하고 시작</span>\n        <span class=\"nc\">SpringApplication</span><span class=\"o\">.</span><span class=\"na\">run</span><span class=\"o\">(</span><span class=\"nc\">MyApplication</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">,</span> <span class=\"n\">args</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>즉, 현대에 와서 <strong>DispatcherServlet이 서블릿 역할을 하면서</strong> 요청을 <strong>Controller</strong>에 전달하고, <strong>Controller</strong>는 <strong>서비스</strong>를 호출하여 실제 비즈니스 로직을 처리하게 하는 방식으로 발전하였다.</p>\n\n<ul>\n  <li>단지 <strong>DispatcherServlet</strong>은 요청을 받아서 적절한 컨트롤러에게 넘겨주는 역할을 한다.</li>\n</ul>\n\n<p>지금까지 살펴본 WAS의 발전 과정을 보면 다음과 같다.</p>\n<ol>\n  <li>WAS는 동적 컨텐츠 처리를 위한 웹 애플리케이션 서버로 분리되며 시작됐다.</li>\n  <li>Tomcat은 Servlet Container로서 Java 기반 웹 애플리케이션을 실행시킨다.</li>\n  <li>초기 Servlet 방식의 한계(중복 코드, 복잡한 설정)를 Spring MVC가 해결했다.</li>\n  <li>DispatcherServlet의 도입으로 공통 로직 처리와 요청 위임이 체계화되었다.</li>\n</ol>\n\n<p>결국 DispatcherServlet이 모든 요청을 받아 적절한 Controller에 위임하므로\nController는 순수 비즈니스 로직에만 집중할 수 있게 되었다.</p>\n<ul>\n  <li>개발자는 반복적인 설정 없이 핵심 기능 개발에 집중 가능!</li>\n</ul>\n\n<p>이처럼 WAS와 Servlet, 그리고 Spring MVC로 이어지는 발전 과정은 더 나은 웹 개발 환경을 만들어왔다.</p>\n\n<p>더 나아가, 웹 애플리케이션 아키텍처는 계속해서 진화하고 있다.</p>\n<ul>\n  <li>Spring WebFlux를 통한 리액티브 프로그래밍 도입</li>\n  <li>클라우드 네이티브 환경 지원</li>\n  <li>마이크로서비스 아키텍처로의 전환</li>\n  <li>서버리스 아키텍처의 등장</li>\n</ul>\n",
                        "tags": ["WAS","Tomcat","Servlet","SpringMVC","Java","WebDevelopment","Architecture","DispatcherServlet","SpringBoot"]
                    }
                
            ],
        
            "Servlet": [
                
                    {
                        "title": "WAS(Web Application Server)와 Servlet",
                        "url": "/2025/01/28/about-was.html",
                        "subtitle": "Tomcat부터 Spring Boot까지",
                        "excerpt": "웹 서버(WS)의 진화 : Apache vs NGINX\n위 post에 이어지는 내용입니다.\n",
                        "author": "Jinho",
                        "date": "January 28, 2025",
                        "background": "/img/posts/apache_tomcat.jpeg",
                        "content": "<p><a href=\"https://jinho7.github.io/2025/01/27/ws-and-was.html\" target=\"웹 서버(WS)의 진화 : Apache vs NGINX \">웹 서버(WS)의 진화 : Apache vs NGINX</a><br />\n<em>위 post에 이어지는 내용입니다.</em></p>\n\n<h1 id=\"was-란\">WAS 란?</h1>\n\n<h2 id=\"was의-정의\">WAS의 정의</h2>\n\n<p>먼저 WAS(Web Application Server)의 정의는 다음과 같다.</p>\n<blockquote>\n  <p><span class=\"post-highlight\">웹 애플리케이션과 서버 환경을 만들어 동작시키는 기능을 제공하는 소프트웨어 프레임워크</span></p>\n</blockquote>\n\n<p>대표적으로 Apache <span class=\"post-highlight\">Tomcat</span>이 있다.</p>\n<ul>\n  <li><em>참고로 Apache Tomcat는 WS 단계에서 계속 이야기했던 Apache와는 아예 별개의 소프트웨어이다.</em></li>\n</ul>\n\n<details>\n<summary>Apache와 Tomcat</summary>\nApache HTTP Server (보통 Apache라고 부름)\n<ul>\n    <li>웹 서버(WS) 역할을 담당</li>\n    <li>주로 정적 콘텐츠를 처리</li>\n    <li>HTTP 요청을 처리하며, 동적 콘텐츠를 처리할 경우에는 WAS(Tomcat)와 연동하여 작업을 나눕니다.</li>\n</ul>\nApache Tomcat (보통 Tomcat이라고 부름)\n<ul>\n    <li>WAS 역할을 담당</li>\n    <li>Servlet Container로서 동작하며, Servlet/JSP 기반의 동적 콘텐츠를 처리\n        <ul>\n            <li><em>정적 콘텐츠도 처리할 수는 있다.</em></li>\n            <li><em>정적 콘텐츠 처리 성능은 Apache HTTP Server보다 낮다.</em></li>\n        </ul>\n    </li>\n    <li>Java EE 표준의 일부인 Servlet/JSP 스펙을 구현하며, Spring MVC와 같은 프레임워크의 기반이 되는 동작을 지원한다.</li>\n</ul>\n</details>\n\n<p><br /></p>\n\n<p>그러나 이런 물음표가 떠오른다.</p>\n\n<p><strong>❓ WAS? TOMCAT? Servlet? Servlet Container? Spring MVC?</strong></p>\n\n<p>다음 기본 개념부터 인지하고 넘어가면 이해하기 쉽다.</p>\n\n<ol>\n  <li><strong>WAS</strong>는 클라이언트의 요청을 처리하여 <strong>동적인 웹 콘텐츠</strong>를 제공하는 서버를 말한다.</li>\n  <li><strong>Tomcat</strong>은 WAS의 대표적인 예시 중 하나이다.</li>\n  <li>Tomcat은 <strong>Servlet Container의 한 종류</strong>이며, <strong>Servlet/JSP 요청을 처리</strong>하는 역할을 한다.</li>\n  <li>Tomcat은 <strong>Servlet 표준</strong>에 맞춘 애플리케이션을 실행하는 데 최적화되어 있다.\n    <ol>\n      <li><strong>Servlet 표준</strong>은 <strong>Java EE</strong>(현재는 <strong>Jakarta EE</strong>) 명세의 일부로, <strong>Java 기반 동적 웹 콘텐츠 처리</strong>를 위한 규격이다.</li>\n      <li>즉, Tomcat은 <strong>Java 기반의 웹 애플리케이션</strong>을 실행하기 위한 서버이다.</li>\n    </ol>\n  </li>\n</ol>\n\n<p><strong>WS와 WAS의 차이의 핵심는 ‘동적 처리 여부’에 있다.</strong></p>\n<ul>\n  <li>현대 웹사이트는 스크롤에 따라 새로운 피드를 보여주거나,<br />\n사용자 맞춤 광고를 제공하는 등의 동적 기능을 포함한다.</li>\n  <li>이러한 <strong>“사용자 맞춤 가공 처리(동적 콘텐츠)”는 결국 서버가 특정 코드를 실행했다</strong>는 의미다.</li>\n  <li>결국 궁금한 것은 ‘<strong>서버가 어떻게 이 코드를 실행하고, 그 결과를 클라이언트에게 제공하는가</strong>’이다.</li>\n</ul>\n\n<div style=\"display: flex; justify-content: space-between; gap: 20px;\">\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/203ab158-60b0-4376-be93-1de497da3d19\" alt=\"Memory Usage\" style=\"width: 100%;\" />\n        <p style=\"text-align: center; color: #666;\">누구나에게 제공되는 “정적인” 컨텐츠이다.</p>\n    </div>\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/5795047e-ae12-4cda-a1f6-e2b3ab8dfd72\" alt=\"Requests Per Second\" style=\"width: 100%;\" />\n        <p style=\"text-align: center; color: #666;\">하지만 로그인하고 나면 “동적인” 컨텐츠가 로드된다.</p>\n    </div>\n</div>\n\n<p>아래는 동적 페이지를 로드하는 과정을 그림으로 표현한 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/ef604672-3c6c-4724-9f9a-9a226cc6e513\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>우리는 앞서 실제 운영/대규모 서비스는 <span class=\"post-highlight\">WS-WAS 분리 구조</span>를 선호한다고 말했다.</p>\n\n<p>나는 WAS의 한 종류인 Tomcat까지의 웹통신 흐름이 어떻게 이루어지는 지가 궁금해졌다.<br />\n그리고 <u>‘jvm, survlet, spring 등 어떤 개념이고 어떤 연관관계가 있고 어떻게 유동적으로 작동할까…?’</u> 가 궁금했다.</p>\n\n<p><br /></p>\n\n<h2 id=\"jvmjava-virtual-machine\">JVM(Java Virtual Machine)</h2>\n\n<p><img src=\"https://github.com/user-attachments/assets/f48a2ce2-5aa4-495c-a686-79e32ce7eed2\" alt=\"Image\" width=\"70%\" height=\"100%\" class=\"center\" /></p>\n\n<p><em>JVM 자체가 현재 내용에서 매우 중요한 내용은 아니라 짧게 이야기하면,</em></p>\n<ul>\n  <li>⇒ 그냥 JVM은 간단히 Java 코드를 실행시켜주는 놈이라고 생각하자.</li>\n  <li>WAS(Tomcat)는 Java로 작성된 웹 애플리케이션을 실행하는 컨테이너이므로,<br />\nWAS도 JVM 위에서 동작한다.</li>\n</ul>\n\n<details>\n<summary>JVM 이란?</summary>\nApache HTTP Server (보통 Apache라고 부름)\n<ul>\n    <li>JVM은 JVM은 Java 바이트코드(.class 파일)를 해석하고 실행하는 가상 머신</li>\n    <li>JRE는 Java 프로그램을 실행하는 데 필요한 모든 것을 포함한다. 라이브러리 등</li>\n        <ul>\n            <li><em>JRE은 JVM을 시작, 필요한 클래스 라이브러리 로드, main() 메서드를 실행한다.</em></li>\n        </ul>\n    <li>JDK는 Java 애플리케이션을 개발하는 데 필요한 모든 도구를 포함한다.</li>\n</ul>\n</details>\n\n<p><br /></p>\n\n<h2 id=\"servlet-container-tomcat\">Servlet Container [Tomcat]</h2>\n\n<p>위에서 “Tomcat은 <strong><u>Servlet Container의 한 종류</u></strong>이며, <strong><u>Servlet/JSP 요청을 처리</u></strong>하는 역할을 한다.” 라고 했다.</p>\n\n<p>1) <strong>Servlet Container</strong>는 Servlet<strong>의 생명 주기</strong>를 관리하는 곳이다.</p>\n<ul>\n  <li>Servlet과 Servlet Container의 관계를 Bean과 Bean Container의 관계와 흡사하다고 생각하면 된다. (“컨테이너와 관리 대상”의 관계로 이해)\n    <ul>\n      <li>Servlet Container는 HTTP 요청과 응답을 처리하는 Servlet을 관리</li>\n      <li>Bean Container는 Spring의 <strong>애플리케이션 내 객체(Bean)</strong>의 생명 주기와 의존성을 관리</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2) 또한, <strong>HTTP 요청 처리 및 응답 생성 과정</strong>은 Servlet Container의 핵심 기능 중 하나이다.</p>\n<ul>\n  <li>웹 브라우저에서 요청이 들어오면, Tomcat은 그 요청을 받아서 적절한 Java 코드(서블릿)로 전달하고, 그 결과를 다시 브라우저로 보내는 역할을 한다.</li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"servlet\">Servlet</h2>\n\n<p>Servlet은 <strong>HTTP 요청을 처리하고 응답을 생성하는 스펙을 정의한 인터페이스</strong>이다.</p>\n<ul>\n  <li>Servlet은 <strong>jakarta.servlet.Servlet</strong>을 최상위 인터페이스로 가진다. (Java API)</li>\n</ul>\n\n<p>Servlet은 <strong>Servlet Container</strong>에 의해 관리되며, 요청이 들어오면 컨테이너가 Servlet의 생명 주기를 관리하고 요청을 처리하기 위한 스레드를 생성한다.</p>\n\n<p>Servlet은 HTTP 요청을 처리하고, 그에 따른 적절한 응답을 생성하는 기본 단위이다. 이를 통해 <span class=\"post-highlight\">REST API의 엔드포인트</span>가 되거나 <span class=\"post-highlight\">동적 웹 페이지를 생성</span>하는 역할을 수행할 수 있다.</p>\n\n<ol>\n  <li>Servlet은 HTTP 요청을 받아 비즈니스 로직을 처리하고 JSON, XML 등의 형식으로 데이터를 응답할 수 있다.</li>\n  <li>동적인 HTML 콘텐츠를 생성할 때도 사용된다.\n    <ul>\n      <li>예를 들어, 비즈니스 로직 처리가 필요한 HTTP 요청이 Web Server로 들어오면, Web Server는 이를 Servlet Container가 실행하는 Servlet에 전달한다.</li>\n      <li>Servlet은 요청을 처리하고 동적인 웹 콘텐츠를 생성한 뒤, 결과를 Web Server를 통해 클라이언트로 반환한다.</li>\n    </ul>\n  </li>\n</ol>\n\n<p>전체적인 통신 흐름은 다음과 같다.</p>\n<ul>\n  <li>WS 는 HTTP 요청을 받아 정적 리소스를 처리하거나, 요청을 WAS에 전달한다.</li>\n  <li>WAS는 Servlet Container를 통해 요청을 처리하고, 처리 결과를 Web Server를 거쳐 클라이언트에 반환한다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/06d2213c-0f90-4a1b-a765-33531aeed39d\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p><br /></p>\n\n<h3 id=\"servlet의-생명주기\">Servlet의 생명주기</h3>\n\n<p>위 그림을 보면 알 수 있듯, Servlet은 다음과 같은 생명 주기를 가진다.</p>\n\n<p>1) <strong>초기화 단계</strong>:</p>\n<ul>\n  <li>최초 요청이 오면 Servlet 클래스(HelloServlet.class)가 로딩된다.</li>\n  <li>web.xml 설정을 참고하여 매핑할 Servlet을 확인한다.</li>\n  <li><span class=\"post-highlight\">해당 Servlet 인스턴스가 있다면 사용하고, 없다면 init()으로 초기화한다.</span></li>\n</ul>\n\n<p>2) <strong>서비스 단계</strong>:</p>\n<ul>\n  <li>Servlet Container는 각 요청마다 새로운 스레드를 생성한다.</li>\n  <li>새로운 Request/Response 객체를 생성하여 service() 메서드를 실행한다.</li>\n  <li>service()는 요청 방식(GET, POST 등)에 따라 적절한 do메서드를 호출한다.</li>\n  <li>요청 처리가 완료되면 해당 Request/Response 객체는 소멸된다.</li>\n</ul>\n\n<p>3) <strong>소멸 단계</strong>:</p>\n<ul>\n  <li><em>서버 종료나 애플리케이션 재배포 시에만 destroy()가 호출된다.</em></li>\n  <li><em>Servlet이 사용하던 리소스를 정리한다.</em></li>\n</ul>\n\n<p><br /></p>\n\n<p>정리하자면,</p>\n<ul>\n  <li>Tomcat은 Servlet 객체를 한 번 생성하면 메모리에 유지하고, 요청이 올 때마다 해당 객체의 <strong>service()</strong> 메서드를 호출한다.</li>\n  <li>따라서, <strong>init()</strong> 메서드는 <strong>최초 요청 시(또는 설정에 따라 애플리케이션 시작 시)</strong> 단 한 번 실행된다.</li>\n  <li>또 종료되기 전이나 reload 전에 destroy()를 호출하여 매번 객체가 생성되는 것을 방지한다.</li>\n</ul>\n\n<p><strong>(🤔 궁금증) servlet은 왜 생성만 하고 제거는 안하지?</strong>\n만약 사용이 끝날 때마다 제거한다면 다음과 같은 문제가 있다.</p>\n<ul>\n  <li>모든 요청에 대해 servlet을 생성하고 소멸하는 것은 OS 와 JVM 에게 필요없는 부하를 일으킨다.\n    <ul>\n      <li>JVM의 <strong>Garbage Collection</strong>과 <strong>메모리 할당/해제</strong>를 빈번하게 유발</li>\n    </ul>\n  </li>\n  <li>동시에 다수의 요청이 들어올 경우 CPU 또는 메모리 리소스 소모에 대한 제한이 어렵다. \n결국 순간적으로 서버가 다운되거나 동시 처리에 문제가 생길 수 있다.\n    <ul>\n      <li><em>(참고로 Tomcat 3.2 이전 버전은 실제 매번 생성과 제거를 했다.)</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p><strong>(✨해결) 해답은 Servlet의 특징과 관리 방식에 있다.</strong></p>\n<ul>\n  <li>수많은 클라이언트의 요청을 동시에 처리해야 하는 WAS의 특성상,\nServlet은 싱글톤 패턴으로 관리하게 되었다.\n    <ul>\n      <li>한 번 생성된 Servlet 인스턴스는 메모리에 계속 유지된다.</li>\n      <li>모든 요청은 동일한 Servlet 인스턴스를 공유한다.</li>\n      <li>init()은 최초 요청 시 한 번만 실행된다.</li>\n      <li>destroy()는 서버 종료나 재배포 시에만 실행된다.</li>\n    </ul>\n  </li>\n  <li><em>(Tomcat 3.2 부터는 디폴트로 <span class=\"post-highlight\">싱글톤 패턴 도입</span>와 <span class=\"post-highlight\">Thread Pool</span> 을 사용)</em></li>\n</ul>\n\n<p><br /></p>\n\n<h1 id=\"servlet-처리-구조의-발전\">Servlet 처리 구조의 발전</h1>\n\n<h2 id=\"기존-servlet-처리-방식\">기존 Servlet 처리 방식</h2>\n\n<p>Tomcat은 다음과 같은 역할을 한다고 하였다.</p>\n<ul>\n  <li>Servlet Container로서 HTTP 요청과 응답을 처리하는 환경 제공</li>\n  <li>Servlet 객체의 생성, 초기화, 요청 처리, 소멸 등 <strong>생명주기를 관리</strong>하는 역할</li>\n</ul>\n\n<p><strong>(🤔 문제점) Servlet은 요청마다 개별적으로 처리 로직을 구현해야 하므로,</strong><br />\n<strong>비슷한 요청을 처리하는 여러 Servlet에서 <span class=\"post-highlight\">중복된 코드가 발생</span>할 수 있다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/7c5e684e-cd0f-4167-8e55-f3d24172f58e\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 기존 서블릿 방식 - 각 URL마다 서블릿을 따로 만들어야 했습니다</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserServlet</span> <span class=\"kd\">extends</span> <span class=\"nc\">HttpServlet</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">doGet</span><span class=\"o\">(</span><span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"nc\">HttpServletResponse</span> <span class=\"n\">response</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 로깅 처리</span>\n        <span class=\"c1\">// 인증 처리</span>\n        <span class=\"c1\">// 공통 에러 처리</span>\n        <span class=\"c1\">// 실제 비즈니스 로직</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProductServlet</span> <span class=\"kd\">extends</span> <span class=\"nc\">HttpServlet</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">doGet</span><span class=\"o\">(</span><span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"nc\">HttpServletResponse</span> <span class=\"n\">response</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 위와 동일한 로깅, 인증, 에러 처리 코드가 반복됨</span>\n        <span class=\"c1\">// 실제 비즈니스 로직</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>이러한 방식은 다음과 같은 문제가 있다.</p>\n<ol>\n  <li>하나의 서블릿 클래스에 너무 많은 책임이 집중된다.</li>\n  <li>URL 매핑, 파라미터 처리, 뷰 선택 등을 모두 수동으로 처리해야 함</li>\n  <li>모든 서블릿에서 공통 로직(로깅, 인증, 에러 처리 등)이 반복됨</li>\n  <li>각각의 서블릿을 web.xml에 일일이 등록해야 함<br />\n (web.xml : 웹 애플리케이션의 <strong>구성 정보</strong>를 제공)</li>\n</ol>\n\n<ul>\n  <li>과거 web.xml은 다음과 같은 중요한 정보들을 담고 있었다.\n    <ul>\n      <li>어떤 서블릿이 존재하는지</li>\n      <li>각 서블릿이 어떤 URL 패턴을 처리하는지</li>\n      <li>어떤 필터들이 요청을 처리하는지</li>\n      <li>웹 애플리케이션의 시작과 종료 시 필요한 리스너는 무엇인지</li>\n    </ul>\n  </li>\n</ul>\n\n<p>⇒ 각 서블릿(요청을 처리하는 클래스)에 대한 정보를 등록해야 한다는 것이다… 😢</p>\n\n<p><br /></p>\n\n<h2 id=\"dispatcherservlet---spring-mvc--공통-로직의-중앙-집중화\"><strong>DispatcherServlet</strong> - Spring MVC : 공통 로직의 중앙 집중화</h2>\n\n<p><strong>(✨ 해결책) 공통 로직의 중앙 집중화</strong></p>\n\n<p>Spring Framework는 기존 서블릿 스펙의 장점을 활용하면서도 그 한계를 개선하는 방향으로 발전했다.</p>\n\n<p><span class=\"post-highlight\">DispatcherServlet이라는 Front Controller를 사용해 공통 로직을 처리하고 요청에 맞는 컨트롤러를 호출하는 특수한 Servlet</span>을 만들어 새로운 구조를 도입했다.</p>\n\n<ul>\n  <li><em>참고로 <strong>DispatcherServlet</strong> 도 <strong>Servlet이다.</strong></em>\n    <ul>\n      <li><em>(이쯤에서 Spring에서의 Controller의 역할이 아구 맞게 떠오른다.)</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/945895b9-66a2-4713-b7a4-8461f3a66075\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>Spring MVC는 이러한 문제를 DispatcherServlet이라는 하나의 Front Controller로 해결했다.</p>\n\n<ul>\n  <li><em>이제 우리가 아는 친숙한 코드가 나온다….</em></li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Spring MVC 방식</span>\n<span class=\"nd\">@Controller</span>  <span class=\"c1\">// 더 이상 HttpServlet을 상속할 필요가 없음</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserController</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@GetMapping</span><span class=\"o\">(</span><span class=\"s\">\"/users\"</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">handleUsers</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 비즈니스 로직에만 집중</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"userList\"</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"nd\">@Controller</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProductController</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@GetMapping</span><span class=\"o\">(</span><span class=\"s\">\"/products\"</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">handleProducts</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 비즈니스 로직에만 집중</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"productList\"</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p><strong>DispatcherServlet</strong>은 다음과 같은 일을 한다.</p>\n\n<ol>\n  <li><strong>DispatcherServlet</strong>은 웹 애플리케이션에 들어오는 모든 HTTP 요청을 먼저 받는다.</li>\n  <li>요청을 <strong>어떤 컨트롤러가 처리할지 결정</strong>하고, 해당 컨트롤러로 요청을 <strong>디스패치(위임)</strong> 한다.</li>\n  <li>요청에 대해 <strong>공통 처리</strong>(예: 인증, 로깅 등)를 먼저 한 후, 적절한 컨트롤러로 요청을 전달한다.</li>\n  <li><strong>DispatcherServlet</strong> 덕분에, 이제 다른 컨트롤러는 굳이 서블릿을 상속할 필요가 없다.</li>\n</ol>\n\n<p>4번에 대해 추가 설명을 하자면, <strong>Spring MVC</strong>에서는 <strong>DispatcherServlet</strong>만 서블릿으로 등록하고, 실제 비즈니스 로직을 처리하는 <strong>컨트롤러</strong>는 <strong>서블릿</strong>이 아니어도 된다는 뜻이다.</p>\n\n<ul>\n  <li><strong>Spring MVC</strong>에서는 <strong>DispatcherServlet</strong>만 서블릿으로 등록하고, 실제 비즈니스 로직을 처리하는 <strong>컨트롤러</strong>는 <strong>서블릿</strong>이 아니어도 된다는 뜻이다.</li>\n  <li>Spring MVC의 <strong>컨트롤러</strong>는 단순한 <strong>자바 클래스</strong>로, <strong>@Controller</strong> 어노테이션을 붙인 클래스를 만들어 요청을 처리할 수 있다.</li>\n  <li>이때, <strong>컨트롤러 클래스는 Servlet을 상속하지 않아도</strong> 된다.</li>\n  <li><strong>DispatcherServlet</strong>이 모든 요청을 처리하고, 요청을 <strong>컨트롤러</strong>로 전달하기 때문에, 실제로는 <strong>서블릿이 아닌 컨트롤러</strong>가 <strong>Servlet 객체를 상속</strong>하지 않아도 된다는 뜻이다.</li>\n</ul>\n\n<p>이렇듯 Spring 프레임워크는 Front Controller를 제공해주고 이를 Dispather Servlet 이라 부른다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/f5b5a218-c501-43c6-8869-c0ccd63acc77\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p><br /></p>\n\n<h2 id=\"servlet과-dispatcherservlet의-역할-분담의-의의\"><strong>Servlet</strong>과 DispatcherServlet의 역할 분담의 의의</h2>\n\n<p>Servlet 표준에서 중요한 점은 Servlet이 <span class=\"post-highlight\">전체 데이터 처리 과정에서 특정한 역할만 수행</span>한다는 것이다.</p>\n\n<p><strong><u>전통적인 서블릿 방식</u></strong>에서는 HTTP 요청/응답 처리부터 비즈니스 로직까지 모든 것을 책임져야했다.</p>\n\n<p>변화한 Spring MVC 구조에는 다음과 같은 장점이 있다.</p>\n\n<p>1) <strong>관심사의 분리(Separation of Concerns)</strong></p>\n<ol>\n  <li>DispatcherServlet이 모든 HTTP 요청을 먼저 받아서 적절한 Controller로 라우팅하는 역할을 담당하게 되었다.</li>\n  <li>이로 인해 Controller는 비즈니스 로직에만 집중할 수 있게 되었다.</li>\n</ol>\n\n<p>2) <strong>POJO(Plain Old Java Object) 기반 개발</strong></p>\n<ol>\n  <li>Controller가 더 이상 HttpServlet을 상속받지 않아도 된다는 것은 매우 중요한 의미를 가진다.</li>\n  <li>이는 일반적인 자바 클래스로 웹 개발이 가능해졌다는 뜻이다.</li>\n</ol>\n\n<p>3) <strong>각 엔드포인트가 명확하게 분리된다.</strong></p>\n\n<p><br /></p>\n\n<p>⇒ Spring Boot는 이러한 통합을 더욱 단순화했다.</p>\n\n<p>개발자는 복잡한 설정 없이도 Tomcat과 Spring이 자연스럽게 협력하는 환경에서 개발할 수 있게 되었다.</p>\n\n<p>web.xml 없이도 자동 구성을 통해 모든 것이 가능해졌다.</p>\n\n<p><em>@SpringBootApplication 어노테이션은 다음 3가지 핵심 어노테이션의 조합이다.</em></p>\n\n<ol>\n  <li>@SpringBootConfiguration</li>\n  <li><span class=\"post-highlight\">@EnableAutoConfiguration</span> [자동 구성]</li>\n  <li>@ComponentScan</li>\n</ol>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@SpringBootApplication</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">MyApplication</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// Spring Boot가 내장 Tomcat을 자동으로 구성하고 시작</span>\n        <span class=\"nc\">SpringApplication</span><span class=\"o\">.</span><span class=\"na\">run</span><span class=\"o\">(</span><span class=\"nc\">MyApplication</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">,</span> <span class=\"n\">args</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>즉, 현대에 와서 <strong>DispatcherServlet이 서블릿 역할을 하면서</strong> 요청을 <strong>Controller</strong>에 전달하고, <strong>Controller</strong>는 <strong>서비스</strong>를 호출하여 실제 비즈니스 로직을 처리하게 하는 방식으로 발전하였다.</p>\n\n<ul>\n  <li>단지 <strong>DispatcherServlet</strong>은 요청을 받아서 적절한 컨트롤러에게 넘겨주는 역할을 한다.</li>\n</ul>\n\n<p>지금까지 살펴본 WAS의 발전 과정을 보면 다음과 같다.</p>\n<ol>\n  <li>WAS는 동적 컨텐츠 처리를 위한 웹 애플리케이션 서버로 분리되며 시작됐다.</li>\n  <li>Tomcat은 Servlet Container로서 Java 기반 웹 애플리케이션을 실행시킨다.</li>\n  <li>초기 Servlet 방식의 한계(중복 코드, 복잡한 설정)를 Spring MVC가 해결했다.</li>\n  <li>DispatcherServlet의 도입으로 공통 로직 처리와 요청 위임이 체계화되었다.</li>\n</ol>\n\n<p>결국 DispatcherServlet이 모든 요청을 받아 적절한 Controller에 위임하므로\nController는 순수 비즈니스 로직에만 집중할 수 있게 되었다.</p>\n<ul>\n  <li>개발자는 반복적인 설정 없이 핵심 기능 개발에 집중 가능!</li>\n</ul>\n\n<p>이처럼 WAS와 Servlet, 그리고 Spring MVC로 이어지는 발전 과정은 더 나은 웹 개발 환경을 만들어왔다.</p>\n\n<p>더 나아가, 웹 애플리케이션 아키텍처는 계속해서 진화하고 있다.</p>\n<ul>\n  <li>Spring WebFlux를 통한 리액티브 프로그래밍 도입</li>\n  <li>클라우드 네이티브 환경 지원</li>\n  <li>마이크로서비스 아키텍처로의 전환</li>\n  <li>서버리스 아키텍처의 등장</li>\n</ul>\n",
                        "tags": ["WAS","Tomcat","Servlet","SpringMVC","Java","WebDevelopment","Architecture","DispatcherServlet","SpringBoot"]
                    }
                
            ],
        
            "SpringMVC": [
                
                    {
                        "title": "WAS(Web Application Server)와 Servlet",
                        "url": "/2025/01/28/about-was.html",
                        "subtitle": "Tomcat부터 Spring Boot까지",
                        "excerpt": "웹 서버(WS)의 진화 : Apache vs NGINX\n위 post에 이어지는 내용입니다.\n",
                        "author": "Jinho",
                        "date": "January 28, 2025",
                        "background": "/img/posts/apache_tomcat.jpeg",
                        "content": "<p><a href=\"https://jinho7.github.io/2025/01/27/ws-and-was.html\" target=\"웹 서버(WS)의 진화 : Apache vs NGINX \">웹 서버(WS)의 진화 : Apache vs NGINX</a><br />\n<em>위 post에 이어지는 내용입니다.</em></p>\n\n<h1 id=\"was-란\">WAS 란?</h1>\n\n<h2 id=\"was의-정의\">WAS의 정의</h2>\n\n<p>먼저 WAS(Web Application Server)의 정의는 다음과 같다.</p>\n<blockquote>\n  <p><span class=\"post-highlight\">웹 애플리케이션과 서버 환경을 만들어 동작시키는 기능을 제공하는 소프트웨어 프레임워크</span></p>\n</blockquote>\n\n<p>대표적으로 Apache <span class=\"post-highlight\">Tomcat</span>이 있다.</p>\n<ul>\n  <li><em>참고로 Apache Tomcat는 WS 단계에서 계속 이야기했던 Apache와는 아예 별개의 소프트웨어이다.</em></li>\n</ul>\n\n<details>\n<summary>Apache와 Tomcat</summary>\nApache HTTP Server (보통 Apache라고 부름)\n<ul>\n    <li>웹 서버(WS) 역할을 담당</li>\n    <li>주로 정적 콘텐츠를 처리</li>\n    <li>HTTP 요청을 처리하며, 동적 콘텐츠를 처리할 경우에는 WAS(Tomcat)와 연동하여 작업을 나눕니다.</li>\n</ul>\nApache Tomcat (보통 Tomcat이라고 부름)\n<ul>\n    <li>WAS 역할을 담당</li>\n    <li>Servlet Container로서 동작하며, Servlet/JSP 기반의 동적 콘텐츠를 처리\n        <ul>\n            <li><em>정적 콘텐츠도 처리할 수는 있다.</em></li>\n            <li><em>정적 콘텐츠 처리 성능은 Apache HTTP Server보다 낮다.</em></li>\n        </ul>\n    </li>\n    <li>Java EE 표준의 일부인 Servlet/JSP 스펙을 구현하며, Spring MVC와 같은 프레임워크의 기반이 되는 동작을 지원한다.</li>\n</ul>\n</details>\n\n<p><br /></p>\n\n<p>그러나 이런 물음표가 떠오른다.</p>\n\n<p><strong>❓ WAS? TOMCAT? Servlet? Servlet Container? Spring MVC?</strong></p>\n\n<p>다음 기본 개념부터 인지하고 넘어가면 이해하기 쉽다.</p>\n\n<ol>\n  <li><strong>WAS</strong>는 클라이언트의 요청을 처리하여 <strong>동적인 웹 콘텐츠</strong>를 제공하는 서버를 말한다.</li>\n  <li><strong>Tomcat</strong>은 WAS의 대표적인 예시 중 하나이다.</li>\n  <li>Tomcat은 <strong>Servlet Container의 한 종류</strong>이며, <strong>Servlet/JSP 요청을 처리</strong>하는 역할을 한다.</li>\n  <li>Tomcat은 <strong>Servlet 표준</strong>에 맞춘 애플리케이션을 실행하는 데 최적화되어 있다.\n    <ol>\n      <li><strong>Servlet 표준</strong>은 <strong>Java EE</strong>(현재는 <strong>Jakarta EE</strong>) 명세의 일부로, <strong>Java 기반 동적 웹 콘텐츠 처리</strong>를 위한 규격이다.</li>\n      <li>즉, Tomcat은 <strong>Java 기반의 웹 애플리케이션</strong>을 실행하기 위한 서버이다.</li>\n    </ol>\n  </li>\n</ol>\n\n<p><strong>WS와 WAS의 차이의 핵심는 ‘동적 처리 여부’에 있다.</strong></p>\n<ul>\n  <li>현대 웹사이트는 스크롤에 따라 새로운 피드를 보여주거나,<br />\n사용자 맞춤 광고를 제공하는 등의 동적 기능을 포함한다.</li>\n  <li>이러한 <strong>“사용자 맞춤 가공 처리(동적 콘텐츠)”는 결국 서버가 특정 코드를 실행했다</strong>는 의미다.</li>\n  <li>결국 궁금한 것은 ‘<strong>서버가 어떻게 이 코드를 실행하고, 그 결과를 클라이언트에게 제공하는가</strong>’이다.</li>\n</ul>\n\n<div style=\"display: flex; justify-content: space-between; gap: 20px;\">\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/203ab158-60b0-4376-be93-1de497da3d19\" alt=\"Memory Usage\" style=\"width: 100%;\" />\n        <p style=\"text-align: center; color: #666;\">누구나에게 제공되는 “정적인” 컨텐츠이다.</p>\n    </div>\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/5795047e-ae12-4cda-a1f6-e2b3ab8dfd72\" alt=\"Requests Per Second\" style=\"width: 100%;\" />\n        <p style=\"text-align: center; color: #666;\">하지만 로그인하고 나면 “동적인” 컨텐츠가 로드된다.</p>\n    </div>\n</div>\n\n<p>아래는 동적 페이지를 로드하는 과정을 그림으로 표현한 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/ef604672-3c6c-4724-9f9a-9a226cc6e513\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>우리는 앞서 실제 운영/대규모 서비스는 <span class=\"post-highlight\">WS-WAS 분리 구조</span>를 선호한다고 말했다.</p>\n\n<p>나는 WAS의 한 종류인 Tomcat까지의 웹통신 흐름이 어떻게 이루어지는 지가 궁금해졌다.<br />\n그리고 <u>‘jvm, survlet, spring 등 어떤 개념이고 어떤 연관관계가 있고 어떻게 유동적으로 작동할까…?’</u> 가 궁금했다.</p>\n\n<p><br /></p>\n\n<h2 id=\"jvmjava-virtual-machine\">JVM(Java Virtual Machine)</h2>\n\n<p><img src=\"https://github.com/user-attachments/assets/f48a2ce2-5aa4-495c-a686-79e32ce7eed2\" alt=\"Image\" width=\"70%\" height=\"100%\" class=\"center\" /></p>\n\n<p><em>JVM 자체가 현재 내용에서 매우 중요한 내용은 아니라 짧게 이야기하면,</em></p>\n<ul>\n  <li>⇒ 그냥 JVM은 간단히 Java 코드를 실행시켜주는 놈이라고 생각하자.</li>\n  <li>WAS(Tomcat)는 Java로 작성된 웹 애플리케이션을 실행하는 컨테이너이므로,<br />\nWAS도 JVM 위에서 동작한다.</li>\n</ul>\n\n<details>\n<summary>JVM 이란?</summary>\nApache HTTP Server (보통 Apache라고 부름)\n<ul>\n    <li>JVM은 JVM은 Java 바이트코드(.class 파일)를 해석하고 실행하는 가상 머신</li>\n    <li>JRE는 Java 프로그램을 실행하는 데 필요한 모든 것을 포함한다. 라이브러리 등</li>\n        <ul>\n            <li><em>JRE은 JVM을 시작, 필요한 클래스 라이브러리 로드, main() 메서드를 실행한다.</em></li>\n        </ul>\n    <li>JDK는 Java 애플리케이션을 개발하는 데 필요한 모든 도구를 포함한다.</li>\n</ul>\n</details>\n\n<p><br /></p>\n\n<h2 id=\"servlet-container-tomcat\">Servlet Container [Tomcat]</h2>\n\n<p>위에서 “Tomcat은 <strong><u>Servlet Container의 한 종류</u></strong>이며, <strong><u>Servlet/JSP 요청을 처리</u></strong>하는 역할을 한다.” 라고 했다.</p>\n\n<p>1) <strong>Servlet Container</strong>는 Servlet<strong>의 생명 주기</strong>를 관리하는 곳이다.</p>\n<ul>\n  <li>Servlet과 Servlet Container의 관계를 Bean과 Bean Container의 관계와 흡사하다고 생각하면 된다. (“컨테이너와 관리 대상”의 관계로 이해)\n    <ul>\n      <li>Servlet Container는 HTTP 요청과 응답을 처리하는 Servlet을 관리</li>\n      <li>Bean Container는 Spring의 <strong>애플리케이션 내 객체(Bean)</strong>의 생명 주기와 의존성을 관리</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2) 또한, <strong>HTTP 요청 처리 및 응답 생성 과정</strong>은 Servlet Container의 핵심 기능 중 하나이다.</p>\n<ul>\n  <li>웹 브라우저에서 요청이 들어오면, Tomcat은 그 요청을 받아서 적절한 Java 코드(서블릿)로 전달하고, 그 결과를 다시 브라우저로 보내는 역할을 한다.</li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"servlet\">Servlet</h2>\n\n<p>Servlet은 <strong>HTTP 요청을 처리하고 응답을 생성하는 스펙을 정의한 인터페이스</strong>이다.</p>\n<ul>\n  <li>Servlet은 <strong>jakarta.servlet.Servlet</strong>을 최상위 인터페이스로 가진다. (Java API)</li>\n</ul>\n\n<p>Servlet은 <strong>Servlet Container</strong>에 의해 관리되며, 요청이 들어오면 컨테이너가 Servlet의 생명 주기를 관리하고 요청을 처리하기 위한 스레드를 생성한다.</p>\n\n<p>Servlet은 HTTP 요청을 처리하고, 그에 따른 적절한 응답을 생성하는 기본 단위이다. 이를 통해 <span class=\"post-highlight\">REST API의 엔드포인트</span>가 되거나 <span class=\"post-highlight\">동적 웹 페이지를 생성</span>하는 역할을 수행할 수 있다.</p>\n\n<ol>\n  <li>Servlet은 HTTP 요청을 받아 비즈니스 로직을 처리하고 JSON, XML 등의 형식으로 데이터를 응답할 수 있다.</li>\n  <li>동적인 HTML 콘텐츠를 생성할 때도 사용된다.\n    <ul>\n      <li>예를 들어, 비즈니스 로직 처리가 필요한 HTTP 요청이 Web Server로 들어오면, Web Server는 이를 Servlet Container가 실행하는 Servlet에 전달한다.</li>\n      <li>Servlet은 요청을 처리하고 동적인 웹 콘텐츠를 생성한 뒤, 결과를 Web Server를 통해 클라이언트로 반환한다.</li>\n    </ul>\n  </li>\n</ol>\n\n<p>전체적인 통신 흐름은 다음과 같다.</p>\n<ul>\n  <li>WS 는 HTTP 요청을 받아 정적 리소스를 처리하거나, 요청을 WAS에 전달한다.</li>\n  <li>WAS는 Servlet Container를 통해 요청을 처리하고, 처리 결과를 Web Server를 거쳐 클라이언트에 반환한다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/06d2213c-0f90-4a1b-a765-33531aeed39d\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p><br /></p>\n\n<h3 id=\"servlet의-생명주기\">Servlet의 생명주기</h3>\n\n<p>위 그림을 보면 알 수 있듯, Servlet은 다음과 같은 생명 주기를 가진다.</p>\n\n<p>1) <strong>초기화 단계</strong>:</p>\n<ul>\n  <li>최초 요청이 오면 Servlet 클래스(HelloServlet.class)가 로딩된다.</li>\n  <li>web.xml 설정을 참고하여 매핑할 Servlet을 확인한다.</li>\n  <li><span class=\"post-highlight\">해당 Servlet 인스턴스가 있다면 사용하고, 없다면 init()으로 초기화한다.</span></li>\n</ul>\n\n<p>2) <strong>서비스 단계</strong>:</p>\n<ul>\n  <li>Servlet Container는 각 요청마다 새로운 스레드를 생성한다.</li>\n  <li>새로운 Request/Response 객체를 생성하여 service() 메서드를 실행한다.</li>\n  <li>service()는 요청 방식(GET, POST 등)에 따라 적절한 do메서드를 호출한다.</li>\n  <li>요청 처리가 완료되면 해당 Request/Response 객체는 소멸된다.</li>\n</ul>\n\n<p>3) <strong>소멸 단계</strong>:</p>\n<ul>\n  <li><em>서버 종료나 애플리케이션 재배포 시에만 destroy()가 호출된다.</em></li>\n  <li><em>Servlet이 사용하던 리소스를 정리한다.</em></li>\n</ul>\n\n<p><br /></p>\n\n<p>정리하자면,</p>\n<ul>\n  <li>Tomcat은 Servlet 객체를 한 번 생성하면 메모리에 유지하고, 요청이 올 때마다 해당 객체의 <strong>service()</strong> 메서드를 호출한다.</li>\n  <li>따라서, <strong>init()</strong> 메서드는 <strong>최초 요청 시(또는 설정에 따라 애플리케이션 시작 시)</strong> 단 한 번 실행된다.</li>\n  <li>또 종료되기 전이나 reload 전에 destroy()를 호출하여 매번 객체가 생성되는 것을 방지한다.</li>\n</ul>\n\n<p><strong>(🤔 궁금증) servlet은 왜 생성만 하고 제거는 안하지?</strong>\n만약 사용이 끝날 때마다 제거한다면 다음과 같은 문제가 있다.</p>\n<ul>\n  <li>모든 요청에 대해 servlet을 생성하고 소멸하는 것은 OS 와 JVM 에게 필요없는 부하를 일으킨다.\n    <ul>\n      <li>JVM의 <strong>Garbage Collection</strong>과 <strong>메모리 할당/해제</strong>를 빈번하게 유발</li>\n    </ul>\n  </li>\n  <li>동시에 다수의 요청이 들어올 경우 CPU 또는 메모리 리소스 소모에 대한 제한이 어렵다. \n결국 순간적으로 서버가 다운되거나 동시 처리에 문제가 생길 수 있다.\n    <ul>\n      <li><em>(참고로 Tomcat 3.2 이전 버전은 실제 매번 생성과 제거를 했다.)</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p><strong>(✨해결) 해답은 Servlet의 특징과 관리 방식에 있다.</strong></p>\n<ul>\n  <li>수많은 클라이언트의 요청을 동시에 처리해야 하는 WAS의 특성상,\nServlet은 싱글톤 패턴으로 관리하게 되었다.\n    <ul>\n      <li>한 번 생성된 Servlet 인스턴스는 메모리에 계속 유지된다.</li>\n      <li>모든 요청은 동일한 Servlet 인스턴스를 공유한다.</li>\n      <li>init()은 최초 요청 시 한 번만 실행된다.</li>\n      <li>destroy()는 서버 종료나 재배포 시에만 실행된다.</li>\n    </ul>\n  </li>\n  <li><em>(Tomcat 3.2 부터는 디폴트로 <span class=\"post-highlight\">싱글톤 패턴 도입</span>와 <span class=\"post-highlight\">Thread Pool</span> 을 사용)</em></li>\n</ul>\n\n<p><br /></p>\n\n<h1 id=\"servlet-처리-구조의-발전\">Servlet 처리 구조의 발전</h1>\n\n<h2 id=\"기존-servlet-처리-방식\">기존 Servlet 처리 방식</h2>\n\n<p>Tomcat은 다음과 같은 역할을 한다고 하였다.</p>\n<ul>\n  <li>Servlet Container로서 HTTP 요청과 응답을 처리하는 환경 제공</li>\n  <li>Servlet 객체의 생성, 초기화, 요청 처리, 소멸 등 <strong>생명주기를 관리</strong>하는 역할</li>\n</ul>\n\n<p><strong>(🤔 문제점) Servlet은 요청마다 개별적으로 처리 로직을 구현해야 하므로,</strong><br />\n<strong>비슷한 요청을 처리하는 여러 Servlet에서 <span class=\"post-highlight\">중복된 코드가 발생</span>할 수 있다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/7c5e684e-cd0f-4167-8e55-f3d24172f58e\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 기존 서블릿 방식 - 각 URL마다 서블릿을 따로 만들어야 했습니다</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserServlet</span> <span class=\"kd\">extends</span> <span class=\"nc\">HttpServlet</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">doGet</span><span class=\"o\">(</span><span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"nc\">HttpServletResponse</span> <span class=\"n\">response</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 로깅 처리</span>\n        <span class=\"c1\">// 인증 처리</span>\n        <span class=\"c1\">// 공통 에러 처리</span>\n        <span class=\"c1\">// 실제 비즈니스 로직</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProductServlet</span> <span class=\"kd\">extends</span> <span class=\"nc\">HttpServlet</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">doGet</span><span class=\"o\">(</span><span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"nc\">HttpServletResponse</span> <span class=\"n\">response</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 위와 동일한 로깅, 인증, 에러 처리 코드가 반복됨</span>\n        <span class=\"c1\">// 실제 비즈니스 로직</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>이러한 방식은 다음과 같은 문제가 있다.</p>\n<ol>\n  <li>하나의 서블릿 클래스에 너무 많은 책임이 집중된다.</li>\n  <li>URL 매핑, 파라미터 처리, 뷰 선택 등을 모두 수동으로 처리해야 함</li>\n  <li>모든 서블릿에서 공통 로직(로깅, 인증, 에러 처리 등)이 반복됨</li>\n  <li>각각의 서블릿을 web.xml에 일일이 등록해야 함<br />\n (web.xml : 웹 애플리케이션의 <strong>구성 정보</strong>를 제공)</li>\n</ol>\n\n<ul>\n  <li>과거 web.xml은 다음과 같은 중요한 정보들을 담고 있었다.\n    <ul>\n      <li>어떤 서블릿이 존재하는지</li>\n      <li>각 서블릿이 어떤 URL 패턴을 처리하는지</li>\n      <li>어떤 필터들이 요청을 처리하는지</li>\n      <li>웹 애플리케이션의 시작과 종료 시 필요한 리스너는 무엇인지</li>\n    </ul>\n  </li>\n</ul>\n\n<p>⇒ 각 서블릿(요청을 처리하는 클래스)에 대한 정보를 등록해야 한다는 것이다… 😢</p>\n\n<p><br /></p>\n\n<h2 id=\"dispatcherservlet---spring-mvc--공통-로직의-중앙-집중화\"><strong>DispatcherServlet</strong> - Spring MVC : 공통 로직의 중앙 집중화</h2>\n\n<p><strong>(✨ 해결책) 공통 로직의 중앙 집중화</strong></p>\n\n<p>Spring Framework는 기존 서블릿 스펙의 장점을 활용하면서도 그 한계를 개선하는 방향으로 발전했다.</p>\n\n<p><span class=\"post-highlight\">DispatcherServlet이라는 Front Controller를 사용해 공통 로직을 처리하고 요청에 맞는 컨트롤러를 호출하는 특수한 Servlet</span>을 만들어 새로운 구조를 도입했다.</p>\n\n<ul>\n  <li><em>참고로 <strong>DispatcherServlet</strong> 도 <strong>Servlet이다.</strong></em>\n    <ul>\n      <li><em>(이쯤에서 Spring에서의 Controller의 역할이 아구 맞게 떠오른다.)</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/945895b9-66a2-4713-b7a4-8461f3a66075\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>Spring MVC는 이러한 문제를 DispatcherServlet이라는 하나의 Front Controller로 해결했다.</p>\n\n<ul>\n  <li><em>이제 우리가 아는 친숙한 코드가 나온다….</em></li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Spring MVC 방식</span>\n<span class=\"nd\">@Controller</span>  <span class=\"c1\">// 더 이상 HttpServlet을 상속할 필요가 없음</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserController</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@GetMapping</span><span class=\"o\">(</span><span class=\"s\">\"/users\"</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">handleUsers</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 비즈니스 로직에만 집중</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"userList\"</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"nd\">@Controller</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProductController</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@GetMapping</span><span class=\"o\">(</span><span class=\"s\">\"/products\"</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">handleProducts</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 비즈니스 로직에만 집중</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"productList\"</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p><strong>DispatcherServlet</strong>은 다음과 같은 일을 한다.</p>\n\n<ol>\n  <li><strong>DispatcherServlet</strong>은 웹 애플리케이션에 들어오는 모든 HTTP 요청을 먼저 받는다.</li>\n  <li>요청을 <strong>어떤 컨트롤러가 처리할지 결정</strong>하고, 해당 컨트롤러로 요청을 <strong>디스패치(위임)</strong> 한다.</li>\n  <li>요청에 대해 <strong>공통 처리</strong>(예: 인증, 로깅 등)를 먼저 한 후, 적절한 컨트롤러로 요청을 전달한다.</li>\n  <li><strong>DispatcherServlet</strong> 덕분에, 이제 다른 컨트롤러는 굳이 서블릿을 상속할 필요가 없다.</li>\n</ol>\n\n<p>4번에 대해 추가 설명을 하자면, <strong>Spring MVC</strong>에서는 <strong>DispatcherServlet</strong>만 서블릿으로 등록하고, 실제 비즈니스 로직을 처리하는 <strong>컨트롤러</strong>는 <strong>서블릿</strong>이 아니어도 된다는 뜻이다.</p>\n\n<ul>\n  <li><strong>Spring MVC</strong>에서는 <strong>DispatcherServlet</strong>만 서블릿으로 등록하고, 실제 비즈니스 로직을 처리하는 <strong>컨트롤러</strong>는 <strong>서블릿</strong>이 아니어도 된다는 뜻이다.</li>\n  <li>Spring MVC의 <strong>컨트롤러</strong>는 단순한 <strong>자바 클래스</strong>로, <strong>@Controller</strong> 어노테이션을 붙인 클래스를 만들어 요청을 처리할 수 있다.</li>\n  <li>이때, <strong>컨트롤러 클래스는 Servlet을 상속하지 않아도</strong> 된다.</li>\n  <li><strong>DispatcherServlet</strong>이 모든 요청을 처리하고, 요청을 <strong>컨트롤러</strong>로 전달하기 때문에, 실제로는 <strong>서블릿이 아닌 컨트롤러</strong>가 <strong>Servlet 객체를 상속</strong>하지 않아도 된다는 뜻이다.</li>\n</ul>\n\n<p>이렇듯 Spring 프레임워크는 Front Controller를 제공해주고 이를 Dispather Servlet 이라 부른다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/f5b5a218-c501-43c6-8869-c0ccd63acc77\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p><br /></p>\n\n<h2 id=\"servlet과-dispatcherservlet의-역할-분담의-의의\"><strong>Servlet</strong>과 DispatcherServlet의 역할 분담의 의의</h2>\n\n<p>Servlet 표준에서 중요한 점은 Servlet이 <span class=\"post-highlight\">전체 데이터 처리 과정에서 특정한 역할만 수행</span>한다는 것이다.</p>\n\n<p><strong><u>전통적인 서블릿 방식</u></strong>에서는 HTTP 요청/응답 처리부터 비즈니스 로직까지 모든 것을 책임져야했다.</p>\n\n<p>변화한 Spring MVC 구조에는 다음과 같은 장점이 있다.</p>\n\n<p>1) <strong>관심사의 분리(Separation of Concerns)</strong></p>\n<ol>\n  <li>DispatcherServlet이 모든 HTTP 요청을 먼저 받아서 적절한 Controller로 라우팅하는 역할을 담당하게 되었다.</li>\n  <li>이로 인해 Controller는 비즈니스 로직에만 집중할 수 있게 되었다.</li>\n</ol>\n\n<p>2) <strong>POJO(Plain Old Java Object) 기반 개발</strong></p>\n<ol>\n  <li>Controller가 더 이상 HttpServlet을 상속받지 않아도 된다는 것은 매우 중요한 의미를 가진다.</li>\n  <li>이는 일반적인 자바 클래스로 웹 개발이 가능해졌다는 뜻이다.</li>\n</ol>\n\n<p>3) <strong>각 엔드포인트가 명확하게 분리된다.</strong></p>\n\n<p><br /></p>\n\n<p>⇒ Spring Boot는 이러한 통합을 더욱 단순화했다.</p>\n\n<p>개발자는 복잡한 설정 없이도 Tomcat과 Spring이 자연스럽게 협력하는 환경에서 개발할 수 있게 되었다.</p>\n\n<p>web.xml 없이도 자동 구성을 통해 모든 것이 가능해졌다.</p>\n\n<p><em>@SpringBootApplication 어노테이션은 다음 3가지 핵심 어노테이션의 조합이다.</em></p>\n\n<ol>\n  <li>@SpringBootConfiguration</li>\n  <li><span class=\"post-highlight\">@EnableAutoConfiguration</span> [자동 구성]</li>\n  <li>@ComponentScan</li>\n</ol>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@SpringBootApplication</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">MyApplication</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// Spring Boot가 내장 Tomcat을 자동으로 구성하고 시작</span>\n        <span class=\"nc\">SpringApplication</span><span class=\"o\">.</span><span class=\"na\">run</span><span class=\"o\">(</span><span class=\"nc\">MyApplication</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">,</span> <span class=\"n\">args</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>즉, 현대에 와서 <strong>DispatcherServlet이 서블릿 역할을 하면서</strong> 요청을 <strong>Controller</strong>에 전달하고, <strong>Controller</strong>는 <strong>서비스</strong>를 호출하여 실제 비즈니스 로직을 처리하게 하는 방식으로 발전하였다.</p>\n\n<ul>\n  <li>단지 <strong>DispatcherServlet</strong>은 요청을 받아서 적절한 컨트롤러에게 넘겨주는 역할을 한다.</li>\n</ul>\n\n<p>지금까지 살펴본 WAS의 발전 과정을 보면 다음과 같다.</p>\n<ol>\n  <li>WAS는 동적 컨텐츠 처리를 위한 웹 애플리케이션 서버로 분리되며 시작됐다.</li>\n  <li>Tomcat은 Servlet Container로서 Java 기반 웹 애플리케이션을 실행시킨다.</li>\n  <li>초기 Servlet 방식의 한계(중복 코드, 복잡한 설정)를 Spring MVC가 해결했다.</li>\n  <li>DispatcherServlet의 도입으로 공통 로직 처리와 요청 위임이 체계화되었다.</li>\n</ol>\n\n<p>결국 DispatcherServlet이 모든 요청을 받아 적절한 Controller에 위임하므로\nController는 순수 비즈니스 로직에만 집중할 수 있게 되었다.</p>\n<ul>\n  <li>개발자는 반복적인 설정 없이 핵심 기능 개발에 집중 가능!</li>\n</ul>\n\n<p>이처럼 WAS와 Servlet, 그리고 Spring MVC로 이어지는 발전 과정은 더 나은 웹 개발 환경을 만들어왔다.</p>\n\n<p>더 나아가, 웹 애플리케이션 아키텍처는 계속해서 진화하고 있다.</p>\n<ul>\n  <li>Spring WebFlux를 통한 리액티브 프로그래밍 도입</li>\n  <li>클라우드 네이티브 환경 지원</li>\n  <li>마이크로서비스 아키텍처로의 전환</li>\n  <li>서버리스 아키텍처의 등장</li>\n</ul>\n",
                        "tags": ["WAS","Tomcat","Servlet","SpringMVC","Java","WebDevelopment","Architecture","DispatcherServlet","SpringBoot"]
                    }
                
            ],
        
            "WebDevelopment": [
                
                    {
                        "title": "WAS(Web Application Server)와 Servlet",
                        "url": "/2025/01/28/about-was.html",
                        "subtitle": "Tomcat부터 Spring Boot까지",
                        "excerpt": "웹 서버(WS)의 진화 : Apache vs NGINX\n위 post에 이어지는 내용입니다.\n",
                        "author": "Jinho",
                        "date": "January 28, 2025",
                        "background": "/img/posts/apache_tomcat.jpeg",
                        "content": "<p><a href=\"https://jinho7.github.io/2025/01/27/ws-and-was.html\" target=\"웹 서버(WS)의 진화 : Apache vs NGINX \">웹 서버(WS)의 진화 : Apache vs NGINX</a><br />\n<em>위 post에 이어지는 내용입니다.</em></p>\n\n<h1 id=\"was-란\">WAS 란?</h1>\n\n<h2 id=\"was의-정의\">WAS의 정의</h2>\n\n<p>먼저 WAS(Web Application Server)의 정의는 다음과 같다.</p>\n<blockquote>\n  <p><span class=\"post-highlight\">웹 애플리케이션과 서버 환경을 만들어 동작시키는 기능을 제공하는 소프트웨어 프레임워크</span></p>\n</blockquote>\n\n<p>대표적으로 Apache <span class=\"post-highlight\">Tomcat</span>이 있다.</p>\n<ul>\n  <li><em>참고로 Apache Tomcat는 WS 단계에서 계속 이야기했던 Apache와는 아예 별개의 소프트웨어이다.</em></li>\n</ul>\n\n<details>\n<summary>Apache와 Tomcat</summary>\nApache HTTP Server (보통 Apache라고 부름)\n<ul>\n    <li>웹 서버(WS) 역할을 담당</li>\n    <li>주로 정적 콘텐츠를 처리</li>\n    <li>HTTP 요청을 처리하며, 동적 콘텐츠를 처리할 경우에는 WAS(Tomcat)와 연동하여 작업을 나눕니다.</li>\n</ul>\nApache Tomcat (보통 Tomcat이라고 부름)\n<ul>\n    <li>WAS 역할을 담당</li>\n    <li>Servlet Container로서 동작하며, Servlet/JSP 기반의 동적 콘텐츠를 처리\n        <ul>\n            <li><em>정적 콘텐츠도 처리할 수는 있다.</em></li>\n            <li><em>정적 콘텐츠 처리 성능은 Apache HTTP Server보다 낮다.</em></li>\n        </ul>\n    </li>\n    <li>Java EE 표준의 일부인 Servlet/JSP 스펙을 구현하며, Spring MVC와 같은 프레임워크의 기반이 되는 동작을 지원한다.</li>\n</ul>\n</details>\n\n<p><br /></p>\n\n<p>그러나 이런 물음표가 떠오른다.</p>\n\n<p><strong>❓ WAS? TOMCAT? Servlet? Servlet Container? Spring MVC?</strong></p>\n\n<p>다음 기본 개념부터 인지하고 넘어가면 이해하기 쉽다.</p>\n\n<ol>\n  <li><strong>WAS</strong>는 클라이언트의 요청을 처리하여 <strong>동적인 웹 콘텐츠</strong>를 제공하는 서버를 말한다.</li>\n  <li><strong>Tomcat</strong>은 WAS의 대표적인 예시 중 하나이다.</li>\n  <li>Tomcat은 <strong>Servlet Container의 한 종류</strong>이며, <strong>Servlet/JSP 요청을 처리</strong>하는 역할을 한다.</li>\n  <li>Tomcat은 <strong>Servlet 표준</strong>에 맞춘 애플리케이션을 실행하는 데 최적화되어 있다.\n    <ol>\n      <li><strong>Servlet 표준</strong>은 <strong>Java EE</strong>(현재는 <strong>Jakarta EE</strong>) 명세의 일부로, <strong>Java 기반 동적 웹 콘텐츠 처리</strong>를 위한 규격이다.</li>\n      <li>즉, Tomcat은 <strong>Java 기반의 웹 애플리케이션</strong>을 실행하기 위한 서버이다.</li>\n    </ol>\n  </li>\n</ol>\n\n<p><strong>WS와 WAS의 차이의 핵심는 ‘동적 처리 여부’에 있다.</strong></p>\n<ul>\n  <li>현대 웹사이트는 스크롤에 따라 새로운 피드를 보여주거나,<br />\n사용자 맞춤 광고를 제공하는 등의 동적 기능을 포함한다.</li>\n  <li>이러한 <strong>“사용자 맞춤 가공 처리(동적 콘텐츠)”는 결국 서버가 특정 코드를 실행했다</strong>는 의미다.</li>\n  <li>결국 궁금한 것은 ‘<strong>서버가 어떻게 이 코드를 실행하고, 그 결과를 클라이언트에게 제공하는가</strong>’이다.</li>\n</ul>\n\n<div style=\"display: flex; justify-content: space-between; gap: 20px;\">\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/203ab158-60b0-4376-be93-1de497da3d19\" alt=\"Memory Usage\" style=\"width: 100%;\" />\n        <p style=\"text-align: center; color: #666;\">누구나에게 제공되는 “정적인” 컨텐츠이다.</p>\n    </div>\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/5795047e-ae12-4cda-a1f6-e2b3ab8dfd72\" alt=\"Requests Per Second\" style=\"width: 100%;\" />\n        <p style=\"text-align: center; color: #666;\">하지만 로그인하고 나면 “동적인” 컨텐츠가 로드된다.</p>\n    </div>\n</div>\n\n<p>아래는 동적 페이지를 로드하는 과정을 그림으로 표현한 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/ef604672-3c6c-4724-9f9a-9a226cc6e513\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>우리는 앞서 실제 운영/대규모 서비스는 <span class=\"post-highlight\">WS-WAS 분리 구조</span>를 선호한다고 말했다.</p>\n\n<p>나는 WAS의 한 종류인 Tomcat까지의 웹통신 흐름이 어떻게 이루어지는 지가 궁금해졌다.<br />\n그리고 <u>‘jvm, survlet, spring 등 어떤 개념이고 어떤 연관관계가 있고 어떻게 유동적으로 작동할까…?’</u> 가 궁금했다.</p>\n\n<p><br /></p>\n\n<h2 id=\"jvmjava-virtual-machine\">JVM(Java Virtual Machine)</h2>\n\n<p><img src=\"https://github.com/user-attachments/assets/f48a2ce2-5aa4-495c-a686-79e32ce7eed2\" alt=\"Image\" width=\"70%\" height=\"100%\" class=\"center\" /></p>\n\n<p><em>JVM 자체가 현재 내용에서 매우 중요한 내용은 아니라 짧게 이야기하면,</em></p>\n<ul>\n  <li>⇒ 그냥 JVM은 간단히 Java 코드를 실행시켜주는 놈이라고 생각하자.</li>\n  <li>WAS(Tomcat)는 Java로 작성된 웹 애플리케이션을 실행하는 컨테이너이므로,<br />\nWAS도 JVM 위에서 동작한다.</li>\n</ul>\n\n<details>\n<summary>JVM 이란?</summary>\nApache HTTP Server (보통 Apache라고 부름)\n<ul>\n    <li>JVM은 JVM은 Java 바이트코드(.class 파일)를 해석하고 실행하는 가상 머신</li>\n    <li>JRE는 Java 프로그램을 실행하는 데 필요한 모든 것을 포함한다. 라이브러리 등</li>\n        <ul>\n            <li><em>JRE은 JVM을 시작, 필요한 클래스 라이브러리 로드, main() 메서드를 실행한다.</em></li>\n        </ul>\n    <li>JDK는 Java 애플리케이션을 개발하는 데 필요한 모든 도구를 포함한다.</li>\n</ul>\n</details>\n\n<p><br /></p>\n\n<h2 id=\"servlet-container-tomcat\">Servlet Container [Tomcat]</h2>\n\n<p>위에서 “Tomcat은 <strong><u>Servlet Container의 한 종류</u></strong>이며, <strong><u>Servlet/JSP 요청을 처리</u></strong>하는 역할을 한다.” 라고 했다.</p>\n\n<p>1) <strong>Servlet Container</strong>는 Servlet<strong>의 생명 주기</strong>를 관리하는 곳이다.</p>\n<ul>\n  <li>Servlet과 Servlet Container의 관계를 Bean과 Bean Container의 관계와 흡사하다고 생각하면 된다. (“컨테이너와 관리 대상”의 관계로 이해)\n    <ul>\n      <li>Servlet Container는 HTTP 요청과 응답을 처리하는 Servlet을 관리</li>\n      <li>Bean Container는 Spring의 <strong>애플리케이션 내 객체(Bean)</strong>의 생명 주기와 의존성을 관리</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2) 또한, <strong>HTTP 요청 처리 및 응답 생성 과정</strong>은 Servlet Container의 핵심 기능 중 하나이다.</p>\n<ul>\n  <li>웹 브라우저에서 요청이 들어오면, Tomcat은 그 요청을 받아서 적절한 Java 코드(서블릿)로 전달하고, 그 결과를 다시 브라우저로 보내는 역할을 한다.</li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"servlet\">Servlet</h2>\n\n<p>Servlet은 <strong>HTTP 요청을 처리하고 응답을 생성하는 스펙을 정의한 인터페이스</strong>이다.</p>\n<ul>\n  <li>Servlet은 <strong>jakarta.servlet.Servlet</strong>을 최상위 인터페이스로 가진다. (Java API)</li>\n</ul>\n\n<p>Servlet은 <strong>Servlet Container</strong>에 의해 관리되며, 요청이 들어오면 컨테이너가 Servlet의 생명 주기를 관리하고 요청을 처리하기 위한 스레드를 생성한다.</p>\n\n<p>Servlet은 HTTP 요청을 처리하고, 그에 따른 적절한 응답을 생성하는 기본 단위이다. 이를 통해 <span class=\"post-highlight\">REST API의 엔드포인트</span>가 되거나 <span class=\"post-highlight\">동적 웹 페이지를 생성</span>하는 역할을 수행할 수 있다.</p>\n\n<ol>\n  <li>Servlet은 HTTP 요청을 받아 비즈니스 로직을 처리하고 JSON, XML 등의 형식으로 데이터를 응답할 수 있다.</li>\n  <li>동적인 HTML 콘텐츠를 생성할 때도 사용된다.\n    <ul>\n      <li>예를 들어, 비즈니스 로직 처리가 필요한 HTTP 요청이 Web Server로 들어오면, Web Server는 이를 Servlet Container가 실행하는 Servlet에 전달한다.</li>\n      <li>Servlet은 요청을 처리하고 동적인 웹 콘텐츠를 생성한 뒤, 결과를 Web Server를 통해 클라이언트로 반환한다.</li>\n    </ul>\n  </li>\n</ol>\n\n<p>전체적인 통신 흐름은 다음과 같다.</p>\n<ul>\n  <li>WS 는 HTTP 요청을 받아 정적 리소스를 처리하거나, 요청을 WAS에 전달한다.</li>\n  <li>WAS는 Servlet Container를 통해 요청을 처리하고, 처리 결과를 Web Server를 거쳐 클라이언트에 반환한다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/06d2213c-0f90-4a1b-a765-33531aeed39d\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p><br /></p>\n\n<h3 id=\"servlet의-생명주기\">Servlet의 생명주기</h3>\n\n<p>위 그림을 보면 알 수 있듯, Servlet은 다음과 같은 생명 주기를 가진다.</p>\n\n<p>1) <strong>초기화 단계</strong>:</p>\n<ul>\n  <li>최초 요청이 오면 Servlet 클래스(HelloServlet.class)가 로딩된다.</li>\n  <li>web.xml 설정을 참고하여 매핑할 Servlet을 확인한다.</li>\n  <li><span class=\"post-highlight\">해당 Servlet 인스턴스가 있다면 사용하고, 없다면 init()으로 초기화한다.</span></li>\n</ul>\n\n<p>2) <strong>서비스 단계</strong>:</p>\n<ul>\n  <li>Servlet Container는 각 요청마다 새로운 스레드를 생성한다.</li>\n  <li>새로운 Request/Response 객체를 생성하여 service() 메서드를 실행한다.</li>\n  <li>service()는 요청 방식(GET, POST 등)에 따라 적절한 do메서드를 호출한다.</li>\n  <li>요청 처리가 완료되면 해당 Request/Response 객체는 소멸된다.</li>\n</ul>\n\n<p>3) <strong>소멸 단계</strong>:</p>\n<ul>\n  <li><em>서버 종료나 애플리케이션 재배포 시에만 destroy()가 호출된다.</em></li>\n  <li><em>Servlet이 사용하던 리소스를 정리한다.</em></li>\n</ul>\n\n<p><br /></p>\n\n<p>정리하자면,</p>\n<ul>\n  <li>Tomcat은 Servlet 객체를 한 번 생성하면 메모리에 유지하고, 요청이 올 때마다 해당 객체의 <strong>service()</strong> 메서드를 호출한다.</li>\n  <li>따라서, <strong>init()</strong> 메서드는 <strong>최초 요청 시(또는 설정에 따라 애플리케이션 시작 시)</strong> 단 한 번 실행된다.</li>\n  <li>또 종료되기 전이나 reload 전에 destroy()를 호출하여 매번 객체가 생성되는 것을 방지한다.</li>\n</ul>\n\n<p><strong>(🤔 궁금증) servlet은 왜 생성만 하고 제거는 안하지?</strong>\n만약 사용이 끝날 때마다 제거한다면 다음과 같은 문제가 있다.</p>\n<ul>\n  <li>모든 요청에 대해 servlet을 생성하고 소멸하는 것은 OS 와 JVM 에게 필요없는 부하를 일으킨다.\n    <ul>\n      <li>JVM의 <strong>Garbage Collection</strong>과 <strong>메모리 할당/해제</strong>를 빈번하게 유발</li>\n    </ul>\n  </li>\n  <li>동시에 다수의 요청이 들어올 경우 CPU 또는 메모리 리소스 소모에 대한 제한이 어렵다. \n결국 순간적으로 서버가 다운되거나 동시 처리에 문제가 생길 수 있다.\n    <ul>\n      <li><em>(참고로 Tomcat 3.2 이전 버전은 실제 매번 생성과 제거를 했다.)</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p><strong>(✨해결) 해답은 Servlet의 특징과 관리 방식에 있다.</strong></p>\n<ul>\n  <li>수많은 클라이언트의 요청을 동시에 처리해야 하는 WAS의 특성상,\nServlet은 싱글톤 패턴으로 관리하게 되었다.\n    <ul>\n      <li>한 번 생성된 Servlet 인스턴스는 메모리에 계속 유지된다.</li>\n      <li>모든 요청은 동일한 Servlet 인스턴스를 공유한다.</li>\n      <li>init()은 최초 요청 시 한 번만 실행된다.</li>\n      <li>destroy()는 서버 종료나 재배포 시에만 실행된다.</li>\n    </ul>\n  </li>\n  <li><em>(Tomcat 3.2 부터는 디폴트로 <span class=\"post-highlight\">싱글톤 패턴 도입</span>와 <span class=\"post-highlight\">Thread Pool</span> 을 사용)</em></li>\n</ul>\n\n<p><br /></p>\n\n<h1 id=\"servlet-처리-구조의-발전\">Servlet 처리 구조의 발전</h1>\n\n<h2 id=\"기존-servlet-처리-방식\">기존 Servlet 처리 방식</h2>\n\n<p>Tomcat은 다음과 같은 역할을 한다고 하였다.</p>\n<ul>\n  <li>Servlet Container로서 HTTP 요청과 응답을 처리하는 환경 제공</li>\n  <li>Servlet 객체의 생성, 초기화, 요청 처리, 소멸 등 <strong>생명주기를 관리</strong>하는 역할</li>\n</ul>\n\n<p><strong>(🤔 문제점) Servlet은 요청마다 개별적으로 처리 로직을 구현해야 하므로,</strong><br />\n<strong>비슷한 요청을 처리하는 여러 Servlet에서 <span class=\"post-highlight\">중복된 코드가 발생</span>할 수 있다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/7c5e684e-cd0f-4167-8e55-f3d24172f58e\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 기존 서블릿 방식 - 각 URL마다 서블릿을 따로 만들어야 했습니다</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserServlet</span> <span class=\"kd\">extends</span> <span class=\"nc\">HttpServlet</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">doGet</span><span class=\"o\">(</span><span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"nc\">HttpServletResponse</span> <span class=\"n\">response</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 로깅 처리</span>\n        <span class=\"c1\">// 인증 처리</span>\n        <span class=\"c1\">// 공통 에러 처리</span>\n        <span class=\"c1\">// 실제 비즈니스 로직</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProductServlet</span> <span class=\"kd\">extends</span> <span class=\"nc\">HttpServlet</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">doGet</span><span class=\"o\">(</span><span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"nc\">HttpServletResponse</span> <span class=\"n\">response</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 위와 동일한 로깅, 인증, 에러 처리 코드가 반복됨</span>\n        <span class=\"c1\">// 실제 비즈니스 로직</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>이러한 방식은 다음과 같은 문제가 있다.</p>\n<ol>\n  <li>하나의 서블릿 클래스에 너무 많은 책임이 집중된다.</li>\n  <li>URL 매핑, 파라미터 처리, 뷰 선택 등을 모두 수동으로 처리해야 함</li>\n  <li>모든 서블릿에서 공통 로직(로깅, 인증, 에러 처리 등)이 반복됨</li>\n  <li>각각의 서블릿을 web.xml에 일일이 등록해야 함<br />\n (web.xml : 웹 애플리케이션의 <strong>구성 정보</strong>를 제공)</li>\n</ol>\n\n<ul>\n  <li>과거 web.xml은 다음과 같은 중요한 정보들을 담고 있었다.\n    <ul>\n      <li>어떤 서블릿이 존재하는지</li>\n      <li>각 서블릿이 어떤 URL 패턴을 처리하는지</li>\n      <li>어떤 필터들이 요청을 처리하는지</li>\n      <li>웹 애플리케이션의 시작과 종료 시 필요한 리스너는 무엇인지</li>\n    </ul>\n  </li>\n</ul>\n\n<p>⇒ 각 서블릿(요청을 처리하는 클래스)에 대한 정보를 등록해야 한다는 것이다… 😢</p>\n\n<p><br /></p>\n\n<h2 id=\"dispatcherservlet---spring-mvc--공통-로직의-중앙-집중화\"><strong>DispatcherServlet</strong> - Spring MVC : 공통 로직의 중앙 집중화</h2>\n\n<p><strong>(✨ 해결책) 공통 로직의 중앙 집중화</strong></p>\n\n<p>Spring Framework는 기존 서블릿 스펙의 장점을 활용하면서도 그 한계를 개선하는 방향으로 발전했다.</p>\n\n<p><span class=\"post-highlight\">DispatcherServlet이라는 Front Controller를 사용해 공통 로직을 처리하고 요청에 맞는 컨트롤러를 호출하는 특수한 Servlet</span>을 만들어 새로운 구조를 도입했다.</p>\n\n<ul>\n  <li><em>참고로 <strong>DispatcherServlet</strong> 도 <strong>Servlet이다.</strong></em>\n    <ul>\n      <li><em>(이쯤에서 Spring에서의 Controller의 역할이 아구 맞게 떠오른다.)</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/945895b9-66a2-4713-b7a4-8461f3a66075\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>Spring MVC는 이러한 문제를 DispatcherServlet이라는 하나의 Front Controller로 해결했다.</p>\n\n<ul>\n  <li><em>이제 우리가 아는 친숙한 코드가 나온다….</em></li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Spring MVC 방식</span>\n<span class=\"nd\">@Controller</span>  <span class=\"c1\">// 더 이상 HttpServlet을 상속할 필요가 없음</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserController</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@GetMapping</span><span class=\"o\">(</span><span class=\"s\">\"/users\"</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">handleUsers</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 비즈니스 로직에만 집중</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"userList\"</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"nd\">@Controller</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProductController</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@GetMapping</span><span class=\"o\">(</span><span class=\"s\">\"/products\"</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">handleProducts</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 비즈니스 로직에만 집중</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"productList\"</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p><strong>DispatcherServlet</strong>은 다음과 같은 일을 한다.</p>\n\n<ol>\n  <li><strong>DispatcherServlet</strong>은 웹 애플리케이션에 들어오는 모든 HTTP 요청을 먼저 받는다.</li>\n  <li>요청을 <strong>어떤 컨트롤러가 처리할지 결정</strong>하고, 해당 컨트롤러로 요청을 <strong>디스패치(위임)</strong> 한다.</li>\n  <li>요청에 대해 <strong>공통 처리</strong>(예: 인증, 로깅 등)를 먼저 한 후, 적절한 컨트롤러로 요청을 전달한다.</li>\n  <li><strong>DispatcherServlet</strong> 덕분에, 이제 다른 컨트롤러는 굳이 서블릿을 상속할 필요가 없다.</li>\n</ol>\n\n<p>4번에 대해 추가 설명을 하자면, <strong>Spring MVC</strong>에서는 <strong>DispatcherServlet</strong>만 서블릿으로 등록하고, 실제 비즈니스 로직을 처리하는 <strong>컨트롤러</strong>는 <strong>서블릿</strong>이 아니어도 된다는 뜻이다.</p>\n\n<ul>\n  <li><strong>Spring MVC</strong>에서는 <strong>DispatcherServlet</strong>만 서블릿으로 등록하고, 실제 비즈니스 로직을 처리하는 <strong>컨트롤러</strong>는 <strong>서블릿</strong>이 아니어도 된다는 뜻이다.</li>\n  <li>Spring MVC의 <strong>컨트롤러</strong>는 단순한 <strong>자바 클래스</strong>로, <strong>@Controller</strong> 어노테이션을 붙인 클래스를 만들어 요청을 처리할 수 있다.</li>\n  <li>이때, <strong>컨트롤러 클래스는 Servlet을 상속하지 않아도</strong> 된다.</li>\n  <li><strong>DispatcherServlet</strong>이 모든 요청을 처리하고, 요청을 <strong>컨트롤러</strong>로 전달하기 때문에, 실제로는 <strong>서블릿이 아닌 컨트롤러</strong>가 <strong>Servlet 객체를 상속</strong>하지 않아도 된다는 뜻이다.</li>\n</ul>\n\n<p>이렇듯 Spring 프레임워크는 Front Controller를 제공해주고 이를 Dispather Servlet 이라 부른다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/f5b5a218-c501-43c6-8869-c0ccd63acc77\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p><br /></p>\n\n<h2 id=\"servlet과-dispatcherservlet의-역할-분담의-의의\"><strong>Servlet</strong>과 DispatcherServlet의 역할 분담의 의의</h2>\n\n<p>Servlet 표준에서 중요한 점은 Servlet이 <span class=\"post-highlight\">전체 데이터 처리 과정에서 특정한 역할만 수행</span>한다는 것이다.</p>\n\n<p><strong><u>전통적인 서블릿 방식</u></strong>에서는 HTTP 요청/응답 처리부터 비즈니스 로직까지 모든 것을 책임져야했다.</p>\n\n<p>변화한 Spring MVC 구조에는 다음과 같은 장점이 있다.</p>\n\n<p>1) <strong>관심사의 분리(Separation of Concerns)</strong></p>\n<ol>\n  <li>DispatcherServlet이 모든 HTTP 요청을 먼저 받아서 적절한 Controller로 라우팅하는 역할을 담당하게 되었다.</li>\n  <li>이로 인해 Controller는 비즈니스 로직에만 집중할 수 있게 되었다.</li>\n</ol>\n\n<p>2) <strong>POJO(Plain Old Java Object) 기반 개발</strong></p>\n<ol>\n  <li>Controller가 더 이상 HttpServlet을 상속받지 않아도 된다는 것은 매우 중요한 의미를 가진다.</li>\n  <li>이는 일반적인 자바 클래스로 웹 개발이 가능해졌다는 뜻이다.</li>\n</ol>\n\n<p>3) <strong>각 엔드포인트가 명확하게 분리된다.</strong></p>\n\n<p><br /></p>\n\n<p>⇒ Spring Boot는 이러한 통합을 더욱 단순화했다.</p>\n\n<p>개발자는 복잡한 설정 없이도 Tomcat과 Spring이 자연스럽게 협력하는 환경에서 개발할 수 있게 되었다.</p>\n\n<p>web.xml 없이도 자동 구성을 통해 모든 것이 가능해졌다.</p>\n\n<p><em>@SpringBootApplication 어노테이션은 다음 3가지 핵심 어노테이션의 조합이다.</em></p>\n\n<ol>\n  <li>@SpringBootConfiguration</li>\n  <li><span class=\"post-highlight\">@EnableAutoConfiguration</span> [자동 구성]</li>\n  <li>@ComponentScan</li>\n</ol>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@SpringBootApplication</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">MyApplication</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// Spring Boot가 내장 Tomcat을 자동으로 구성하고 시작</span>\n        <span class=\"nc\">SpringApplication</span><span class=\"o\">.</span><span class=\"na\">run</span><span class=\"o\">(</span><span class=\"nc\">MyApplication</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">,</span> <span class=\"n\">args</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>즉, 현대에 와서 <strong>DispatcherServlet이 서블릿 역할을 하면서</strong> 요청을 <strong>Controller</strong>에 전달하고, <strong>Controller</strong>는 <strong>서비스</strong>를 호출하여 실제 비즈니스 로직을 처리하게 하는 방식으로 발전하였다.</p>\n\n<ul>\n  <li>단지 <strong>DispatcherServlet</strong>은 요청을 받아서 적절한 컨트롤러에게 넘겨주는 역할을 한다.</li>\n</ul>\n\n<p>지금까지 살펴본 WAS의 발전 과정을 보면 다음과 같다.</p>\n<ol>\n  <li>WAS는 동적 컨텐츠 처리를 위한 웹 애플리케이션 서버로 분리되며 시작됐다.</li>\n  <li>Tomcat은 Servlet Container로서 Java 기반 웹 애플리케이션을 실행시킨다.</li>\n  <li>초기 Servlet 방식의 한계(중복 코드, 복잡한 설정)를 Spring MVC가 해결했다.</li>\n  <li>DispatcherServlet의 도입으로 공통 로직 처리와 요청 위임이 체계화되었다.</li>\n</ol>\n\n<p>결국 DispatcherServlet이 모든 요청을 받아 적절한 Controller에 위임하므로\nController는 순수 비즈니스 로직에만 집중할 수 있게 되었다.</p>\n<ul>\n  <li>개발자는 반복적인 설정 없이 핵심 기능 개발에 집중 가능!</li>\n</ul>\n\n<p>이처럼 WAS와 Servlet, 그리고 Spring MVC로 이어지는 발전 과정은 더 나은 웹 개발 환경을 만들어왔다.</p>\n\n<p>더 나아가, 웹 애플리케이션 아키텍처는 계속해서 진화하고 있다.</p>\n<ul>\n  <li>Spring WebFlux를 통한 리액티브 프로그래밍 도입</li>\n  <li>클라우드 네이티브 환경 지원</li>\n  <li>마이크로서비스 아키텍처로의 전환</li>\n  <li>서버리스 아키텍처의 등장</li>\n</ul>\n",
                        "tags": ["WAS","Tomcat","Servlet","SpringMVC","Java","WebDevelopment","Architecture","DispatcherServlet","SpringBoot"]
                    }
                
            ],
        
            "DispatcherServlet": [
                
                    {
                        "title": "WAS(Web Application Server)와 Servlet",
                        "url": "/2025/01/28/about-was.html",
                        "subtitle": "Tomcat부터 Spring Boot까지",
                        "excerpt": "웹 서버(WS)의 진화 : Apache vs NGINX\n위 post에 이어지는 내용입니다.\n",
                        "author": "Jinho",
                        "date": "January 28, 2025",
                        "background": "/img/posts/apache_tomcat.jpeg",
                        "content": "<p><a href=\"https://jinho7.github.io/2025/01/27/ws-and-was.html\" target=\"웹 서버(WS)의 진화 : Apache vs NGINX \">웹 서버(WS)의 진화 : Apache vs NGINX</a><br />\n<em>위 post에 이어지는 내용입니다.</em></p>\n\n<h1 id=\"was-란\">WAS 란?</h1>\n\n<h2 id=\"was의-정의\">WAS의 정의</h2>\n\n<p>먼저 WAS(Web Application Server)의 정의는 다음과 같다.</p>\n<blockquote>\n  <p><span class=\"post-highlight\">웹 애플리케이션과 서버 환경을 만들어 동작시키는 기능을 제공하는 소프트웨어 프레임워크</span></p>\n</blockquote>\n\n<p>대표적으로 Apache <span class=\"post-highlight\">Tomcat</span>이 있다.</p>\n<ul>\n  <li><em>참고로 Apache Tomcat는 WS 단계에서 계속 이야기했던 Apache와는 아예 별개의 소프트웨어이다.</em></li>\n</ul>\n\n<details>\n<summary>Apache와 Tomcat</summary>\nApache HTTP Server (보통 Apache라고 부름)\n<ul>\n    <li>웹 서버(WS) 역할을 담당</li>\n    <li>주로 정적 콘텐츠를 처리</li>\n    <li>HTTP 요청을 처리하며, 동적 콘텐츠를 처리할 경우에는 WAS(Tomcat)와 연동하여 작업을 나눕니다.</li>\n</ul>\nApache Tomcat (보통 Tomcat이라고 부름)\n<ul>\n    <li>WAS 역할을 담당</li>\n    <li>Servlet Container로서 동작하며, Servlet/JSP 기반의 동적 콘텐츠를 처리\n        <ul>\n            <li><em>정적 콘텐츠도 처리할 수는 있다.</em></li>\n            <li><em>정적 콘텐츠 처리 성능은 Apache HTTP Server보다 낮다.</em></li>\n        </ul>\n    </li>\n    <li>Java EE 표준의 일부인 Servlet/JSP 스펙을 구현하며, Spring MVC와 같은 프레임워크의 기반이 되는 동작을 지원한다.</li>\n</ul>\n</details>\n\n<p><br /></p>\n\n<p>그러나 이런 물음표가 떠오른다.</p>\n\n<p><strong>❓ WAS? TOMCAT? Servlet? Servlet Container? Spring MVC?</strong></p>\n\n<p>다음 기본 개념부터 인지하고 넘어가면 이해하기 쉽다.</p>\n\n<ol>\n  <li><strong>WAS</strong>는 클라이언트의 요청을 처리하여 <strong>동적인 웹 콘텐츠</strong>를 제공하는 서버를 말한다.</li>\n  <li><strong>Tomcat</strong>은 WAS의 대표적인 예시 중 하나이다.</li>\n  <li>Tomcat은 <strong>Servlet Container의 한 종류</strong>이며, <strong>Servlet/JSP 요청을 처리</strong>하는 역할을 한다.</li>\n  <li>Tomcat은 <strong>Servlet 표준</strong>에 맞춘 애플리케이션을 실행하는 데 최적화되어 있다.\n    <ol>\n      <li><strong>Servlet 표준</strong>은 <strong>Java EE</strong>(현재는 <strong>Jakarta EE</strong>) 명세의 일부로, <strong>Java 기반 동적 웹 콘텐츠 처리</strong>를 위한 규격이다.</li>\n      <li>즉, Tomcat은 <strong>Java 기반의 웹 애플리케이션</strong>을 실행하기 위한 서버이다.</li>\n    </ol>\n  </li>\n</ol>\n\n<p><strong>WS와 WAS의 차이의 핵심는 ‘동적 처리 여부’에 있다.</strong></p>\n<ul>\n  <li>현대 웹사이트는 스크롤에 따라 새로운 피드를 보여주거나,<br />\n사용자 맞춤 광고를 제공하는 등의 동적 기능을 포함한다.</li>\n  <li>이러한 <strong>“사용자 맞춤 가공 처리(동적 콘텐츠)”는 결국 서버가 특정 코드를 실행했다</strong>는 의미다.</li>\n  <li>결국 궁금한 것은 ‘<strong>서버가 어떻게 이 코드를 실행하고, 그 결과를 클라이언트에게 제공하는가</strong>’이다.</li>\n</ul>\n\n<div style=\"display: flex; justify-content: space-between; gap: 20px;\">\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/203ab158-60b0-4376-be93-1de497da3d19\" alt=\"Memory Usage\" style=\"width: 100%;\" />\n        <p style=\"text-align: center; color: #666;\">누구나에게 제공되는 “정적인” 컨텐츠이다.</p>\n    </div>\n    <div style=\"flex: 1;\">\n        <img src=\"https://github.com/user-attachments/assets/5795047e-ae12-4cda-a1f6-e2b3ab8dfd72\" alt=\"Requests Per Second\" style=\"width: 100%;\" />\n        <p style=\"text-align: center; color: #666;\">하지만 로그인하고 나면 “동적인” 컨텐츠가 로드된다.</p>\n    </div>\n</div>\n\n<p>아래는 동적 페이지를 로드하는 과정을 그림으로 표현한 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/ef604672-3c6c-4724-9f9a-9a226cc6e513\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p>우리는 앞서 실제 운영/대규모 서비스는 <span class=\"post-highlight\">WS-WAS 분리 구조</span>를 선호한다고 말했다.</p>\n\n<p>나는 WAS의 한 종류인 Tomcat까지의 웹통신 흐름이 어떻게 이루어지는 지가 궁금해졌다.<br />\n그리고 <u>‘jvm, survlet, spring 등 어떤 개념이고 어떤 연관관계가 있고 어떻게 유동적으로 작동할까…?’</u> 가 궁금했다.</p>\n\n<p><br /></p>\n\n<h2 id=\"jvmjava-virtual-machine\">JVM(Java Virtual Machine)</h2>\n\n<p><img src=\"https://github.com/user-attachments/assets/f48a2ce2-5aa4-495c-a686-79e32ce7eed2\" alt=\"Image\" width=\"70%\" height=\"100%\" class=\"center\" /></p>\n\n<p><em>JVM 자체가 현재 내용에서 매우 중요한 내용은 아니라 짧게 이야기하면,</em></p>\n<ul>\n  <li>⇒ 그냥 JVM은 간단히 Java 코드를 실행시켜주는 놈이라고 생각하자.</li>\n  <li>WAS(Tomcat)는 Java로 작성된 웹 애플리케이션을 실행하는 컨테이너이므로,<br />\nWAS도 JVM 위에서 동작한다.</li>\n</ul>\n\n<details>\n<summary>JVM 이란?</summary>\nApache HTTP Server (보통 Apache라고 부름)\n<ul>\n    <li>JVM은 JVM은 Java 바이트코드(.class 파일)를 해석하고 실행하는 가상 머신</li>\n    <li>JRE는 Java 프로그램을 실행하는 데 필요한 모든 것을 포함한다. 라이브러리 등</li>\n        <ul>\n            <li><em>JRE은 JVM을 시작, 필요한 클래스 라이브러리 로드, main() 메서드를 실행한다.</em></li>\n        </ul>\n    <li>JDK는 Java 애플리케이션을 개발하는 데 필요한 모든 도구를 포함한다.</li>\n</ul>\n</details>\n\n<p><br /></p>\n\n<h2 id=\"servlet-container-tomcat\">Servlet Container [Tomcat]</h2>\n\n<p>위에서 “Tomcat은 <strong><u>Servlet Container의 한 종류</u></strong>이며, <strong><u>Servlet/JSP 요청을 처리</u></strong>하는 역할을 한다.” 라고 했다.</p>\n\n<p>1) <strong>Servlet Container</strong>는 Servlet<strong>의 생명 주기</strong>를 관리하는 곳이다.</p>\n<ul>\n  <li>Servlet과 Servlet Container의 관계를 Bean과 Bean Container의 관계와 흡사하다고 생각하면 된다. (“컨테이너와 관리 대상”의 관계로 이해)\n    <ul>\n      <li>Servlet Container는 HTTP 요청과 응답을 처리하는 Servlet을 관리</li>\n      <li>Bean Container는 Spring의 <strong>애플리케이션 내 객체(Bean)</strong>의 생명 주기와 의존성을 관리</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2) 또한, <strong>HTTP 요청 처리 및 응답 생성 과정</strong>은 Servlet Container의 핵심 기능 중 하나이다.</p>\n<ul>\n  <li>웹 브라우저에서 요청이 들어오면, Tomcat은 그 요청을 받아서 적절한 Java 코드(서블릿)로 전달하고, 그 결과를 다시 브라우저로 보내는 역할을 한다.</li>\n</ul>\n\n<p><br /></p>\n\n<h2 id=\"servlet\">Servlet</h2>\n\n<p>Servlet은 <strong>HTTP 요청을 처리하고 응답을 생성하는 스펙을 정의한 인터페이스</strong>이다.</p>\n<ul>\n  <li>Servlet은 <strong>jakarta.servlet.Servlet</strong>을 최상위 인터페이스로 가진다. (Java API)</li>\n</ul>\n\n<p>Servlet은 <strong>Servlet Container</strong>에 의해 관리되며, 요청이 들어오면 컨테이너가 Servlet의 생명 주기를 관리하고 요청을 처리하기 위한 스레드를 생성한다.</p>\n\n<p>Servlet은 HTTP 요청을 처리하고, 그에 따른 적절한 응답을 생성하는 기본 단위이다. 이를 통해 <span class=\"post-highlight\">REST API의 엔드포인트</span>가 되거나 <span class=\"post-highlight\">동적 웹 페이지를 생성</span>하는 역할을 수행할 수 있다.</p>\n\n<ol>\n  <li>Servlet은 HTTP 요청을 받아 비즈니스 로직을 처리하고 JSON, XML 등의 형식으로 데이터를 응답할 수 있다.</li>\n  <li>동적인 HTML 콘텐츠를 생성할 때도 사용된다.\n    <ul>\n      <li>예를 들어, 비즈니스 로직 처리가 필요한 HTTP 요청이 Web Server로 들어오면, Web Server는 이를 Servlet Container가 실행하는 Servlet에 전달한다.</li>\n      <li>Servlet은 요청을 처리하고 동적인 웹 콘텐츠를 생성한 뒤, 결과를 Web Server를 통해 클라이언트로 반환한다.</li>\n    </ul>\n  </li>\n</ol>\n\n<p>전체적인 통신 흐름은 다음과 같다.</p>\n<ul>\n  <li>WS 는 HTTP 요청을 받아 정적 리소스를 처리하거나, 요청을 WAS에 전달한다.</li>\n  <li>WAS는 Servlet Container를 통해 요청을 처리하고, 처리 결과를 Web Server를 거쳐 클라이언트에 반환한다.</li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/06d2213c-0f90-4a1b-a765-33531aeed39d\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p><br /></p>\n\n<h3 id=\"servlet의-생명주기\">Servlet의 생명주기</h3>\n\n<p>위 그림을 보면 알 수 있듯, Servlet은 다음과 같은 생명 주기를 가진다.</p>\n\n<p>1) <strong>초기화 단계</strong>:</p>\n<ul>\n  <li>최초 요청이 오면 Servlet 클래스(HelloServlet.class)가 로딩된다.</li>\n  <li>web.xml 설정을 참고하여 매핑할 Servlet을 확인한다.</li>\n  <li><span class=\"post-highlight\">해당 Servlet 인스턴스가 있다면 사용하고, 없다면 init()으로 초기화한다.</span></li>\n</ul>\n\n<p>2) <strong>서비스 단계</strong>:</p>\n<ul>\n  <li>Servlet Container는 각 요청마다 새로운 스레드를 생성한다.</li>\n  <li>새로운 Request/Response 객체를 생성하여 service() 메서드를 실행한다.</li>\n  <li>service()는 요청 방식(GET, POST 등)에 따라 적절한 do메서드를 호출한다.</li>\n  <li>요청 처리가 완료되면 해당 Request/Response 객체는 소멸된다.</li>\n</ul>\n\n<p>3) <strong>소멸 단계</strong>:</p>\n<ul>\n  <li><em>서버 종료나 애플리케이션 재배포 시에만 destroy()가 호출된다.</em></li>\n  <li><em>Servlet이 사용하던 리소스를 정리한다.</em></li>\n</ul>\n\n<p><br /></p>\n\n<p>정리하자면,</p>\n<ul>\n  <li>Tomcat은 Servlet 객체를 한 번 생성하면 메모리에 유지하고, 요청이 올 때마다 해당 객체의 <strong>service()</strong> 메서드를 호출한다.</li>\n  <li>따라서, <strong>init()</strong> 메서드는 <strong>최초 요청 시(또는 설정에 따라 애플리케이션 시작 시)</strong> 단 한 번 실행된다.</li>\n  <li>또 종료되기 전이나 reload 전에 destroy()를 호출하여 매번 객체가 생성되는 것을 방지한다.</li>\n</ul>\n\n<p><strong>(🤔 궁금증) servlet은 왜 생성만 하고 제거는 안하지?</strong>\n만약 사용이 끝날 때마다 제거한다면 다음과 같은 문제가 있다.</p>\n<ul>\n  <li>모든 요청에 대해 servlet을 생성하고 소멸하는 것은 OS 와 JVM 에게 필요없는 부하를 일으킨다.\n    <ul>\n      <li>JVM의 <strong>Garbage Collection</strong>과 <strong>메모리 할당/해제</strong>를 빈번하게 유발</li>\n    </ul>\n  </li>\n  <li>동시에 다수의 요청이 들어올 경우 CPU 또는 메모리 리소스 소모에 대한 제한이 어렵다. \n결국 순간적으로 서버가 다운되거나 동시 처리에 문제가 생길 수 있다.\n    <ul>\n      <li><em>(참고로 Tomcat 3.2 이전 버전은 실제 매번 생성과 제거를 했다.)</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p><strong>(✨해결) 해답은 Servlet의 특징과 관리 방식에 있다.</strong></p>\n<ul>\n  <li>수많은 클라이언트의 요청을 동시에 처리해야 하는 WAS의 특성상,\nServlet은 싱글톤 패턴으로 관리하게 되었다.\n    <ul>\n      <li>한 번 생성된 Servlet 인스턴스는 메모리에 계속 유지된다.</li>\n      <li>모든 요청은 동일한 Servlet 인스턴스를 공유한다.</li>\n      <li>init()은 최초 요청 시 한 번만 실행된다.</li>\n      <li>destroy()는 서버 종료나 재배포 시에만 실행된다.</li>\n    </ul>\n  </li>\n  <li><em>(Tomcat 3.2 부터는 디폴트로 <span class=\"post-highlight\">싱글톤 패턴 도입</span>와 <span class=\"post-highlight\">Thread Pool</span> 을 사용)</em></li>\n</ul>\n\n<p><br /></p>\n\n<h1 id=\"servlet-처리-구조의-발전\">Servlet 처리 구조의 발전</h1>\n\n<h2 id=\"기존-servlet-처리-방식\">기존 Servlet 처리 방식</h2>\n\n<p>Tomcat은 다음과 같은 역할을 한다고 하였다.</p>\n<ul>\n  <li>Servlet Container로서 HTTP 요청과 응답을 처리하는 환경 제공</li>\n  <li>Servlet 객체의 생성, 초기화, 요청 처리, 소멸 등 <strong>생명주기를 관리</strong>하는 역할</li>\n</ul>\n\n<p><strong>(🤔 문제점) Servlet은 요청마다 개별적으로 처리 로직을 구현해야 하므로,</strong><br />\n<strong>비슷한 요청을 처리하는 여러 Servlet에서 <span class=\"post-highlight\">중복된 코드가 발생</span>할 수 있다.</strong></p>\n\n<p><img src=\"https://github.com/user-attachments/assets/7c5e684e-cd0f-4167-8e55-f3d24172f58e\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 기존 서블릿 방식 - 각 URL마다 서블릿을 따로 만들어야 했습니다</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserServlet</span> <span class=\"kd\">extends</span> <span class=\"nc\">HttpServlet</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">doGet</span><span class=\"o\">(</span><span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"nc\">HttpServletResponse</span> <span class=\"n\">response</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 로깅 처리</span>\n        <span class=\"c1\">// 인증 처리</span>\n        <span class=\"c1\">// 공통 에러 처리</span>\n        <span class=\"c1\">// 실제 비즈니스 로직</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProductServlet</span> <span class=\"kd\">extends</span> <span class=\"nc\">HttpServlet</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">doGet</span><span class=\"o\">(</span><span class=\"nc\">HttpServletRequest</span> <span class=\"n\">request</span><span class=\"o\">,</span> <span class=\"nc\">HttpServletResponse</span> <span class=\"n\">response</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 위와 동일한 로깅, 인증, 에러 처리 코드가 반복됨</span>\n        <span class=\"c1\">// 실제 비즈니스 로직</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>이러한 방식은 다음과 같은 문제가 있다.</p>\n<ol>\n  <li>하나의 서블릿 클래스에 너무 많은 책임이 집중된다.</li>\n  <li>URL 매핑, 파라미터 처리, 뷰 선택 등을 모두 수동으로 처리해야 함</li>\n  <li>모든 서블릿에서 공통 로직(로깅, 인증, 에러 처리 등)이 반복됨</li>\n  <li>각각의 서블릿을 web.xml에 일일이 등록해야 함<br />\n (web.xml : 웹 애플리케이션의 <strong>구성 정보</strong>를 제공)</li>\n</ol>\n\n<ul>\n  <li>과거 web.xml은 다음과 같은 중요한 정보들을 담고 있었다.\n    <ul>\n      <li>어떤 서블릿이 존재하는지</li>\n      <li>각 서블릿이 어떤 URL 패턴을 처리하는지</li>\n      <li>어떤 필터들이 요청을 처리하는지</li>\n      <li>웹 애플리케이션의 시작과 종료 시 필요한 리스너는 무엇인지</li>\n    </ul>\n  </li>\n</ul>\n\n<p>⇒ 각 서블릿(요청을 처리하는 클래스)에 대한 정보를 등록해야 한다는 것이다… 😢</p>\n\n<p><br /></p>\n\n<h2 id=\"dispatcherservlet---spring-mvc--공통-로직의-중앙-집중화\"><strong>DispatcherServlet</strong> - Spring MVC : 공통 로직의 중앙 집중화</h2>\n\n<p><strong>(✨ 해결책) 공통 로직의 중앙 집중화</strong></p>\n\n<p>Spring Framework는 기존 서블릿 스펙의 장점을 활용하면서도 그 한계를 개선하는 방향으로 발전했다.</p>\n\n<p><span class=\"post-highlight\">DispatcherServlet이라는 Front Controller를 사용해 공통 로직을 처리하고 요청에 맞는 컨트롤러를 호출하는 특수한 Servlet</span>을 만들어 새로운 구조를 도입했다.</p>\n\n<ul>\n  <li><em>참고로 <strong>DispatcherServlet</strong> 도 <strong>Servlet이다.</strong></em>\n    <ul>\n      <li><em>(이쯤에서 Spring에서의 Controller의 역할이 아구 맞게 떠오른다.)</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p><img src=\"https://github.com/user-attachments/assets/945895b9-66a2-4713-b7a4-8461f3a66075\" alt=\"Image\" width=\"80%\" height=\"100%\" class=\"center\" /></p>\n\n<p>Spring MVC는 이러한 문제를 DispatcherServlet이라는 하나의 Front Controller로 해결했다.</p>\n\n<ul>\n  <li><em>이제 우리가 아는 친숙한 코드가 나온다….</em></li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Spring MVC 방식</span>\n<span class=\"nd\">@Controller</span>  <span class=\"c1\">// 더 이상 HttpServlet을 상속할 필요가 없음</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserController</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@GetMapping</span><span class=\"o\">(</span><span class=\"s\">\"/users\"</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">handleUsers</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 비즈니스 로직에만 집중</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"userList\"</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"nd\">@Controller</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProductController</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@GetMapping</span><span class=\"o\">(</span><span class=\"s\">\"/products\"</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">handleProducts</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 비즈니스 로직에만 집중</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"productList\"</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p><strong>DispatcherServlet</strong>은 다음과 같은 일을 한다.</p>\n\n<ol>\n  <li><strong>DispatcherServlet</strong>은 웹 애플리케이션에 들어오는 모든 HTTP 요청을 먼저 받는다.</li>\n  <li>요청을 <strong>어떤 컨트롤러가 처리할지 결정</strong>하고, 해당 컨트롤러로 요청을 <strong>디스패치(위임)</strong> 한다.</li>\n  <li>요청에 대해 <strong>공통 처리</strong>(예: 인증, 로깅 등)를 먼저 한 후, 적절한 컨트롤러로 요청을 전달한다.</li>\n  <li><strong>DispatcherServlet</strong> 덕분에, 이제 다른 컨트롤러는 굳이 서블릿을 상속할 필요가 없다.</li>\n</ol>\n\n<p>4번에 대해 추가 설명을 하자면, <strong>Spring MVC</strong>에서는 <strong>DispatcherServlet</strong>만 서블릿으로 등록하고, 실제 비즈니스 로직을 처리하는 <strong>컨트롤러</strong>는 <strong>서블릿</strong>이 아니어도 된다는 뜻이다.</p>\n\n<ul>\n  <li><strong>Spring MVC</strong>에서는 <strong>DispatcherServlet</strong>만 서블릿으로 등록하고, 실제 비즈니스 로직을 처리하는 <strong>컨트롤러</strong>는 <strong>서블릿</strong>이 아니어도 된다는 뜻이다.</li>\n  <li>Spring MVC의 <strong>컨트롤러</strong>는 단순한 <strong>자바 클래스</strong>로, <strong>@Controller</strong> 어노테이션을 붙인 클래스를 만들어 요청을 처리할 수 있다.</li>\n  <li>이때, <strong>컨트롤러 클래스는 Servlet을 상속하지 않아도</strong> 된다.</li>\n  <li><strong>DispatcherServlet</strong>이 모든 요청을 처리하고, 요청을 <strong>컨트롤러</strong>로 전달하기 때문에, 실제로는 <strong>서블릿이 아닌 컨트롤러</strong>가 <strong>Servlet 객체를 상속</strong>하지 않아도 된다는 뜻이다.</li>\n</ul>\n\n<p>이렇듯 Spring 프레임워크는 Front Controller를 제공해주고 이를 Dispather Servlet 이라 부른다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/f5b5a218-c501-43c6-8869-c0ccd63acc77\" alt=\"Image\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<p><br /></p>\n\n<h2 id=\"servlet과-dispatcherservlet의-역할-분담의-의의\"><strong>Servlet</strong>과 DispatcherServlet의 역할 분담의 의의</h2>\n\n<p>Servlet 표준에서 중요한 점은 Servlet이 <span class=\"post-highlight\">전체 데이터 처리 과정에서 특정한 역할만 수행</span>한다는 것이다.</p>\n\n<p><strong><u>전통적인 서블릿 방식</u></strong>에서는 HTTP 요청/응답 처리부터 비즈니스 로직까지 모든 것을 책임져야했다.</p>\n\n<p>변화한 Spring MVC 구조에는 다음과 같은 장점이 있다.</p>\n\n<p>1) <strong>관심사의 분리(Separation of Concerns)</strong></p>\n<ol>\n  <li>DispatcherServlet이 모든 HTTP 요청을 먼저 받아서 적절한 Controller로 라우팅하는 역할을 담당하게 되었다.</li>\n  <li>이로 인해 Controller는 비즈니스 로직에만 집중할 수 있게 되었다.</li>\n</ol>\n\n<p>2) <strong>POJO(Plain Old Java Object) 기반 개발</strong></p>\n<ol>\n  <li>Controller가 더 이상 HttpServlet을 상속받지 않아도 된다는 것은 매우 중요한 의미를 가진다.</li>\n  <li>이는 일반적인 자바 클래스로 웹 개발이 가능해졌다는 뜻이다.</li>\n</ol>\n\n<p>3) <strong>각 엔드포인트가 명확하게 분리된다.</strong></p>\n\n<p><br /></p>\n\n<p>⇒ Spring Boot는 이러한 통합을 더욱 단순화했다.</p>\n\n<p>개발자는 복잡한 설정 없이도 Tomcat과 Spring이 자연스럽게 협력하는 환경에서 개발할 수 있게 되었다.</p>\n\n<p>web.xml 없이도 자동 구성을 통해 모든 것이 가능해졌다.</p>\n\n<p><em>@SpringBootApplication 어노테이션은 다음 3가지 핵심 어노테이션의 조합이다.</em></p>\n\n<ol>\n  <li>@SpringBootConfiguration</li>\n  <li><span class=\"post-highlight\">@EnableAutoConfiguration</span> [자동 구성]</li>\n  <li>@ComponentScan</li>\n</ol>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@SpringBootApplication</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">MyApplication</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// Spring Boot가 내장 Tomcat을 자동으로 구성하고 시작</span>\n        <span class=\"nc\">SpringApplication</span><span class=\"o\">.</span><span class=\"na\">run</span><span class=\"o\">(</span><span class=\"nc\">MyApplication</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">,</span> <span class=\"n\">args</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>즉, 현대에 와서 <strong>DispatcherServlet이 서블릿 역할을 하면서</strong> 요청을 <strong>Controller</strong>에 전달하고, <strong>Controller</strong>는 <strong>서비스</strong>를 호출하여 실제 비즈니스 로직을 처리하게 하는 방식으로 발전하였다.</p>\n\n<ul>\n  <li>단지 <strong>DispatcherServlet</strong>은 요청을 받아서 적절한 컨트롤러에게 넘겨주는 역할을 한다.</li>\n</ul>\n\n<p>지금까지 살펴본 WAS의 발전 과정을 보면 다음과 같다.</p>\n<ol>\n  <li>WAS는 동적 컨텐츠 처리를 위한 웹 애플리케이션 서버로 분리되며 시작됐다.</li>\n  <li>Tomcat은 Servlet Container로서 Java 기반 웹 애플리케이션을 실행시킨다.</li>\n  <li>초기 Servlet 방식의 한계(중복 코드, 복잡한 설정)를 Spring MVC가 해결했다.</li>\n  <li>DispatcherServlet의 도입으로 공통 로직 처리와 요청 위임이 체계화되었다.</li>\n</ol>\n\n<p>결국 DispatcherServlet이 모든 요청을 받아 적절한 Controller에 위임하므로\nController는 순수 비즈니스 로직에만 집중할 수 있게 되었다.</p>\n<ul>\n  <li>개발자는 반복적인 설정 없이 핵심 기능 개발에 집중 가능!</li>\n</ul>\n\n<p>이처럼 WAS와 Servlet, 그리고 Spring MVC로 이어지는 발전 과정은 더 나은 웹 개발 환경을 만들어왔다.</p>\n\n<p>더 나아가, 웹 애플리케이션 아키텍처는 계속해서 진화하고 있다.</p>\n<ul>\n  <li>Spring WebFlux를 통한 리액티브 프로그래밍 도입</li>\n  <li>클라우드 네이티브 환경 지원</li>\n  <li>마이크로서비스 아키텍처로의 전환</li>\n  <li>서버리스 아키텍처의 등장</li>\n</ul>\n",
                        "tags": ["WAS","Tomcat","Servlet","SpringMVC","Java","WebDevelopment","Architecture","DispatcherServlet","SpringBoot"]
                    }
                
            ],
        
            "PacketTracer": [
                
                    {
                        "title": "Packet Tracer로 네트워크 이해하기",
                        "url": "/2025/02/08/packet-tracer-network.html",
                        "subtitle": "LAN 토폴로지, 스위치, 라우터, 방화벽",
                        "excerpt": "LAN 토폴로지와 스위치\n",
                        "author": "Jinho",
                        "date": "February 08, 2025",
                        "background": "/img/posts/network_topology.jpeg",
                        "content": "<h1 id=\"lan-토폴로지와-스위치\">LAN 토폴로지와 스위치</h1>\n\n<hr />\n\n<h2 id=\"packet-tracer에-들어가기-전\">Packet Tracer에 들어가기 전</h2>\n\n<p>먼저 네트워크의 기본 구성 요소부터 이해해보자.</p>\n\n<p><strong>라우터, 스위치, 엔드 디바이스(PC, 서버 등)가 어떻게 상호 작용</strong>하는지 알아보자.</p>\n\n<ul>\n  <li>가장 기본적인 두 대의 디바이스(<code class=\"language-plaintext highlighter-rouge\">PC</code>)가 있다고 가정해보자.</li>\n  <li>두 PC를 연결하고, IP 주소 설정, 서브넷 마스크 설정을 하고 ping 테스트를 통해 연결.\n    <ul>\n      <li>이 과정에서 TCP/IP의 기본 개념을 이해해보자.</li>\n    </ul>\n  </li>\n  <li>그 다음 단계로 <code class=\"language-plaintext highlighter-rouge\">스위치</code>를 추가하여 여러 대의 <code class=\"language-plaintext highlighter-rouge\">PC</code>를 연결.\n    <ul>\n      <li>L2 통신의 개념과 MAC 주소의 역할을 이해해보자.</li>\n    </ul>\n  </li>\n  <li>마지막으로 <code class=\"language-plaintext highlighter-rouge\">라우터</code>를 추가하여 서로 다른 네트워크 간의 통신을 구현.\n    <ul>\n      <li>라우팅 테이블, 게이트웨이 등의 개념을 학습해보자.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"사용법\">사용법</h2>\n\n<h2 id=\"pc\">PC</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@tdMGa/btsMchWsAbo/pXUJ5sc1Jn5zlePiDz1mrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:264,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>장치 타입 → End Devices → PC / LAPTOP 등 Drag &amp; Drop</li>\n</ul>\n\n<h2 id=\"switch\">Switch</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bdJ1mb/btsMedLRoGJ/cpMkbVJahG5gP3qwnew9Uk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:194,”originHeight”:256,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"router\">Router</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@A02nQ/btsMeKJcj9q/usIeZ7q3BDrYQHVk4TpOuk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:208,”originHeight”:276,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"connection\">Connection</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@rOlnO/btsMdkEVmv0/U1xgvAbp826OCElZjbp2Sk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:280,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>실선은 Copper Straight [PC - Switch/Router]</li>\n  <li>점선은 Copper Cross - Over [Switch/Router … Switch/Router]</li>\n  <li>번개 모양은 Automatic</li>\n</ul>\n\n<h2 id=\"기본-사용-방법\">기본 사용 방법</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@mamWH/btsMdM8WmZV/J6Eve21yZP8cKJkdv8KQrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:666,”originHeight”:558,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>장치(PC 와 Laptop)들을 놓는다.</li>\n  <li>각 디바이스 개수만큼 연결한 스위치 추가</li>\n  <li>실선과 점선으로 연결</li>\n  <li>스위치 0 → 메뉴에서 FastEthernet0/1 선택</li>\n  <li>PC 0 → 메뉴에서 FastEthernet0 선택</li>\n  <li>(나머지도 동일하게 연결)</li>\n  <li>왼쪽 스위치 : <code class=\"language-plaintext highlighter-rouge\">FastEthernet0/2</code> 오른쪽 스위치 : <code class=\"language-plaintext highlighter-rouge\">FastEthernet0/3</code></li>\n  <li>PC 클릭 → Desktop → IP Configuration → IP Address에 <code class=\"language-plaintext highlighter-rouge\">198.168.0.1</code><br />\nSubnet Mask에 <code class=\"language-plaintext highlighter-rouge\">255.255.255.0</code>\n    <ul>\n      <li>나머지 장치는 IP 주소 ~0.2, ~0.3 순으로 입력</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dhy2rZ/btsMczo0VIn/LHz5KS8UijOguFkFqLdSSk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:338,”style”:”alignCenter”,”width”:780,”height”:206}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Desktop → Command Prompt로 ping 테스트</li>\n  <li>작업 공간에서 Simulation 가능 [실제 이동 경로 &amp; 헤더 정보 등을 볼 수 있다.]</li>\n</ul>\n\n<h2 id=\"lan-topology\">LAN Topology</h2>\n\n<ul>\n  <li>같은 로컬 에이리어 네트워크 (LAN) 내에서 네트워크 장비와 디바이스들이 어떻게 물리적 혹은 논리적으로 연결되어 있는지 나타내는 구조</li>\n</ul>\n\n<h2 id=\"lan과-wan\">LAN과 WAN</h2>\n\n<ul>\n  <li><strong>LAN (로컬 영역 네트워크)</strong>:\n    <ul>\n      <li>제한된 지역 내에서 연결된 네트워크</li>\n      <li><strong>스위치</strong>는 MAC 주소를 사용하여 네트워크 내 장치들 간에 데이터를 전달합니다. 스위치는 <strong>MAC 주소 테이블</strong>을 사용해 데이터를 해당 장치로 정확하게 전달</li>\n    </ul>\n  </li>\n  <li><strong>WAN (광역 네트워크)</strong>:\n    <ul>\n      <li>더 넓은 지역, 심지어 전 세계적으로 연결된 네트워크\n        <ul>\n          <li>인터넷이 대표적인 WAN 예시</li>\n        </ul>\n      </li>\n      <li>WAN에서는 서로 MAC 주소를 알 수 없음</li>\n      <li>WAN에서 라우터는 <strong>IP 주소</strong>를 기반으로 데이터를 전달하는데, 각 네트워크 간의 경로를 찾기 위해 <strong>라우팅 테이블</strong>을 사용\n        <ul>\n          <li>NAT / PAT</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cyma1b/btsMcdGGX7j/3HjkxSXXuguLBaXiMCtKp1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:933,”style”:”alignCenter”,”width”:757,”height”:552}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"1-bus-형\">1) Bus 형</h2>\n\n<ul>\n  <li>하나의 메인 케이블(백본)에 모든 노드가 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>구조가 단순하고 설치 비용이 저렴</li>\n      <li>노드 추가/제거가 쉽고 유연함</li>\n      <li>케이블 길이가 짧아 경제적</li>\n      <li>소규모 네트워크에 적합</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>트래픽 증가 시 성능 저하</li>\n      <li>메인 케이블 장애 시 전체 영향</li>\n      <li>데이터 충돌 발생 가능</li>\n      <li>보안 취약점 존재</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cdwQWE/btsMctoZGjP/YoLinRs4T7sWM3Iv3xCkfK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1138,”originHeight”:650,”style”:”alignCenter”,”width”:690,”height”:394}_#][#_Image</td>\n      <td>kage@XghRi/btsMc2doIc4/cDKKGHIAwzkFizYIthmvX1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:978,”originHeight”:456,”style”:”alignCenter”,”width”:620,”height”:289}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"2-ring-형\">2) Ring 형</h2>\n\n<ul>\n  <li>각 노드가 양옆의 두 노드와 연결되어 원형을 이루는 구조</li>\n  <li>자동선택 기능을 사용한 링</li>\n  <li>장점 :\n    <ul>\n      <li>데이터 흐름이 일정하고 예측 가능</li>\n      <li>충돌이 적고 전송이 안정적</li>\n      <li>각 노드가 리피터 역할 수행</li>\n      <li>장거리 전송에 유리</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>단일 노드 장애가 전체에 영향</li>\n      <li>네트워크 확장이 제한적</li>\n      <li>설치/제거 시 네트워크 중단</li>\n      <li>양방향 링 구성 시 비용 증가</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@lYUdr/btsMetVb0e8/23KtOkSs1PeRKuNml0S2AK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1108,”originHeight”:642,”style”:”alignCenter”,”width”:598,”height”:346}_#][#_Image</td>\n      <td>kage@rYlFs/btsMeKWHZEC/wFs32hn23rG7rKA9WFyKxK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:982,”originHeight”:460,”style”:”alignCenter”,”width”:621,”height”:291}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"3-star-형\">3) Star 형</h2>\n\n<ul>\n  <li>중앙에 허브가 있고 모든 노드가 이 허브에 직접 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>구현과 유지보수가 단순하고 직관적</li>\n      <li>개별 노드 장애가 다른 노드에 영향 없음</li>\n      <li>높은 성능과 데이터 전송 속도</li>\n      <li>중앙 집중적 보안 관리 용이</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>중앙 허브 장애 시 전체 네트워크 마비 - 단일 장애 지점 (SPOF)</li>\n      <li>허브에 과부하 발생 가능</li>\n      <li>케이블 설치 비용이 높음</li>\n      <li>허브 용량에 따른 확장성 제한</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@NJ0T7/btsMdF26Hzf/aEmXKMDwoG1TwsmUekA04K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1088,”originHeight”:678,”style”:”alignCenter”,”width”:627,”height”:391}_#][#_Image</td>\n      <td>kage@vFDga/btsMcTgvpqn/IDhAPb27H9xt3kN9pDOB7k/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:456,”style”:”alignCenter”,”width”:585,”height”:277}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"4-mesh-형\">4) Mesh 형</h2>\n\n<ul>\n  <li>모든 노드가 서로 직접 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>높은 안정성과 이중화 구성</li>\n      <li>효율적인 트래픽 분산</li>\n      <li>우회 경로 확보로 신뢰성 높음</li>\n      <li>뛰어난 보안성</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>설치/유지보수 비용이 매우 높음</li>\n      <li>구현과 설정이 매우 복잡</li>\n      <li>케이블 연결 관리가 어려움</li>\n      <li>노드 수 증가에 따른 복잡도 급증</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bb9BX4/btsMeahgXHL/gVJ4LgKjyCG8M1I6DkkbP0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1070,”originHeight”:674,”style”:”alignCenter”,”width”:628,”height”:396}_#][#_Image</td>\n      <td>kage@ovOWb/btsMb2rFLwg/Qi0orK06gCRkfnrkBXhvyK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:432,”style”:”alignCenter”,”width”:677,”height”:303}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"5-tree-형\">5) Tree 형</h2>\n\n<ul>\n  <li>계층적 구조로, 상위 노드에서 하위 노드로 분기되는 형태</li>\n  <li>장점 :\n    <ul>\n      <li>네트워크 확장이 용이</li>\n      <li>체계적인 계층 구조 관리</li>\n      <li>하위 네트워크 독립성</li>\n      <li>효율적인 트래픽 관리</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>루트 노드 장애 시 전체 영향</li>\n      <li>계층 증가에 따른 관리 복잡성</li>\n      <li>상위 노드 병목 현상 가능</li>\n      <li>깊이가 깊어질수록 지연 증가</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@wounf/btsMcywRCH9/2KnaYgagHLQKp4cBdcumy0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:985,”style”:”alignCenter”,”width”:765,”height”:589}_#][#_Image</td>\n      <td>kage@dI6An5/btsMd4hh7vI/Gxr1Nv7uKXeDV0vrZs1qT0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:960,”originHeight”:458,”style”:”alignCenter”,”width”:642,”height”:306}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>192.168.0.1 to 192.168.0.12</li>\n</ul>\n\n<h2 id=\"vlanvirtual-lan-case-1--switch-1개\">VLAN(Virtual LAN) (case 1 : Switch 1개)</h2>\n\n<h2 id=\"vlan이란\">VLAN이란?</h2>\n\n<p>“<strong>논리적인 구조의 속임수로 같은 물리적 공간에 있는 네트워크를 다른 네트워크에 있는 것처럼 속이는 기술</strong>”</p>\n\n<ul>\n  <li>먼저, 물리적인 LAN을 먼저 생각해보면, 같은 건물이나 같은 층에 있는 컴퓨터들이 하나의 네트워크로 연결되어 있는 구조이다.</li>\n  <li>그런데 예를 들면, 마케팅팀과 개발팀이 다른 네트워크에 있어야 한다고 가정해보자.\n    <ul>\n      <li>전통적인 방식이라면 물리적으로 별도의 네트워크 장비와 케이블을 설치해야 했다.</li>\n      <li>하지만, VLAN은 이런 물리적 제약을 소프트웨어적으로 해결한다.</li>\n    </ul>\n  </li>\n  <li>하나의 물리적인 스위치를 마치 여러 개의 독립된 스위치처럼 동작하게 만드는 기술이다.</li>\n  <li>예를 들어, 같은 스위치에 연결된 컴퓨터라도 서로 다른 VLAN에 속하면 마치 다른 네트워크에 있는 것처럼 통신이 분리된다.</li>\n</ul>\n\n<h2 id=\"초기-default-vlan-설정\">초기 default VLAN 설정</h2>\n\n<ul>\n  <li>show vlan으로 확인해보자.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bTHrGF/btsMea2FcPL/VagNQtcNTnfvH7OWzcKevk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1250,”originHeight”:974,”style”:”alignCenter”,”width”:670,”height”:522}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>처음 VLAN 1은 ‘기본 VLAN’이다.</li>\n  <li>모든 스위치 포트는 처음에 이 VLAN 1에 속하도록 설정되어 있다.\n    <ul>\n      <li>그래서 별다른 설정 없이는 같은 물리적인 공간에 있다면 한 네트워크에 속하도록 설정이 된다.</li>\n    </ul>\n  </li>\n  <li>그리고 VLAN 1002부터 1005까지는 특별한 목적으로 예약된 VLAN이다. (사용 불가)\n    <ul>\n      <li>FDDI, 토큰링 등으로 고정되어 있다.</li>\n    </ul>\n  </li>\n  <li>우리가 새로운 VLAN을 할당하려고 하면 “2 ~ 1001” 의 VLAN을 사용해서 나누면 된다.</li>\n</ul>\n\n<h2 id=\"vlan-구성하기\">VLAN 구성하기</h2>\n\n<ul>\n  <li>먼저 VLAN 2개를 생성한다.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch#enable\nSwitch#config terminal\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#vlan 2\nSwitch(config-if)#name VLAN_2\nSwitch(config-if)#exit\n</code></pre></div></div>\n\n<ul>\n  <li>enable : 관리자 모드 진입</li>\n  <li>config terminal : 글로벌 모드 진입</li>\n  <li>vlan 2 : vlan 모드 진입</li>\n  <li>name <이름> : 진입되어 있는 vlan의 이름 설정</이름></li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dsQlbd/btsMdqdX0ps/kPhix6BIWT0KDKtVJzq3NK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1185,”originHeight”:1000,”style”:”alignCenter”,”width”:734,”height”:619}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>결과</p>\n\n<ul>\n  <li>그리고, <code class=\"language-plaintext highlighter-rouge\">VLAN_2</code>엔 <code class=\"language-plaintext highlighter-rouge\">Fa0/1</code> 과 <code class=\"language-plaintext highlighter-rouge\">Fa0/2</code>, <code class=\"language-plaintext highlighter-rouge\">VLAN_3</code>엔 <code class=\"language-plaintext highlighter-rouge\">Fa0/3</code> 과 <code class=\"language-plaintext highlighter-rouge\">Fa0/4</code> 포트를 배정시킨다.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch#enable\nSwitch#config terminal\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#interface fa0/1\nSwitch(config-if)#switchport mode access\nSwitch(config-if)#switchport access vlan 2\n</code></pre></div></div>\n\n<ul>\n  <li>inteface fa0/1 : 인터페이스 모드 진입</li>\n  <li>switchport mode access : 해당 포트를 VLAN 전용으로 사용함을 선언</li>\n  <li>switchport access vlan 2 : 해당 포트가 속한 VLAN 번호 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@GEPhJ/btsMcd0ZUA9/NJfHXH7fr603Pozrp0XUN1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:779,”style”:”alignCenter”,”width”:697,”height”:424,”caption”:”결과”}_#][#_Image</td>\n      <td>kage@ZktHy/btsMceFDArB/GmkkKk7xrFmJK5XI7GNxS1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:975,”style”:”alignCenter”,”width”:686,”height”:523}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"vlan-통신-테스트\">VLAN 통신 테스트</h2>\n\n<ol>\n  <li><code class=\"language-plaintext highlighter-rouge\">192.168.0.1</code> to <code class=\"language-plaintext highlighter-rouge\">192.168.0.2</code>\n    <ul>\n      <li>같은 VLAN 내에서는 통신 가능</li>\n    </ul>\n  </li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@BqqF9/btsMceevW1X/38cHtm9y7VtBM8yRsEMKb1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:742,”originHeight”:340,”style”:”alignCenter”,”width”:653,”height”:299}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li><code class=\"language-plaintext highlighter-rouge\">192.168.0.1</code> to <code class=\"language-plaintext highlighter-rouge\">192.168.0.2</code></li>\n</ol>\n\n<ul>\n  <li>다른 VLAN 끼리는 통신 불가능</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@905VT/btsMcKD1XhO/HVQpVtHJXEQCpfTAUkHWYk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1060,”originHeight”:502,”style”:”alignCenter”,”width”:668,”height”:316}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"vlanvirtual-lan-case-2--switch-여러-개\">VLAN(Virtual LAN) (case 2 : Switch 여러 개)</h2>\n\n<ul>\n  <li>그렇다면 네트워크를 확장하고 좀 더 현실적인 아키텍쳐로 바뀌면 어떨까?</li>\n  <li>먼저 Switch를 하나 더 두어보자.</li>\n  <li><em>들어가기전</em>\n    <ul>\n      <li>VLAN 설정 자체는 IP 주소를 직접 변경하지 않는다.\n        <ul>\n          <li>VLAN은 Layer 2(데이터 링크 계층)에서 작동하는 반면,<br />\nIP 주소는 Layer 3(네트워크 계층)에서 작동하기 때문.</li>\n        </ul>\n      </li>\n      <li>그러나, 실제 네트워크 운영에서는 일반적으로 각 VLAN마다 서로 다른 IP 대역을 할당한다.\n        <ul>\n          <li>네트워크 관리와 보안을 위한 설계</li>\n        </ul>\n      </li>\n      <li>그러므로 VLAN 별로 다른 대역을 할당해보자.\n        <ul>\n          <li>VLAN 2: 203.237.20.nnn</li>\n          <li>VLAN 3: 203.237.30.nnn</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@pcw1H/btsMc0NoTlz/v9c56wkkpb2qWxKk6BEsq0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1031,”originHeight”:1000,”style”:”alignCenter”,”width”:680,”height”:660}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 0 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@d5TDWZ/btsMekcZbAx/1meC8Kjg2Niht4JKNpWjE1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:325,”style”:”alignCenter”,”width”:757,”height”:192}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 1 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bxI7Ez/btsMcsXSPgC/McV65YvUN8ELGhZbpqxaEK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:336,”style”:”alignCenter”,”width”:750,”height”:197}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>여기서 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>🤔 과연 PC2는 PC0과 통신이 가능할까?\n    <ul>\n      <li>결과를 보면, PC1과는 통신이 가능하지만, 다른 스위치로 넘어가면서 통신이 불가능해진다</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cdqmkw/btsMeSmNMeI/jnvpXenhi6dV8W4U8oGWaK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:994,”originHeight”:806,”style”:”alignCenter”,”width”:664,”height”:538}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>이런 논리적인 흐름의 질문이 든다.\n    <ol>\n      <li>오히려 VLAN 설정하기 전에 그냥 여러 스위치를 건너 뛰어도 통신이 됐음.</li>\n      <li>그리고 같은 VLAN 끼리는 통신이 된다고 했다.</li>\n      <li>그런데 갑자기 같은 VLAN에서 여러 스위치를 건너뛰면 왜 통신이 안될까?</li>\n    </ol>\n  </li>\n  <li>여기서 <strong>VLAN 태그</strong>라는 개념이 등장한다.\n    <ul>\n      <li>VLAN을 설정하면 각 패킷에는 특별한 VLAN ID가 붙게 된다.\n        <ul>\n          <li>(마치 우편물에 부서명을 적는 것과 같다.)</li>\n        </ul>\n      </li>\n      <li>일반적인 스위치의 Port(Access Port)는 VLAN 태그를 처리하는 방법에 대해 1가지 밖에 모른다.\n        <ul>\n          <li>PACKET 들어올 때 : 자신의 VLAN 번호를 태그로 붙인다.</li>\n          <li>PACKET 나갈 때 : 태그를 제거하고 보낸다.</li>\n        </ul>\n      </li>\n      <li>그럼 여기서 문제가 발생한다.\n        <ul>\n          <li>PC2에서 나온 패킷\n            <ul>\n              <li>Switch 0으로 들어올 때 : fa0/2에서 VLAN 2 태그를 붙임</li>\n            </ul>\n          </li>\n          <li>이 패킷이 fa0/5로 가면서 VLAN 1의 통신으로 취급됨 [VLAN 2 태그가 떨어짐]</li>\n          <li>다른 스위치의 fa0/3에 도착했을 때도 VLAN 1의 통신으로 인식됨</li>\n          <li>결과적으로 원래의 VLAN 2 통신이 의도대로 전달되지 못함.</li>\n        </ul>\n      </li>\n      <li>[즉, <strong>Switch0의 fa0/와 Switch1의 fa0/3이 VLAN 1이기 때문</strong>]</li>\n    </ul>\n  </li>\n</ul>\n\n<p>→ <strong>스위치 간 VLAN 전용 통로가 필요하다!</strong></p>\n\n<h2 id=\"트렁크trunk\">트렁크(Trunk)</h2>\n\n<p>[먼저 PC2가 PC0과 통신이 가능하도록 해결해보자]</p>\n\n<ul>\n  <li>Switch0과 Switch1간에 VLAN 2,3 전용 포트 따로 설정!</li>\n  <li>switch0의 fa0/5, fa0/6을 각각 VLAN 2,3 전용으로 설정</li>\n  <li>switch1의 fa0/3, fa0/4를 각각 VLAN 2,3 전용으로 설정</li>\n  <li>Switch 0 포트의 VLAN 상태</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b3x84T/btsMei0AEyD/DYcMw88NkSnY9eQ8B22zcK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1154,”originHeight”:64,”style”:”alignCenter”,”width”:699,”height”:39}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 1 포트의 VLAN 상태</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@URbjM/btsMdIyMTr2/uZ7hOtRQPSYbugPuyZe3s1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1064,”originHeight”:74,”style”:”alignCenter”,”width”:731,”height”:51}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC2에서 PC0로 통신이 가능하다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@AcI9Y/btsMeveoKpG/MRkQDsbDHXP76MV9pLzZR0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:956,”originHeight”:432,”style”:”alignCenter”,”width”:727,”height”:329}_#][#_Image</td>\n      <td>kage@cav9Br/btsMdpMVs7n/kO9tRv5kLVsRKP9bNXqDuK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:714,”originHeight”:510,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>그런데 또 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>🤔 과연 VLAN 별 통신 라인 추가가 바람직한 해결인가?\n    <ul>\n      <li>만약 VLAN이 수백개라면..?</li>\n      <li>일일이 연결해줄 수 없다</li>\n      <li>또한 추가 가능한 VLAN ID는 1000개.\n        <ul>\n          <li>→ <strong>Trunk</strong> 가 해결책</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"트렁크란\">트렁크란?</h2>\n\n<ul>\n  <li><strong>트렁크는 모든 VLAN 패킷을 하나의 포트로 통과시키는 것</strong></li>\n  <li>스위치 간 프레임 전달에 하나의 물리적 연결(포트)를 공유하는 것.</li>\n  <li>VLAN 트렁킹된 스위치들 간에 여러 VLAN에서 나온 프레임들을 이 트렁크를 통해 전달한다.</li>\n  <li>즉, 스위치와 스위치 간 프레임 전달 시 하나의 포트에 다수의 VLAN이 지나갈 수 있도록하는 링크.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch(config)#interface fa0/5\nSwitch(config-if)#switchport mode trunk\n\nSwitch(config-if)#\n%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to down\n\n%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to up\nexit\nSwitch(config)#exit\nSwitch#\n%SYS-5-CONFIG_I: Configured from console by console\nshow interface trunk\nPort        Mode         Encapsulation  Status        Native vlan\nFa0/5       on           802.1q         trunking      1\n\nPort        Vlans allowed on trunk\nFa0/5       1-1005\n\nPort        Vlans allowed and active in management domain\nFa0/5       1,2,3\n\nPort        Vlans in spanning tree forwarding state and not pruned\nFa0/5       none\n</code></pre></div></div>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cj9Kft/btsMcrLrqjC/NZkK8P615yIbq5LWFeBswk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:839,”style”:”alignCenter”,”caption”:”Switch0의 Fa0/5 포트 Trunk 설정”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li>Fa0/5가 트렁크 포트로 on (강제로 트렁크 모드로 설정) 되었다.</li>\n  <li>1~1005는 이론적으로 모든 VLAN 범위가 통과 가능하다.</li>\n  <li>실제 현재 사용 중인 VLAN : 1, 2, 3이 현재 활성화되어 있다.</li>\n  <li>Vlans in spanning tree forwarding state and not pruned : None<br />\n(활성화된 VLAN들이 여기 나타나야 한다. - 없다.)</li>\n</ol>\n\n<ul>\n  <li>Fa0/5 포트는 Native VLAN이 1로 설정됨</li>\n  <li>반대편 Fa0/3 포트는 Native VLAN이 2로 설정됨\n    <ul>\n      <li>Switch1의 Fa0/3 포트도 Trunk로 설정해준다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@kzW3S/btsMec7cVIK/IBXxcLCh7BYeCYd9J2nScK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1136,”originHeight”:414,”style”:”alignCenter”,”width”:654,”height”:238}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>물론 PC2에서 PC0로 통신이 가능해졌다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bryfWp/btsMcPE65aP/UGX9KHYfm1QMvME24buAtk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:956,”originHeight”:428,”style”:”alignCenter”,”width”:706,”height”:316}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"inter-vlan\">Inter-VLAN</h2>\n\n<ul>\n  <li>놓치면 안되는 것의 “<strong>기술의 도입에 대한 목적</strong>”이다.\n    <ul>\n      <li>VLAN의 목적은 가상의 LAN으로서 관리의 편리성 추구이며,<br />\n다른 VLAN과의 통신 제한이 아니다.</li>\n    </ul>\n  </li>\n  <li>그럼, 서로 다른 VLAN 간의 통신이 가능하도록 하는 방법은 없을까?</li>\n  <li>VLAN 간 통신을 하려면 라우터(게이트웨이)가 있어야 한다.\n    <ul>\n      <li>라우터를 경유하여 마치 다른 LAN으로 통신하는 것처럼 동작한다.</li>\n    </ul>\n  </li>\n  <li>[다른 네트워크 영역은 라우터가 필요!!!]</li>\n</ul>\n\n<h2 id=\"서브-인터페이스\">서브 인터페이스</h2>\n\n<ul>\n  <li>단순히 생각하면 이런 생각이 든다.</li>\n  <li>전통적인 라우터 방식: 각 VLAN마다 라우터의 물리적 인터페이스를 하나씩 사용</li>\n  <li>그러나 이런 생각의 전환을 해본다.\n    <ul>\n      <li><strong>하나의 물리적 라우터 인터페이스에 여러 개의 논리적 인터페이스를 생성하여 각각 다른 VLAN을 처리할 수 있도록 할 수 있다면?</strong></li>\n      <li>그런데, Fa0/0이라는 물리적 라우터 인터페이스에 어떻게 여러 개의 논리적 인터페이스를 생성할까?</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@Y1VKx/btsMeSUECM4/0Qz0wbAb4G4UBmT0SLhXYk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:260,”originHeight”:298,”style”:”alignCenter”,”width”:167,”height”:191}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>서브 인터페이스: 하나의 인터페이스에 여러 VLAN들의 인터페이스를 논리적으로 나누는 것</li>\n  <li>2811 모델을 추가해준다!\n    <ul>\n      <li>참고 :</li>\n      <li><em>2811 라우터는 Cisco의 중급 라우터로, Inter-VLAN 라우팅을 위한 서브인터페이스 구성을 지원합니다. 서브인터페이스란 하나의 물리적 인터페이스를 여러 개의 논리적 인터페이스로 나누어 사용할 수 있게 해주는 기능입니다. 이는 마치 하나의 도로를 여러 개의 차선으로 나누어 서로 다른 목적지로 가는 차들을 효율적으로 처리하는 것과 비슷합니다.</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p>1. fa0/0 활성화</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dysMoj/btsMcdzWje7/FkpECQDsjzhv7gtsA3SGI1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:846,”originHeight”:200,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>2. fa0/0.2 생성, VLAN2 연결, IP주소 할당 &amp; fa0/0.3 생성, VLAN3 연결, IP주소 할당</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b2QZaS/btsMb1M28tD/PwRCtfFGc9U9WdizCjU6pk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:691,”style”:”alignCenter”,”width”:790,”height”:426}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>3. switch1 fa0/4를 트렁크 모드로 설정</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bGoCk8/btsMdHT860Z/dwqr98u0ihaJDerscGQ7j1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1248,”originHeight”:546,”style”:”alignCenter”,”width”:718,”height”:314}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>4. Router의 서브 인터페이스 상태 확인</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bnyTgA/btsMevrWYog/pDkKHGHiWCNLKzR85a7Qn1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:219,”style”:”alignCenter”,”width”:819,”height”:140}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>5. 게이트웨이 설정</p>\n\n<p>- VLAN 2 (PC0, 1, 2) → 203.237.20.254</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bjr2GX/btsMey9WnrP/zNHfPdHwYlhyUSeIwsz6n0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:384,”style”:”alignCenter”,”width”:767,”height”:230}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>- VLAN 3 (Laptop0, 1, 2) → 203.237.30.254</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@9Pp8f/btsMcxY6pxv/toN6xYeoWLuqsvp1xIlJ90/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:606,”style”:”alignCenter”,”width”:773,”height”:366}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h1 id=\"스위치\">스위치</h1>\n\n<hr />\n\n<h2 id=\"스위치의-동작-원리\">스위치의 동작 원리</h2>\n\n<h2 id=\"mac-주소-테이블-동작-원리\">MAC 주소 테이블 동작 원리</h2>\n\n<ul>\n  <li>스위치와 노드들이 <strong>ARP</strong>를 통해 MAC 주소 정보를 지속적으로 교환한다.\n    <ul>\n      <li>ARP 프로토콜에 포함된 MAC 주소 정보를 기반으로 스위치의 MAC 주소 테이블이 구축된다.</li>\n      <li>실제 데이터 전송 (ping 등)이 발생하면, 이 MAC 주소 테이블을 참조하여 패킷을 적절한 포트로 전달</li>\n    </ul>\n  </li>\n  <li>MAC 주소 테이블은 네트워크 토폴리지 변화를 반영하기 위해 일정 주기로 초기화되며, 최신 정보로 동적 갱신된다.</li>\n</ul>\n\n<h2 id=\"arp란\">ARP란?</h2>\n\n<ul>\n  <li>IP 네트워크에서 IP 주소를 물리적인 MAC 주소로 변환하는 핵심 프로토콜</li>\n  <li>컴퓨터가 같은 네트워크 상의 다른 장치와 통신하려면 반드시 상대방의 MAC 주소를 알아야 하는데,<br />\nARP가 이 주소 변환 과정을 자동으로 처리해준다.</li>\n</ul>\n\n<h2 id=\"arp를-활용한-동작-원리\">ARP를 활용한 동작 원리</h2>\n\n<p><em>PC0에서 Laptop0으로 ping을 보낸다고 가정</em></p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cDoPQ4/btsMdLhTSuP/NdTWBqnwp8pAXYoKUrWZrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:988,”originHeight”:436,”style”:”alignCenter”,”width”:742,”height”:327}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li>ARP Request (PC0 → Switch0)\n    <ul>\n      <li>PC0이 Laptop0의 MAC 주소를 알아내기 위해 ARP 요청 패킷 전송</li>\n      <li>패킷 내용:\n        <ul>\n          <li>출발지: PC0의 IP 주소와 MAC 주소</li>\n          <li>목적지: Laptop0의 IP 주소 (MAC 주소는 미확인 상태)</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>스위치 <strong>브로드캐스트</strong> (Switch0 → 모든 노드)\n    <ul>\n      <li>Switch0은 PC0의 <strong>MAC 주소를 자신의 테이블에 기록</strong></li>\n      <li>수신한 ARP 요청 패킷을 모든 포트로 브로드캐스트</li>\n    </ul>\n  </li>\n  <li>ARP reply (Laptop0 → Switch0)\n    <ul>\n      <li>Laptop0이 자신의 IP 주소를 확인하고 ARP 응답 패킷 생성</li>\n      <li>패킷 내용:\n        <ul>\n          <li>출발지: Laptop0의 IP 주소와 MAC 주소</li>\n          <li>목적지: PC0의 IP 주소와 MAC 주소</li>\n        </ul>\n      </li>\n      <li>Laptop0은 PC0의 MAC 주소를 자신의 ARP 캐시에 저장</li>\n    </ul>\n  </li>\n  <li>스위치 전달 단계 (Switch0 → PC0)\n    <ul>\n      <li>Switch0은 수신한 응답 패킷을 PC0에게 전달</li>\n      <li>PC0과 Laptop0의 MAC 주소 정보를 MAC 주소 테이블에 저장</li>\n    </ul>\n  </li>\n  <li>통신 시작\n    <ul>\n      <li>PC0이 Laptop0의 MAC 주소를 획득하여 실제 데이터 통신 가능</li>\n    </ul>\n  </li>\n</ol>\n\n<h2 id=\"시뮬레이션\">시뮬레이션</h2>\n\n<ul>\n  <li>시뮬레이션을 눌러서 이벤트 목록창을 볼 수 있다.</li>\n  <li>편지봉투 모양의 [Add Simple PDU] → ICMP 패킷 전송 시뮬레이션</li>\n  <li>송신노드와 수신 노드를 클릭하고 Show All/None 클릭 후 ARP, ICMP 패킷만 클릭한다.</li>\n  <li><em>PC0에서 Laptop0으로 편지를 보낸다.</em></li>\n  <li>ARP - ICMP 순으로 통신이 이루어진다.</li>\n</ul>\n\n<h2 id=\"1-arp-패킷-분석\">1) ARP 패킷 분석</h2>\n\n<p>1. PC0 → Switch0 ARP Request</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cwVj4Z/btsMcHN0AZ1/QtiRKPTAkw5cwMHngIJq5K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:900,”originHeight”:1158,”style”:”alignCenter”,”width”:522,”height”:672}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>ARP\n    <ul>\n      <li>Source MAC<br />\n= PC0 의 MAC 주소</li>\n      <li>Source IP<br />\n= PC0의 IP 주소</li>\n      <li>Target MAC<br />\n= Laptop 의 MAC 주소 [모르는 주소]</li>\n      <li>Target IP<br />\n= Laptop0의 IP주소</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2. Switch0 → 모든 노드 (브로드캐스트)</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dvlpX3/btsMdr43c4X/YNHxFWmjmqgayudoXkG1l0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:818,”originHeight”:124,”style”:”alignCenter”,”width”:594,”height”:90}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch0은 수신한 ARP Request를 모든 포트로 전달</li>\n  <li>Switch0의 MAC 주소 테이블에 PC0의 정보 기록\n    <ul>\n      <li>포트 번호와 PC0의 MAC 주소 매핑</li>\n    </ul>\n  </li>\n</ul>\n\n<p>3. Laptop0→ Switch0 ARP Reply</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@K4KvV/btsMcdUawiw/VpUysCPR5W9T4yYTKTcqJK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1002,”originHeight”:1242,”style”:”alignCenter”,”width”:627,”height”:777}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>ARP\n    <ul>\n      <li>Source MAC<br />\n= Laptop0 의 MAC 주소</li>\n      <li>Source IP<br />\n= Laptop0의 IP 주소</li>\n      <li>Target MAC<br />\n= PC0 의 MAC 주소</li>\n      <li>Target IP<br />\n= Laptop0의 IP주소</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"2-icmp-패킷-분석\">2. ICMP 패킷 분석</h2>\n\n<ol>\n  <li>PC → Laptop</li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@6AWAV/btsMdMA4Jmh/dd2ilCfmHRbqRt9DFVNWhK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2056,”originHeight”:1186,”style”:”alignCenter”,”width”:690,”height”:398}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>SRC ADDR = PC0의 MAC 주소</li>\n  <li>DEST ADDR = Laptop0의 MAC 주소</li>\n</ul>\n\n<h2 id=\"3-switch0의-mac-주소-테이블-변화\">3) Switch0의 MAC 주소 테이블 변화</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dEbxME/btsMdnn7IXG/koFfWfejqCW9bxxbzaYPb0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1080,”originHeight”:611,”style”:”alignCenter”,”width”:747,”height”:423}_#][#_Image</td>\n      <td>kage@WjEAg/btsMdmbIixx/in3AqgZZ7OkLwPpGkcb270/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1080,”originHeight”:734,”style”:”alignCenter”,”width”:727,”height”:494}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>위를 보니 Fa0/1 Fa0/4에 연결된 PC0과 Laptop0의 MAC 주소가 테이블에 기재되었다.</li>\n</ul>\n\n<p>🤔 갑자기 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>Switch0 → 모든 노드로 BroadCast할 때 각자의 MAC 주소 받아오면 되는거 아닌가?</li>\n  <li>해답은 ARP를 이용해 MAC 주소 테이블이 어떻게 유지하는지의 방법에 있다.\n    <ul>\n      <li>스위치의 MAC 주소 학습은 ‘출발지(Source) MAC 주소’만을 대상으로 한다.\n        <ul>\n          <li>PC0이 ARP Request를 보낼 때</li>\n          <li>Laptop0이 ARP Reply를 보낼 때</li>\n        </ul>\n      </li>\n      <li>모든 노드로 전달된 ARP-Request 패킷에 대해 수신 노드가 아니면 응답하지 않는다.</li>\n      <li>PC1과 Laptop1은 Swtich0이 전달한 ARP-Request에 대해 Reply 하지 않는다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>그런데 이런 ‘고민’도 떠오른다.</p>\n\n<p>1.효율성</p>\n\n<ul>\n  <li>ARP는 매우 짧은 시간 간격으로 반복 실행한다.\n    <ul>\n      <li>노드들이 많은 네트워크에서는 통신량으로 부하 가중</li>\n      <li>특히 스위치가 모든 노드에게 BroadCast하는 ARP-Request에서</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2. 보안상의 문제</p>\n\n<ul>\n  <li>Laptop1이 악의적인 공격자라고 가정해보자.\n    <ul>\n      <li>ARP Reply가 실제로 해당 IP 주소를 가진 정당한 장치에서 온 것인지 확인하지 않는다. (보안 X)</li>\n      <li>이 때 Laptop0의 IP에 Laptop1 MAC 주소를 실어서 Reply한다면?</li>\n      <li>테이블이 제대로 갱신되기 전까지 PC0은 Laptop0인 줄 알고 모든 패킷을 보낸다.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"vlan을-통한-해결\">VLAN을 통한 해결</h2>\n\n<ul>\n  <li>MAC 주소를 이용한 라우팅\n    <ul>\n      <li>동일한 네트워크(LAN)에서 스위치를 통해서만 발생한다.</li>\n      <li>라우터를 통한 외부 네트워크로의 통신에는 사용되지 않는다.\n        <ul>\n          <li>ARP 패킷은 하나의 네트워크에서만 송수신한다.</li>\n          <li>LAN을 논리적으로 분리된 가상의 VLAN으로 관리한다.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h1 id=\"라우터\">라우터</h1>\n\n<hr />\n\n<h2 id=\"라우터란\">라우터란?</h2>\n\n<ul>\n  <li>라우터는 서로 다른 네트워크를 연결하는 3계층 장비.</li>\n  <li>IP 주소를 기반으로 패킷의 최적 경로를 결정하고 전달한다.\n    <ul>\n      <li>스위치가 같은 네트워크 내에서 MAC 주소를 기반으로 통신을 담당한다면,</li>\n      <li>라우터는 서로 다른 네트워크 간의 통신을 가능하게 만드는 일종의 ‘네트워크 간의 다리’ 역할을 한다.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"라우터의-mode\">라우터의 Mode</h2>\n\n<ul>\n  <li><strong>사용자 모드(User EXEC Mode)</strong>\n    <ul>\n      <li>기본적인 정보 조회만 가능, 설정 변경 불가</li>\n      <li>&gt; 로 표시</li>\n    </ul>\n  </li>\n  <li><strong>관리자 모드(Privileged EXEC Mode)</strong>\n    <ul>\n      <li>라우터 설정을 변경할 순 없지만 시스템 정보 상세조회 가능</li>\n      <li># 으로 표시</li>\n    </ul>\n  </li>\n  <li><strong>글로벌 모드(Global Configuration Mode)</strong>\n    <ul>\n      <li>라우터 설정(이름, 보안, 인터페이스 등)을 변경</li>\n      <li>(config)# 로 표시</li>\n      <li><strong>라인 모드(Line Configuration Mode)</strong>\n        <ul>\n          <li>콘솔, 원격 접속(Telnet, SSH 등) 관련 설정 변경</li>\n          <li>(config-line)# 로 표시</li>\n        </ul>\n      </li>\n      <li><strong>인터페이스 모드(Interface Configuration Mode)</strong>\n        <ul>\n          <li>라우터의 네트워크 인터페이스(이더넷, 시리얼 등) 설정을 변경</li>\n          <li>라우터의 인터페이스에 IP 주소를 설정하고 활성화/비활성화</li>\n          <li>(config-if)# 로 표시</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"목표-네트워크-구성\">목표 네트워크 구성</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@FrASQ/btsMeLVCXVC/1wKsZjYPW9BikRxL7DFtC1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:813,”originHeight”:495,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"기본-설정\">기본 설정</h2>\n\n<ul>\n  <li>라우터 3대: [Network Devices] → [Routers] → [2811]</li>\n  <li>스위치 1대 : [Network Devices] → [Switches] → [2960]</li>\n  <li>PC 3대, 노트북 1대, 서버 1대 : [End Devices] → [PC], [Laptop], [Server]</li>\n</ul>\n\n<h2 id=\"라우터---시리얼-인터페이스-장착\">라우터 - 시리얼 인터페이스 장착</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@zgPDU/btsMd3bDPMR/E6TXH94lrMz3OrUR6TF5hK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:1293,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC와 달리 두 라우터 간에 데이터를 주고받기 위한 동기화가 필요</li>\n  <li>FastEthernet이 아닌 Serial 인터페이스를 사용하므로 모듈을 추가해야 한다.\n    <ul>\n      <li>HWIC-2T 추가</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"노드-간-연결하기\">노드 간 연결하기</h2>\n\n<ul>\n  <li>Laptop0은 통신용이 아니라 Router0을 설정하기 위한 콘솔\n    <ul>\n      <li>FastEthernet 케이블이 아닌 RS232(하늘색) 케이블로 연결</li>\n    </ul>\n  </li>\n  <li>라우더들끼리 Serial DCE 연결\n    <ul>\n      <li>먼저 클릭한 쪽에 시계 모양 - 두 라우터 간 데이터를 주고받기 위한 동기화가 필요</li>\n      <li>Serial DCE(Data Communication Equipment): 시간 동기화를 주도하는 노드 (시계 있는 쪽)</li>\n      <li>Serial DTE(Data Terminal Equipment): 그에 따라 동기화하는 노드 (시계 없는 쪽)</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@evpmpX/btsMdMnzPql/PLX7aieEhAKMJ6N99C2j5K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2184,”originHeight”:1246,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"ip-설정\">IP 설정</h2>\n\n<ul>\n  <li>컴퓨터들은 203.237.nnn.nnn/24 사용(C클래스)\n    <ul>\n      <li>1번부터 시작</li>\n    </ul>\n  </li>\n  <li>원격 관리가 필요한 스위치나 서버는 100번 부터</li>\n  <li>라우터는 광역의 랜들을 연결하므로 A클래스 IP 사용\n    <ul>\n      <li>규모가 작아 30비트 서브넷 마스크를 사용하여 최대 4개의 라우터를 묶을 수 있도록</li>\n    </ul>\n  </li>\n  <li>스위치는 2계층 장비\n    <ul>\n      <li>IP 주소 설정 불필요</li>\n      <li>원격 접속으로 스위치 관리\n        <ul>\n          <li>IP 주소 할당 필요</li>\n          <li>VLAN1에 할당</li>\n        </ul>\n      </li>\n      <li>스위치 IP 주소 설정</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bk8xpK/btsMd7Sxxul/dQMOVhudaYmzsa519EoeQK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1374,”originHeight”:164,”style”:”alignCenter”,”width”:635,”height”:76}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>총 6개의 LAN</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@UGTSj/btsMcKRyRRh/QFOQKnpr0nm0a6K8eUWWKk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1762,”originHeight”:1000,”style”:”alignCenter”,”width”:698,”height”:396}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"연결-확인\">연결 확인</h2>\n\n<ul>\n  <li>PC0에서 테스트</li>\n</ul>\n\n<ol>\n  <li>PC0 로컬 호스트(127.0.0.1)</li>\n  <li>PC0 → Switch1(VLAN1, 203.237.10.100)</li>\n  <li>PC0 → Server0(203.237.10.101)</li>\n  <li>PC0 → Router0(203.237.10.254)\n    <ul>\n      <li>모두 통신 성공</li>\n    </ul>\n  </li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@s9v2J/btsMcYPw7T1/QedNlAylJ9wAnApW81hp3K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1000,”originHeight”:1605,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>5. PC0 → PC2(203.237.30.1)</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@mi021/btsMdHGFlHG/cChGsiN9Pw0rWY0kG0w7q1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:996,”originHeight”:374,”style”:”alignCenter”,”width”:684,”height”:257}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><strong>unreachable</strong> 이 발생한다\n    <ul>\n      <li>PC0으로 부터 받은 패킷을 Router0이 어느 인터페이스로 보내야할지 모르기 때문</li>\n      <li>→ <strong>라우팅 테이블</strong>이 필요하다</li>\n      <li>아래는 Router0의 라우팅 정보</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@beagrf/btsMdMujNSG/uzGad36EzxcCPqRZ3PJy21/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1260,”originHeight”:698,”style”:”alignCenter”,”width”:746,”height”:413}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"정적-라우팅-설정\">정적 라우팅 설정</h2>\n\n<ul>\n  <li>정적 라우팅 대상\n    <ul>\n      <li>1번 PC0 입장에서 목적지가\n        <ul>\n          <li><strong>2번</strong> 네트워크(203.237.20.nnn/24)인 패킷 : serial0/3/0 (혹은 1.1.1.2)</li>\n          <li><strong>3번</strong> 네트워크(203.237.30.nnn/24)인 패킷 : serial0/3/1 (혹은 2.2.2.2)</li>\n          <li>6번 네트워크(3.3.3.nnn/30)인 패킷 : serial0/3/0 혹은 serial0/3/1</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>Router1의 정적 라우팅 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@JLnX1/btsMckFDkMJ/ik8vROKAHLaZQPxINyMSmK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1226,”originHeight”:442,”style”:”alignCenter”,”width”:694,”height”:250}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Router2의 정적 라우팅 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@k4yPj/btsMexiTcvl/Ewo59hWdxO2tOqMp9GTtNK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1248,”originHeight”:504,”style”:”alignCenter”,”width”:736,”height”:297}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Router3의 정적 라우팅 설정 + route 확인</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cnu0SN/btsMdH0043d/jjkekr1KEkmqtXM0E7LRUK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1270,”originHeight”:1186,”style”:”alignCenter”,”width”:756,”height”:706}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"통신테스트-by-ping\">통신테스트 by ping</h2>\n\n<ul>\n  <li>PC0 ↔ PC1</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dD0uXu/btsMb0Hnvj9/50DKkNchVlTaBfBiYNEMiK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:962,”originHeight”:422,”style”:”alignCenter”,”width”:730,”height”:320}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC0 ↔ PC2</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cEoaLU/btsMdGgIz36/93lJ36D1HjrKK9gQaOKvb1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:432,”style”:”alignCenter”,”width”:780,”height”:350}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h1 id=\"방화벽---네트워크-구성\">방화벽 - 네트워크 구성</h1>\n\n<hr />\n\n<h2 id=\"망구성\">망구성</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@kO9qL/btsMengxOIb/FFIVXRjKkeW6JnSOKHGXqk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:524,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"asa0-구성-설정\">ASA0 구성 설정</h2>\n\n<p>1. 인터페이스 통신 상태</p>\n\n<ul>\n  <li>내부망 : 통신 가능</li>\n  <li>외부망 : 통신 불가\n    <ul>\n      <li>inPC → outPC 불가능</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bh2bBN/btsMd7rqkl0/g4AYl1hwkqpXZ1NDwCwO30/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1278,”originHeight”:266,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>2. IP 주소 설정</p>\n\n<ul>\n  <li>Inside : 설정됨</li>\n  <li>outside : 설정되어있지 않음\n    <ul>\n      <li>→ VLAN에서 203.237.20.253으로 설정</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cormPm/btsMc1r1E8A/LKXIkkQ8YcBwbHGgFGWQIk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1406,”originHeight”:342,”style”:”alignCenter”,”width”:807,”height”:196}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>3. Config 확인</p>\n\n<ul>\n  <li>내부망 Security-level : 100</li>\n  <li>외부망 Security-level : 0</li>\n  <li>보안 레벨이 높은 곳 → 낮은 곳 : 허용 (반대는 불가능)</li>\n  <li>내부망 노드들은 DHCP를 이용하여 IP 할당받는다.</li>\n</ul>\n\n<h2 id=\"inpc-dhcp-설정\">inPC DHCP 설정</h2>\n\n<ul>\n  <li>inPC는 ASA가 DHCP로 주소를 할당해준다고 했다.\n    <ul>\n      <li>게이트웨이는 ASA0 inside의 ip 주소로 고정된다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@HAypL/btsMemIHLU2/tcja6hVK1aurUDoEGiKLAK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1388,”originHeight”:636,”style”:”alignCenter”,”width”:703,”height”:322}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>outPC는 고정 주소 사용 중</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@lNS8u/btsMdHzVPu4/iHvbzNmifAq1gElLiDlpW1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1304,”originHeight”:546,”style”:”alignCenter”,”width”:707,”height”:296}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"router0-설정\">Router0 설정</h2>\n\n<ul>\n  <li>fa0/0 IP 설정 &amp; 활성화\n    <ul>\n      <li>203.237.10.254/24</li>\n    </ul>\n  </li>\n  <li>fa0/0 IP 설정 &amp; 활성화\n    <ul>\n      <li>203.237.20.253/24</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"rna-설정\">RNA 설정</h2>\n\n<h2 id=\"routing\">Routing</h2>\n\n<ul>\n  <li>라우터의 정적라우팅\n    <ul>\n      <li>네트워크 디바이스들이 서로 다른 네트워크에 있을 때, 그들 사이의 통신 경로를 명확히 지정해줘야 한다.</li>\n      <li>예를 들어, 내부 네트워크의 PC가 다른 네트워크의 서버와 통신하려면, 그 경로를 알아야 한다.</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">ip route &lt;목적지 네트워크 주소&gt; &lt;목적지 서브넷 마스크&gt; &lt;다음 홉 IP 주소/출구 인터페이스&gt;</code></li>\n    </ul>\n  </li>\n  <li>방화벽의 정적라우팅\n    <ul>\n      <li>트래픽이 반드시 방화벽을 통과하도록 하여 보안 정책을 적용할 수 있게 한다.</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">route &lt;VLAN명&gt; &lt;외부망 네트워크 주소&gt; &lt;외부망 서브넷마스크&gt; &lt;다음 홉 IP 주소&gt;</code></li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@UMo4w/btsMemPruKw/su6TBN30w2NLPGdTiu8nN0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2110,”originHeight”:1000,”style”:”alignCenter”,”width”:734,”height”:348}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>→ 어떤 목적지 주소를 갖는 패킷이든 외부망의 Router0인 203.207.20.254로 전송한다.</p>\n\n<ul>\n  <li>통신확인</li>\n  <li>inPC ↔ ASA0</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@ea7sUx/btsMcHURKDV/D3ikyzQhpSkEa8QCBP2sK1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:972,”originHeight”:428,”style”:”alignCenter”,”width”:708,”height”:312}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>inPC ↔ outPC</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b7mUIE/btsMcfqYrdM/SvtR3wkJNdKRzXgHMUMtIK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:986,”originHeight”:368,”style”:”alignCenter”,”width”:702,”height”:262}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"nat\">NAT</h2>\n\n<ul>\n  <li>inPC → outPC 까지는 패킷 전달이 잘 되지만,</li>\n  <li>Router0 → ASA0으로 전달이 되지 않는다.</li>\n</ul>\n\n<p><strong>outPC → Router1로 전달되는 패킷</strong></p>\n\n<ul>\n  <li>outPC(203.237.10.10)가 inPC(192.168.1.5)로 통신을 시도할 때, Router는 문제에 직면한다.\n    <ul>\n      <li>목적지 주소가 사설IP이기 때문에 외부에서 인식이 불가능하다.</li>\n      <li>→ Rotuer 입장에서 어디로 보내야 할 지 모른다.\n        <ul>\n          <li>(마치 동 호수만 알고, 택배 기사가 서울에서 배달을 하려는 상황과 마찬가지)</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@xD2B6/btsMeR9g8xQ/eG7q1kOXNaBGJdcSFREQoK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2080,”originHeight”:1270,”style”:”alignCenter”,”width”:783,”height”:478}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>⇒ ASA가 사설 IP를 공인 IP로 변경해서 보내줘야 한다.</li>\n  <li>ASA의 <strong>NAT</strong></li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@tUl9o/btsMeRVJT2O/PJFvZxKK7bVxaO8Vexhkt0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:414,”originHeight”:143,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>들어오는 패킷의 처리\n    <ul>\n      <li>외부 노드들은 내부 네트워크의 실제 사설 IP를 알 필요가 없다.\n        <ul>\n          <li>대신 ASA의 공인 IP 주소로 통신을 시도</li>\n        </ul>\n      </li>\n      <li>ASA는 NAT 테이블을 유지하면서, 어떤 외부 통신이 어떤 내부 노드를 위한 것인지 추적</li>\n      <li>수신된 패킷의 목적지 주소를 적절한 내부 사설 IP로 변환하여 전달</li>\n    </ul>\n  </li>\n  <li>나가는 패킷의 처리\n    <ul>\n      <li>내부 노드가 외부로 통신을 시도할 때, ASA는 출발지의 사설 IP를 자신의 공인 IP로 변환</li>\n      <li>이 과정에서 ASA는 어떤 내부 노드가 어떤 통신을 시작했는지 NAT 테이블에 기록</li>\n      <li>나중에 응답이 돌아오면, 이 테이블을 참조하여 올바른 내부 노드에게 전달</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"nat-설정\">NAT 설정</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@czZH5n/btsMc0fu60D/gU0ev4kVhViqehGSDDt6K0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1220,”originHeight”:196,”style”:”alignCenter”,”width”:742,”height”:119}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>in2out 객체 생성 (네트워크 객체 모드)</li>\n  <li>대상 서브넷을 지정해준다.</li>\n  <li>NAT 지정\n    <ul>\n      <li>내외부망을 연결하는 (inside, outside)를 동적 매핑</li>\n      <li>공인 Ip 주소는 인터페이스에 할당된 IP 주소를 사용한다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@ccZXOd/btsMcjzZe4x/9s6nimQ80LBoH1dkmToAWK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:942,”originHeight”:138,”style”:”alignCenter”,”width”:676,”height”:99}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>그래도 inPC → outPC의 통신이 실패하게 된다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bajXRR/btsMcZgFpCY/BFAnMrFdvAP1aAJVnNh9z0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:600,”originHeight”:157,”style”:”alignCenter”,”width”:524,”height”:137}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"acl\">ACL</h2>\n\n<ul>\n  <li>패킷을 보면 목적지 주소는 공인 IP 주소로 정확히 설정되어 있으나,</li>\n  <li>외부망에서 내부망으로 들어오는 트래픽의 흐름을 방화벽이 모두 Block하고 있기 때문</li>\n  <li><strong>즉, 인터페이스마다 어떤 출발지 &amp; 어떤 목적지 를 가지는 트래픽을 허용 / 거부 할 것인지 정의해줘야 한다.</strong></li>\n  <li>→ ACL : 이러한 Allow/Deny 접근 제어 목록</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>access-list &lt;ACL명&gt; &lt;타입&gt; &lt;동작&gt; &lt;프로토콜&gt; &lt;출발지&gt; &lt;목적지&gt;\naccess-group &lt;ACL명&gt; &lt;트래픽&gt; &lt;인터페이스 키워드&gt; &lt;VLAN 명&gt;\n</code></pre></div></div>\n\n<ul>\n  <li>ACL 설정\n    <ul>\n      <li>모든 출발지에서 모든 목적지로 가는 ICMP(ping) 트래픽을 허용하는 규칙을 만든다.</li>\n      <li>만든 규칙을 외부 인터페이스의 인바운드 방향에 적용</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@eklCj3/btsMeUZeeor/0St67walf4cyejJZvVb2N0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1224,”originHeight”:300,”style”:”alignCenter”,”width”:767,”height”:188}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>inPC → outPC Ping 확인</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bMTQzA/btsMeyozeji/a8vxJ4pw0kExxZ6GUmDnRk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:962,”originHeight”:434,”style”:”alignCenter”,”width”:749,”height”:338}_#]</td>\n    </tr>\n  </tbody>\n</table>\n",
                        "tags": ["Network","PacketTracer","LAN","Switch","Router","Firewall","VLAN","Topology"]
                    }
                
            ],
        
            "LAN": [
                
                    {
                        "title": "Packet Tracer로 네트워크 이해하기",
                        "url": "/2025/02/08/packet-tracer-network.html",
                        "subtitle": "LAN 토폴로지, 스위치, 라우터, 방화벽",
                        "excerpt": "LAN 토폴로지와 스위치\n",
                        "author": "Jinho",
                        "date": "February 08, 2025",
                        "background": "/img/posts/network_topology.jpeg",
                        "content": "<h1 id=\"lan-토폴로지와-스위치\">LAN 토폴로지와 스위치</h1>\n\n<hr />\n\n<h2 id=\"packet-tracer에-들어가기-전\">Packet Tracer에 들어가기 전</h2>\n\n<p>먼저 네트워크의 기본 구성 요소부터 이해해보자.</p>\n\n<p><strong>라우터, 스위치, 엔드 디바이스(PC, 서버 등)가 어떻게 상호 작용</strong>하는지 알아보자.</p>\n\n<ul>\n  <li>가장 기본적인 두 대의 디바이스(<code class=\"language-plaintext highlighter-rouge\">PC</code>)가 있다고 가정해보자.</li>\n  <li>두 PC를 연결하고, IP 주소 설정, 서브넷 마스크 설정을 하고 ping 테스트를 통해 연결.\n    <ul>\n      <li>이 과정에서 TCP/IP의 기본 개념을 이해해보자.</li>\n    </ul>\n  </li>\n  <li>그 다음 단계로 <code class=\"language-plaintext highlighter-rouge\">스위치</code>를 추가하여 여러 대의 <code class=\"language-plaintext highlighter-rouge\">PC</code>를 연결.\n    <ul>\n      <li>L2 통신의 개념과 MAC 주소의 역할을 이해해보자.</li>\n    </ul>\n  </li>\n  <li>마지막으로 <code class=\"language-plaintext highlighter-rouge\">라우터</code>를 추가하여 서로 다른 네트워크 간의 통신을 구현.\n    <ul>\n      <li>라우팅 테이블, 게이트웨이 등의 개념을 학습해보자.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"사용법\">사용법</h2>\n\n<h2 id=\"pc\">PC</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@tdMGa/btsMchWsAbo/pXUJ5sc1Jn5zlePiDz1mrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:264,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>장치 타입 → End Devices → PC / LAPTOP 등 Drag &amp; Drop</li>\n</ul>\n\n<h2 id=\"switch\">Switch</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bdJ1mb/btsMedLRoGJ/cpMkbVJahG5gP3qwnew9Uk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:194,”originHeight”:256,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"router\">Router</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@A02nQ/btsMeKJcj9q/usIeZ7q3BDrYQHVk4TpOuk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:208,”originHeight”:276,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"connection\">Connection</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@rOlnO/btsMdkEVmv0/U1xgvAbp826OCElZjbp2Sk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:280,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>실선은 Copper Straight [PC - Switch/Router]</li>\n  <li>점선은 Copper Cross - Over [Switch/Router … Switch/Router]</li>\n  <li>번개 모양은 Automatic</li>\n</ul>\n\n<h2 id=\"기본-사용-방법\">기본 사용 방법</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@mamWH/btsMdM8WmZV/J6Eve21yZP8cKJkdv8KQrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:666,”originHeight”:558,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>장치(PC 와 Laptop)들을 놓는다.</li>\n  <li>각 디바이스 개수만큼 연결한 스위치 추가</li>\n  <li>실선과 점선으로 연결</li>\n  <li>스위치 0 → 메뉴에서 FastEthernet0/1 선택</li>\n  <li>PC 0 → 메뉴에서 FastEthernet0 선택</li>\n  <li>(나머지도 동일하게 연결)</li>\n  <li>왼쪽 스위치 : <code class=\"language-plaintext highlighter-rouge\">FastEthernet0/2</code> 오른쪽 스위치 : <code class=\"language-plaintext highlighter-rouge\">FastEthernet0/3</code></li>\n  <li>PC 클릭 → Desktop → IP Configuration → IP Address에 <code class=\"language-plaintext highlighter-rouge\">198.168.0.1</code><br />\nSubnet Mask에 <code class=\"language-plaintext highlighter-rouge\">255.255.255.0</code>\n    <ul>\n      <li>나머지 장치는 IP 주소 ~0.2, ~0.3 순으로 입력</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dhy2rZ/btsMczo0VIn/LHz5KS8UijOguFkFqLdSSk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:338,”style”:”alignCenter”,”width”:780,”height”:206}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Desktop → Command Prompt로 ping 테스트</li>\n  <li>작업 공간에서 Simulation 가능 [실제 이동 경로 &amp; 헤더 정보 등을 볼 수 있다.]</li>\n</ul>\n\n<h2 id=\"lan-topology\">LAN Topology</h2>\n\n<ul>\n  <li>같은 로컬 에이리어 네트워크 (LAN) 내에서 네트워크 장비와 디바이스들이 어떻게 물리적 혹은 논리적으로 연결되어 있는지 나타내는 구조</li>\n</ul>\n\n<h2 id=\"lan과-wan\">LAN과 WAN</h2>\n\n<ul>\n  <li><strong>LAN (로컬 영역 네트워크)</strong>:\n    <ul>\n      <li>제한된 지역 내에서 연결된 네트워크</li>\n      <li><strong>스위치</strong>는 MAC 주소를 사용하여 네트워크 내 장치들 간에 데이터를 전달합니다. 스위치는 <strong>MAC 주소 테이블</strong>을 사용해 데이터를 해당 장치로 정확하게 전달</li>\n    </ul>\n  </li>\n  <li><strong>WAN (광역 네트워크)</strong>:\n    <ul>\n      <li>더 넓은 지역, 심지어 전 세계적으로 연결된 네트워크\n        <ul>\n          <li>인터넷이 대표적인 WAN 예시</li>\n        </ul>\n      </li>\n      <li>WAN에서는 서로 MAC 주소를 알 수 없음</li>\n      <li>WAN에서 라우터는 <strong>IP 주소</strong>를 기반으로 데이터를 전달하는데, 각 네트워크 간의 경로를 찾기 위해 <strong>라우팅 테이블</strong>을 사용\n        <ul>\n          <li>NAT / PAT</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cyma1b/btsMcdGGX7j/3HjkxSXXuguLBaXiMCtKp1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:933,”style”:”alignCenter”,”width”:757,”height”:552}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"1-bus-형\">1) Bus 형</h2>\n\n<ul>\n  <li>하나의 메인 케이블(백본)에 모든 노드가 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>구조가 단순하고 설치 비용이 저렴</li>\n      <li>노드 추가/제거가 쉽고 유연함</li>\n      <li>케이블 길이가 짧아 경제적</li>\n      <li>소규모 네트워크에 적합</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>트래픽 증가 시 성능 저하</li>\n      <li>메인 케이블 장애 시 전체 영향</li>\n      <li>데이터 충돌 발생 가능</li>\n      <li>보안 취약점 존재</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cdwQWE/btsMctoZGjP/YoLinRs4T7sWM3Iv3xCkfK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1138,”originHeight”:650,”style”:”alignCenter”,”width”:690,”height”:394}_#][#_Image</td>\n      <td>kage@XghRi/btsMc2doIc4/cDKKGHIAwzkFizYIthmvX1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:978,”originHeight”:456,”style”:”alignCenter”,”width”:620,”height”:289}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"2-ring-형\">2) Ring 형</h2>\n\n<ul>\n  <li>각 노드가 양옆의 두 노드와 연결되어 원형을 이루는 구조</li>\n  <li>자동선택 기능을 사용한 링</li>\n  <li>장점 :\n    <ul>\n      <li>데이터 흐름이 일정하고 예측 가능</li>\n      <li>충돌이 적고 전송이 안정적</li>\n      <li>각 노드가 리피터 역할 수행</li>\n      <li>장거리 전송에 유리</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>단일 노드 장애가 전체에 영향</li>\n      <li>네트워크 확장이 제한적</li>\n      <li>설치/제거 시 네트워크 중단</li>\n      <li>양방향 링 구성 시 비용 증가</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@lYUdr/btsMetVb0e8/23KtOkSs1PeRKuNml0S2AK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1108,”originHeight”:642,”style”:”alignCenter”,”width”:598,”height”:346}_#][#_Image</td>\n      <td>kage@rYlFs/btsMeKWHZEC/wFs32hn23rG7rKA9WFyKxK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:982,”originHeight”:460,”style”:”alignCenter”,”width”:621,”height”:291}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"3-star-형\">3) Star 형</h2>\n\n<ul>\n  <li>중앙에 허브가 있고 모든 노드가 이 허브에 직접 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>구현과 유지보수가 단순하고 직관적</li>\n      <li>개별 노드 장애가 다른 노드에 영향 없음</li>\n      <li>높은 성능과 데이터 전송 속도</li>\n      <li>중앙 집중적 보안 관리 용이</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>중앙 허브 장애 시 전체 네트워크 마비 - 단일 장애 지점 (SPOF)</li>\n      <li>허브에 과부하 발생 가능</li>\n      <li>케이블 설치 비용이 높음</li>\n      <li>허브 용량에 따른 확장성 제한</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@NJ0T7/btsMdF26Hzf/aEmXKMDwoG1TwsmUekA04K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1088,”originHeight”:678,”style”:”alignCenter”,”width”:627,”height”:391}_#][#_Image</td>\n      <td>kage@vFDga/btsMcTgvpqn/IDhAPb27H9xt3kN9pDOB7k/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:456,”style”:”alignCenter”,”width”:585,”height”:277}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"4-mesh-형\">4) Mesh 형</h2>\n\n<ul>\n  <li>모든 노드가 서로 직접 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>높은 안정성과 이중화 구성</li>\n      <li>효율적인 트래픽 분산</li>\n      <li>우회 경로 확보로 신뢰성 높음</li>\n      <li>뛰어난 보안성</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>설치/유지보수 비용이 매우 높음</li>\n      <li>구현과 설정이 매우 복잡</li>\n      <li>케이블 연결 관리가 어려움</li>\n      <li>노드 수 증가에 따른 복잡도 급증</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bb9BX4/btsMeahgXHL/gVJ4LgKjyCG8M1I6DkkbP0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1070,”originHeight”:674,”style”:”alignCenter”,”width”:628,”height”:396}_#][#_Image</td>\n      <td>kage@ovOWb/btsMb2rFLwg/Qi0orK06gCRkfnrkBXhvyK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:432,”style”:”alignCenter”,”width”:677,”height”:303}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"5-tree-형\">5) Tree 형</h2>\n\n<ul>\n  <li>계층적 구조로, 상위 노드에서 하위 노드로 분기되는 형태</li>\n  <li>장점 :\n    <ul>\n      <li>네트워크 확장이 용이</li>\n      <li>체계적인 계층 구조 관리</li>\n      <li>하위 네트워크 독립성</li>\n      <li>효율적인 트래픽 관리</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>루트 노드 장애 시 전체 영향</li>\n      <li>계층 증가에 따른 관리 복잡성</li>\n      <li>상위 노드 병목 현상 가능</li>\n      <li>깊이가 깊어질수록 지연 증가</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@wounf/btsMcywRCH9/2KnaYgagHLQKp4cBdcumy0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:985,”style”:”alignCenter”,”width”:765,”height”:589}_#][#_Image</td>\n      <td>kage@dI6An5/btsMd4hh7vI/Gxr1Nv7uKXeDV0vrZs1qT0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:960,”originHeight”:458,”style”:”alignCenter”,”width”:642,”height”:306}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>192.168.0.1 to 192.168.0.12</li>\n</ul>\n\n<h2 id=\"vlanvirtual-lan-case-1--switch-1개\">VLAN(Virtual LAN) (case 1 : Switch 1개)</h2>\n\n<h2 id=\"vlan이란\">VLAN이란?</h2>\n\n<p>“<strong>논리적인 구조의 속임수로 같은 물리적 공간에 있는 네트워크를 다른 네트워크에 있는 것처럼 속이는 기술</strong>”</p>\n\n<ul>\n  <li>먼저, 물리적인 LAN을 먼저 생각해보면, 같은 건물이나 같은 층에 있는 컴퓨터들이 하나의 네트워크로 연결되어 있는 구조이다.</li>\n  <li>그런데 예를 들면, 마케팅팀과 개발팀이 다른 네트워크에 있어야 한다고 가정해보자.\n    <ul>\n      <li>전통적인 방식이라면 물리적으로 별도의 네트워크 장비와 케이블을 설치해야 했다.</li>\n      <li>하지만, VLAN은 이런 물리적 제약을 소프트웨어적으로 해결한다.</li>\n    </ul>\n  </li>\n  <li>하나의 물리적인 스위치를 마치 여러 개의 독립된 스위치처럼 동작하게 만드는 기술이다.</li>\n  <li>예를 들어, 같은 스위치에 연결된 컴퓨터라도 서로 다른 VLAN에 속하면 마치 다른 네트워크에 있는 것처럼 통신이 분리된다.</li>\n</ul>\n\n<h2 id=\"초기-default-vlan-설정\">초기 default VLAN 설정</h2>\n\n<ul>\n  <li>show vlan으로 확인해보자.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bTHrGF/btsMea2FcPL/VagNQtcNTnfvH7OWzcKevk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1250,”originHeight”:974,”style”:”alignCenter”,”width”:670,”height”:522}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>처음 VLAN 1은 ‘기본 VLAN’이다.</li>\n  <li>모든 스위치 포트는 처음에 이 VLAN 1에 속하도록 설정되어 있다.\n    <ul>\n      <li>그래서 별다른 설정 없이는 같은 물리적인 공간에 있다면 한 네트워크에 속하도록 설정이 된다.</li>\n    </ul>\n  </li>\n  <li>그리고 VLAN 1002부터 1005까지는 특별한 목적으로 예약된 VLAN이다. (사용 불가)\n    <ul>\n      <li>FDDI, 토큰링 등으로 고정되어 있다.</li>\n    </ul>\n  </li>\n  <li>우리가 새로운 VLAN을 할당하려고 하면 “2 ~ 1001” 의 VLAN을 사용해서 나누면 된다.</li>\n</ul>\n\n<h2 id=\"vlan-구성하기\">VLAN 구성하기</h2>\n\n<ul>\n  <li>먼저 VLAN 2개를 생성한다.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch#enable\nSwitch#config terminal\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#vlan 2\nSwitch(config-if)#name VLAN_2\nSwitch(config-if)#exit\n</code></pre></div></div>\n\n<ul>\n  <li>enable : 관리자 모드 진입</li>\n  <li>config terminal : 글로벌 모드 진입</li>\n  <li>vlan 2 : vlan 모드 진입</li>\n  <li>name <이름> : 진입되어 있는 vlan의 이름 설정</이름></li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dsQlbd/btsMdqdX0ps/kPhix6BIWT0KDKtVJzq3NK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1185,”originHeight”:1000,”style”:”alignCenter”,”width”:734,”height”:619}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>결과</p>\n\n<ul>\n  <li>그리고, <code class=\"language-plaintext highlighter-rouge\">VLAN_2</code>엔 <code class=\"language-plaintext highlighter-rouge\">Fa0/1</code> 과 <code class=\"language-plaintext highlighter-rouge\">Fa0/2</code>, <code class=\"language-plaintext highlighter-rouge\">VLAN_3</code>엔 <code class=\"language-plaintext highlighter-rouge\">Fa0/3</code> 과 <code class=\"language-plaintext highlighter-rouge\">Fa0/4</code> 포트를 배정시킨다.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch#enable\nSwitch#config terminal\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#interface fa0/1\nSwitch(config-if)#switchport mode access\nSwitch(config-if)#switchport access vlan 2\n</code></pre></div></div>\n\n<ul>\n  <li>inteface fa0/1 : 인터페이스 모드 진입</li>\n  <li>switchport mode access : 해당 포트를 VLAN 전용으로 사용함을 선언</li>\n  <li>switchport access vlan 2 : 해당 포트가 속한 VLAN 번호 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@GEPhJ/btsMcd0ZUA9/NJfHXH7fr603Pozrp0XUN1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:779,”style”:”alignCenter”,”width”:697,”height”:424,”caption”:”결과”}_#][#_Image</td>\n      <td>kage@ZktHy/btsMceFDArB/GmkkKk7xrFmJK5XI7GNxS1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:975,”style”:”alignCenter”,”width”:686,”height”:523}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"vlan-통신-테스트\">VLAN 통신 테스트</h2>\n\n<ol>\n  <li><code class=\"language-plaintext highlighter-rouge\">192.168.0.1</code> to <code class=\"language-plaintext highlighter-rouge\">192.168.0.2</code>\n    <ul>\n      <li>같은 VLAN 내에서는 통신 가능</li>\n    </ul>\n  </li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@BqqF9/btsMceevW1X/38cHtm9y7VtBM8yRsEMKb1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:742,”originHeight”:340,”style”:”alignCenter”,”width”:653,”height”:299}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li><code class=\"language-plaintext highlighter-rouge\">192.168.0.1</code> to <code class=\"language-plaintext highlighter-rouge\">192.168.0.2</code></li>\n</ol>\n\n<ul>\n  <li>다른 VLAN 끼리는 통신 불가능</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@905VT/btsMcKD1XhO/HVQpVtHJXEQCpfTAUkHWYk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1060,”originHeight”:502,”style”:”alignCenter”,”width”:668,”height”:316}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"vlanvirtual-lan-case-2--switch-여러-개\">VLAN(Virtual LAN) (case 2 : Switch 여러 개)</h2>\n\n<ul>\n  <li>그렇다면 네트워크를 확장하고 좀 더 현실적인 아키텍쳐로 바뀌면 어떨까?</li>\n  <li>먼저 Switch를 하나 더 두어보자.</li>\n  <li><em>들어가기전</em>\n    <ul>\n      <li>VLAN 설정 자체는 IP 주소를 직접 변경하지 않는다.\n        <ul>\n          <li>VLAN은 Layer 2(데이터 링크 계층)에서 작동하는 반면,<br />\nIP 주소는 Layer 3(네트워크 계층)에서 작동하기 때문.</li>\n        </ul>\n      </li>\n      <li>그러나, 실제 네트워크 운영에서는 일반적으로 각 VLAN마다 서로 다른 IP 대역을 할당한다.\n        <ul>\n          <li>네트워크 관리와 보안을 위한 설계</li>\n        </ul>\n      </li>\n      <li>그러므로 VLAN 별로 다른 대역을 할당해보자.\n        <ul>\n          <li>VLAN 2: 203.237.20.nnn</li>\n          <li>VLAN 3: 203.237.30.nnn</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@pcw1H/btsMc0NoTlz/v9c56wkkpb2qWxKk6BEsq0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1031,”originHeight”:1000,”style”:”alignCenter”,”width”:680,”height”:660}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 0 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@d5TDWZ/btsMekcZbAx/1meC8Kjg2Niht4JKNpWjE1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:325,”style”:”alignCenter”,”width”:757,”height”:192}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 1 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bxI7Ez/btsMcsXSPgC/McV65YvUN8ELGhZbpqxaEK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:336,”style”:”alignCenter”,”width”:750,”height”:197}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>여기서 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>🤔 과연 PC2는 PC0과 통신이 가능할까?\n    <ul>\n      <li>결과를 보면, PC1과는 통신이 가능하지만, 다른 스위치로 넘어가면서 통신이 불가능해진다</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cdqmkw/btsMeSmNMeI/jnvpXenhi6dV8W4U8oGWaK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:994,”originHeight”:806,”style”:”alignCenter”,”width”:664,”height”:538}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>이런 논리적인 흐름의 질문이 든다.\n    <ol>\n      <li>오히려 VLAN 설정하기 전에 그냥 여러 스위치를 건너 뛰어도 통신이 됐음.</li>\n      <li>그리고 같은 VLAN 끼리는 통신이 된다고 했다.</li>\n      <li>그런데 갑자기 같은 VLAN에서 여러 스위치를 건너뛰면 왜 통신이 안될까?</li>\n    </ol>\n  </li>\n  <li>여기서 <strong>VLAN 태그</strong>라는 개념이 등장한다.\n    <ul>\n      <li>VLAN을 설정하면 각 패킷에는 특별한 VLAN ID가 붙게 된다.\n        <ul>\n          <li>(마치 우편물에 부서명을 적는 것과 같다.)</li>\n        </ul>\n      </li>\n      <li>일반적인 스위치의 Port(Access Port)는 VLAN 태그를 처리하는 방법에 대해 1가지 밖에 모른다.\n        <ul>\n          <li>PACKET 들어올 때 : 자신의 VLAN 번호를 태그로 붙인다.</li>\n          <li>PACKET 나갈 때 : 태그를 제거하고 보낸다.</li>\n        </ul>\n      </li>\n      <li>그럼 여기서 문제가 발생한다.\n        <ul>\n          <li>PC2에서 나온 패킷\n            <ul>\n              <li>Switch 0으로 들어올 때 : fa0/2에서 VLAN 2 태그를 붙임</li>\n            </ul>\n          </li>\n          <li>이 패킷이 fa0/5로 가면서 VLAN 1의 통신으로 취급됨 [VLAN 2 태그가 떨어짐]</li>\n          <li>다른 스위치의 fa0/3에 도착했을 때도 VLAN 1의 통신으로 인식됨</li>\n          <li>결과적으로 원래의 VLAN 2 통신이 의도대로 전달되지 못함.</li>\n        </ul>\n      </li>\n      <li>[즉, <strong>Switch0의 fa0/와 Switch1의 fa0/3이 VLAN 1이기 때문</strong>]</li>\n    </ul>\n  </li>\n</ul>\n\n<p>→ <strong>스위치 간 VLAN 전용 통로가 필요하다!</strong></p>\n\n<h2 id=\"트렁크trunk\">트렁크(Trunk)</h2>\n\n<p>[먼저 PC2가 PC0과 통신이 가능하도록 해결해보자]</p>\n\n<ul>\n  <li>Switch0과 Switch1간에 VLAN 2,3 전용 포트 따로 설정!</li>\n  <li>switch0의 fa0/5, fa0/6을 각각 VLAN 2,3 전용으로 설정</li>\n  <li>switch1의 fa0/3, fa0/4를 각각 VLAN 2,3 전용으로 설정</li>\n  <li>Switch 0 포트의 VLAN 상태</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b3x84T/btsMei0AEyD/DYcMw88NkSnY9eQ8B22zcK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1154,”originHeight”:64,”style”:”alignCenter”,”width”:699,”height”:39}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 1 포트의 VLAN 상태</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@URbjM/btsMdIyMTr2/uZ7hOtRQPSYbugPuyZe3s1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1064,”originHeight”:74,”style”:”alignCenter”,”width”:731,”height”:51}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC2에서 PC0로 통신이 가능하다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@AcI9Y/btsMeveoKpG/MRkQDsbDHXP76MV9pLzZR0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:956,”originHeight”:432,”style”:”alignCenter”,”width”:727,”height”:329}_#][#_Image</td>\n      <td>kage@cav9Br/btsMdpMVs7n/kO9tRv5kLVsRKP9bNXqDuK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:714,”originHeight”:510,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>그런데 또 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>🤔 과연 VLAN 별 통신 라인 추가가 바람직한 해결인가?\n    <ul>\n      <li>만약 VLAN이 수백개라면..?</li>\n      <li>일일이 연결해줄 수 없다</li>\n      <li>또한 추가 가능한 VLAN ID는 1000개.\n        <ul>\n          <li>→ <strong>Trunk</strong> 가 해결책</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"트렁크란\">트렁크란?</h2>\n\n<ul>\n  <li><strong>트렁크는 모든 VLAN 패킷을 하나의 포트로 통과시키는 것</strong></li>\n  <li>스위치 간 프레임 전달에 하나의 물리적 연결(포트)를 공유하는 것.</li>\n  <li>VLAN 트렁킹된 스위치들 간에 여러 VLAN에서 나온 프레임들을 이 트렁크를 통해 전달한다.</li>\n  <li>즉, 스위치와 스위치 간 프레임 전달 시 하나의 포트에 다수의 VLAN이 지나갈 수 있도록하는 링크.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch(config)#interface fa0/5\nSwitch(config-if)#switchport mode trunk\n\nSwitch(config-if)#\n%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to down\n\n%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to up\nexit\nSwitch(config)#exit\nSwitch#\n%SYS-5-CONFIG_I: Configured from console by console\nshow interface trunk\nPort        Mode         Encapsulation  Status        Native vlan\nFa0/5       on           802.1q         trunking      1\n\nPort        Vlans allowed on trunk\nFa0/5       1-1005\n\nPort        Vlans allowed and active in management domain\nFa0/5       1,2,3\n\nPort        Vlans in spanning tree forwarding state and not pruned\nFa0/5       none\n</code></pre></div></div>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cj9Kft/btsMcrLrqjC/NZkK8P615yIbq5LWFeBswk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:839,”style”:”alignCenter”,”caption”:”Switch0의 Fa0/5 포트 Trunk 설정”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li>Fa0/5가 트렁크 포트로 on (강제로 트렁크 모드로 설정) 되었다.</li>\n  <li>1~1005는 이론적으로 모든 VLAN 범위가 통과 가능하다.</li>\n  <li>실제 현재 사용 중인 VLAN : 1, 2, 3이 현재 활성화되어 있다.</li>\n  <li>Vlans in spanning tree forwarding state and not pruned : None<br />\n(활성화된 VLAN들이 여기 나타나야 한다. - 없다.)</li>\n</ol>\n\n<ul>\n  <li>Fa0/5 포트는 Native VLAN이 1로 설정됨</li>\n  <li>반대편 Fa0/3 포트는 Native VLAN이 2로 설정됨\n    <ul>\n      <li>Switch1의 Fa0/3 포트도 Trunk로 설정해준다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@kzW3S/btsMec7cVIK/IBXxcLCh7BYeCYd9J2nScK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1136,”originHeight”:414,”style”:”alignCenter”,”width”:654,”height”:238}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>물론 PC2에서 PC0로 통신이 가능해졌다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bryfWp/btsMcPE65aP/UGX9KHYfm1QMvME24buAtk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:956,”originHeight”:428,”style”:”alignCenter”,”width”:706,”height”:316}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"inter-vlan\">Inter-VLAN</h2>\n\n<ul>\n  <li>놓치면 안되는 것의 “<strong>기술의 도입에 대한 목적</strong>”이다.\n    <ul>\n      <li>VLAN의 목적은 가상의 LAN으로서 관리의 편리성 추구이며,<br />\n다른 VLAN과의 통신 제한이 아니다.</li>\n    </ul>\n  </li>\n  <li>그럼, 서로 다른 VLAN 간의 통신이 가능하도록 하는 방법은 없을까?</li>\n  <li>VLAN 간 통신을 하려면 라우터(게이트웨이)가 있어야 한다.\n    <ul>\n      <li>라우터를 경유하여 마치 다른 LAN으로 통신하는 것처럼 동작한다.</li>\n    </ul>\n  </li>\n  <li>[다른 네트워크 영역은 라우터가 필요!!!]</li>\n</ul>\n\n<h2 id=\"서브-인터페이스\">서브 인터페이스</h2>\n\n<ul>\n  <li>단순히 생각하면 이런 생각이 든다.</li>\n  <li>전통적인 라우터 방식: 각 VLAN마다 라우터의 물리적 인터페이스를 하나씩 사용</li>\n  <li>그러나 이런 생각의 전환을 해본다.\n    <ul>\n      <li><strong>하나의 물리적 라우터 인터페이스에 여러 개의 논리적 인터페이스를 생성하여 각각 다른 VLAN을 처리할 수 있도록 할 수 있다면?</strong></li>\n      <li>그런데, Fa0/0이라는 물리적 라우터 인터페이스에 어떻게 여러 개의 논리적 인터페이스를 생성할까?</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@Y1VKx/btsMeSUECM4/0Qz0wbAb4G4UBmT0SLhXYk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:260,”originHeight”:298,”style”:”alignCenter”,”width”:167,”height”:191}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>서브 인터페이스: 하나의 인터페이스에 여러 VLAN들의 인터페이스를 논리적으로 나누는 것</li>\n  <li>2811 모델을 추가해준다!\n    <ul>\n      <li>참고 :</li>\n      <li><em>2811 라우터는 Cisco의 중급 라우터로, Inter-VLAN 라우팅을 위한 서브인터페이스 구성을 지원합니다. 서브인터페이스란 하나의 물리적 인터페이스를 여러 개의 논리적 인터페이스로 나누어 사용할 수 있게 해주는 기능입니다. 이는 마치 하나의 도로를 여러 개의 차선으로 나누어 서로 다른 목적지로 가는 차들을 효율적으로 처리하는 것과 비슷합니다.</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p>1. fa0/0 활성화</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dysMoj/btsMcdzWje7/FkpECQDsjzhv7gtsA3SGI1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:846,”originHeight”:200,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>2. fa0/0.2 생성, VLAN2 연결, IP주소 할당 &amp; fa0/0.3 생성, VLAN3 연결, IP주소 할당</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b2QZaS/btsMb1M28tD/PwRCtfFGc9U9WdizCjU6pk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:691,”style”:”alignCenter”,”width”:790,”height”:426}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>3. switch1 fa0/4를 트렁크 모드로 설정</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bGoCk8/btsMdHT860Z/dwqr98u0ihaJDerscGQ7j1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1248,”originHeight”:546,”style”:”alignCenter”,”width”:718,”height”:314}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>4. Router의 서브 인터페이스 상태 확인</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bnyTgA/btsMevrWYog/pDkKHGHiWCNLKzR85a7Qn1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:219,”style”:”alignCenter”,”width”:819,”height”:140}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>5. 게이트웨이 설정</p>\n\n<p>- VLAN 2 (PC0, 1, 2) → 203.237.20.254</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bjr2GX/btsMey9WnrP/zNHfPdHwYlhyUSeIwsz6n0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:384,”style”:”alignCenter”,”width”:767,”height”:230}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>- VLAN 3 (Laptop0, 1, 2) → 203.237.30.254</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@9Pp8f/btsMcxY6pxv/toN6xYeoWLuqsvp1xIlJ90/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:606,”style”:”alignCenter”,”width”:773,”height”:366}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h1 id=\"스위치\">스위치</h1>\n\n<hr />\n\n<h2 id=\"스위치의-동작-원리\">스위치의 동작 원리</h2>\n\n<h2 id=\"mac-주소-테이블-동작-원리\">MAC 주소 테이블 동작 원리</h2>\n\n<ul>\n  <li>스위치와 노드들이 <strong>ARP</strong>를 통해 MAC 주소 정보를 지속적으로 교환한다.\n    <ul>\n      <li>ARP 프로토콜에 포함된 MAC 주소 정보를 기반으로 스위치의 MAC 주소 테이블이 구축된다.</li>\n      <li>실제 데이터 전송 (ping 등)이 발생하면, 이 MAC 주소 테이블을 참조하여 패킷을 적절한 포트로 전달</li>\n    </ul>\n  </li>\n  <li>MAC 주소 테이블은 네트워크 토폴리지 변화를 반영하기 위해 일정 주기로 초기화되며, 최신 정보로 동적 갱신된다.</li>\n</ul>\n\n<h2 id=\"arp란\">ARP란?</h2>\n\n<ul>\n  <li>IP 네트워크에서 IP 주소를 물리적인 MAC 주소로 변환하는 핵심 프로토콜</li>\n  <li>컴퓨터가 같은 네트워크 상의 다른 장치와 통신하려면 반드시 상대방의 MAC 주소를 알아야 하는데,<br />\nARP가 이 주소 변환 과정을 자동으로 처리해준다.</li>\n</ul>\n\n<h2 id=\"arp를-활용한-동작-원리\">ARP를 활용한 동작 원리</h2>\n\n<p><em>PC0에서 Laptop0으로 ping을 보낸다고 가정</em></p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cDoPQ4/btsMdLhTSuP/NdTWBqnwp8pAXYoKUrWZrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:988,”originHeight”:436,”style”:”alignCenter”,”width”:742,”height”:327}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li>ARP Request (PC0 → Switch0)\n    <ul>\n      <li>PC0이 Laptop0의 MAC 주소를 알아내기 위해 ARP 요청 패킷 전송</li>\n      <li>패킷 내용:\n        <ul>\n          <li>출발지: PC0의 IP 주소와 MAC 주소</li>\n          <li>목적지: Laptop0의 IP 주소 (MAC 주소는 미확인 상태)</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>스위치 <strong>브로드캐스트</strong> (Switch0 → 모든 노드)\n    <ul>\n      <li>Switch0은 PC0의 <strong>MAC 주소를 자신의 테이블에 기록</strong></li>\n      <li>수신한 ARP 요청 패킷을 모든 포트로 브로드캐스트</li>\n    </ul>\n  </li>\n  <li>ARP reply (Laptop0 → Switch0)\n    <ul>\n      <li>Laptop0이 자신의 IP 주소를 확인하고 ARP 응답 패킷 생성</li>\n      <li>패킷 내용:\n        <ul>\n          <li>출발지: Laptop0의 IP 주소와 MAC 주소</li>\n          <li>목적지: PC0의 IP 주소와 MAC 주소</li>\n        </ul>\n      </li>\n      <li>Laptop0은 PC0의 MAC 주소를 자신의 ARP 캐시에 저장</li>\n    </ul>\n  </li>\n  <li>스위치 전달 단계 (Switch0 → PC0)\n    <ul>\n      <li>Switch0은 수신한 응답 패킷을 PC0에게 전달</li>\n      <li>PC0과 Laptop0의 MAC 주소 정보를 MAC 주소 테이블에 저장</li>\n    </ul>\n  </li>\n  <li>통신 시작\n    <ul>\n      <li>PC0이 Laptop0의 MAC 주소를 획득하여 실제 데이터 통신 가능</li>\n    </ul>\n  </li>\n</ol>\n\n<h2 id=\"시뮬레이션\">시뮬레이션</h2>\n\n<ul>\n  <li>시뮬레이션을 눌러서 이벤트 목록창을 볼 수 있다.</li>\n  <li>편지봉투 모양의 [Add Simple PDU] → ICMP 패킷 전송 시뮬레이션</li>\n  <li>송신노드와 수신 노드를 클릭하고 Show All/None 클릭 후 ARP, ICMP 패킷만 클릭한다.</li>\n  <li><em>PC0에서 Laptop0으로 편지를 보낸다.</em></li>\n  <li>ARP - ICMP 순으로 통신이 이루어진다.</li>\n</ul>\n\n<h2 id=\"1-arp-패킷-분석\">1) ARP 패킷 분석</h2>\n\n<p>1. PC0 → Switch0 ARP Request</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cwVj4Z/btsMcHN0AZ1/QtiRKPTAkw5cwMHngIJq5K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:900,”originHeight”:1158,”style”:”alignCenter”,”width”:522,”height”:672}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>ARP\n    <ul>\n      <li>Source MAC<br />\n= PC0 의 MAC 주소</li>\n      <li>Source IP<br />\n= PC0의 IP 주소</li>\n      <li>Target MAC<br />\n= Laptop 의 MAC 주소 [모르는 주소]</li>\n      <li>Target IP<br />\n= Laptop0의 IP주소</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2. Switch0 → 모든 노드 (브로드캐스트)</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dvlpX3/btsMdr43c4X/YNHxFWmjmqgayudoXkG1l0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:818,”originHeight”:124,”style”:”alignCenter”,”width”:594,”height”:90}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch0은 수신한 ARP Request를 모든 포트로 전달</li>\n  <li>Switch0의 MAC 주소 테이블에 PC0의 정보 기록\n    <ul>\n      <li>포트 번호와 PC0의 MAC 주소 매핑</li>\n    </ul>\n  </li>\n</ul>\n\n<p>3. Laptop0→ Switch0 ARP Reply</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@K4KvV/btsMcdUawiw/VpUysCPR5W9T4yYTKTcqJK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1002,”originHeight”:1242,”style”:”alignCenter”,”width”:627,”height”:777}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>ARP\n    <ul>\n      <li>Source MAC<br />\n= Laptop0 의 MAC 주소</li>\n      <li>Source IP<br />\n= Laptop0의 IP 주소</li>\n      <li>Target MAC<br />\n= PC0 의 MAC 주소</li>\n      <li>Target IP<br />\n= Laptop0의 IP주소</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"2-icmp-패킷-분석\">2. ICMP 패킷 분석</h2>\n\n<ol>\n  <li>PC → Laptop</li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@6AWAV/btsMdMA4Jmh/dd2ilCfmHRbqRt9DFVNWhK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2056,”originHeight”:1186,”style”:”alignCenter”,”width”:690,”height”:398}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>SRC ADDR = PC0의 MAC 주소</li>\n  <li>DEST ADDR = Laptop0의 MAC 주소</li>\n</ul>\n\n<h2 id=\"3-switch0의-mac-주소-테이블-변화\">3) Switch0의 MAC 주소 테이블 변화</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dEbxME/btsMdnn7IXG/koFfWfejqCW9bxxbzaYPb0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1080,”originHeight”:611,”style”:”alignCenter”,”width”:747,”height”:423}_#][#_Image</td>\n      <td>kage@WjEAg/btsMdmbIixx/in3AqgZZ7OkLwPpGkcb270/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1080,”originHeight”:734,”style”:”alignCenter”,”width”:727,”height”:494}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>위를 보니 Fa0/1 Fa0/4에 연결된 PC0과 Laptop0의 MAC 주소가 테이블에 기재되었다.</li>\n</ul>\n\n<p>🤔 갑자기 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>Switch0 → 모든 노드로 BroadCast할 때 각자의 MAC 주소 받아오면 되는거 아닌가?</li>\n  <li>해답은 ARP를 이용해 MAC 주소 테이블이 어떻게 유지하는지의 방법에 있다.\n    <ul>\n      <li>스위치의 MAC 주소 학습은 ‘출발지(Source) MAC 주소’만을 대상으로 한다.\n        <ul>\n          <li>PC0이 ARP Request를 보낼 때</li>\n          <li>Laptop0이 ARP Reply를 보낼 때</li>\n        </ul>\n      </li>\n      <li>모든 노드로 전달된 ARP-Request 패킷에 대해 수신 노드가 아니면 응답하지 않는다.</li>\n      <li>PC1과 Laptop1은 Swtich0이 전달한 ARP-Request에 대해 Reply 하지 않는다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>그런데 이런 ‘고민’도 떠오른다.</p>\n\n<p>1.효율성</p>\n\n<ul>\n  <li>ARP는 매우 짧은 시간 간격으로 반복 실행한다.\n    <ul>\n      <li>노드들이 많은 네트워크에서는 통신량으로 부하 가중</li>\n      <li>특히 스위치가 모든 노드에게 BroadCast하는 ARP-Request에서</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2. 보안상의 문제</p>\n\n<ul>\n  <li>Laptop1이 악의적인 공격자라고 가정해보자.\n    <ul>\n      <li>ARP Reply가 실제로 해당 IP 주소를 가진 정당한 장치에서 온 것인지 확인하지 않는다. (보안 X)</li>\n      <li>이 때 Laptop0의 IP에 Laptop1 MAC 주소를 실어서 Reply한다면?</li>\n      <li>테이블이 제대로 갱신되기 전까지 PC0은 Laptop0인 줄 알고 모든 패킷을 보낸다.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"vlan을-통한-해결\">VLAN을 통한 해결</h2>\n\n<ul>\n  <li>MAC 주소를 이용한 라우팅\n    <ul>\n      <li>동일한 네트워크(LAN)에서 스위치를 통해서만 발생한다.</li>\n      <li>라우터를 통한 외부 네트워크로의 통신에는 사용되지 않는다.\n        <ul>\n          <li>ARP 패킷은 하나의 네트워크에서만 송수신한다.</li>\n          <li>LAN을 논리적으로 분리된 가상의 VLAN으로 관리한다.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h1 id=\"라우터\">라우터</h1>\n\n<hr />\n\n<h2 id=\"라우터란\">라우터란?</h2>\n\n<ul>\n  <li>라우터는 서로 다른 네트워크를 연결하는 3계층 장비.</li>\n  <li>IP 주소를 기반으로 패킷의 최적 경로를 결정하고 전달한다.\n    <ul>\n      <li>스위치가 같은 네트워크 내에서 MAC 주소를 기반으로 통신을 담당한다면,</li>\n      <li>라우터는 서로 다른 네트워크 간의 통신을 가능하게 만드는 일종의 ‘네트워크 간의 다리’ 역할을 한다.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"라우터의-mode\">라우터의 Mode</h2>\n\n<ul>\n  <li><strong>사용자 모드(User EXEC Mode)</strong>\n    <ul>\n      <li>기본적인 정보 조회만 가능, 설정 변경 불가</li>\n      <li>&gt; 로 표시</li>\n    </ul>\n  </li>\n  <li><strong>관리자 모드(Privileged EXEC Mode)</strong>\n    <ul>\n      <li>라우터 설정을 변경할 순 없지만 시스템 정보 상세조회 가능</li>\n      <li># 으로 표시</li>\n    </ul>\n  </li>\n  <li><strong>글로벌 모드(Global Configuration Mode)</strong>\n    <ul>\n      <li>라우터 설정(이름, 보안, 인터페이스 등)을 변경</li>\n      <li>(config)# 로 표시</li>\n      <li><strong>라인 모드(Line Configuration Mode)</strong>\n        <ul>\n          <li>콘솔, 원격 접속(Telnet, SSH 등) 관련 설정 변경</li>\n          <li>(config-line)# 로 표시</li>\n        </ul>\n      </li>\n      <li><strong>인터페이스 모드(Interface Configuration Mode)</strong>\n        <ul>\n          <li>라우터의 네트워크 인터페이스(이더넷, 시리얼 등) 설정을 변경</li>\n          <li>라우터의 인터페이스에 IP 주소를 설정하고 활성화/비활성화</li>\n          <li>(config-if)# 로 표시</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"목표-네트워크-구성\">목표 네트워크 구성</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@FrASQ/btsMeLVCXVC/1wKsZjYPW9BikRxL7DFtC1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:813,”originHeight”:495,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"기본-설정\">기본 설정</h2>\n\n<ul>\n  <li>라우터 3대: [Network Devices] → [Routers] → [2811]</li>\n  <li>스위치 1대 : [Network Devices] → [Switches] → [2960]</li>\n  <li>PC 3대, 노트북 1대, 서버 1대 : [End Devices] → [PC], [Laptop], [Server]</li>\n</ul>\n\n<h2 id=\"라우터---시리얼-인터페이스-장착\">라우터 - 시리얼 인터페이스 장착</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@zgPDU/btsMd3bDPMR/E6TXH94lrMz3OrUR6TF5hK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:1293,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC와 달리 두 라우터 간에 데이터를 주고받기 위한 동기화가 필요</li>\n  <li>FastEthernet이 아닌 Serial 인터페이스를 사용하므로 모듈을 추가해야 한다.\n    <ul>\n      <li>HWIC-2T 추가</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"노드-간-연결하기\">노드 간 연결하기</h2>\n\n<ul>\n  <li>Laptop0은 통신용이 아니라 Router0을 설정하기 위한 콘솔\n    <ul>\n      <li>FastEthernet 케이블이 아닌 RS232(하늘색) 케이블로 연결</li>\n    </ul>\n  </li>\n  <li>라우더들끼리 Serial DCE 연결\n    <ul>\n      <li>먼저 클릭한 쪽에 시계 모양 - 두 라우터 간 데이터를 주고받기 위한 동기화가 필요</li>\n      <li>Serial DCE(Data Communication Equipment): 시간 동기화를 주도하는 노드 (시계 있는 쪽)</li>\n      <li>Serial DTE(Data Terminal Equipment): 그에 따라 동기화하는 노드 (시계 없는 쪽)</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@evpmpX/btsMdMnzPql/PLX7aieEhAKMJ6N99C2j5K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2184,”originHeight”:1246,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"ip-설정\">IP 설정</h2>\n\n<ul>\n  <li>컴퓨터들은 203.237.nnn.nnn/24 사용(C클래스)\n    <ul>\n      <li>1번부터 시작</li>\n    </ul>\n  </li>\n  <li>원격 관리가 필요한 스위치나 서버는 100번 부터</li>\n  <li>라우터는 광역의 랜들을 연결하므로 A클래스 IP 사용\n    <ul>\n      <li>규모가 작아 30비트 서브넷 마스크를 사용하여 최대 4개의 라우터를 묶을 수 있도록</li>\n    </ul>\n  </li>\n  <li>스위치는 2계층 장비\n    <ul>\n      <li>IP 주소 설정 불필요</li>\n      <li>원격 접속으로 스위치 관리\n        <ul>\n          <li>IP 주소 할당 필요</li>\n          <li>VLAN1에 할당</li>\n        </ul>\n      </li>\n      <li>스위치 IP 주소 설정</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bk8xpK/btsMd7Sxxul/dQMOVhudaYmzsa519EoeQK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1374,”originHeight”:164,”style”:”alignCenter”,”width”:635,”height”:76}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>총 6개의 LAN</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@UGTSj/btsMcKRyRRh/QFOQKnpr0nm0a6K8eUWWKk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1762,”originHeight”:1000,”style”:”alignCenter”,”width”:698,”height”:396}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"연결-확인\">연결 확인</h2>\n\n<ul>\n  <li>PC0에서 테스트</li>\n</ul>\n\n<ol>\n  <li>PC0 로컬 호스트(127.0.0.1)</li>\n  <li>PC0 → Switch1(VLAN1, 203.237.10.100)</li>\n  <li>PC0 → Server0(203.237.10.101)</li>\n  <li>PC0 → Router0(203.237.10.254)\n    <ul>\n      <li>모두 통신 성공</li>\n    </ul>\n  </li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@s9v2J/btsMcYPw7T1/QedNlAylJ9wAnApW81hp3K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1000,”originHeight”:1605,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>5. PC0 → PC2(203.237.30.1)</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@mi021/btsMdHGFlHG/cChGsiN9Pw0rWY0kG0w7q1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:996,”originHeight”:374,”style”:”alignCenter”,”width”:684,”height”:257}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><strong>unreachable</strong> 이 발생한다\n    <ul>\n      <li>PC0으로 부터 받은 패킷을 Router0이 어느 인터페이스로 보내야할지 모르기 때문</li>\n      <li>→ <strong>라우팅 테이블</strong>이 필요하다</li>\n      <li>아래는 Router0의 라우팅 정보</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@beagrf/btsMdMujNSG/uzGad36EzxcCPqRZ3PJy21/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1260,”originHeight”:698,”style”:”alignCenter”,”width”:746,”height”:413}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"정적-라우팅-설정\">정적 라우팅 설정</h2>\n\n<ul>\n  <li>정적 라우팅 대상\n    <ul>\n      <li>1번 PC0 입장에서 목적지가\n        <ul>\n          <li><strong>2번</strong> 네트워크(203.237.20.nnn/24)인 패킷 : serial0/3/0 (혹은 1.1.1.2)</li>\n          <li><strong>3번</strong> 네트워크(203.237.30.nnn/24)인 패킷 : serial0/3/1 (혹은 2.2.2.2)</li>\n          <li>6번 네트워크(3.3.3.nnn/30)인 패킷 : serial0/3/0 혹은 serial0/3/1</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>Router1의 정적 라우팅 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@JLnX1/btsMckFDkMJ/ik8vROKAHLaZQPxINyMSmK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1226,”originHeight”:442,”style”:”alignCenter”,”width”:694,”height”:250}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Router2의 정적 라우팅 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@k4yPj/btsMexiTcvl/Ewo59hWdxO2tOqMp9GTtNK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1248,”originHeight”:504,”style”:”alignCenter”,”width”:736,”height”:297}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Router3의 정적 라우팅 설정 + route 확인</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cnu0SN/btsMdH0043d/jjkekr1KEkmqtXM0E7LRUK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1270,”originHeight”:1186,”style”:”alignCenter”,”width”:756,”height”:706}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"통신테스트-by-ping\">통신테스트 by ping</h2>\n\n<ul>\n  <li>PC0 ↔ PC1</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dD0uXu/btsMb0Hnvj9/50DKkNchVlTaBfBiYNEMiK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:962,”originHeight”:422,”style”:”alignCenter”,”width”:730,”height”:320}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC0 ↔ PC2</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cEoaLU/btsMdGgIz36/93lJ36D1HjrKK9gQaOKvb1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:432,”style”:”alignCenter”,”width”:780,”height”:350}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h1 id=\"방화벽---네트워크-구성\">방화벽 - 네트워크 구성</h1>\n\n<hr />\n\n<h2 id=\"망구성\">망구성</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@kO9qL/btsMengxOIb/FFIVXRjKkeW6JnSOKHGXqk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:524,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"asa0-구성-설정\">ASA0 구성 설정</h2>\n\n<p>1. 인터페이스 통신 상태</p>\n\n<ul>\n  <li>내부망 : 통신 가능</li>\n  <li>외부망 : 통신 불가\n    <ul>\n      <li>inPC → outPC 불가능</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bh2bBN/btsMd7rqkl0/g4AYl1hwkqpXZ1NDwCwO30/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1278,”originHeight”:266,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>2. IP 주소 설정</p>\n\n<ul>\n  <li>Inside : 설정됨</li>\n  <li>outside : 설정되어있지 않음\n    <ul>\n      <li>→ VLAN에서 203.237.20.253으로 설정</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cormPm/btsMc1r1E8A/LKXIkkQ8YcBwbHGgFGWQIk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1406,”originHeight”:342,”style”:”alignCenter”,”width”:807,”height”:196}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>3. Config 확인</p>\n\n<ul>\n  <li>내부망 Security-level : 100</li>\n  <li>외부망 Security-level : 0</li>\n  <li>보안 레벨이 높은 곳 → 낮은 곳 : 허용 (반대는 불가능)</li>\n  <li>내부망 노드들은 DHCP를 이용하여 IP 할당받는다.</li>\n</ul>\n\n<h2 id=\"inpc-dhcp-설정\">inPC DHCP 설정</h2>\n\n<ul>\n  <li>inPC는 ASA가 DHCP로 주소를 할당해준다고 했다.\n    <ul>\n      <li>게이트웨이는 ASA0 inside의 ip 주소로 고정된다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@HAypL/btsMemIHLU2/tcja6hVK1aurUDoEGiKLAK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1388,”originHeight”:636,”style”:”alignCenter”,”width”:703,”height”:322}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>outPC는 고정 주소 사용 중</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@lNS8u/btsMdHzVPu4/iHvbzNmifAq1gElLiDlpW1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1304,”originHeight”:546,”style”:”alignCenter”,”width”:707,”height”:296}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"router0-설정\">Router0 설정</h2>\n\n<ul>\n  <li>fa0/0 IP 설정 &amp; 활성화\n    <ul>\n      <li>203.237.10.254/24</li>\n    </ul>\n  </li>\n  <li>fa0/0 IP 설정 &amp; 활성화\n    <ul>\n      <li>203.237.20.253/24</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"rna-설정\">RNA 설정</h2>\n\n<h2 id=\"routing\">Routing</h2>\n\n<ul>\n  <li>라우터의 정적라우팅\n    <ul>\n      <li>네트워크 디바이스들이 서로 다른 네트워크에 있을 때, 그들 사이의 통신 경로를 명확히 지정해줘야 한다.</li>\n      <li>예를 들어, 내부 네트워크의 PC가 다른 네트워크의 서버와 통신하려면, 그 경로를 알아야 한다.</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">ip route &lt;목적지 네트워크 주소&gt; &lt;목적지 서브넷 마스크&gt; &lt;다음 홉 IP 주소/출구 인터페이스&gt;</code></li>\n    </ul>\n  </li>\n  <li>방화벽의 정적라우팅\n    <ul>\n      <li>트래픽이 반드시 방화벽을 통과하도록 하여 보안 정책을 적용할 수 있게 한다.</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">route &lt;VLAN명&gt; &lt;외부망 네트워크 주소&gt; &lt;외부망 서브넷마스크&gt; &lt;다음 홉 IP 주소&gt;</code></li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@UMo4w/btsMemPruKw/su6TBN30w2NLPGdTiu8nN0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2110,”originHeight”:1000,”style”:”alignCenter”,”width”:734,”height”:348}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>→ 어떤 목적지 주소를 갖는 패킷이든 외부망의 Router0인 203.207.20.254로 전송한다.</p>\n\n<ul>\n  <li>통신확인</li>\n  <li>inPC ↔ ASA0</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@ea7sUx/btsMcHURKDV/D3ikyzQhpSkEa8QCBP2sK1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:972,”originHeight”:428,”style”:”alignCenter”,”width”:708,”height”:312}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>inPC ↔ outPC</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b7mUIE/btsMcfqYrdM/SvtR3wkJNdKRzXgHMUMtIK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:986,”originHeight”:368,”style”:”alignCenter”,”width”:702,”height”:262}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"nat\">NAT</h2>\n\n<ul>\n  <li>inPC → outPC 까지는 패킷 전달이 잘 되지만,</li>\n  <li>Router0 → ASA0으로 전달이 되지 않는다.</li>\n</ul>\n\n<p><strong>outPC → Router1로 전달되는 패킷</strong></p>\n\n<ul>\n  <li>outPC(203.237.10.10)가 inPC(192.168.1.5)로 통신을 시도할 때, Router는 문제에 직면한다.\n    <ul>\n      <li>목적지 주소가 사설IP이기 때문에 외부에서 인식이 불가능하다.</li>\n      <li>→ Rotuer 입장에서 어디로 보내야 할 지 모른다.\n        <ul>\n          <li>(마치 동 호수만 알고, 택배 기사가 서울에서 배달을 하려는 상황과 마찬가지)</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@xD2B6/btsMeR9g8xQ/eG7q1kOXNaBGJdcSFREQoK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2080,”originHeight”:1270,”style”:”alignCenter”,”width”:783,”height”:478}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>⇒ ASA가 사설 IP를 공인 IP로 변경해서 보내줘야 한다.</li>\n  <li>ASA의 <strong>NAT</strong></li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@tUl9o/btsMeRVJT2O/PJFvZxKK7bVxaO8Vexhkt0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:414,”originHeight”:143,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>들어오는 패킷의 처리\n    <ul>\n      <li>외부 노드들은 내부 네트워크의 실제 사설 IP를 알 필요가 없다.\n        <ul>\n          <li>대신 ASA의 공인 IP 주소로 통신을 시도</li>\n        </ul>\n      </li>\n      <li>ASA는 NAT 테이블을 유지하면서, 어떤 외부 통신이 어떤 내부 노드를 위한 것인지 추적</li>\n      <li>수신된 패킷의 목적지 주소를 적절한 내부 사설 IP로 변환하여 전달</li>\n    </ul>\n  </li>\n  <li>나가는 패킷의 처리\n    <ul>\n      <li>내부 노드가 외부로 통신을 시도할 때, ASA는 출발지의 사설 IP를 자신의 공인 IP로 변환</li>\n      <li>이 과정에서 ASA는 어떤 내부 노드가 어떤 통신을 시작했는지 NAT 테이블에 기록</li>\n      <li>나중에 응답이 돌아오면, 이 테이블을 참조하여 올바른 내부 노드에게 전달</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"nat-설정\">NAT 설정</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@czZH5n/btsMc0fu60D/gU0ev4kVhViqehGSDDt6K0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1220,”originHeight”:196,”style”:”alignCenter”,”width”:742,”height”:119}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>in2out 객체 생성 (네트워크 객체 모드)</li>\n  <li>대상 서브넷을 지정해준다.</li>\n  <li>NAT 지정\n    <ul>\n      <li>내외부망을 연결하는 (inside, outside)를 동적 매핑</li>\n      <li>공인 Ip 주소는 인터페이스에 할당된 IP 주소를 사용한다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@ccZXOd/btsMcjzZe4x/9s6nimQ80LBoH1dkmToAWK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:942,”originHeight”:138,”style”:”alignCenter”,”width”:676,”height”:99}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>그래도 inPC → outPC의 통신이 실패하게 된다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bajXRR/btsMcZgFpCY/BFAnMrFdvAP1aAJVnNh9z0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:600,”originHeight”:157,”style”:”alignCenter”,”width”:524,”height”:137}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"acl\">ACL</h2>\n\n<ul>\n  <li>패킷을 보면 목적지 주소는 공인 IP 주소로 정확히 설정되어 있으나,</li>\n  <li>외부망에서 내부망으로 들어오는 트래픽의 흐름을 방화벽이 모두 Block하고 있기 때문</li>\n  <li><strong>즉, 인터페이스마다 어떤 출발지 &amp; 어떤 목적지 를 가지는 트래픽을 허용 / 거부 할 것인지 정의해줘야 한다.</strong></li>\n  <li>→ ACL : 이러한 Allow/Deny 접근 제어 목록</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>access-list &lt;ACL명&gt; &lt;타입&gt; &lt;동작&gt; &lt;프로토콜&gt; &lt;출발지&gt; &lt;목적지&gt;\naccess-group &lt;ACL명&gt; &lt;트래픽&gt; &lt;인터페이스 키워드&gt; &lt;VLAN 명&gt;\n</code></pre></div></div>\n\n<ul>\n  <li>ACL 설정\n    <ul>\n      <li>모든 출발지에서 모든 목적지로 가는 ICMP(ping) 트래픽을 허용하는 규칙을 만든다.</li>\n      <li>만든 규칙을 외부 인터페이스의 인바운드 방향에 적용</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@eklCj3/btsMeUZeeor/0St67walf4cyejJZvVb2N0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1224,”originHeight”:300,”style”:”alignCenter”,”width”:767,”height”:188}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>inPC → outPC Ping 확인</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bMTQzA/btsMeyozeji/a8vxJ4pw0kExxZ6GUmDnRk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:962,”originHeight”:434,”style”:”alignCenter”,”width”:749,”height”:338}_#]</td>\n    </tr>\n  </tbody>\n</table>\n",
                        "tags": ["Network","PacketTracer","LAN","Switch","Router","Firewall","VLAN","Topology"]
                    }
                
            ],
        
            "Switch": [
                
                    {
                        "title": "Packet Tracer로 네트워크 이해하기",
                        "url": "/2025/02/08/packet-tracer-network.html",
                        "subtitle": "LAN 토폴로지, 스위치, 라우터, 방화벽",
                        "excerpt": "LAN 토폴로지와 스위치\n",
                        "author": "Jinho",
                        "date": "February 08, 2025",
                        "background": "/img/posts/network_topology.jpeg",
                        "content": "<h1 id=\"lan-토폴로지와-스위치\">LAN 토폴로지와 스위치</h1>\n\n<hr />\n\n<h2 id=\"packet-tracer에-들어가기-전\">Packet Tracer에 들어가기 전</h2>\n\n<p>먼저 네트워크의 기본 구성 요소부터 이해해보자.</p>\n\n<p><strong>라우터, 스위치, 엔드 디바이스(PC, 서버 등)가 어떻게 상호 작용</strong>하는지 알아보자.</p>\n\n<ul>\n  <li>가장 기본적인 두 대의 디바이스(<code class=\"language-plaintext highlighter-rouge\">PC</code>)가 있다고 가정해보자.</li>\n  <li>두 PC를 연결하고, IP 주소 설정, 서브넷 마스크 설정을 하고 ping 테스트를 통해 연결.\n    <ul>\n      <li>이 과정에서 TCP/IP의 기본 개념을 이해해보자.</li>\n    </ul>\n  </li>\n  <li>그 다음 단계로 <code class=\"language-plaintext highlighter-rouge\">스위치</code>를 추가하여 여러 대의 <code class=\"language-plaintext highlighter-rouge\">PC</code>를 연결.\n    <ul>\n      <li>L2 통신의 개념과 MAC 주소의 역할을 이해해보자.</li>\n    </ul>\n  </li>\n  <li>마지막으로 <code class=\"language-plaintext highlighter-rouge\">라우터</code>를 추가하여 서로 다른 네트워크 간의 통신을 구현.\n    <ul>\n      <li>라우팅 테이블, 게이트웨이 등의 개념을 학습해보자.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"사용법\">사용법</h2>\n\n<h2 id=\"pc\">PC</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@tdMGa/btsMchWsAbo/pXUJ5sc1Jn5zlePiDz1mrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:264,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>장치 타입 → End Devices → PC / LAPTOP 등 Drag &amp; Drop</li>\n</ul>\n\n<h2 id=\"switch\">Switch</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bdJ1mb/btsMedLRoGJ/cpMkbVJahG5gP3qwnew9Uk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:194,”originHeight”:256,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"router\">Router</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@A02nQ/btsMeKJcj9q/usIeZ7q3BDrYQHVk4TpOuk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:208,”originHeight”:276,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"connection\">Connection</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@rOlnO/btsMdkEVmv0/U1xgvAbp826OCElZjbp2Sk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:280,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>실선은 Copper Straight [PC - Switch/Router]</li>\n  <li>점선은 Copper Cross - Over [Switch/Router … Switch/Router]</li>\n  <li>번개 모양은 Automatic</li>\n</ul>\n\n<h2 id=\"기본-사용-방법\">기본 사용 방법</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@mamWH/btsMdM8WmZV/J6Eve21yZP8cKJkdv8KQrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:666,”originHeight”:558,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>장치(PC 와 Laptop)들을 놓는다.</li>\n  <li>각 디바이스 개수만큼 연결한 스위치 추가</li>\n  <li>실선과 점선으로 연결</li>\n  <li>스위치 0 → 메뉴에서 FastEthernet0/1 선택</li>\n  <li>PC 0 → 메뉴에서 FastEthernet0 선택</li>\n  <li>(나머지도 동일하게 연결)</li>\n  <li>왼쪽 스위치 : <code class=\"language-plaintext highlighter-rouge\">FastEthernet0/2</code> 오른쪽 스위치 : <code class=\"language-plaintext highlighter-rouge\">FastEthernet0/3</code></li>\n  <li>PC 클릭 → Desktop → IP Configuration → IP Address에 <code class=\"language-plaintext highlighter-rouge\">198.168.0.1</code><br />\nSubnet Mask에 <code class=\"language-plaintext highlighter-rouge\">255.255.255.0</code>\n    <ul>\n      <li>나머지 장치는 IP 주소 ~0.2, ~0.3 순으로 입력</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dhy2rZ/btsMczo0VIn/LHz5KS8UijOguFkFqLdSSk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:338,”style”:”alignCenter”,”width”:780,”height”:206}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Desktop → Command Prompt로 ping 테스트</li>\n  <li>작업 공간에서 Simulation 가능 [실제 이동 경로 &amp; 헤더 정보 등을 볼 수 있다.]</li>\n</ul>\n\n<h2 id=\"lan-topology\">LAN Topology</h2>\n\n<ul>\n  <li>같은 로컬 에이리어 네트워크 (LAN) 내에서 네트워크 장비와 디바이스들이 어떻게 물리적 혹은 논리적으로 연결되어 있는지 나타내는 구조</li>\n</ul>\n\n<h2 id=\"lan과-wan\">LAN과 WAN</h2>\n\n<ul>\n  <li><strong>LAN (로컬 영역 네트워크)</strong>:\n    <ul>\n      <li>제한된 지역 내에서 연결된 네트워크</li>\n      <li><strong>스위치</strong>는 MAC 주소를 사용하여 네트워크 내 장치들 간에 데이터를 전달합니다. 스위치는 <strong>MAC 주소 테이블</strong>을 사용해 데이터를 해당 장치로 정확하게 전달</li>\n    </ul>\n  </li>\n  <li><strong>WAN (광역 네트워크)</strong>:\n    <ul>\n      <li>더 넓은 지역, 심지어 전 세계적으로 연결된 네트워크\n        <ul>\n          <li>인터넷이 대표적인 WAN 예시</li>\n        </ul>\n      </li>\n      <li>WAN에서는 서로 MAC 주소를 알 수 없음</li>\n      <li>WAN에서 라우터는 <strong>IP 주소</strong>를 기반으로 데이터를 전달하는데, 각 네트워크 간의 경로를 찾기 위해 <strong>라우팅 테이블</strong>을 사용\n        <ul>\n          <li>NAT / PAT</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cyma1b/btsMcdGGX7j/3HjkxSXXuguLBaXiMCtKp1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:933,”style”:”alignCenter”,”width”:757,”height”:552}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"1-bus-형\">1) Bus 형</h2>\n\n<ul>\n  <li>하나의 메인 케이블(백본)에 모든 노드가 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>구조가 단순하고 설치 비용이 저렴</li>\n      <li>노드 추가/제거가 쉽고 유연함</li>\n      <li>케이블 길이가 짧아 경제적</li>\n      <li>소규모 네트워크에 적합</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>트래픽 증가 시 성능 저하</li>\n      <li>메인 케이블 장애 시 전체 영향</li>\n      <li>데이터 충돌 발생 가능</li>\n      <li>보안 취약점 존재</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cdwQWE/btsMctoZGjP/YoLinRs4T7sWM3Iv3xCkfK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1138,”originHeight”:650,”style”:”alignCenter”,”width”:690,”height”:394}_#][#_Image</td>\n      <td>kage@XghRi/btsMc2doIc4/cDKKGHIAwzkFizYIthmvX1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:978,”originHeight”:456,”style”:”alignCenter”,”width”:620,”height”:289}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"2-ring-형\">2) Ring 형</h2>\n\n<ul>\n  <li>각 노드가 양옆의 두 노드와 연결되어 원형을 이루는 구조</li>\n  <li>자동선택 기능을 사용한 링</li>\n  <li>장점 :\n    <ul>\n      <li>데이터 흐름이 일정하고 예측 가능</li>\n      <li>충돌이 적고 전송이 안정적</li>\n      <li>각 노드가 리피터 역할 수행</li>\n      <li>장거리 전송에 유리</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>단일 노드 장애가 전체에 영향</li>\n      <li>네트워크 확장이 제한적</li>\n      <li>설치/제거 시 네트워크 중단</li>\n      <li>양방향 링 구성 시 비용 증가</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@lYUdr/btsMetVb0e8/23KtOkSs1PeRKuNml0S2AK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1108,”originHeight”:642,”style”:”alignCenter”,”width”:598,”height”:346}_#][#_Image</td>\n      <td>kage@rYlFs/btsMeKWHZEC/wFs32hn23rG7rKA9WFyKxK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:982,”originHeight”:460,”style”:”alignCenter”,”width”:621,”height”:291}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"3-star-형\">3) Star 형</h2>\n\n<ul>\n  <li>중앙에 허브가 있고 모든 노드가 이 허브에 직접 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>구현과 유지보수가 단순하고 직관적</li>\n      <li>개별 노드 장애가 다른 노드에 영향 없음</li>\n      <li>높은 성능과 데이터 전송 속도</li>\n      <li>중앙 집중적 보안 관리 용이</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>중앙 허브 장애 시 전체 네트워크 마비 - 단일 장애 지점 (SPOF)</li>\n      <li>허브에 과부하 발생 가능</li>\n      <li>케이블 설치 비용이 높음</li>\n      <li>허브 용량에 따른 확장성 제한</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@NJ0T7/btsMdF26Hzf/aEmXKMDwoG1TwsmUekA04K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1088,”originHeight”:678,”style”:”alignCenter”,”width”:627,”height”:391}_#][#_Image</td>\n      <td>kage@vFDga/btsMcTgvpqn/IDhAPb27H9xt3kN9pDOB7k/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:456,”style”:”alignCenter”,”width”:585,”height”:277}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"4-mesh-형\">4) Mesh 형</h2>\n\n<ul>\n  <li>모든 노드가 서로 직접 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>높은 안정성과 이중화 구성</li>\n      <li>효율적인 트래픽 분산</li>\n      <li>우회 경로 확보로 신뢰성 높음</li>\n      <li>뛰어난 보안성</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>설치/유지보수 비용이 매우 높음</li>\n      <li>구현과 설정이 매우 복잡</li>\n      <li>케이블 연결 관리가 어려움</li>\n      <li>노드 수 증가에 따른 복잡도 급증</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bb9BX4/btsMeahgXHL/gVJ4LgKjyCG8M1I6DkkbP0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1070,”originHeight”:674,”style”:”alignCenter”,”width”:628,”height”:396}_#][#_Image</td>\n      <td>kage@ovOWb/btsMb2rFLwg/Qi0orK06gCRkfnrkBXhvyK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:432,”style”:”alignCenter”,”width”:677,”height”:303}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"5-tree-형\">5) Tree 형</h2>\n\n<ul>\n  <li>계층적 구조로, 상위 노드에서 하위 노드로 분기되는 형태</li>\n  <li>장점 :\n    <ul>\n      <li>네트워크 확장이 용이</li>\n      <li>체계적인 계층 구조 관리</li>\n      <li>하위 네트워크 독립성</li>\n      <li>효율적인 트래픽 관리</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>루트 노드 장애 시 전체 영향</li>\n      <li>계층 증가에 따른 관리 복잡성</li>\n      <li>상위 노드 병목 현상 가능</li>\n      <li>깊이가 깊어질수록 지연 증가</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@wounf/btsMcywRCH9/2KnaYgagHLQKp4cBdcumy0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:985,”style”:”alignCenter”,”width”:765,”height”:589}_#][#_Image</td>\n      <td>kage@dI6An5/btsMd4hh7vI/Gxr1Nv7uKXeDV0vrZs1qT0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:960,”originHeight”:458,”style”:”alignCenter”,”width”:642,”height”:306}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>192.168.0.1 to 192.168.0.12</li>\n</ul>\n\n<h2 id=\"vlanvirtual-lan-case-1--switch-1개\">VLAN(Virtual LAN) (case 1 : Switch 1개)</h2>\n\n<h2 id=\"vlan이란\">VLAN이란?</h2>\n\n<p>“<strong>논리적인 구조의 속임수로 같은 물리적 공간에 있는 네트워크를 다른 네트워크에 있는 것처럼 속이는 기술</strong>”</p>\n\n<ul>\n  <li>먼저, 물리적인 LAN을 먼저 생각해보면, 같은 건물이나 같은 층에 있는 컴퓨터들이 하나의 네트워크로 연결되어 있는 구조이다.</li>\n  <li>그런데 예를 들면, 마케팅팀과 개발팀이 다른 네트워크에 있어야 한다고 가정해보자.\n    <ul>\n      <li>전통적인 방식이라면 물리적으로 별도의 네트워크 장비와 케이블을 설치해야 했다.</li>\n      <li>하지만, VLAN은 이런 물리적 제약을 소프트웨어적으로 해결한다.</li>\n    </ul>\n  </li>\n  <li>하나의 물리적인 스위치를 마치 여러 개의 독립된 스위치처럼 동작하게 만드는 기술이다.</li>\n  <li>예를 들어, 같은 스위치에 연결된 컴퓨터라도 서로 다른 VLAN에 속하면 마치 다른 네트워크에 있는 것처럼 통신이 분리된다.</li>\n</ul>\n\n<h2 id=\"초기-default-vlan-설정\">초기 default VLAN 설정</h2>\n\n<ul>\n  <li>show vlan으로 확인해보자.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bTHrGF/btsMea2FcPL/VagNQtcNTnfvH7OWzcKevk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1250,”originHeight”:974,”style”:”alignCenter”,”width”:670,”height”:522}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>처음 VLAN 1은 ‘기본 VLAN’이다.</li>\n  <li>모든 스위치 포트는 처음에 이 VLAN 1에 속하도록 설정되어 있다.\n    <ul>\n      <li>그래서 별다른 설정 없이는 같은 물리적인 공간에 있다면 한 네트워크에 속하도록 설정이 된다.</li>\n    </ul>\n  </li>\n  <li>그리고 VLAN 1002부터 1005까지는 특별한 목적으로 예약된 VLAN이다. (사용 불가)\n    <ul>\n      <li>FDDI, 토큰링 등으로 고정되어 있다.</li>\n    </ul>\n  </li>\n  <li>우리가 새로운 VLAN을 할당하려고 하면 “2 ~ 1001” 의 VLAN을 사용해서 나누면 된다.</li>\n</ul>\n\n<h2 id=\"vlan-구성하기\">VLAN 구성하기</h2>\n\n<ul>\n  <li>먼저 VLAN 2개를 생성한다.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch#enable\nSwitch#config terminal\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#vlan 2\nSwitch(config-if)#name VLAN_2\nSwitch(config-if)#exit\n</code></pre></div></div>\n\n<ul>\n  <li>enable : 관리자 모드 진입</li>\n  <li>config terminal : 글로벌 모드 진입</li>\n  <li>vlan 2 : vlan 모드 진입</li>\n  <li>name <이름> : 진입되어 있는 vlan의 이름 설정</이름></li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dsQlbd/btsMdqdX0ps/kPhix6BIWT0KDKtVJzq3NK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1185,”originHeight”:1000,”style”:”alignCenter”,”width”:734,”height”:619}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>결과</p>\n\n<ul>\n  <li>그리고, <code class=\"language-plaintext highlighter-rouge\">VLAN_2</code>엔 <code class=\"language-plaintext highlighter-rouge\">Fa0/1</code> 과 <code class=\"language-plaintext highlighter-rouge\">Fa0/2</code>, <code class=\"language-plaintext highlighter-rouge\">VLAN_3</code>엔 <code class=\"language-plaintext highlighter-rouge\">Fa0/3</code> 과 <code class=\"language-plaintext highlighter-rouge\">Fa0/4</code> 포트를 배정시킨다.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch#enable\nSwitch#config terminal\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#interface fa0/1\nSwitch(config-if)#switchport mode access\nSwitch(config-if)#switchport access vlan 2\n</code></pre></div></div>\n\n<ul>\n  <li>inteface fa0/1 : 인터페이스 모드 진입</li>\n  <li>switchport mode access : 해당 포트를 VLAN 전용으로 사용함을 선언</li>\n  <li>switchport access vlan 2 : 해당 포트가 속한 VLAN 번호 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@GEPhJ/btsMcd0ZUA9/NJfHXH7fr603Pozrp0XUN1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:779,”style”:”alignCenter”,”width”:697,”height”:424,”caption”:”결과”}_#][#_Image</td>\n      <td>kage@ZktHy/btsMceFDArB/GmkkKk7xrFmJK5XI7GNxS1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:975,”style”:”alignCenter”,”width”:686,”height”:523}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"vlan-통신-테스트\">VLAN 통신 테스트</h2>\n\n<ol>\n  <li><code class=\"language-plaintext highlighter-rouge\">192.168.0.1</code> to <code class=\"language-plaintext highlighter-rouge\">192.168.0.2</code>\n    <ul>\n      <li>같은 VLAN 내에서는 통신 가능</li>\n    </ul>\n  </li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@BqqF9/btsMceevW1X/38cHtm9y7VtBM8yRsEMKb1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:742,”originHeight”:340,”style”:”alignCenter”,”width”:653,”height”:299}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li><code class=\"language-plaintext highlighter-rouge\">192.168.0.1</code> to <code class=\"language-plaintext highlighter-rouge\">192.168.0.2</code></li>\n</ol>\n\n<ul>\n  <li>다른 VLAN 끼리는 통신 불가능</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@905VT/btsMcKD1XhO/HVQpVtHJXEQCpfTAUkHWYk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1060,”originHeight”:502,”style”:”alignCenter”,”width”:668,”height”:316}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"vlanvirtual-lan-case-2--switch-여러-개\">VLAN(Virtual LAN) (case 2 : Switch 여러 개)</h2>\n\n<ul>\n  <li>그렇다면 네트워크를 확장하고 좀 더 현실적인 아키텍쳐로 바뀌면 어떨까?</li>\n  <li>먼저 Switch를 하나 더 두어보자.</li>\n  <li><em>들어가기전</em>\n    <ul>\n      <li>VLAN 설정 자체는 IP 주소를 직접 변경하지 않는다.\n        <ul>\n          <li>VLAN은 Layer 2(데이터 링크 계층)에서 작동하는 반면,<br />\nIP 주소는 Layer 3(네트워크 계층)에서 작동하기 때문.</li>\n        </ul>\n      </li>\n      <li>그러나, 실제 네트워크 운영에서는 일반적으로 각 VLAN마다 서로 다른 IP 대역을 할당한다.\n        <ul>\n          <li>네트워크 관리와 보안을 위한 설계</li>\n        </ul>\n      </li>\n      <li>그러므로 VLAN 별로 다른 대역을 할당해보자.\n        <ul>\n          <li>VLAN 2: 203.237.20.nnn</li>\n          <li>VLAN 3: 203.237.30.nnn</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@pcw1H/btsMc0NoTlz/v9c56wkkpb2qWxKk6BEsq0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1031,”originHeight”:1000,”style”:”alignCenter”,”width”:680,”height”:660}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 0 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@d5TDWZ/btsMekcZbAx/1meC8Kjg2Niht4JKNpWjE1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:325,”style”:”alignCenter”,”width”:757,”height”:192}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 1 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bxI7Ez/btsMcsXSPgC/McV65YvUN8ELGhZbpqxaEK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:336,”style”:”alignCenter”,”width”:750,”height”:197}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>여기서 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>🤔 과연 PC2는 PC0과 통신이 가능할까?\n    <ul>\n      <li>결과를 보면, PC1과는 통신이 가능하지만, 다른 스위치로 넘어가면서 통신이 불가능해진다</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cdqmkw/btsMeSmNMeI/jnvpXenhi6dV8W4U8oGWaK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:994,”originHeight”:806,”style”:”alignCenter”,”width”:664,”height”:538}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>이런 논리적인 흐름의 질문이 든다.\n    <ol>\n      <li>오히려 VLAN 설정하기 전에 그냥 여러 스위치를 건너 뛰어도 통신이 됐음.</li>\n      <li>그리고 같은 VLAN 끼리는 통신이 된다고 했다.</li>\n      <li>그런데 갑자기 같은 VLAN에서 여러 스위치를 건너뛰면 왜 통신이 안될까?</li>\n    </ol>\n  </li>\n  <li>여기서 <strong>VLAN 태그</strong>라는 개념이 등장한다.\n    <ul>\n      <li>VLAN을 설정하면 각 패킷에는 특별한 VLAN ID가 붙게 된다.\n        <ul>\n          <li>(마치 우편물에 부서명을 적는 것과 같다.)</li>\n        </ul>\n      </li>\n      <li>일반적인 스위치의 Port(Access Port)는 VLAN 태그를 처리하는 방법에 대해 1가지 밖에 모른다.\n        <ul>\n          <li>PACKET 들어올 때 : 자신의 VLAN 번호를 태그로 붙인다.</li>\n          <li>PACKET 나갈 때 : 태그를 제거하고 보낸다.</li>\n        </ul>\n      </li>\n      <li>그럼 여기서 문제가 발생한다.\n        <ul>\n          <li>PC2에서 나온 패킷\n            <ul>\n              <li>Switch 0으로 들어올 때 : fa0/2에서 VLAN 2 태그를 붙임</li>\n            </ul>\n          </li>\n          <li>이 패킷이 fa0/5로 가면서 VLAN 1의 통신으로 취급됨 [VLAN 2 태그가 떨어짐]</li>\n          <li>다른 스위치의 fa0/3에 도착했을 때도 VLAN 1의 통신으로 인식됨</li>\n          <li>결과적으로 원래의 VLAN 2 통신이 의도대로 전달되지 못함.</li>\n        </ul>\n      </li>\n      <li>[즉, <strong>Switch0의 fa0/와 Switch1의 fa0/3이 VLAN 1이기 때문</strong>]</li>\n    </ul>\n  </li>\n</ul>\n\n<p>→ <strong>스위치 간 VLAN 전용 통로가 필요하다!</strong></p>\n\n<h2 id=\"트렁크trunk\">트렁크(Trunk)</h2>\n\n<p>[먼저 PC2가 PC0과 통신이 가능하도록 해결해보자]</p>\n\n<ul>\n  <li>Switch0과 Switch1간에 VLAN 2,3 전용 포트 따로 설정!</li>\n  <li>switch0의 fa0/5, fa0/6을 각각 VLAN 2,3 전용으로 설정</li>\n  <li>switch1의 fa0/3, fa0/4를 각각 VLAN 2,3 전용으로 설정</li>\n  <li>Switch 0 포트의 VLAN 상태</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b3x84T/btsMei0AEyD/DYcMw88NkSnY9eQ8B22zcK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1154,”originHeight”:64,”style”:”alignCenter”,”width”:699,”height”:39}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 1 포트의 VLAN 상태</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@URbjM/btsMdIyMTr2/uZ7hOtRQPSYbugPuyZe3s1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1064,”originHeight”:74,”style”:”alignCenter”,”width”:731,”height”:51}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC2에서 PC0로 통신이 가능하다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@AcI9Y/btsMeveoKpG/MRkQDsbDHXP76MV9pLzZR0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:956,”originHeight”:432,”style”:”alignCenter”,”width”:727,”height”:329}_#][#_Image</td>\n      <td>kage@cav9Br/btsMdpMVs7n/kO9tRv5kLVsRKP9bNXqDuK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:714,”originHeight”:510,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>그런데 또 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>🤔 과연 VLAN 별 통신 라인 추가가 바람직한 해결인가?\n    <ul>\n      <li>만약 VLAN이 수백개라면..?</li>\n      <li>일일이 연결해줄 수 없다</li>\n      <li>또한 추가 가능한 VLAN ID는 1000개.\n        <ul>\n          <li>→ <strong>Trunk</strong> 가 해결책</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"트렁크란\">트렁크란?</h2>\n\n<ul>\n  <li><strong>트렁크는 모든 VLAN 패킷을 하나의 포트로 통과시키는 것</strong></li>\n  <li>스위치 간 프레임 전달에 하나의 물리적 연결(포트)를 공유하는 것.</li>\n  <li>VLAN 트렁킹된 스위치들 간에 여러 VLAN에서 나온 프레임들을 이 트렁크를 통해 전달한다.</li>\n  <li>즉, 스위치와 스위치 간 프레임 전달 시 하나의 포트에 다수의 VLAN이 지나갈 수 있도록하는 링크.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch(config)#interface fa0/5\nSwitch(config-if)#switchport mode trunk\n\nSwitch(config-if)#\n%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to down\n\n%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to up\nexit\nSwitch(config)#exit\nSwitch#\n%SYS-5-CONFIG_I: Configured from console by console\nshow interface trunk\nPort        Mode         Encapsulation  Status        Native vlan\nFa0/5       on           802.1q         trunking      1\n\nPort        Vlans allowed on trunk\nFa0/5       1-1005\n\nPort        Vlans allowed and active in management domain\nFa0/5       1,2,3\n\nPort        Vlans in spanning tree forwarding state and not pruned\nFa0/5       none\n</code></pre></div></div>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cj9Kft/btsMcrLrqjC/NZkK8P615yIbq5LWFeBswk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:839,”style”:”alignCenter”,”caption”:”Switch0의 Fa0/5 포트 Trunk 설정”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li>Fa0/5가 트렁크 포트로 on (강제로 트렁크 모드로 설정) 되었다.</li>\n  <li>1~1005는 이론적으로 모든 VLAN 범위가 통과 가능하다.</li>\n  <li>실제 현재 사용 중인 VLAN : 1, 2, 3이 현재 활성화되어 있다.</li>\n  <li>Vlans in spanning tree forwarding state and not pruned : None<br />\n(활성화된 VLAN들이 여기 나타나야 한다. - 없다.)</li>\n</ol>\n\n<ul>\n  <li>Fa0/5 포트는 Native VLAN이 1로 설정됨</li>\n  <li>반대편 Fa0/3 포트는 Native VLAN이 2로 설정됨\n    <ul>\n      <li>Switch1의 Fa0/3 포트도 Trunk로 설정해준다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@kzW3S/btsMec7cVIK/IBXxcLCh7BYeCYd9J2nScK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1136,”originHeight”:414,”style”:”alignCenter”,”width”:654,”height”:238}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>물론 PC2에서 PC0로 통신이 가능해졌다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bryfWp/btsMcPE65aP/UGX9KHYfm1QMvME24buAtk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:956,”originHeight”:428,”style”:”alignCenter”,”width”:706,”height”:316}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"inter-vlan\">Inter-VLAN</h2>\n\n<ul>\n  <li>놓치면 안되는 것의 “<strong>기술의 도입에 대한 목적</strong>”이다.\n    <ul>\n      <li>VLAN의 목적은 가상의 LAN으로서 관리의 편리성 추구이며,<br />\n다른 VLAN과의 통신 제한이 아니다.</li>\n    </ul>\n  </li>\n  <li>그럼, 서로 다른 VLAN 간의 통신이 가능하도록 하는 방법은 없을까?</li>\n  <li>VLAN 간 통신을 하려면 라우터(게이트웨이)가 있어야 한다.\n    <ul>\n      <li>라우터를 경유하여 마치 다른 LAN으로 통신하는 것처럼 동작한다.</li>\n    </ul>\n  </li>\n  <li>[다른 네트워크 영역은 라우터가 필요!!!]</li>\n</ul>\n\n<h2 id=\"서브-인터페이스\">서브 인터페이스</h2>\n\n<ul>\n  <li>단순히 생각하면 이런 생각이 든다.</li>\n  <li>전통적인 라우터 방식: 각 VLAN마다 라우터의 물리적 인터페이스를 하나씩 사용</li>\n  <li>그러나 이런 생각의 전환을 해본다.\n    <ul>\n      <li><strong>하나의 물리적 라우터 인터페이스에 여러 개의 논리적 인터페이스를 생성하여 각각 다른 VLAN을 처리할 수 있도록 할 수 있다면?</strong></li>\n      <li>그런데, Fa0/0이라는 물리적 라우터 인터페이스에 어떻게 여러 개의 논리적 인터페이스를 생성할까?</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@Y1VKx/btsMeSUECM4/0Qz0wbAb4G4UBmT0SLhXYk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:260,”originHeight”:298,”style”:”alignCenter”,”width”:167,”height”:191}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>서브 인터페이스: 하나의 인터페이스에 여러 VLAN들의 인터페이스를 논리적으로 나누는 것</li>\n  <li>2811 모델을 추가해준다!\n    <ul>\n      <li>참고 :</li>\n      <li><em>2811 라우터는 Cisco의 중급 라우터로, Inter-VLAN 라우팅을 위한 서브인터페이스 구성을 지원합니다. 서브인터페이스란 하나의 물리적 인터페이스를 여러 개의 논리적 인터페이스로 나누어 사용할 수 있게 해주는 기능입니다. 이는 마치 하나의 도로를 여러 개의 차선으로 나누어 서로 다른 목적지로 가는 차들을 효율적으로 처리하는 것과 비슷합니다.</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p>1. fa0/0 활성화</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dysMoj/btsMcdzWje7/FkpECQDsjzhv7gtsA3SGI1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:846,”originHeight”:200,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>2. fa0/0.2 생성, VLAN2 연결, IP주소 할당 &amp; fa0/0.3 생성, VLAN3 연결, IP주소 할당</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b2QZaS/btsMb1M28tD/PwRCtfFGc9U9WdizCjU6pk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:691,”style”:”alignCenter”,”width”:790,”height”:426}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>3. switch1 fa0/4를 트렁크 모드로 설정</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bGoCk8/btsMdHT860Z/dwqr98u0ihaJDerscGQ7j1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1248,”originHeight”:546,”style”:”alignCenter”,”width”:718,”height”:314}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>4. Router의 서브 인터페이스 상태 확인</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bnyTgA/btsMevrWYog/pDkKHGHiWCNLKzR85a7Qn1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:219,”style”:”alignCenter”,”width”:819,”height”:140}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>5. 게이트웨이 설정</p>\n\n<p>- VLAN 2 (PC0, 1, 2) → 203.237.20.254</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bjr2GX/btsMey9WnrP/zNHfPdHwYlhyUSeIwsz6n0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:384,”style”:”alignCenter”,”width”:767,”height”:230}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>- VLAN 3 (Laptop0, 1, 2) → 203.237.30.254</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@9Pp8f/btsMcxY6pxv/toN6xYeoWLuqsvp1xIlJ90/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:606,”style”:”alignCenter”,”width”:773,”height”:366}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h1 id=\"스위치\">스위치</h1>\n\n<hr />\n\n<h2 id=\"스위치의-동작-원리\">스위치의 동작 원리</h2>\n\n<h2 id=\"mac-주소-테이블-동작-원리\">MAC 주소 테이블 동작 원리</h2>\n\n<ul>\n  <li>스위치와 노드들이 <strong>ARP</strong>를 통해 MAC 주소 정보를 지속적으로 교환한다.\n    <ul>\n      <li>ARP 프로토콜에 포함된 MAC 주소 정보를 기반으로 스위치의 MAC 주소 테이블이 구축된다.</li>\n      <li>실제 데이터 전송 (ping 등)이 발생하면, 이 MAC 주소 테이블을 참조하여 패킷을 적절한 포트로 전달</li>\n    </ul>\n  </li>\n  <li>MAC 주소 테이블은 네트워크 토폴리지 변화를 반영하기 위해 일정 주기로 초기화되며, 최신 정보로 동적 갱신된다.</li>\n</ul>\n\n<h2 id=\"arp란\">ARP란?</h2>\n\n<ul>\n  <li>IP 네트워크에서 IP 주소를 물리적인 MAC 주소로 변환하는 핵심 프로토콜</li>\n  <li>컴퓨터가 같은 네트워크 상의 다른 장치와 통신하려면 반드시 상대방의 MAC 주소를 알아야 하는데,<br />\nARP가 이 주소 변환 과정을 자동으로 처리해준다.</li>\n</ul>\n\n<h2 id=\"arp를-활용한-동작-원리\">ARP를 활용한 동작 원리</h2>\n\n<p><em>PC0에서 Laptop0으로 ping을 보낸다고 가정</em></p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cDoPQ4/btsMdLhTSuP/NdTWBqnwp8pAXYoKUrWZrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:988,”originHeight”:436,”style”:”alignCenter”,”width”:742,”height”:327}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li>ARP Request (PC0 → Switch0)\n    <ul>\n      <li>PC0이 Laptop0의 MAC 주소를 알아내기 위해 ARP 요청 패킷 전송</li>\n      <li>패킷 내용:\n        <ul>\n          <li>출발지: PC0의 IP 주소와 MAC 주소</li>\n          <li>목적지: Laptop0의 IP 주소 (MAC 주소는 미확인 상태)</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>스위치 <strong>브로드캐스트</strong> (Switch0 → 모든 노드)\n    <ul>\n      <li>Switch0은 PC0의 <strong>MAC 주소를 자신의 테이블에 기록</strong></li>\n      <li>수신한 ARP 요청 패킷을 모든 포트로 브로드캐스트</li>\n    </ul>\n  </li>\n  <li>ARP reply (Laptop0 → Switch0)\n    <ul>\n      <li>Laptop0이 자신의 IP 주소를 확인하고 ARP 응답 패킷 생성</li>\n      <li>패킷 내용:\n        <ul>\n          <li>출발지: Laptop0의 IP 주소와 MAC 주소</li>\n          <li>목적지: PC0의 IP 주소와 MAC 주소</li>\n        </ul>\n      </li>\n      <li>Laptop0은 PC0의 MAC 주소를 자신의 ARP 캐시에 저장</li>\n    </ul>\n  </li>\n  <li>스위치 전달 단계 (Switch0 → PC0)\n    <ul>\n      <li>Switch0은 수신한 응답 패킷을 PC0에게 전달</li>\n      <li>PC0과 Laptop0의 MAC 주소 정보를 MAC 주소 테이블에 저장</li>\n    </ul>\n  </li>\n  <li>통신 시작\n    <ul>\n      <li>PC0이 Laptop0의 MAC 주소를 획득하여 실제 데이터 통신 가능</li>\n    </ul>\n  </li>\n</ol>\n\n<h2 id=\"시뮬레이션\">시뮬레이션</h2>\n\n<ul>\n  <li>시뮬레이션을 눌러서 이벤트 목록창을 볼 수 있다.</li>\n  <li>편지봉투 모양의 [Add Simple PDU] → ICMP 패킷 전송 시뮬레이션</li>\n  <li>송신노드와 수신 노드를 클릭하고 Show All/None 클릭 후 ARP, ICMP 패킷만 클릭한다.</li>\n  <li><em>PC0에서 Laptop0으로 편지를 보낸다.</em></li>\n  <li>ARP - ICMP 순으로 통신이 이루어진다.</li>\n</ul>\n\n<h2 id=\"1-arp-패킷-분석\">1) ARP 패킷 분석</h2>\n\n<p>1. PC0 → Switch0 ARP Request</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cwVj4Z/btsMcHN0AZ1/QtiRKPTAkw5cwMHngIJq5K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:900,”originHeight”:1158,”style”:”alignCenter”,”width”:522,”height”:672}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>ARP\n    <ul>\n      <li>Source MAC<br />\n= PC0 의 MAC 주소</li>\n      <li>Source IP<br />\n= PC0의 IP 주소</li>\n      <li>Target MAC<br />\n= Laptop 의 MAC 주소 [모르는 주소]</li>\n      <li>Target IP<br />\n= Laptop0의 IP주소</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2. Switch0 → 모든 노드 (브로드캐스트)</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dvlpX3/btsMdr43c4X/YNHxFWmjmqgayudoXkG1l0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:818,”originHeight”:124,”style”:”alignCenter”,”width”:594,”height”:90}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch0은 수신한 ARP Request를 모든 포트로 전달</li>\n  <li>Switch0의 MAC 주소 테이블에 PC0의 정보 기록\n    <ul>\n      <li>포트 번호와 PC0의 MAC 주소 매핑</li>\n    </ul>\n  </li>\n</ul>\n\n<p>3. Laptop0→ Switch0 ARP Reply</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@K4KvV/btsMcdUawiw/VpUysCPR5W9T4yYTKTcqJK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1002,”originHeight”:1242,”style”:”alignCenter”,”width”:627,”height”:777}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>ARP\n    <ul>\n      <li>Source MAC<br />\n= Laptop0 의 MAC 주소</li>\n      <li>Source IP<br />\n= Laptop0의 IP 주소</li>\n      <li>Target MAC<br />\n= PC0 의 MAC 주소</li>\n      <li>Target IP<br />\n= Laptop0의 IP주소</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"2-icmp-패킷-분석\">2. ICMP 패킷 분석</h2>\n\n<ol>\n  <li>PC → Laptop</li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@6AWAV/btsMdMA4Jmh/dd2ilCfmHRbqRt9DFVNWhK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2056,”originHeight”:1186,”style”:”alignCenter”,”width”:690,”height”:398}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>SRC ADDR = PC0의 MAC 주소</li>\n  <li>DEST ADDR = Laptop0의 MAC 주소</li>\n</ul>\n\n<h2 id=\"3-switch0의-mac-주소-테이블-변화\">3) Switch0의 MAC 주소 테이블 변화</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dEbxME/btsMdnn7IXG/koFfWfejqCW9bxxbzaYPb0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1080,”originHeight”:611,”style”:”alignCenter”,”width”:747,”height”:423}_#][#_Image</td>\n      <td>kage@WjEAg/btsMdmbIixx/in3AqgZZ7OkLwPpGkcb270/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1080,”originHeight”:734,”style”:”alignCenter”,”width”:727,”height”:494}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>위를 보니 Fa0/1 Fa0/4에 연결된 PC0과 Laptop0의 MAC 주소가 테이블에 기재되었다.</li>\n</ul>\n\n<p>🤔 갑자기 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>Switch0 → 모든 노드로 BroadCast할 때 각자의 MAC 주소 받아오면 되는거 아닌가?</li>\n  <li>해답은 ARP를 이용해 MAC 주소 테이블이 어떻게 유지하는지의 방법에 있다.\n    <ul>\n      <li>스위치의 MAC 주소 학습은 ‘출발지(Source) MAC 주소’만을 대상으로 한다.\n        <ul>\n          <li>PC0이 ARP Request를 보낼 때</li>\n          <li>Laptop0이 ARP Reply를 보낼 때</li>\n        </ul>\n      </li>\n      <li>모든 노드로 전달된 ARP-Request 패킷에 대해 수신 노드가 아니면 응답하지 않는다.</li>\n      <li>PC1과 Laptop1은 Swtich0이 전달한 ARP-Request에 대해 Reply 하지 않는다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>그런데 이런 ‘고민’도 떠오른다.</p>\n\n<p>1.효율성</p>\n\n<ul>\n  <li>ARP는 매우 짧은 시간 간격으로 반복 실행한다.\n    <ul>\n      <li>노드들이 많은 네트워크에서는 통신량으로 부하 가중</li>\n      <li>특히 스위치가 모든 노드에게 BroadCast하는 ARP-Request에서</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2. 보안상의 문제</p>\n\n<ul>\n  <li>Laptop1이 악의적인 공격자라고 가정해보자.\n    <ul>\n      <li>ARP Reply가 실제로 해당 IP 주소를 가진 정당한 장치에서 온 것인지 확인하지 않는다. (보안 X)</li>\n      <li>이 때 Laptop0의 IP에 Laptop1 MAC 주소를 실어서 Reply한다면?</li>\n      <li>테이블이 제대로 갱신되기 전까지 PC0은 Laptop0인 줄 알고 모든 패킷을 보낸다.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"vlan을-통한-해결\">VLAN을 통한 해결</h2>\n\n<ul>\n  <li>MAC 주소를 이용한 라우팅\n    <ul>\n      <li>동일한 네트워크(LAN)에서 스위치를 통해서만 발생한다.</li>\n      <li>라우터를 통한 외부 네트워크로의 통신에는 사용되지 않는다.\n        <ul>\n          <li>ARP 패킷은 하나의 네트워크에서만 송수신한다.</li>\n          <li>LAN을 논리적으로 분리된 가상의 VLAN으로 관리한다.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h1 id=\"라우터\">라우터</h1>\n\n<hr />\n\n<h2 id=\"라우터란\">라우터란?</h2>\n\n<ul>\n  <li>라우터는 서로 다른 네트워크를 연결하는 3계층 장비.</li>\n  <li>IP 주소를 기반으로 패킷의 최적 경로를 결정하고 전달한다.\n    <ul>\n      <li>스위치가 같은 네트워크 내에서 MAC 주소를 기반으로 통신을 담당한다면,</li>\n      <li>라우터는 서로 다른 네트워크 간의 통신을 가능하게 만드는 일종의 ‘네트워크 간의 다리’ 역할을 한다.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"라우터의-mode\">라우터의 Mode</h2>\n\n<ul>\n  <li><strong>사용자 모드(User EXEC Mode)</strong>\n    <ul>\n      <li>기본적인 정보 조회만 가능, 설정 변경 불가</li>\n      <li>&gt; 로 표시</li>\n    </ul>\n  </li>\n  <li><strong>관리자 모드(Privileged EXEC Mode)</strong>\n    <ul>\n      <li>라우터 설정을 변경할 순 없지만 시스템 정보 상세조회 가능</li>\n      <li># 으로 표시</li>\n    </ul>\n  </li>\n  <li><strong>글로벌 모드(Global Configuration Mode)</strong>\n    <ul>\n      <li>라우터 설정(이름, 보안, 인터페이스 등)을 변경</li>\n      <li>(config)# 로 표시</li>\n      <li><strong>라인 모드(Line Configuration Mode)</strong>\n        <ul>\n          <li>콘솔, 원격 접속(Telnet, SSH 등) 관련 설정 변경</li>\n          <li>(config-line)# 로 표시</li>\n        </ul>\n      </li>\n      <li><strong>인터페이스 모드(Interface Configuration Mode)</strong>\n        <ul>\n          <li>라우터의 네트워크 인터페이스(이더넷, 시리얼 등) 설정을 변경</li>\n          <li>라우터의 인터페이스에 IP 주소를 설정하고 활성화/비활성화</li>\n          <li>(config-if)# 로 표시</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"목표-네트워크-구성\">목표 네트워크 구성</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@FrASQ/btsMeLVCXVC/1wKsZjYPW9BikRxL7DFtC1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:813,”originHeight”:495,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"기본-설정\">기본 설정</h2>\n\n<ul>\n  <li>라우터 3대: [Network Devices] → [Routers] → [2811]</li>\n  <li>스위치 1대 : [Network Devices] → [Switches] → [2960]</li>\n  <li>PC 3대, 노트북 1대, 서버 1대 : [End Devices] → [PC], [Laptop], [Server]</li>\n</ul>\n\n<h2 id=\"라우터---시리얼-인터페이스-장착\">라우터 - 시리얼 인터페이스 장착</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@zgPDU/btsMd3bDPMR/E6TXH94lrMz3OrUR6TF5hK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:1293,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC와 달리 두 라우터 간에 데이터를 주고받기 위한 동기화가 필요</li>\n  <li>FastEthernet이 아닌 Serial 인터페이스를 사용하므로 모듈을 추가해야 한다.\n    <ul>\n      <li>HWIC-2T 추가</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"노드-간-연결하기\">노드 간 연결하기</h2>\n\n<ul>\n  <li>Laptop0은 통신용이 아니라 Router0을 설정하기 위한 콘솔\n    <ul>\n      <li>FastEthernet 케이블이 아닌 RS232(하늘색) 케이블로 연결</li>\n    </ul>\n  </li>\n  <li>라우더들끼리 Serial DCE 연결\n    <ul>\n      <li>먼저 클릭한 쪽에 시계 모양 - 두 라우터 간 데이터를 주고받기 위한 동기화가 필요</li>\n      <li>Serial DCE(Data Communication Equipment): 시간 동기화를 주도하는 노드 (시계 있는 쪽)</li>\n      <li>Serial DTE(Data Terminal Equipment): 그에 따라 동기화하는 노드 (시계 없는 쪽)</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@evpmpX/btsMdMnzPql/PLX7aieEhAKMJ6N99C2j5K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2184,”originHeight”:1246,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"ip-설정\">IP 설정</h2>\n\n<ul>\n  <li>컴퓨터들은 203.237.nnn.nnn/24 사용(C클래스)\n    <ul>\n      <li>1번부터 시작</li>\n    </ul>\n  </li>\n  <li>원격 관리가 필요한 스위치나 서버는 100번 부터</li>\n  <li>라우터는 광역의 랜들을 연결하므로 A클래스 IP 사용\n    <ul>\n      <li>규모가 작아 30비트 서브넷 마스크를 사용하여 최대 4개의 라우터를 묶을 수 있도록</li>\n    </ul>\n  </li>\n  <li>스위치는 2계층 장비\n    <ul>\n      <li>IP 주소 설정 불필요</li>\n      <li>원격 접속으로 스위치 관리\n        <ul>\n          <li>IP 주소 할당 필요</li>\n          <li>VLAN1에 할당</li>\n        </ul>\n      </li>\n      <li>스위치 IP 주소 설정</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bk8xpK/btsMd7Sxxul/dQMOVhudaYmzsa519EoeQK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1374,”originHeight”:164,”style”:”alignCenter”,”width”:635,”height”:76}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>총 6개의 LAN</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@UGTSj/btsMcKRyRRh/QFOQKnpr0nm0a6K8eUWWKk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1762,”originHeight”:1000,”style”:”alignCenter”,”width”:698,”height”:396}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"연결-확인\">연결 확인</h2>\n\n<ul>\n  <li>PC0에서 테스트</li>\n</ul>\n\n<ol>\n  <li>PC0 로컬 호스트(127.0.0.1)</li>\n  <li>PC0 → Switch1(VLAN1, 203.237.10.100)</li>\n  <li>PC0 → Server0(203.237.10.101)</li>\n  <li>PC0 → Router0(203.237.10.254)\n    <ul>\n      <li>모두 통신 성공</li>\n    </ul>\n  </li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@s9v2J/btsMcYPw7T1/QedNlAylJ9wAnApW81hp3K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1000,”originHeight”:1605,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>5. PC0 → PC2(203.237.30.1)</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@mi021/btsMdHGFlHG/cChGsiN9Pw0rWY0kG0w7q1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:996,”originHeight”:374,”style”:”alignCenter”,”width”:684,”height”:257}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><strong>unreachable</strong> 이 발생한다\n    <ul>\n      <li>PC0으로 부터 받은 패킷을 Router0이 어느 인터페이스로 보내야할지 모르기 때문</li>\n      <li>→ <strong>라우팅 테이블</strong>이 필요하다</li>\n      <li>아래는 Router0의 라우팅 정보</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@beagrf/btsMdMujNSG/uzGad36EzxcCPqRZ3PJy21/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1260,”originHeight”:698,”style”:”alignCenter”,”width”:746,”height”:413}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"정적-라우팅-설정\">정적 라우팅 설정</h2>\n\n<ul>\n  <li>정적 라우팅 대상\n    <ul>\n      <li>1번 PC0 입장에서 목적지가\n        <ul>\n          <li><strong>2번</strong> 네트워크(203.237.20.nnn/24)인 패킷 : serial0/3/0 (혹은 1.1.1.2)</li>\n          <li><strong>3번</strong> 네트워크(203.237.30.nnn/24)인 패킷 : serial0/3/1 (혹은 2.2.2.2)</li>\n          <li>6번 네트워크(3.3.3.nnn/30)인 패킷 : serial0/3/0 혹은 serial0/3/1</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>Router1의 정적 라우팅 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@JLnX1/btsMckFDkMJ/ik8vROKAHLaZQPxINyMSmK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1226,”originHeight”:442,”style”:”alignCenter”,”width”:694,”height”:250}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Router2의 정적 라우팅 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@k4yPj/btsMexiTcvl/Ewo59hWdxO2tOqMp9GTtNK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1248,”originHeight”:504,”style”:”alignCenter”,”width”:736,”height”:297}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Router3의 정적 라우팅 설정 + route 확인</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cnu0SN/btsMdH0043d/jjkekr1KEkmqtXM0E7LRUK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1270,”originHeight”:1186,”style”:”alignCenter”,”width”:756,”height”:706}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"통신테스트-by-ping\">통신테스트 by ping</h2>\n\n<ul>\n  <li>PC0 ↔ PC1</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dD0uXu/btsMb0Hnvj9/50DKkNchVlTaBfBiYNEMiK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:962,”originHeight”:422,”style”:”alignCenter”,”width”:730,”height”:320}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC0 ↔ PC2</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cEoaLU/btsMdGgIz36/93lJ36D1HjrKK9gQaOKvb1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:432,”style”:”alignCenter”,”width”:780,”height”:350}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h1 id=\"방화벽---네트워크-구성\">방화벽 - 네트워크 구성</h1>\n\n<hr />\n\n<h2 id=\"망구성\">망구성</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@kO9qL/btsMengxOIb/FFIVXRjKkeW6JnSOKHGXqk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:524,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"asa0-구성-설정\">ASA0 구성 설정</h2>\n\n<p>1. 인터페이스 통신 상태</p>\n\n<ul>\n  <li>내부망 : 통신 가능</li>\n  <li>외부망 : 통신 불가\n    <ul>\n      <li>inPC → outPC 불가능</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bh2bBN/btsMd7rqkl0/g4AYl1hwkqpXZ1NDwCwO30/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1278,”originHeight”:266,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>2. IP 주소 설정</p>\n\n<ul>\n  <li>Inside : 설정됨</li>\n  <li>outside : 설정되어있지 않음\n    <ul>\n      <li>→ VLAN에서 203.237.20.253으로 설정</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cormPm/btsMc1r1E8A/LKXIkkQ8YcBwbHGgFGWQIk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1406,”originHeight”:342,”style”:”alignCenter”,”width”:807,”height”:196}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>3. Config 확인</p>\n\n<ul>\n  <li>내부망 Security-level : 100</li>\n  <li>외부망 Security-level : 0</li>\n  <li>보안 레벨이 높은 곳 → 낮은 곳 : 허용 (반대는 불가능)</li>\n  <li>내부망 노드들은 DHCP를 이용하여 IP 할당받는다.</li>\n</ul>\n\n<h2 id=\"inpc-dhcp-설정\">inPC DHCP 설정</h2>\n\n<ul>\n  <li>inPC는 ASA가 DHCP로 주소를 할당해준다고 했다.\n    <ul>\n      <li>게이트웨이는 ASA0 inside의 ip 주소로 고정된다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@HAypL/btsMemIHLU2/tcja6hVK1aurUDoEGiKLAK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1388,”originHeight”:636,”style”:”alignCenter”,”width”:703,”height”:322}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>outPC는 고정 주소 사용 중</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@lNS8u/btsMdHzVPu4/iHvbzNmifAq1gElLiDlpW1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1304,”originHeight”:546,”style”:”alignCenter”,”width”:707,”height”:296}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"router0-설정\">Router0 설정</h2>\n\n<ul>\n  <li>fa0/0 IP 설정 &amp; 활성화\n    <ul>\n      <li>203.237.10.254/24</li>\n    </ul>\n  </li>\n  <li>fa0/0 IP 설정 &amp; 활성화\n    <ul>\n      <li>203.237.20.253/24</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"rna-설정\">RNA 설정</h2>\n\n<h2 id=\"routing\">Routing</h2>\n\n<ul>\n  <li>라우터의 정적라우팅\n    <ul>\n      <li>네트워크 디바이스들이 서로 다른 네트워크에 있을 때, 그들 사이의 통신 경로를 명확히 지정해줘야 한다.</li>\n      <li>예를 들어, 내부 네트워크의 PC가 다른 네트워크의 서버와 통신하려면, 그 경로를 알아야 한다.</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">ip route &lt;목적지 네트워크 주소&gt; &lt;목적지 서브넷 마스크&gt; &lt;다음 홉 IP 주소/출구 인터페이스&gt;</code></li>\n    </ul>\n  </li>\n  <li>방화벽의 정적라우팅\n    <ul>\n      <li>트래픽이 반드시 방화벽을 통과하도록 하여 보안 정책을 적용할 수 있게 한다.</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">route &lt;VLAN명&gt; &lt;외부망 네트워크 주소&gt; &lt;외부망 서브넷마스크&gt; &lt;다음 홉 IP 주소&gt;</code></li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@UMo4w/btsMemPruKw/su6TBN30w2NLPGdTiu8nN0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2110,”originHeight”:1000,”style”:”alignCenter”,”width”:734,”height”:348}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>→ 어떤 목적지 주소를 갖는 패킷이든 외부망의 Router0인 203.207.20.254로 전송한다.</p>\n\n<ul>\n  <li>통신확인</li>\n  <li>inPC ↔ ASA0</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@ea7sUx/btsMcHURKDV/D3ikyzQhpSkEa8QCBP2sK1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:972,”originHeight”:428,”style”:”alignCenter”,”width”:708,”height”:312}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>inPC ↔ outPC</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b7mUIE/btsMcfqYrdM/SvtR3wkJNdKRzXgHMUMtIK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:986,”originHeight”:368,”style”:”alignCenter”,”width”:702,”height”:262}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"nat\">NAT</h2>\n\n<ul>\n  <li>inPC → outPC 까지는 패킷 전달이 잘 되지만,</li>\n  <li>Router0 → ASA0으로 전달이 되지 않는다.</li>\n</ul>\n\n<p><strong>outPC → Router1로 전달되는 패킷</strong></p>\n\n<ul>\n  <li>outPC(203.237.10.10)가 inPC(192.168.1.5)로 통신을 시도할 때, Router는 문제에 직면한다.\n    <ul>\n      <li>목적지 주소가 사설IP이기 때문에 외부에서 인식이 불가능하다.</li>\n      <li>→ Rotuer 입장에서 어디로 보내야 할 지 모른다.\n        <ul>\n          <li>(마치 동 호수만 알고, 택배 기사가 서울에서 배달을 하려는 상황과 마찬가지)</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@xD2B6/btsMeR9g8xQ/eG7q1kOXNaBGJdcSFREQoK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2080,”originHeight”:1270,”style”:”alignCenter”,”width”:783,”height”:478}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>⇒ ASA가 사설 IP를 공인 IP로 변경해서 보내줘야 한다.</li>\n  <li>ASA의 <strong>NAT</strong></li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@tUl9o/btsMeRVJT2O/PJFvZxKK7bVxaO8Vexhkt0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:414,”originHeight”:143,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>들어오는 패킷의 처리\n    <ul>\n      <li>외부 노드들은 내부 네트워크의 실제 사설 IP를 알 필요가 없다.\n        <ul>\n          <li>대신 ASA의 공인 IP 주소로 통신을 시도</li>\n        </ul>\n      </li>\n      <li>ASA는 NAT 테이블을 유지하면서, 어떤 외부 통신이 어떤 내부 노드를 위한 것인지 추적</li>\n      <li>수신된 패킷의 목적지 주소를 적절한 내부 사설 IP로 변환하여 전달</li>\n    </ul>\n  </li>\n  <li>나가는 패킷의 처리\n    <ul>\n      <li>내부 노드가 외부로 통신을 시도할 때, ASA는 출발지의 사설 IP를 자신의 공인 IP로 변환</li>\n      <li>이 과정에서 ASA는 어떤 내부 노드가 어떤 통신을 시작했는지 NAT 테이블에 기록</li>\n      <li>나중에 응답이 돌아오면, 이 테이블을 참조하여 올바른 내부 노드에게 전달</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"nat-설정\">NAT 설정</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@czZH5n/btsMc0fu60D/gU0ev4kVhViqehGSDDt6K0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1220,”originHeight”:196,”style”:”alignCenter”,”width”:742,”height”:119}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>in2out 객체 생성 (네트워크 객체 모드)</li>\n  <li>대상 서브넷을 지정해준다.</li>\n  <li>NAT 지정\n    <ul>\n      <li>내외부망을 연결하는 (inside, outside)를 동적 매핑</li>\n      <li>공인 Ip 주소는 인터페이스에 할당된 IP 주소를 사용한다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@ccZXOd/btsMcjzZe4x/9s6nimQ80LBoH1dkmToAWK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:942,”originHeight”:138,”style”:”alignCenter”,”width”:676,”height”:99}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>그래도 inPC → outPC의 통신이 실패하게 된다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bajXRR/btsMcZgFpCY/BFAnMrFdvAP1aAJVnNh9z0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:600,”originHeight”:157,”style”:”alignCenter”,”width”:524,”height”:137}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"acl\">ACL</h2>\n\n<ul>\n  <li>패킷을 보면 목적지 주소는 공인 IP 주소로 정확히 설정되어 있으나,</li>\n  <li>외부망에서 내부망으로 들어오는 트래픽의 흐름을 방화벽이 모두 Block하고 있기 때문</li>\n  <li><strong>즉, 인터페이스마다 어떤 출발지 &amp; 어떤 목적지 를 가지는 트래픽을 허용 / 거부 할 것인지 정의해줘야 한다.</strong></li>\n  <li>→ ACL : 이러한 Allow/Deny 접근 제어 목록</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>access-list &lt;ACL명&gt; &lt;타입&gt; &lt;동작&gt; &lt;프로토콜&gt; &lt;출발지&gt; &lt;목적지&gt;\naccess-group &lt;ACL명&gt; &lt;트래픽&gt; &lt;인터페이스 키워드&gt; &lt;VLAN 명&gt;\n</code></pre></div></div>\n\n<ul>\n  <li>ACL 설정\n    <ul>\n      <li>모든 출발지에서 모든 목적지로 가는 ICMP(ping) 트래픽을 허용하는 규칙을 만든다.</li>\n      <li>만든 규칙을 외부 인터페이스의 인바운드 방향에 적용</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@eklCj3/btsMeUZeeor/0St67walf4cyejJZvVb2N0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1224,”originHeight”:300,”style”:”alignCenter”,”width”:767,”height”:188}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>inPC → outPC Ping 확인</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bMTQzA/btsMeyozeji/a8vxJ4pw0kExxZ6GUmDnRk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:962,”originHeight”:434,”style”:”alignCenter”,”width”:749,”height”:338}_#]</td>\n    </tr>\n  </tbody>\n</table>\n",
                        "tags": ["Network","PacketTracer","LAN","Switch","Router","Firewall","VLAN","Topology"]
                    }
                
            ],
        
            "Router": [
                
                    {
                        "title": "Packet Tracer로 네트워크 이해하기",
                        "url": "/2025/02/08/packet-tracer-network.html",
                        "subtitle": "LAN 토폴로지, 스위치, 라우터, 방화벽",
                        "excerpt": "LAN 토폴로지와 스위치\n",
                        "author": "Jinho",
                        "date": "February 08, 2025",
                        "background": "/img/posts/network_topology.jpeg",
                        "content": "<h1 id=\"lan-토폴로지와-스위치\">LAN 토폴로지와 스위치</h1>\n\n<hr />\n\n<h2 id=\"packet-tracer에-들어가기-전\">Packet Tracer에 들어가기 전</h2>\n\n<p>먼저 네트워크의 기본 구성 요소부터 이해해보자.</p>\n\n<p><strong>라우터, 스위치, 엔드 디바이스(PC, 서버 등)가 어떻게 상호 작용</strong>하는지 알아보자.</p>\n\n<ul>\n  <li>가장 기본적인 두 대의 디바이스(<code class=\"language-plaintext highlighter-rouge\">PC</code>)가 있다고 가정해보자.</li>\n  <li>두 PC를 연결하고, IP 주소 설정, 서브넷 마스크 설정을 하고 ping 테스트를 통해 연결.\n    <ul>\n      <li>이 과정에서 TCP/IP의 기본 개념을 이해해보자.</li>\n    </ul>\n  </li>\n  <li>그 다음 단계로 <code class=\"language-plaintext highlighter-rouge\">스위치</code>를 추가하여 여러 대의 <code class=\"language-plaintext highlighter-rouge\">PC</code>를 연결.\n    <ul>\n      <li>L2 통신의 개념과 MAC 주소의 역할을 이해해보자.</li>\n    </ul>\n  </li>\n  <li>마지막으로 <code class=\"language-plaintext highlighter-rouge\">라우터</code>를 추가하여 서로 다른 네트워크 간의 통신을 구현.\n    <ul>\n      <li>라우팅 테이블, 게이트웨이 등의 개념을 학습해보자.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"사용법\">사용법</h2>\n\n<h2 id=\"pc\">PC</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@tdMGa/btsMchWsAbo/pXUJ5sc1Jn5zlePiDz1mrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:264,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>장치 타입 → End Devices → PC / LAPTOP 등 Drag &amp; Drop</li>\n</ul>\n\n<h2 id=\"switch\">Switch</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bdJ1mb/btsMedLRoGJ/cpMkbVJahG5gP3qwnew9Uk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:194,”originHeight”:256,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"router\">Router</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@A02nQ/btsMeKJcj9q/usIeZ7q3BDrYQHVk4TpOuk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:208,”originHeight”:276,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"connection\">Connection</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@rOlnO/btsMdkEVmv0/U1xgvAbp826OCElZjbp2Sk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:280,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>실선은 Copper Straight [PC - Switch/Router]</li>\n  <li>점선은 Copper Cross - Over [Switch/Router … Switch/Router]</li>\n  <li>번개 모양은 Automatic</li>\n</ul>\n\n<h2 id=\"기본-사용-방법\">기본 사용 방법</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@mamWH/btsMdM8WmZV/J6Eve21yZP8cKJkdv8KQrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:666,”originHeight”:558,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>장치(PC 와 Laptop)들을 놓는다.</li>\n  <li>각 디바이스 개수만큼 연결한 스위치 추가</li>\n  <li>실선과 점선으로 연결</li>\n  <li>스위치 0 → 메뉴에서 FastEthernet0/1 선택</li>\n  <li>PC 0 → 메뉴에서 FastEthernet0 선택</li>\n  <li>(나머지도 동일하게 연결)</li>\n  <li>왼쪽 스위치 : <code class=\"language-plaintext highlighter-rouge\">FastEthernet0/2</code> 오른쪽 스위치 : <code class=\"language-plaintext highlighter-rouge\">FastEthernet0/3</code></li>\n  <li>PC 클릭 → Desktop → IP Configuration → IP Address에 <code class=\"language-plaintext highlighter-rouge\">198.168.0.1</code><br />\nSubnet Mask에 <code class=\"language-plaintext highlighter-rouge\">255.255.255.0</code>\n    <ul>\n      <li>나머지 장치는 IP 주소 ~0.2, ~0.3 순으로 입력</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dhy2rZ/btsMczo0VIn/LHz5KS8UijOguFkFqLdSSk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:338,”style”:”alignCenter”,”width”:780,”height”:206}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Desktop → Command Prompt로 ping 테스트</li>\n  <li>작업 공간에서 Simulation 가능 [실제 이동 경로 &amp; 헤더 정보 등을 볼 수 있다.]</li>\n</ul>\n\n<h2 id=\"lan-topology\">LAN Topology</h2>\n\n<ul>\n  <li>같은 로컬 에이리어 네트워크 (LAN) 내에서 네트워크 장비와 디바이스들이 어떻게 물리적 혹은 논리적으로 연결되어 있는지 나타내는 구조</li>\n</ul>\n\n<h2 id=\"lan과-wan\">LAN과 WAN</h2>\n\n<ul>\n  <li><strong>LAN (로컬 영역 네트워크)</strong>:\n    <ul>\n      <li>제한된 지역 내에서 연결된 네트워크</li>\n      <li><strong>스위치</strong>는 MAC 주소를 사용하여 네트워크 내 장치들 간에 데이터를 전달합니다. 스위치는 <strong>MAC 주소 테이블</strong>을 사용해 데이터를 해당 장치로 정확하게 전달</li>\n    </ul>\n  </li>\n  <li><strong>WAN (광역 네트워크)</strong>:\n    <ul>\n      <li>더 넓은 지역, 심지어 전 세계적으로 연결된 네트워크\n        <ul>\n          <li>인터넷이 대표적인 WAN 예시</li>\n        </ul>\n      </li>\n      <li>WAN에서는 서로 MAC 주소를 알 수 없음</li>\n      <li>WAN에서 라우터는 <strong>IP 주소</strong>를 기반으로 데이터를 전달하는데, 각 네트워크 간의 경로를 찾기 위해 <strong>라우팅 테이블</strong>을 사용\n        <ul>\n          <li>NAT / PAT</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cyma1b/btsMcdGGX7j/3HjkxSXXuguLBaXiMCtKp1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:933,”style”:”alignCenter”,”width”:757,”height”:552}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"1-bus-형\">1) Bus 형</h2>\n\n<ul>\n  <li>하나의 메인 케이블(백본)에 모든 노드가 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>구조가 단순하고 설치 비용이 저렴</li>\n      <li>노드 추가/제거가 쉽고 유연함</li>\n      <li>케이블 길이가 짧아 경제적</li>\n      <li>소규모 네트워크에 적합</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>트래픽 증가 시 성능 저하</li>\n      <li>메인 케이블 장애 시 전체 영향</li>\n      <li>데이터 충돌 발생 가능</li>\n      <li>보안 취약점 존재</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cdwQWE/btsMctoZGjP/YoLinRs4T7sWM3Iv3xCkfK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1138,”originHeight”:650,”style”:”alignCenter”,”width”:690,”height”:394}_#][#_Image</td>\n      <td>kage@XghRi/btsMc2doIc4/cDKKGHIAwzkFizYIthmvX1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:978,”originHeight”:456,”style”:”alignCenter”,”width”:620,”height”:289}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"2-ring-형\">2) Ring 형</h2>\n\n<ul>\n  <li>각 노드가 양옆의 두 노드와 연결되어 원형을 이루는 구조</li>\n  <li>자동선택 기능을 사용한 링</li>\n  <li>장점 :\n    <ul>\n      <li>데이터 흐름이 일정하고 예측 가능</li>\n      <li>충돌이 적고 전송이 안정적</li>\n      <li>각 노드가 리피터 역할 수행</li>\n      <li>장거리 전송에 유리</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>단일 노드 장애가 전체에 영향</li>\n      <li>네트워크 확장이 제한적</li>\n      <li>설치/제거 시 네트워크 중단</li>\n      <li>양방향 링 구성 시 비용 증가</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@lYUdr/btsMetVb0e8/23KtOkSs1PeRKuNml0S2AK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1108,”originHeight”:642,”style”:”alignCenter”,”width”:598,”height”:346}_#][#_Image</td>\n      <td>kage@rYlFs/btsMeKWHZEC/wFs32hn23rG7rKA9WFyKxK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:982,”originHeight”:460,”style”:”alignCenter”,”width”:621,”height”:291}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"3-star-형\">3) Star 형</h2>\n\n<ul>\n  <li>중앙에 허브가 있고 모든 노드가 이 허브에 직접 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>구현과 유지보수가 단순하고 직관적</li>\n      <li>개별 노드 장애가 다른 노드에 영향 없음</li>\n      <li>높은 성능과 데이터 전송 속도</li>\n      <li>중앙 집중적 보안 관리 용이</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>중앙 허브 장애 시 전체 네트워크 마비 - 단일 장애 지점 (SPOF)</li>\n      <li>허브에 과부하 발생 가능</li>\n      <li>케이블 설치 비용이 높음</li>\n      <li>허브 용량에 따른 확장성 제한</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@NJ0T7/btsMdF26Hzf/aEmXKMDwoG1TwsmUekA04K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1088,”originHeight”:678,”style”:”alignCenter”,”width”:627,”height”:391}_#][#_Image</td>\n      <td>kage@vFDga/btsMcTgvpqn/IDhAPb27H9xt3kN9pDOB7k/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:456,”style”:”alignCenter”,”width”:585,”height”:277}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"4-mesh-형\">4) Mesh 형</h2>\n\n<ul>\n  <li>모든 노드가 서로 직접 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>높은 안정성과 이중화 구성</li>\n      <li>효율적인 트래픽 분산</li>\n      <li>우회 경로 확보로 신뢰성 높음</li>\n      <li>뛰어난 보안성</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>설치/유지보수 비용이 매우 높음</li>\n      <li>구현과 설정이 매우 복잡</li>\n      <li>케이블 연결 관리가 어려움</li>\n      <li>노드 수 증가에 따른 복잡도 급증</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bb9BX4/btsMeahgXHL/gVJ4LgKjyCG8M1I6DkkbP0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1070,”originHeight”:674,”style”:”alignCenter”,”width”:628,”height”:396}_#][#_Image</td>\n      <td>kage@ovOWb/btsMb2rFLwg/Qi0orK06gCRkfnrkBXhvyK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:432,”style”:”alignCenter”,”width”:677,”height”:303}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"5-tree-형\">5) Tree 형</h2>\n\n<ul>\n  <li>계층적 구조로, 상위 노드에서 하위 노드로 분기되는 형태</li>\n  <li>장점 :\n    <ul>\n      <li>네트워크 확장이 용이</li>\n      <li>체계적인 계층 구조 관리</li>\n      <li>하위 네트워크 독립성</li>\n      <li>효율적인 트래픽 관리</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>루트 노드 장애 시 전체 영향</li>\n      <li>계층 증가에 따른 관리 복잡성</li>\n      <li>상위 노드 병목 현상 가능</li>\n      <li>깊이가 깊어질수록 지연 증가</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@wounf/btsMcywRCH9/2KnaYgagHLQKp4cBdcumy0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:985,”style”:”alignCenter”,”width”:765,”height”:589}_#][#_Image</td>\n      <td>kage@dI6An5/btsMd4hh7vI/Gxr1Nv7uKXeDV0vrZs1qT0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:960,”originHeight”:458,”style”:”alignCenter”,”width”:642,”height”:306}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>192.168.0.1 to 192.168.0.12</li>\n</ul>\n\n<h2 id=\"vlanvirtual-lan-case-1--switch-1개\">VLAN(Virtual LAN) (case 1 : Switch 1개)</h2>\n\n<h2 id=\"vlan이란\">VLAN이란?</h2>\n\n<p>“<strong>논리적인 구조의 속임수로 같은 물리적 공간에 있는 네트워크를 다른 네트워크에 있는 것처럼 속이는 기술</strong>”</p>\n\n<ul>\n  <li>먼저, 물리적인 LAN을 먼저 생각해보면, 같은 건물이나 같은 층에 있는 컴퓨터들이 하나의 네트워크로 연결되어 있는 구조이다.</li>\n  <li>그런데 예를 들면, 마케팅팀과 개발팀이 다른 네트워크에 있어야 한다고 가정해보자.\n    <ul>\n      <li>전통적인 방식이라면 물리적으로 별도의 네트워크 장비와 케이블을 설치해야 했다.</li>\n      <li>하지만, VLAN은 이런 물리적 제약을 소프트웨어적으로 해결한다.</li>\n    </ul>\n  </li>\n  <li>하나의 물리적인 스위치를 마치 여러 개의 독립된 스위치처럼 동작하게 만드는 기술이다.</li>\n  <li>예를 들어, 같은 스위치에 연결된 컴퓨터라도 서로 다른 VLAN에 속하면 마치 다른 네트워크에 있는 것처럼 통신이 분리된다.</li>\n</ul>\n\n<h2 id=\"초기-default-vlan-설정\">초기 default VLAN 설정</h2>\n\n<ul>\n  <li>show vlan으로 확인해보자.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bTHrGF/btsMea2FcPL/VagNQtcNTnfvH7OWzcKevk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1250,”originHeight”:974,”style”:”alignCenter”,”width”:670,”height”:522}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>처음 VLAN 1은 ‘기본 VLAN’이다.</li>\n  <li>모든 스위치 포트는 처음에 이 VLAN 1에 속하도록 설정되어 있다.\n    <ul>\n      <li>그래서 별다른 설정 없이는 같은 물리적인 공간에 있다면 한 네트워크에 속하도록 설정이 된다.</li>\n    </ul>\n  </li>\n  <li>그리고 VLAN 1002부터 1005까지는 특별한 목적으로 예약된 VLAN이다. (사용 불가)\n    <ul>\n      <li>FDDI, 토큰링 등으로 고정되어 있다.</li>\n    </ul>\n  </li>\n  <li>우리가 새로운 VLAN을 할당하려고 하면 “2 ~ 1001” 의 VLAN을 사용해서 나누면 된다.</li>\n</ul>\n\n<h2 id=\"vlan-구성하기\">VLAN 구성하기</h2>\n\n<ul>\n  <li>먼저 VLAN 2개를 생성한다.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch#enable\nSwitch#config terminal\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#vlan 2\nSwitch(config-if)#name VLAN_2\nSwitch(config-if)#exit\n</code></pre></div></div>\n\n<ul>\n  <li>enable : 관리자 모드 진입</li>\n  <li>config terminal : 글로벌 모드 진입</li>\n  <li>vlan 2 : vlan 모드 진입</li>\n  <li>name <이름> : 진입되어 있는 vlan의 이름 설정</이름></li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dsQlbd/btsMdqdX0ps/kPhix6BIWT0KDKtVJzq3NK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1185,”originHeight”:1000,”style”:”alignCenter”,”width”:734,”height”:619}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>결과</p>\n\n<ul>\n  <li>그리고, <code class=\"language-plaintext highlighter-rouge\">VLAN_2</code>엔 <code class=\"language-plaintext highlighter-rouge\">Fa0/1</code> 과 <code class=\"language-plaintext highlighter-rouge\">Fa0/2</code>, <code class=\"language-plaintext highlighter-rouge\">VLAN_3</code>엔 <code class=\"language-plaintext highlighter-rouge\">Fa0/3</code> 과 <code class=\"language-plaintext highlighter-rouge\">Fa0/4</code> 포트를 배정시킨다.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch#enable\nSwitch#config terminal\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#interface fa0/1\nSwitch(config-if)#switchport mode access\nSwitch(config-if)#switchport access vlan 2\n</code></pre></div></div>\n\n<ul>\n  <li>inteface fa0/1 : 인터페이스 모드 진입</li>\n  <li>switchport mode access : 해당 포트를 VLAN 전용으로 사용함을 선언</li>\n  <li>switchport access vlan 2 : 해당 포트가 속한 VLAN 번호 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@GEPhJ/btsMcd0ZUA9/NJfHXH7fr603Pozrp0XUN1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:779,”style”:”alignCenter”,”width”:697,”height”:424,”caption”:”결과”}_#][#_Image</td>\n      <td>kage@ZktHy/btsMceFDArB/GmkkKk7xrFmJK5XI7GNxS1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:975,”style”:”alignCenter”,”width”:686,”height”:523}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"vlan-통신-테스트\">VLAN 통신 테스트</h2>\n\n<ol>\n  <li><code class=\"language-plaintext highlighter-rouge\">192.168.0.1</code> to <code class=\"language-plaintext highlighter-rouge\">192.168.0.2</code>\n    <ul>\n      <li>같은 VLAN 내에서는 통신 가능</li>\n    </ul>\n  </li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@BqqF9/btsMceevW1X/38cHtm9y7VtBM8yRsEMKb1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:742,”originHeight”:340,”style”:”alignCenter”,”width”:653,”height”:299}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li><code class=\"language-plaintext highlighter-rouge\">192.168.0.1</code> to <code class=\"language-plaintext highlighter-rouge\">192.168.0.2</code></li>\n</ol>\n\n<ul>\n  <li>다른 VLAN 끼리는 통신 불가능</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@905VT/btsMcKD1XhO/HVQpVtHJXEQCpfTAUkHWYk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1060,”originHeight”:502,”style”:”alignCenter”,”width”:668,”height”:316}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"vlanvirtual-lan-case-2--switch-여러-개\">VLAN(Virtual LAN) (case 2 : Switch 여러 개)</h2>\n\n<ul>\n  <li>그렇다면 네트워크를 확장하고 좀 더 현실적인 아키텍쳐로 바뀌면 어떨까?</li>\n  <li>먼저 Switch를 하나 더 두어보자.</li>\n  <li><em>들어가기전</em>\n    <ul>\n      <li>VLAN 설정 자체는 IP 주소를 직접 변경하지 않는다.\n        <ul>\n          <li>VLAN은 Layer 2(데이터 링크 계층)에서 작동하는 반면,<br />\nIP 주소는 Layer 3(네트워크 계층)에서 작동하기 때문.</li>\n        </ul>\n      </li>\n      <li>그러나, 실제 네트워크 운영에서는 일반적으로 각 VLAN마다 서로 다른 IP 대역을 할당한다.\n        <ul>\n          <li>네트워크 관리와 보안을 위한 설계</li>\n        </ul>\n      </li>\n      <li>그러므로 VLAN 별로 다른 대역을 할당해보자.\n        <ul>\n          <li>VLAN 2: 203.237.20.nnn</li>\n          <li>VLAN 3: 203.237.30.nnn</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@pcw1H/btsMc0NoTlz/v9c56wkkpb2qWxKk6BEsq0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1031,”originHeight”:1000,”style”:”alignCenter”,”width”:680,”height”:660}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 0 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@d5TDWZ/btsMekcZbAx/1meC8Kjg2Niht4JKNpWjE1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:325,”style”:”alignCenter”,”width”:757,”height”:192}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 1 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bxI7Ez/btsMcsXSPgC/McV65YvUN8ELGhZbpqxaEK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:336,”style”:”alignCenter”,”width”:750,”height”:197}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>여기서 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>🤔 과연 PC2는 PC0과 통신이 가능할까?\n    <ul>\n      <li>결과를 보면, PC1과는 통신이 가능하지만, 다른 스위치로 넘어가면서 통신이 불가능해진다</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cdqmkw/btsMeSmNMeI/jnvpXenhi6dV8W4U8oGWaK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:994,”originHeight”:806,”style”:”alignCenter”,”width”:664,”height”:538}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>이런 논리적인 흐름의 질문이 든다.\n    <ol>\n      <li>오히려 VLAN 설정하기 전에 그냥 여러 스위치를 건너 뛰어도 통신이 됐음.</li>\n      <li>그리고 같은 VLAN 끼리는 통신이 된다고 했다.</li>\n      <li>그런데 갑자기 같은 VLAN에서 여러 스위치를 건너뛰면 왜 통신이 안될까?</li>\n    </ol>\n  </li>\n  <li>여기서 <strong>VLAN 태그</strong>라는 개념이 등장한다.\n    <ul>\n      <li>VLAN을 설정하면 각 패킷에는 특별한 VLAN ID가 붙게 된다.\n        <ul>\n          <li>(마치 우편물에 부서명을 적는 것과 같다.)</li>\n        </ul>\n      </li>\n      <li>일반적인 스위치의 Port(Access Port)는 VLAN 태그를 처리하는 방법에 대해 1가지 밖에 모른다.\n        <ul>\n          <li>PACKET 들어올 때 : 자신의 VLAN 번호를 태그로 붙인다.</li>\n          <li>PACKET 나갈 때 : 태그를 제거하고 보낸다.</li>\n        </ul>\n      </li>\n      <li>그럼 여기서 문제가 발생한다.\n        <ul>\n          <li>PC2에서 나온 패킷\n            <ul>\n              <li>Switch 0으로 들어올 때 : fa0/2에서 VLAN 2 태그를 붙임</li>\n            </ul>\n          </li>\n          <li>이 패킷이 fa0/5로 가면서 VLAN 1의 통신으로 취급됨 [VLAN 2 태그가 떨어짐]</li>\n          <li>다른 스위치의 fa0/3에 도착했을 때도 VLAN 1의 통신으로 인식됨</li>\n          <li>결과적으로 원래의 VLAN 2 통신이 의도대로 전달되지 못함.</li>\n        </ul>\n      </li>\n      <li>[즉, <strong>Switch0의 fa0/와 Switch1의 fa0/3이 VLAN 1이기 때문</strong>]</li>\n    </ul>\n  </li>\n</ul>\n\n<p>→ <strong>스위치 간 VLAN 전용 통로가 필요하다!</strong></p>\n\n<h2 id=\"트렁크trunk\">트렁크(Trunk)</h2>\n\n<p>[먼저 PC2가 PC0과 통신이 가능하도록 해결해보자]</p>\n\n<ul>\n  <li>Switch0과 Switch1간에 VLAN 2,3 전용 포트 따로 설정!</li>\n  <li>switch0의 fa0/5, fa0/6을 각각 VLAN 2,3 전용으로 설정</li>\n  <li>switch1의 fa0/3, fa0/4를 각각 VLAN 2,3 전용으로 설정</li>\n  <li>Switch 0 포트의 VLAN 상태</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b3x84T/btsMei0AEyD/DYcMw88NkSnY9eQ8B22zcK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1154,”originHeight”:64,”style”:”alignCenter”,”width”:699,”height”:39}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 1 포트의 VLAN 상태</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@URbjM/btsMdIyMTr2/uZ7hOtRQPSYbugPuyZe3s1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1064,”originHeight”:74,”style”:”alignCenter”,”width”:731,”height”:51}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC2에서 PC0로 통신이 가능하다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@AcI9Y/btsMeveoKpG/MRkQDsbDHXP76MV9pLzZR0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:956,”originHeight”:432,”style”:”alignCenter”,”width”:727,”height”:329}_#][#_Image</td>\n      <td>kage@cav9Br/btsMdpMVs7n/kO9tRv5kLVsRKP9bNXqDuK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:714,”originHeight”:510,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>그런데 또 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>🤔 과연 VLAN 별 통신 라인 추가가 바람직한 해결인가?\n    <ul>\n      <li>만약 VLAN이 수백개라면..?</li>\n      <li>일일이 연결해줄 수 없다</li>\n      <li>또한 추가 가능한 VLAN ID는 1000개.\n        <ul>\n          <li>→ <strong>Trunk</strong> 가 해결책</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"트렁크란\">트렁크란?</h2>\n\n<ul>\n  <li><strong>트렁크는 모든 VLAN 패킷을 하나의 포트로 통과시키는 것</strong></li>\n  <li>스위치 간 프레임 전달에 하나의 물리적 연결(포트)를 공유하는 것.</li>\n  <li>VLAN 트렁킹된 스위치들 간에 여러 VLAN에서 나온 프레임들을 이 트렁크를 통해 전달한다.</li>\n  <li>즉, 스위치와 스위치 간 프레임 전달 시 하나의 포트에 다수의 VLAN이 지나갈 수 있도록하는 링크.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch(config)#interface fa0/5\nSwitch(config-if)#switchport mode trunk\n\nSwitch(config-if)#\n%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to down\n\n%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to up\nexit\nSwitch(config)#exit\nSwitch#\n%SYS-5-CONFIG_I: Configured from console by console\nshow interface trunk\nPort        Mode         Encapsulation  Status        Native vlan\nFa0/5       on           802.1q         trunking      1\n\nPort        Vlans allowed on trunk\nFa0/5       1-1005\n\nPort        Vlans allowed and active in management domain\nFa0/5       1,2,3\n\nPort        Vlans in spanning tree forwarding state and not pruned\nFa0/5       none\n</code></pre></div></div>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cj9Kft/btsMcrLrqjC/NZkK8P615yIbq5LWFeBswk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:839,”style”:”alignCenter”,”caption”:”Switch0의 Fa0/5 포트 Trunk 설정”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li>Fa0/5가 트렁크 포트로 on (강제로 트렁크 모드로 설정) 되었다.</li>\n  <li>1~1005는 이론적으로 모든 VLAN 범위가 통과 가능하다.</li>\n  <li>실제 현재 사용 중인 VLAN : 1, 2, 3이 현재 활성화되어 있다.</li>\n  <li>Vlans in spanning tree forwarding state and not pruned : None<br />\n(활성화된 VLAN들이 여기 나타나야 한다. - 없다.)</li>\n</ol>\n\n<ul>\n  <li>Fa0/5 포트는 Native VLAN이 1로 설정됨</li>\n  <li>반대편 Fa0/3 포트는 Native VLAN이 2로 설정됨\n    <ul>\n      <li>Switch1의 Fa0/3 포트도 Trunk로 설정해준다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@kzW3S/btsMec7cVIK/IBXxcLCh7BYeCYd9J2nScK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1136,”originHeight”:414,”style”:”alignCenter”,”width”:654,”height”:238}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>물론 PC2에서 PC0로 통신이 가능해졌다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bryfWp/btsMcPE65aP/UGX9KHYfm1QMvME24buAtk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:956,”originHeight”:428,”style”:”alignCenter”,”width”:706,”height”:316}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"inter-vlan\">Inter-VLAN</h2>\n\n<ul>\n  <li>놓치면 안되는 것의 “<strong>기술의 도입에 대한 목적</strong>”이다.\n    <ul>\n      <li>VLAN의 목적은 가상의 LAN으로서 관리의 편리성 추구이며,<br />\n다른 VLAN과의 통신 제한이 아니다.</li>\n    </ul>\n  </li>\n  <li>그럼, 서로 다른 VLAN 간의 통신이 가능하도록 하는 방법은 없을까?</li>\n  <li>VLAN 간 통신을 하려면 라우터(게이트웨이)가 있어야 한다.\n    <ul>\n      <li>라우터를 경유하여 마치 다른 LAN으로 통신하는 것처럼 동작한다.</li>\n    </ul>\n  </li>\n  <li>[다른 네트워크 영역은 라우터가 필요!!!]</li>\n</ul>\n\n<h2 id=\"서브-인터페이스\">서브 인터페이스</h2>\n\n<ul>\n  <li>단순히 생각하면 이런 생각이 든다.</li>\n  <li>전통적인 라우터 방식: 각 VLAN마다 라우터의 물리적 인터페이스를 하나씩 사용</li>\n  <li>그러나 이런 생각의 전환을 해본다.\n    <ul>\n      <li><strong>하나의 물리적 라우터 인터페이스에 여러 개의 논리적 인터페이스를 생성하여 각각 다른 VLAN을 처리할 수 있도록 할 수 있다면?</strong></li>\n      <li>그런데, Fa0/0이라는 물리적 라우터 인터페이스에 어떻게 여러 개의 논리적 인터페이스를 생성할까?</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@Y1VKx/btsMeSUECM4/0Qz0wbAb4G4UBmT0SLhXYk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:260,”originHeight”:298,”style”:”alignCenter”,”width”:167,”height”:191}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>서브 인터페이스: 하나의 인터페이스에 여러 VLAN들의 인터페이스를 논리적으로 나누는 것</li>\n  <li>2811 모델을 추가해준다!\n    <ul>\n      <li>참고 :</li>\n      <li><em>2811 라우터는 Cisco의 중급 라우터로, Inter-VLAN 라우팅을 위한 서브인터페이스 구성을 지원합니다. 서브인터페이스란 하나의 물리적 인터페이스를 여러 개의 논리적 인터페이스로 나누어 사용할 수 있게 해주는 기능입니다. 이는 마치 하나의 도로를 여러 개의 차선으로 나누어 서로 다른 목적지로 가는 차들을 효율적으로 처리하는 것과 비슷합니다.</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p>1. fa0/0 활성화</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dysMoj/btsMcdzWje7/FkpECQDsjzhv7gtsA3SGI1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:846,”originHeight”:200,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>2. fa0/0.2 생성, VLAN2 연결, IP주소 할당 &amp; fa0/0.3 생성, VLAN3 연결, IP주소 할당</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b2QZaS/btsMb1M28tD/PwRCtfFGc9U9WdizCjU6pk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:691,”style”:”alignCenter”,”width”:790,”height”:426}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>3. switch1 fa0/4를 트렁크 모드로 설정</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bGoCk8/btsMdHT860Z/dwqr98u0ihaJDerscGQ7j1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1248,”originHeight”:546,”style”:”alignCenter”,”width”:718,”height”:314}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>4. Router의 서브 인터페이스 상태 확인</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bnyTgA/btsMevrWYog/pDkKHGHiWCNLKzR85a7Qn1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:219,”style”:”alignCenter”,”width”:819,”height”:140}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>5. 게이트웨이 설정</p>\n\n<p>- VLAN 2 (PC0, 1, 2) → 203.237.20.254</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bjr2GX/btsMey9WnrP/zNHfPdHwYlhyUSeIwsz6n0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:384,”style”:”alignCenter”,”width”:767,”height”:230}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>- VLAN 3 (Laptop0, 1, 2) → 203.237.30.254</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@9Pp8f/btsMcxY6pxv/toN6xYeoWLuqsvp1xIlJ90/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:606,”style”:”alignCenter”,”width”:773,”height”:366}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h1 id=\"스위치\">스위치</h1>\n\n<hr />\n\n<h2 id=\"스위치의-동작-원리\">스위치의 동작 원리</h2>\n\n<h2 id=\"mac-주소-테이블-동작-원리\">MAC 주소 테이블 동작 원리</h2>\n\n<ul>\n  <li>스위치와 노드들이 <strong>ARP</strong>를 통해 MAC 주소 정보를 지속적으로 교환한다.\n    <ul>\n      <li>ARP 프로토콜에 포함된 MAC 주소 정보를 기반으로 스위치의 MAC 주소 테이블이 구축된다.</li>\n      <li>실제 데이터 전송 (ping 등)이 발생하면, 이 MAC 주소 테이블을 참조하여 패킷을 적절한 포트로 전달</li>\n    </ul>\n  </li>\n  <li>MAC 주소 테이블은 네트워크 토폴리지 변화를 반영하기 위해 일정 주기로 초기화되며, 최신 정보로 동적 갱신된다.</li>\n</ul>\n\n<h2 id=\"arp란\">ARP란?</h2>\n\n<ul>\n  <li>IP 네트워크에서 IP 주소를 물리적인 MAC 주소로 변환하는 핵심 프로토콜</li>\n  <li>컴퓨터가 같은 네트워크 상의 다른 장치와 통신하려면 반드시 상대방의 MAC 주소를 알아야 하는데,<br />\nARP가 이 주소 변환 과정을 자동으로 처리해준다.</li>\n</ul>\n\n<h2 id=\"arp를-활용한-동작-원리\">ARP를 활용한 동작 원리</h2>\n\n<p><em>PC0에서 Laptop0으로 ping을 보낸다고 가정</em></p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cDoPQ4/btsMdLhTSuP/NdTWBqnwp8pAXYoKUrWZrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:988,”originHeight”:436,”style”:”alignCenter”,”width”:742,”height”:327}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li>ARP Request (PC0 → Switch0)\n    <ul>\n      <li>PC0이 Laptop0의 MAC 주소를 알아내기 위해 ARP 요청 패킷 전송</li>\n      <li>패킷 내용:\n        <ul>\n          <li>출발지: PC0의 IP 주소와 MAC 주소</li>\n          <li>목적지: Laptop0의 IP 주소 (MAC 주소는 미확인 상태)</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>스위치 <strong>브로드캐스트</strong> (Switch0 → 모든 노드)\n    <ul>\n      <li>Switch0은 PC0의 <strong>MAC 주소를 자신의 테이블에 기록</strong></li>\n      <li>수신한 ARP 요청 패킷을 모든 포트로 브로드캐스트</li>\n    </ul>\n  </li>\n  <li>ARP reply (Laptop0 → Switch0)\n    <ul>\n      <li>Laptop0이 자신의 IP 주소를 확인하고 ARP 응답 패킷 생성</li>\n      <li>패킷 내용:\n        <ul>\n          <li>출발지: Laptop0의 IP 주소와 MAC 주소</li>\n          <li>목적지: PC0의 IP 주소와 MAC 주소</li>\n        </ul>\n      </li>\n      <li>Laptop0은 PC0의 MAC 주소를 자신의 ARP 캐시에 저장</li>\n    </ul>\n  </li>\n  <li>스위치 전달 단계 (Switch0 → PC0)\n    <ul>\n      <li>Switch0은 수신한 응답 패킷을 PC0에게 전달</li>\n      <li>PC0과 Laptop0의 MAC 주소 정보를 MAC 주소 테이블에 저장</li>\n    </ul>\n  </li>\n  <li>통신 시작\n    <ul>\n      <li>PC0이 Laptop0의 MAC 주소를 획득하여 실제 데이터 통신 가능</li>\n    </ul>\n  </li>\n</ol>\n\n<h2 id=\"시뮬레이션\">시뮬레이션</h2>\n\n<ul>\n  <li>시뮬레이션을 눌러서 이벤트 목록창을 볼 수 있다.</li>\n  <li>편지봉투 모양의 [Add Simple PDU] → ICMP 패킷 전송 시뮬레이션</li>\n  <li>송신노드와 수신 노드를 클릭하고 Show All/None 클릭 후 ARP, ICMP 패킷만 클릭한다.</li>\n  <li><em>PC0에서 Laptop0으로 편지를 보낸다.</em></li>\n  <li>ARP - ICMP 순으로 통신이 이루어진다.</li>\n</ul>\n\n<h2 id=\"1-arp-패킷-분석\">1) ARP 패킷 분석</h2>\n\n<p>1. PC0 → Switch0 ARP Request</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cwVj4Z/btsMcHN0AZ1/QtiRKPTAkw5cwMHngIJq5K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:900,”originHeight”:1158,”style”:”alignCenter”,”width”:522,”height”:672}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>ARP\n    <ul>\n      <li>Source MAC<br />\n= PC0 의 MAC 주소</li>\n      <li>Source IP<br />\n= PC0의 IP 주소</li>\n      <li>Target MAC<br />\n= Laptop 의 MAC 주소 [모르는 주소]</li>\n      <li>Target IP<br />\n= Laptop0의 IP주소</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2. Switch0 → 모든 노드 (브로드캐스트)</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dvlpX3/btsMdr43c4X/YNHxFWmjmqgayudoXkG1l0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:818,”originHeight”:124,”style”:”alignCenter”,”width”:594,”height”:90}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch0은 수신한 ARP Request를 모든 포트로 전달</li>\n  <li>Switch0의 MAC 주소 테이블에 PC0의 정보 기록\n    <ul>\n      <li>포트 번호와 PC0의 MAC 주소 매핑</li>\n    </ul>\n  </li>\n</ul>\n\n<p>3. Laptop0→ Switch0 ARP Reply</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@K4KvV/btsMcdUawiw/VpUysCPR5W9T4yYTKTcqJK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1002,”originHeight”:1242,”style”:”alignCenter”,”width”:627,”height”:777}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>ARP\n    <ul>\n      <li>Source MAC<br />\n= Laptop0 의 MAC 주소</li>\n      <li>Source IP<br />\n= Laptop0의 IP 주소</li>\n      <li>Target MAC<br />\n= PC0 의 MAC 주소</li>\n      <li>Target IP<br />\n= Laptop0의 IP주소</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"2-icmp-패킷-분석\">2. ICMP 패킷 분석</h2>\n\n<ol>\n  <li>PC → Laptop</li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@6AWAV/btsMdMA4Jmh/dd2ilCfmHRbqRt9DFVNWhK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2056,”originHeight”:1186,”style”:”alignCenter”,”width”:690,”height”:398}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>SRC ADDR = PC0의 MAC 주소</li>\n  <li>DEST ADDR = Laptop0의 MAC 주소</li>\n</ul>\n\n<h2 id=\"3-switch0의-mac-주소-테이블-변화\">3) Switch0의 MAC 주소 테이블 변화</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dEbxME/btsMdnn7IXG/koFfWfejqCW9bxxbzaYPb0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1080,”originHeight”:611,”style”:”alignCenter”,”width”:747,”height”:423}_#][#_Image</td>\n      <td>kage@WjEAg/btsMdmbIixx/in3AqgZZ7OkLwPpGkcb270/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1080,”originHeight”:734,”style”:”alignCenter”,”width”:727,”height”:494}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>위를 보니 Fa0/1 Fa0/4에 연결된 PC0과 Laptop0의 MAC 주소가 테이블에 기재되었다.</li>\n</ul>\n\n<p>🤔 갑자기 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>Switch0 → 모든 노드로 BroadCast할 때 각자의 MAC 주소 받아오면 되는거 아닌가?</li>\n  <li>해답은 ARP를 이용해 MAC 주소 테이블이 어떻게 유지하는지의 방법에 있다.\n    <ul>\n      <li>스위치의 MAC 주소 학습은 ‘출발지(Source) MAC 주소’만을 대상으로 한다.\n        <ul>\n          <li>PC0이 ARP Request를 보낼 때</li>\n          <li>Laptop0이 ARP Reply를 보낼 때</li>\n        </ul>\n      </li>\n      <li>모든 노드로 전달된 ARP-Request 패킷에 대해 수신 노드가 아니면 응답하지 않는다.</li>\n      <li>PC1과 Laptop1은 Swtich0이 전달한 ARP-Request에 대해 Reply 하지 않는다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>그런데 이런 ‘고민’도 떠오른다.</p>\n\n<p>1.효율성</p>\n\n<ul>\n  <li>ARP는 매우 짧은 시간 간격으로 반복 실행한다.\n    <ul>\n      <li>노드들이 많은 네트워크에서는 통신량으로 부하 가중</li>\n      <li>특히 스위치가 모든 노드에게 BroadCast하는 ARP-Request에서</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2. 보안상의 문제</p>\n\n<ul>\n  <li>Laptop1이 악의적인 공격자라고 가정해보자.\n    <ul>\n      <li>ARP Reply가 실제로 해당 IP 주소를 가진 정당한 장치에서 온 것인지 확인하지 않는다. (보안 X)</li>\n      <li>이 때 Laptop0의 IP에 Laptop1 MAC 주소를 실어서 Reply한다면?</li>\n      <li>테이블이 제대로 갱신되기 전까지 PC0은 Laptop0인 줄 알고 모든 패킷을 보낸다.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"vlan을-통한-해결\">VLAN을 통한 해결</h2>\n\n<ul>\n  <li>MAC 주소를 이용한 라우팅\n    <ul>\n      <li>동일한 네트워크(LAN)에서 스위치를 통해서만 발생한다.</li>\n      <li>라우터를 통한 외부 네트워크로의 통신에는 사용되지 않는다.\n        <ul>\n          <li>ARP 패킷은 하나의 네트워크에서만 송수신한다.</li>\n          <li>LAN을 논리적으로 분리된 가상의 VLAN으로 관리한다.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h1 id=\"라우터\">라우터</h1>\n\n<hr />\n\n<h2 id=\"라우터란\">라우터란?</h2>\n\n<ul>\n  <li>라우터는 서로 다른 네트워크를 연결하는 3계층 장비.</li>\n  <li>IP 주소를 기반으로 패킷의 최적 경로를 결정하고 전달한다.\n    <ul>\n      <li>스위치가 같은 네트워크 내에서 MAC 주소를 기반으로 통신을 담당한다면,</li>\n      <li>라우터는 서로 다른 네트워크 간의 통신을 가능하게 만드는 일종의 ‘네트워크 간의 다리’ 역할을 한다.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"라우터의-mode\">라우터의 Mode</h2>\n\n<ul>\n  <li><strong>사용자 모드(User EXEC Mode)</strong>\n    <ul>\n      <li>기본적인 정보 조회만 가능, 설정 변경 불가</li>\n      <li>&gt; 로 표시</li>\n    </ul>\n  </li>\n  <li><strong>관리자 모드(Privileged EXEC Mode)</strong>\n    <ul>\n      <li>라우터 설정을 변경할 순 없지만 시스템 정보 상세조회 가능</li>\n      <li># 으로 표시</li>\n    </ul>\n  </li>\n  <li><strong>글로벌 모드(Global Configuration Mode)</strong>\n    <ul>\n      <li>라우터 설정(이름, 보안, 인터페이스 등)을 변경</li>\n      <li>(config)# 로 표시</li>\n      <li><strong>라인 모드(Line Configuration Mode)</strong>\n        <ul>\n          <li>콘솔, 원격 접속(Telnet, SSH 등) 관련 설정 변경</li>\n          <li>(config-line)# 로 표시</li>\n        </ul>\n      </li>\n      <li><strong>인터페이스 모드(Interface Configuration Mode)</strong>\n        <ul>\n          <li>라우터의 네트워크 인터페이스(이더넷, 시리얼 등) 설정을 변경</li>\n          <li>라우터의 인터페이스에 IP 주소를 설정하고 활성화/비활성화</li>\n          <li>(config-if)# 로 표시</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"목표-네트워크-구성\">목표 네트워크 구성</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@FrASQ/btsMeLVCXVC/1wKsZjYPW9BikRxL7DFtC1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:813,”originHeight”:495,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"기본-설정\">기본 설정</h2>\n\n<ul>\n  <li>라우터 3대: [Network Devices] → [Routers] → [2811]</li>\n  <li>스위치 1대 : [Network Devices] → [Switches] → [2960]</li>\n  <li>PC 3대, 노트북 1대, 서버 1대 : [End Devices] → [PC], [Laptop], [Server]</li>\n</ul>\n\n<h2 id=\"라우터---시리얼-인터페이스-장착\">라우터 - 시리얼 인터페이스 장착</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@zgPDU/btsMd3bDPMR/E6TXH94lrMz3OrUR6TF5hK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:1293,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC와 달리 두 라우터 간에 데이터를 주고받기 위한 동기화가 필요</li>\n  <li>FastEthernet이 아닌 Serial 인터페이스를 사용하므로 모듈을 추가해야 한다.\n    <ul>\n      <li>HWIC-2T 추가</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"노드-간-연결하기\">노드 간 연결하기</h2>\n\n<ul>\n  <li>Laptop0은 통신용이 아니라 Router0을 설정하기 위한 콘솔\n    <ul>\n      <li>FastEthernet 케이블이 아닌 RS232(하늘색) 케이블로 연결</li>\n    </ul>\n  </li>\n  <li>라우더들끼리 Serial DCE 연결\n    <ul>\n      <li>먼저 클릭한 쪽에 시계 모양 - 두 라우터 간 데이터를 주고받기 위한 동기화가 필요</li>\n      <li>Serial DCE(Data Communication Equipment): 시간 동기화를 주도하는 노드 (시계 있는 쪽)</li>\n      <li>Serial DTE(Data Terminal Equipment): 그에 따라 동기화하는 노드 (시계 없는 쪽)</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@evpmpX/btsMdMnzPql/PLX7aieEhAKMJ6N99C2j5K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2184,”originHeight”:1246,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"ip-설정\">IP 설정</h2>\n\n<ul>\n  <li>컴퓨터들은 203.237.nnn.nnn/24 사용(C클래스)\n    <ul>\n      <li>1번부터 시작</li>\n    </ul>\n  </li>\n  <li>원격 관리가 필요한 스위치나 서버는 100번 부터</li>\n  <li>라우터는 광역의 랜들을 연결하므로 A클래스 IP 사용\n    <ul>\n      <li>규모가 작아 30비트 서브넷 마스크를 사용하여 최대 4개의 라우터를 묶을 수 있도록</li>\n    </ul>\n  </li>\n  <li>스위치는 2계층 장비\n    <ul>\n      <li>IP 주소 설정 불필요</li>\n      <li>원격 접속으로 스위치 관리\n        <ul>\n          <li>IP 주소 할당 필요</li>\n          <li>VLAN1에 할당</li>\n        </ul>\n      </li>\n      <li>스위치 IP 주소 설정</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bk8xpK/btsMd7Sxxul/dQMOVhudaYmzsa519EoeQK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1374,”originHeight”:164,”style”:”alignCenter”,”width”:635,”height”:76}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>총 6개의 LAN</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@UGTSj/btsMcKRyRRh/QFOQKnpr0nm0a6K8eUWWKk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1762,”originHeight”:1000,”style”:”alignCenter”,”width”:698,”height”:396}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"연결-확인\">연결 확인</h2>\n\n<ul>\n  <li>PC0에서 테스트</li>\n</ul>\n\n<ol>\n  <li>PC0 로컬 호스트(127.0.0.1)</li>\n  <li>PC0 → Switch1(VLAN1, 203.237.10.100)</li>\n  <li>PC0 → Server0(203.237.10.101)</li>\n  <li>PC0 → Router0(203.237.10.254)\n    <ul>\n      <li>모두 통신 성공</li>\n    </ul>\n  </li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@s9v2J/btsMcYPw7T1/QedNlAylJ9wAnApW81hp3K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1000,”originHeight”:1605,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>5. PC0 → PC2(203.237.30.1)</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@mi021/btsMdHGFlHG/cChGsiN9Pw0rWY0kG0w7q1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:996,”originHeight”:374,”style”:”alignCenter”,”width”:684,”height”:257}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><strong>unreachable</strong> 이 발생한다\n    <ul>\n      <li>PC0으로 부터 받은 패킷을 Router0이 어느 인터페이스로 보내야할지 모르기 때문</li>\n      <li>→ <strong>라우팅 테이블</strong>이 필요하다</li>\n      <li>아래는 Router0의 라우팅 정보</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@beagrf/btsMdMujNSG/uzGad36EzxcCPqRZ3PJy21/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1260,”originHeight”:698,”style”:”alignCenter”,”width”:746,”height”:413}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"정적-라우팅-설정\">정적 라우팅 설정</h2>\n\n<ul>\n  <li>정적 라우팅 대상\n    <ul>\n      <li>1번 PC0 입장에서 목적지가\n        <ul>\n          <li><strong>2번</strong> 네트워크(203.237.20.nnn/24)인 패킷 : serial0/3/0 (혹은 1.1.1.2)</li>\n          <li><strong>3번</strong> 네트워크(203.237.30.nnn/24)인 패킷 : serial0/3/1 (혹은 2.2.2.2)</li>\n          <li>6번 네트워크(3.3.3.nnn/30)인 패킷 : serial0/3/0 혹은 serial0/3/1</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>Router1의 정적 라우팅 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@JLnX1/btsMckFDkMJ/ik8vROKAHLaZQPxINyMSmK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1226,”originHeight”:442,”style”:”alignCenter”,”width”:694,”height”:250}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Router2의 정적 라우팅 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@k4yPj/btsMexiTcvl/Ewo59hWdxO2tOqMp9GTtNK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1248,”originHeight”:504,”style”:”alignCenter”,”width”:736,”height”:297}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Router3의 정적 라우팅 설정 + route 확인</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cnu0SN/btsMdH0043d/jjkekr1KEkmqtXM0E7LRUK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1270,”originHeight”:1186,”style”:”alignCenter”,”width”:756,”height”:706}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"통신테스트-by-ping\">통신테스트 by ping</h2>\n\n<ul>\n  <li>PC0 ↔ PC1</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dD0uXu/btsMb0Hnvj9/50DKkNchVlTaBfBiYNEMiK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:962,”originHeight”:422,”style”:”alignCenter”,”width”:730,”height”:320}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC0 ↔ PC2</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cEoaLU/btsMdGgIz36/93lJ36D1HjrKK9gQaOKvb1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:432,”style”:”alignCenter”,”width”:780,”height”:350}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h1 id=\"방화벽---네트워크-구성\">방화벽 - 네트워크 구성</h1>\n\n<hr />\n\n<h2 id=\"망구성\">망구성</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@kO9qL/btsMengxOIb/FFIVXRjKkeW6JnSOKHGXqk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:524,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"asa0-구성-설정\">ASA0 구성 설정</h2>\n\n<p>1. 인터페이스 통신 상태</p>\n\n<ul>\n  <li>내부망 : 통신 가능</li>\n  <li>외부망 : 통신 불가\n    <ul>\n      <li>inPC → outPC 불가능</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bh2bBN/btsMd7rqkl0/g4AYl1hwkqpXZ1NDwCwO30/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1278,”originHeight”:266,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>2. IP 주소 설정</p>\n\n<ul>\n  <li>Inside : 설정됨</li>\n  <li>outside : 설정되어있지 않음\n    <ul>\n      <li>→ VLAN에서 203.237.20.253으로 설정</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cormPm/btsMc1r1E8A/LKXIkkQ8YcBwbHGgFGWQIk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1406,”originHeight”:342,”style”:”alignCenter”,”width”:807,”height”:196}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>3. Config 확인</p>\n\n<ul>\n  <li>내부망 Security-level : 100</li>\n  <li>외부망 Security-level : 0</li>\n  <li>보안 레벨이 높은 곳 → 낮은 곳 : 허용 (반대는 불가능)</li>\n  <li>내부망 노드들은 DHCP를 이용하여 IP 할당받는다.</li>\n</ul>\n\n<h2 id=\"inpc-dhcp-설정\">inPC DHCP 설정</h2>\n\n<ul>\n  <li>inPC는 ASA가 DHCP로 주소를 할당해준다고 했다.\n    <ul>\n      <li>게이트웨이는 ASA0 inside의 ip 주소로 고정된다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@HAypL/btsMemIHLU2/tcja6hVK1aurUDoEGiKLAK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1388,”originHeight”:636,”style”:”alignCenter”,”width”:703,”height”:322}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>outPC는 고정 주소 사용 중</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@lNS8u/btsMdHzVPu4/iHvbzNmifAq1gElLiDlpW1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1304,”originHeight”:546,”style”:”alignCenter”,”width”:707,”height”:296}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"router0-설정\">Router0 설정</h2>\n\n<ul>\n  <li>fa0/0 IP 설정 &amp; 활성화\n    <ul>\n      <li>203.237.10.254/24</li>\n    </ul>\n  </li>\n  <li>fa0/0 IP 설정 &amp; 활성화\n    <ul>\n      <li>203.237.20.253/24</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"rna-설정\">RNA 설정</h2>\n\n<h2 id=\"routing\">Routing</h2>\n\n<ul>\n  <li>라우터의 정적라우팅\n    <ul>\n      <li>네트워크 디바이스들이 서로 다른 네트워크에 있을 때, 그들 사이의 통신 경로를 명확히 지정해줘야 한다.</li>\n      <li>예를 들어, 내부 네트워크의 PC가 다른 네트워크의 서버와 통신하려면, 그 경로를 알아야 한다.</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">ip route &lt;목적지 네트워크 주소&gt; &lt;목적지 서브넷 마스크&gt; &lt;다음 홉 IP 주소/출구 인터페이스&gt;</code></li>\n    </ul>\n  </li>\n  <li>방화벽의 정적라우팅\n    <ul>\n      <li>트래픽이 반드시 방화벽을 통과하도록 하여 보안 정책을 적용할 수 있게 한다.</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">route &lt;VLAN명&gt; &lt;외부망 네트워크 주소&gt; &lt;외부망 서브넷마스크&gt; &lt;다음 홉 IP 주소&gt;</code></li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@UMo4w/btsMemPruKw/su6TBN30w2NLPGdTiu8nN0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2110,”originHeight”:1000,”style”:”alignCenter”,”width”:734,”height”:348}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>→ 어떤 목적지 주소를 갖는 패킷이든 외부망의 Router0인 203.207.20.254로 전송한다.</p>\n\n<ul>\n  <li>통신확인</li>\n  <li>inPC ↔ ASA0</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@ea7sUx/btsMcHURKDV/D3ikyzQhpSkEa8QCBP2sK1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:972,”originHeight”:428,”style”:”alignCenter”,”width”:708,”height”:312}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>inPC ↔ outPC</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b7mUIE/btsMcfqYrdM/SvtR3wkJNdKRzXgHMUMtIK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:986,”originHeight”:368,”style”:”alignCenter”,”width”:702,”height”:262}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"nat\">NAT</h2>\n\n<ul>\n  <li>inPC → outPC 까지는 패킷 전달이 잘 되지만,</li>\n  <li>Router0 → ASA0으로 전달이 되지 않는다.</li>\n</ul>\n\n<p><strong>outPC → Router1로 전달되는 패킷</strong></p>\n\n<ul>\n  <li>outPC(203.237.10.10)가 inPC(192.168.1.5)로 통신을 시도할 때, Router는 문제에 직면한다.\n    <ul>\n      <li>목적지 주소가 사설IP이기 때문에 외부에서 인식이 불가능하다.</li>\n      <li>→ Rotuer 입장에서 어디로 보내야 할 지 모른다.\n        <ul>\n          <li>(마치 동 호수만 알고, 택배 기사가 서울에서 배달을 하려는 상황과 마찬가지)</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@xD2B6/btsMeR9g8xQ/eG7q1kOXNaBGJdcSFREQoK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2080,”originHeight”:1270,”style”:”alignCenter”,”width”:783,”height”:478}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>⇒ ASA가 사설 IP를 공인 IP로 변경해서 보내줘야 한다.</li>\n  <li>ASA의 <strong>NAT</strong></li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@tUl9o/btsMeRVJT2O/PJFvZxKK7bVxaO8Vexhkt0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:414,”originHeight”:143,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>들어오는 패킷의 처리\n    <ul>\n      <li>외부 노드들은 내부 네트워크의 실제 사설 IP를 알 필요가 없다.\n        <ul>\n          <li>대신 ASA의 공인 IP 주소로 통신을 시도</li>\n        </ul>\n      </li>\n      <li>ASA는 NAT 테이블을 유지하면서, 어떤 외부 통신이 어떤 내부 노드를 위한 것인지 추적</li>\n      <li>수신된 패킷의 목적지 주소를 적절한 내부 사설 IP로 변환하여 전달</li>\n    </ul>\n  </li>\n  <li>나가는 패킷의 처리\n    <ul>\n      <li>내부 노드가 외부로 통신을 시도할 때, ASA는 출발지의 사설 IP를 자신의 공인 IP로 변환</li>\n      <li>이 과정에서 ASA는 어떤 내부 노드가 어떤 통신을 시작했는지 NAT 테이블에 기록</li>\n      <li>나중에 응답이 돌아오면, 이 테이블을 참조하여 올바른 내부 노드에게 전달</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"nat-설정\">NAT 설정</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@czZH5n/btsMc0fu60D/gU0ev4kVhViqehGSDDt6K0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1220,”originHeight”:196,”style”:”alignCenter”,”width”:742,”height”:119}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>in2out 객체 생성 (네트워크 객체 모드)</li>\n  <li>대상 서브넷을 지정해준다.</li>\n  <li>NAT 지정\n    <ul>\n      <li>내외부망을 연결하는 (inside, outside)를 동적 매핑</li>\n      <li>공인 Ip 주소는 인터페이스에 할당된 IP 주소를 사용한다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@ccZXOd/btsMcjzZe4x/9s6nimQ80LBoH1dkmToAWK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:942,”originHeight”:138,”style”:”alignCenter”,”width”:676,”height”:99}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>그래도 inPC → outPC의 통신이 실패하게 된다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bajXRR/btsMcZgFpCY/BFAnMrFdvAP1aAJVnNh9z0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:600,”originHeight”:157,”style”:”alignCenter”,”width”:524,”height”:137}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"acl\">ACL</h2>\n\n<ul>\n  <li>패킷을 보면 목적지 주소는 공인 IP 주소로 정확히 설정되어 있으나,</li>\n  <li>외부망에서 내부망으로 들어오는 트래픽의 흐름을 방화벽이 모두 Block하고 있기 때문</li>\n  <li><strong>즉, 인터페이스마다 어떤 출발지 &amp; 어떤 목적지 를 가지는 트래픽을 허용 / 거부 할 것인지 정의해줘야 한다.</strong></li>\n  <li>→ ACL : 이러한 Allow/Deny 접근 제어 목록</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>access-list &lt;ACL명&gt; &lt;타입&gt; &lt;동작&gt; &lt;프로토콜&gt; &lt;출발지&gt; &lt;목적지&gt;\naccess-group &lt;ACL명&gt; &lt;트래픽&gt; &lt;인터페이스 키워드&gt; &lt;VLAN 명&gt;\n</code></pre></div></div>\n\n<ul>\n  <li>ACL 설정\n    <ul>\n      <li>모든 출발지에서 모든 목적지로 가는 ICMP(ping) 트래픽을 허용하는 규칙을 만든다.</li>\n      <li>만든 규칙을 외부 인터페이스의 인바운드 방향에 적용</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@eklCj3/btsMeUZeeor/0St67walf4cyejJZvVb2N0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1224,”originHeight”:300,”style”:”alignCenter”,”width”:767,”height”:188}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>inPC → outPC Ping 확인</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bMTQzA/btsMeyozeji/a8vxJ4pw0kExxZ6GUmDnRk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:962,”originHeight”:434,”style”:”alignCenter”,”width”:749,”height”:338}_#]</td>\n    </tr>\n  </tbody>\n</table>\n",
                        "tags": ["Network","PacketTracer","LAN","Switch","Router","Firewall","VLAN","Topology"]
                    }
                
            ],
        
            "Firewall": [
                
                    {
                        "title": "Packet Tracer로 네트워크 이해하기",
                        "url": "/2025/02/08/packet-tracer-network.html",
                        "subtitle": "LAN 토폴로지, 스위치, 라우터, 방화벽",
                        "excerpt": "LAN 토폴로지와 스위치\n",
                        "author": "Jinho",
                        "date": "February 08, 2025",
                        "background": "/img/posts/network_topology.jpeg",
                        "content": "<h1 id=\"lan-토폴로지와-스위치\">LAN 토폴로지와 스위치</h1>\n\n<hr />\n\n<h2 id=\"packet-tracer에-들어가기-전\">Packet Tracer에 들어가기 전</h2>\n\n<p>먼저 네트워크의 기본 구성 요소부터 이해해보자.</p>\n\n<p><strong>라우터, 스위치, 엔드 디바이스(PC, 서버 등)가 어떻게 상호 작용</strong>하는지 알아보자.</p>\n\n<ul>\n  <li>가장 기본적인 두 대의 디바이스(<code class=\"language-plaintext highlighter-rouge\">PC</code>)가 있다고 가정해보자.</li>\n  <li>두 PC를 연결하고, IP 주소 설정, 서브넷 마스크 설정을 하고 ping 테스트를 통해 연결.\n    <ul>\n      <li>이 과정에서 TCP/IP의 기본 개념을 이해해보자.</li>\n    </ul>\n  </li>\n  <li>그 다음 단계로 <code class=\"language-plaintext highlighter-rouge\">스위치</code>를 추가하여 여러 대의 <code class=\"language-plaintext highlighter-rouge\">PC</code>를 연결.\n    <ul>\n      <li>L2 통신의 개념과 MAC 주소의 역할을 이해해보자.</li>\n    </ul>\n  </li>\n  <li>마지막으로 <code class=\"language-plaintext highlighter-rouge\">라우터</code>를 추가하여 서로 다른 네트워크 간의 통신을 구현.\n    <ul>\n      <li>라우팅 테이블, 게이트웨이 등의 개념을 학습해보자.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"사용법\">사용법</h2>\n\n<h2 id=\"pc\">PC</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@tdMGa/btsMchWsAbo/pXUJ5sc1Jn5zlePiDz1mrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:264,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>장치 타입 → End Devices → PC / LAPTOP 등 Drag &amp; Drop</li>\n</ul>\n\n<h2 id=\"switch\">Switch</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bdJ1mb/btsMedLRoGJ/cpMkbVJahG5gP3qwnew9Uk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:194,”originHeight”:256,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"router\">Router</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@A02nQ/btsMeKJcj9q/usIeZ7q3BDrYQHVk4TpOuk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:208,”originHeight”:276,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"connection\">Connection</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@rOlnO/btsMdkEVmv0/U1xgvAbp826OCElZjbp2Sk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:280,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>실선은 Copper Straight [PC - Switch/Router]</li>\n  <li>점선은 Copper Cross - Over [Switch/Router … Switch/Router]</li>\n  <li>번개 모양은 Automatic</li>\n</ul>\n\n<h2 id=\"기본-사용-방법\">기본 사용 방법</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@mamWH/btsMdM8WmZV/J6Eve21yZP8cKJkdv8KQrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:666,”originHeight”:558,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>장치(PC 와 Laptop)들을 놓는다.</li>\n  <li>각 디바이스 개수만큼 연결한 스위치 추가</li>\n  <li>실선과 점선으로 연결</li>\n  <li>스위치 0 → 메뉴에서 FastEthernet0/1 선택</li>\n  <li>PC 0 → 메뉴에서 FastEthernet0 선택</li>\n  <li>(나머지도 동일하게 연결)</li>\n  <li>왼쪽 스위치 : <code class=\"language-plaintext highlighter-rouge\">FastEthernet0/2</code> 오른쪽 스위치 : <code class=\"language-plaintext highlighter-rouge\">FastEthernet0/3</code></li>\n  <li>PC 클릭 → Desktop → IP Configuration → IP Address에 <code class=\"language-plaintext highlighter-rouge\">198.168.0.1</code><br />\nSubnet Mask에 <code class=\"language-plaintext highlighter-rouge\">255.255.255.0</code>\n    <ul>\n      <li>나머지 장치는 IP 주소 ~0.2, ~0.3 순으로 입력</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dhy2rZ/btsMczo0VIn/LHz5KS8UijOguFkFqLdSSk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:338,”style”:”alignCenter”,”width”:780,”height”:206}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Desktop → Command Prompt로 ping 테스트</li>\n  <li>작업 공간에서 Simulation 가능 [실제 이동 경로 &amp; 헤더 정보 등을 볼 수 있다.]</li>\n</ul>\n\n<h2 id=\"lan-topology\">LAN Topology</h2>\n\n<ul>\n  <li>같은 로컬 에이리어 네트워크 (LAN) 내에서 네트워크 장비와 디바이스들이 어떻게 물리적 혹은 논리적으로 연결되어 있는지 나타내는 구조</li>\n</ul>\n\n<h2 id=\"lan과-wan\">LAN과 WAN</h2>\n\n<ul>\n  <li><strong>LAN (로컬 영역 네트워크)</strong>:\n    <ul>\n      <li>제한된 지역 내에서 연결된 네트워크</li>\n      <li><strong>스위치</strong>는 MAC 주소를 사용하여 네트워크 내 장치들 간에 데이터를 전달합니다. 스위치는 <strong>MAC 주소 테이블</strong>을 사용해 데이터를 해당 장치로 정확하게 전달</li>\n    </ul>\n  </li>\n  <li><strong>WAN (광역 네트워크)</strong>:\n    <ul>\n      <li>더 넓은 지역, 심지어 전 세계적으로 연결된 네트워크\n        <ul>\n          <li>인터넷이 대표적인 WAN 예시</li>\n        </ul>\n      </li>\n      <li>WAN에서는 서로 MAC 주소를 알 수 없음</li>\n      <li>WAN에서 라우터는 <strong>IP 주소</strong>를 기반으로 데이터를 전달하는데, 각 네트워크 간의 경로를 찾기 위해 <strong>라우팅 테이블</strong>을 사용\n        <ul>\n          <li>NAT / PAT</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cyma1b/btsMcdGGX7j/3HjkxSXXuguLBaXiMCtKp1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:933,”style”:”alignCenter”,”width”:757,”height”:552}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"1-bus-형\">1) Bus 형</h2>\n\n<ul>\n  <li>하나의 메인 케이블(백본)에 모든 노드가 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>구조가 단순하고 설치 비용이 저렴</li>\n      <li>노드 추가/제거가 쉽고 유연함</li>\n      <li>케이블 길이가 짧아 경제적</li>\n      <li>소규모 네트워크에 적합</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>트래픽 증가 시 성능 저하</li>\n      <li>메인 케이블 장애 시 전체 영향</li>\n      <li>데이터 충돌 발생 가능</li>\n      <li>보안 취약점 존재</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cdwQWE/btsMctoZGjP/YoLinRs4T7sWM3Iv3xCkfK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1138,”originHeight”:650,”style”:”alignCenter”,”width”:690,”height”:394}_#][#_Image</td>\n      <td>kage@XghRi/btsMc2doIc4/cDKKGHIAwzkFizYIthmvX1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:978,”originHeight”:456,”style”:”alignCenter”,”width”:620,”height”:289}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"2-ring-형\">2) Ring 형</h2>\n\n<ul>\n  <li>각 노드가 양옆의 두 노드와 연결되어 원형을 이루는 구조</li>\n  <li>자동선택 기능을 사용한 링</li>\n  <li>장점 :\n    <ul>\n      <li>데이터 흐름이 일정하고 예측 가능</li>\n      <li>충돌이 적고 전송이 안정적</li>\n      <li>각 노드가 리피터 역할 수행</li>\n      <li>장거리 전송에 유리</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>단일 노드 장애가 전체에 영향</li>\n      <li>네트워크 확장이 제한적</li>\n      <li>설치/제거 시 네트워크 중단</li>\n      <li>양방향 링 구성 시 비용 증가</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@lYUdr/btsMetVb0e8/23KtOkSs1PeRKuNml0S2AK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1108,”originHeight”:642,”style”:”alignCenter”,”width”:598,”height”:346}_#][#_Image</td>\n      <td>kage@rYlFs/btsMeKWHZEC/wFs32hn23rG7rKA9WFyKxK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:982,”originHeight”:460,”style”:”alignCenter”,”width”:621,”height”:291}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"3-star-형\">3) Star 형</h2>\n\n<ul>\n  <li>중앙에 허브가 있고 모든 노드가 이 허브에 직접 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>구현과 유지보수가 단순하고 직관적</li>\n      <li>개별 노드 장애가 다른 노드에 영향 없음</li>\n      <li>높은 성능과 데이터 전송 속도</li>\n      <li>중앙 집중적 보안 관리 용이</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>중앙 허브 장애 시 전체 네트워크 마비 - 단일 장애 지점 (SPOF)</li>\n      <li>허브에 과부하 발생 가능</li>\n      <li>케이블 설치 비용이 높음</li>\n      <li>허브 용량에 따른 확장성 제한</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@NJ0T7/btsMdF26Hzf/aEmXKMDwoG1TwsmUekA04K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1088,”originHeight”:678,”style”:”alignCenter”,”width”:627,”height”:391}_#][#_Image</td>\n      <td>kage@vFDga/btsMcTgvpqn/IDhAPb27H9xt3kN9pDOB7k/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:456,”style”:”alignCenter”,”width”:585,”height”:277}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"4-mesh-형\">4) Mesh 형</h2>\n\n<ul>\n  <li>모든 노드가 서로 직접 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>높은 안정성과 이중화 구성</li>\n      <li>효율적인 트래픽 분산</li>\n      <li>우회 경로 확보로 신뢰성 높음</li>\n      <li>뛰어난 보안성</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>설치/유지보수 비용이 매우 높음</li>\n      <li>구현과 설정이 매우 복잡</li>\n      <li>케이블 연결 관리가 어려움</li>\n      <li>노드 수 증가에 따른 복잡도 급증</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bb9BX4/btsMeahgXHL/gVJ4LgKjyCG8M1I6DkkbP0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1070,”originHeight”:674,”style”:”alignCenter”,”width”:628,”height”:396}_#][#_Image</td>\n      <td>kage@ovOWb/btsMb2rFLwg/Qi0orK06gCRkfnrkBXhvyK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:432,”style”:”alignCenter”,”width”:677,”height”:303}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"5-tree-형\">5) Tree 형</h2>\n\n<ul>\n  <li>계층적 구조로, 상위 노드에서 하위 노드로 분기되는 형태</li>\n  <li>장점 :\n    <ul>\n      <li>네트워크 확장이 용이</li>\n      <li>체계적인 계층 구조 관리</li>\n      <li>하위 네트워크 독립성</li>\n      <li>효율적인 트래픽 관리</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>루트 노드 장애 시 전체 영향</li>\n      <li>계층 증가에 따른 관리 복잡성</li>\n      <li>상위 노드 병목 현상 가능</li>\n      <li>깊이가 깊어질수록 지연 증가</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@wounf/btsMcywRCH9/2KnaYgagHLQKp4cBdcumy0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:985,”style”:”alignCenter”,”width”:765,”height”:589}_#][#_Image</td>\n      <td>kage@dI6An5/btsMd4hh7vI/Gxr1Nv7uKXeDV0vrZs1qT0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:960,”originHeight”:458,”style”:”alignCenter”,”width”:642,”height”:306}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>192.168.0.1 to 192.168.0.12</li>\n</ul>\n\n<h2 id=\"vlanvirtual-lan-case-1--switch-1개\">VLAN(Virtual LAN) (case 1 : Switch 1개)</h2>\n\n<h2 id=\"vlan이란\">VLAN이란?</h2>\n\n<p>“<strong>논리적인 구조의 속임수로 같은 물리적 공간에 있는 네트워크를 다른 네트워크에 있는 것처럼 속이는 기술</strong>”</p>\n\n<ul>\n  <li>먼저, 물리적인 LAN을 먼저 생각해보면, 같은 건물이나 같은 층에 있는 컴퓨터들이 하나의 네트워크로 연결되어 있는 구조이다.</li>\n  <li>그런데 예를 들면, 마케팅팀과 개발팀이 다른 네트워크에 있어야 한다고 가정해보자.\n    <ul>\n      <li>전통적인 방식이라면 물리적으로 별도의 네트워크 장비와 케이블을 설치해야 했다.</li>\n      <li>하지만, VLAN은 이런 물리적 제약을 소프트웨어적으로 해결한다.</li>\n    </ul>\n  </li>\n  <li>하나의 물리적인 스위치를 마치 여러 개의 독립된 스위치처럼 동작하게 만드는 기술이다.</li>\n  <li>예를 들어, 같은 스위치에 연결된 컴퓨터라도 서로 다른 VLAN에 속하면 마치 다른 네트워크에 있는 것처럼 통신이 분리된다.</li>\n</ul>\n\n<h2 id=\"초기-default-vlan-설정\">초기 default VLAN 설정</h2>\n\n<ul>\n  <li>show vlan으로 확인해보자.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bTHrGF/btsMea2FcPL/VagNQtcNTnfvH7OWzcKevk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1250,”originHeight”:974,”style”:”alignCenter”,”width”:670,”height”:522}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>처음 VLAN 1은 ‘기본 VLAN’이다.</li>\n  <li>모든 스위치 포트는 처음에 이 VLAN 1에 속하도록 설정되어 있다.\n    <ul>\n      <li>그래서 별다른 설정 없이는 같은 물리적인 공간에 있다면 한 네트워크에 속하도록 설정이 된다.</li>\n    </ul>\n  </li>\n  <li>그리고 VLAN 1002부터 1005까지는 특별한 목적으로 예약된 VLAN이다. (사용 불가)\n    <ul>\n      <li>FDDI, 토큰링 등으로 고정되어 있다.</li>\n    </ul>\n  </li>\n  <li>우리가 새로운 VLAN을 할당하려고 하면 “2 ~ 1001” 의 VLAN을 사용해서 나누면 된다.</li>\n</ul>\n\n<h2 id=\"vlan-구성하기\">VLAN 구성하기</h2>\n\n<ul>\n  <li>먼저 VLAN 2개를 생성한다.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch#enable\nSwitch#config terminal\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#vlan 2\nSwitch(config-if)#name VLAN_2\nSwitch(config-if)#exit\n</code></pre></div></div>\n\n<ul>\n  <li>enable : 관리자 모드 진입</li>\n  <li>config terminal : 글로벌 모드 진입</li>\n  <li>vlan 2 : vlan 모드 진입</li>\n  <li>name <이름> : 진입되어 있는 vlan의 이름 설정</이름></li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dsQlbd/btsMdqdX0ps/kPhix6BIWT0KDKtVJzq3NK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1185,”originHeight”:1000,”style”:”alignCenter”,”width”:734,”height”:619}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>결과</p>\n\n<ul>\n  <li>그리고, <code class=\"language-plaintext highlighter-rouge\">VLAN_2</code>엔 <code class=\"language-plaintext highlighter-rouge\">Fa0/1</code> 과 <code class=\"language-plaintext highlighter-rouge\">Fa0/2</code>, <code class=\"language-plaintext highlighter-rouge\">VLAN_3</code>엔 <code class=\"language-plaintext highlighter-rouge\">Fa0/3</code> 과 <code class=\"language-plaintext highlighter-rouge\">Fa0/4</code> 포트를 배정시킨다.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch#enable\nSwitch#config terminal\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#interface fa0/1\nSwitch(config-if)#switchport mode access\nSwitch(config-if)#switchport access vlan 2\n</code></pre></div></div>\n\n<ul>\n  <li>inteface fa0/1 : 인터페이스 모드 진입</li>\n  <li>switchport mode access : 해당 포트를 VLAN 전용으로 사용함을 선언</li>\n  <li>switchport access vlan 2 : 해당 포트가 속한 VLAN 번호 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@GEPhJ/btsMcd0ZUA9/NJfHXH7fr603Pozrp0XUN1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:779,”style”:”alignCenter”,”width”:697,”height”:424,”caption”:”결과”}_#][#_Image</td>\n      <td>kage@ZktHy/btsMceFDArB/GmkkKk7xrFmJK5XI7GNxS1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:975,”style”:”alignCenter”,”width”:686,”height”:523}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"vlan-통신-테스트\">VLAN 통신 테스트</h2>\n\n<ol>\n  <li><code class=\"language-plaintext highlighter-rouge\">192.168.0.1</code> to <code class=\"language-plaintext highlighter-rouge\">192.168.0.2</code>\n    <ul>\n      <li>같은 VLAN 내에서는 통신 가능</li>\n    </ul>\n  </li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@BqqF9/btsMceevW1X/38cHtm9y7VtBM8yRsEMKb1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:742,”originHeight”:340,”style”:”alignCenter”,”width”:653,”height”:299}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li><code class=\"language-plaintext highlighter-rouge\">192.168.0.1</code> to <code class=\"language-plaintext highlighter-rouge\">192.168.0.2</code></li>\n</ol>\n\n<ul>\n  <li>다른 VLAN 끼리는 통신 불가능</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@905VT/btsMcKD1XhO/HVQpVtHJXEQCpfTAUkHWYk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1060,”originHeight”:502,”style”:”alignCenter”,”width”:668,”height”:316}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"vlanvirtual-lan-case-2--switch-여러-개\">VLAN(Virtual LAN) (case 2 : Switch 여러 개)</h2>\n\n<ul>\n  <li>그렇다면 네트워크를 확장하고 좀 더 현실적인 아키텍쳐로 바뀌면 어떨까?</li>\n  <li>먼저 Switch를 하나 더 두어보자.</li>\n  <li><em>들어가기전</em>\n    <ul>\n      <li>VLAN 설정 자체는 IP 주소를 직접 변경하지 않는다.\n        <ul>\n          <li>VLAN은 Layer 2(데이터 링크 계층)에서 작동하는 반면,<br />\nIP 주소는 Layer 3(네트워크 계층)에서 작동하기 때문.</li>\n        </ul>\n      </li>\n      <li>그러나, 실제 네트워크 운영에서는 일반적으로 각 VLAN마다 서로 다른 IP 대역을 할당한다.\n        <ul>\n          <li>네트워크 관리와 보안을 위한 설계</li>\n        </ul>\n      </li>\n      <li>그러므로 VLAN 별로 다른 대역을 할당해보자.\n        <ul>\n          <li>VLAN 2: 203.237.20.nnn</li>\n          <li>VLAN 3: 203.237.30.nnn</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@pcw1H/btsMc0NoTlz/v9c56wkkpb2qWxKk6BEsq0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1031,”originHeight”:1000,”style”:”alignCenter”,”width”:680,”height”:660}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 0 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@d5TDWZ/btsMekcZbAx/1meC8Kjg2Niht4JKNpWjE1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:325,”style”:”alignCenter”,”width”:757,”height”:192}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 1 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bxI7Ez/btsMcsXSPgC/McV65YvUN8ELGhZbpqxaEK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:336,”style”:”alignCenter”,”width”:750,”height”:197}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>여기서 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>🤔 과연 PC2는 PC0과 통신이 가능할까?\n    <ul>\n      <li>결과를 보면, PC1과는 통신이 가능하지만, 다른 스위치로 넘어가면서 통신이 불가능해진다</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cdqmkw/btsMeSmNMeI/jnvpXenhi6dV8W4U8oGWaK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:994,”originHeight”:806,”style”:”alignCenter”,”width”:664,”height”:538}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>이런 논리적인 흐름의 질문이 든다.\n    <ol>\n      <li>오히려 VLAN 설정하기 전에 그냥 여러 스위치를 건너 뛰어도 통신이 됐음.</li>\n      <li>그리고 같은 VLAN 끼리는 통신이 된다고 했다.</li>\n      <li>그런데 갑자기 같은 VLAN에서 여러 스위치를 건너뛰면 왜 통신이 안될까?</li>\n    </ol>\n  </li>\n  <li>여기서 <strong>VLAN 태그</strong>라는 개념이 등장한다.\n    <ul>\n      <li>VLAN을 설정하면 각 패킷에는 특별한 VLAN ID가 붙게 된다.\n        <ul>\n          <li>(마치 우편물에 부서명을 적는 것과 같다.)</li>\n        </ul>\n      </li>\n      <li>일반적인 스위치의 Port(Access Port)는 VLAN 태그를 처리하는 방법에 대해 1가지 밖에 모른다.\n        <ul>\n          <li>PACKET 들어올 때 : 자신의 VLAN 번호를 태그로 붙인다.</li>\n          <li>PACKET 나갈 때 : 태그를 제거하고 보낸다.</li>\n        </ul>\n      </li>\n      <li>그럼 여기서 문제가 발생한다.\n        <ul>\n          <li>PC2에서 나온 패킷\n            <ul>\n              <li>Switch 0으로 들어올 때 : fa0/2에서 VLAN 2 태그를 붙임</li>\n            </ul>\n          </li>\n          <li>이 패킷이 fa0/5로 가면서 VLAN 1의 통신으로 취급됨 [VLAN 2 태그가 떨어짐]</li>\n          <li>다른 스위치의 fa0/3에 도착했을 때도 VLAN 1의 통신으로 인식됨</li>\n          <li>결과적으로 원래의 VLAN 2 통신이 의도대로 전달되지 못함.</li>\n        </ul>\n      </li>\n      <li>[즉, <strong>Switch0의 fa0/와 Switch1의 fa0/3이 VLAN 1이기 때문</strong>]</li>\n    </ul>\n  </li>\n</ul>\n\n<p>→ <strong>스위치 간 VLAN 전용 통로가 필요하다!</strong></p>\n\n<h2 id=\"트렁크trunk\">트렁크(Trunk)</h2>\n\n<p>[먼저 PC2가 PC0과 통신이 가능하도록 해결해보자]</p>\n\n<ul>\n  <li>Switch0과 Switch1간에 VLAN 2,3 전용 포트 따로 설정!</li>\n  <li>switch0의 fa0/5, fa0/6을 각각 VLAN 2,3 전용으로 설정</li>\n  <li>switch1의 fa0/3, fa0/4를 각각 VLAN 2,3 전용으로 설정</li>\n  <li>Switch 0 포트의 VLAN 상태</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b3x84T/btsMei0AEyD/DYcMw88NkSnY9eQ8B22zcK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1154,”originHeight”:64,”style”:”alignCenter”,”width”:699,”height”:39}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 1 포트의 VLAN 상태</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@URbjM/btsMdIyMTr2/uZ7hOtRQPSYbugPuyZe3s1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1064,”originHeight”:74,”style”:”alignCenter”,”width”:731,”height”:51}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC2에서 PC0로 통신이 가능하다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@AcI9Y/btsMeveoKpG/MRkQDsbDHXP76MV9pLzZR0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:956,”originHeight”:432,”style”:”alignCenter”,”width”:727,”height”:329}_#][#_Image</td>\n      <td>kage@cav9Br/btsMdpMVs7n/kO9tRv5kLVsRKP9bNXqDuK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:714,”originHeight”:510,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>그런데 또 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>🤔 과연 VLAN 별 통신 라인 추가가 바람직한 해결인가?\n    <ul>\n      <li>만약 VLAN이 수백개라면..?</li>\n      <li>일일이 연결해줄 수 없다</li>\n      <li>또한 추가 가능한 VLAN ID는 1000개.\n        <ul>\n          <li>→ <strong>Trunk</strong> 가 해결책</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"트렁크란\">트렁크란?</h2>\n\n<ul>\n  <li><strong>트렁크는 모든 VLAN 패킷을 하나의 포트로 통과시키는 것</strong></li>\n  <li>스위치 간 프레임 전달에 하나의 물리적 연결(포트)를 공유하는 것.</li>\n  <li>VLAN 트렁킹된 스위치들 간에 여러 VLAN에서 나온 프레임들을 이 트렁크를 통해 전달한다.</li>\n  <li>즉, 스위치와 스위치 간 프레임 전달 시 하나의 포트에 다수의 VLAN이 지나갈 수 있도록하는 링크.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch(config)#interface fa0/5\nSwitch(config-if)#switchport mode trunk\n\nSwitch(config-if)#\n%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to down\n\n%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to up\nexit\nSwitch(config)#exit\nSwitch#\n%SYS-5-CONFIG_I: Configured from console by console\nshow interface trunk\nPort        Mode         Encapsulation  Status        Native vlan\nFa0/5       on           802.1q         trunking      1\n\nPort        Vlans allowed on trunk\nFa0/5       1-1005\n\nPort        Vlans allowed and active in management domain\nFa0/5       1,2,3\n\nPort        Vlans in spanning tree forwarding state and not pruned\nFa0/5       none\n</code></pre></div></div>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cj9Kft/btsMcrLrqjC/NZkK8P615yIbq5LWFeBswk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:839,”style”:”alignCenter”,”caption”:”Switch0의 Fa0/5 포트 Trunk 설정”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li>Fa0/5가 트렁크 포트로 on (강제로 트렁크 모드로 설정) 되었다.</li>\n  <li>1~1005는 이론적으로 모든 VLAN 범위가 통과 가능하다.</li>\n  <li>실제 현재 사용 중인 VLAN : 1, 2, 3이 현재 활성화되어 있다.</li>\n  <li>Vlans in spanning tree forwarding state and not pruned : None<br />\n(활성화된 VLAN들이 여기 나타나야 한다. - 없다.)</li>\n</ol>\n\n<ul>\n  <li>Fa0/5 포트는 Native VLAN이 1로 설정됨</li>\n  <li>반대편 Fa0/3 포트는 Native VLAN이 2로 설정됨\n    <ul>\n      <li>Switch1의 Fa0/3 포트도 Trunk로 설정해준다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@kzW3S/btsMec7cVIK/IBXxcLCh7BYeCYd9J2nScK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1136,”originHeight”:414,”style”:”alignCenter”,”width”:654,”height”:238}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>물론 PC2에서 PC0로 통신이 가능해졌다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bryfWp/btsMcPE65aP/UGX9KHYfm1QMvME24buAtk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:956,”originHeight”:428,”style”:”alignCenter”,”width”:706,”height”:316}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"inter-vlan\">Inter-VLAN</h2>\n\n<ul>\n  <li>놓치면 안되는 것의 “<strong>기술의 도입에 대한 목적</strong>”이다.\n    <ul>\n      <li>VLAN의 목적은 가상의 LAN으로서 관리의 편리성 추구이며,<br />\n다른 VLAN과의 통신 제한이 아니다.</li>\n    </ul>\n  </li>\n  <li>그럼, 서로 다른 VLAN 간의 통신이 가능하도록 하는 방법은 없을까?</li>\n  <li>VLAN 간 통신을 하려면 라우터(게이트웨이)가 있어야 한다.\n    <ul>\n      <li>라우터를 경유하여 마치 다른 LAN으로 통신하는 것처럼 동작한다.</li>\n    </ul>\n  </li>\n  <li>[다른 네트워크 영역은 라우터가 필요!!!]</li>\n</ul>\n\n<h2 id=\"서브-인터페이스\">서브 인터페이스</h2>\n\n<ul>\n  <li>단순히 생각하면 이런 생각이 든다.</li>\n  <li>전통적인 라우터 방식: 각 VLAN마다 라우터의 물리적 인터페이스를 하나씩 사용</li>\n  <li>그러나 이런 생각의 전환을 해본다.\n    <ul>\n      <li><strong>하나의 물리적 라우터 인터페이스에 여러 개의 논리적 인터페이스를 생성하여 각각 다른 VLAN을 처리할 수 있도록 할 수 있다면?</strong></li>\n      <li>그런데, Fa0/0이라는 물리적 라우터 인터페이스에 어떻게 여러 개의 논리적 인터페이스를 생성할까?</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@Y1VKx/btsMeSUECM4/0Qz0wbAb4G4UBmT0SLhXYk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:260,”originHeight”:298,”style”:”alignCenter”,”width”:167,”height”:191}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>서브 인터페이스: 하나의 인터페이스에 여러 VLAN들의 인터페이스를 논리적으로 나누는 것</li>\n  <li>2811 모델을 추가해준다!\n    <ul>\n      <li>참고 :</li>\n      <li><em>2811 라우터는 Cisco의 중급 라우터로, Inter-VLAN 라우팅을 위한 서브인터페이스 구성을 지원합니다. 서브인터페이스란 하나의 물리적 인터페이스를 여러 개의 논리적 인터페이스로 나누어 사용할 수 있게 해주는 기능입니다. 이는 마치 하나의 도로를 여러 개의 차선으로 나누어 서로 다른 목적지로 가는 차들을 효율적으로 처리하는 것과 비슷합니다.</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p>1. fa0/0 활성화</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dysMoj/btsMcdzWje7/FkpECQDsjzhv7gtsA3SGI1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:846,”originHeight”:200,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>2. fa0/0.2 생성, VLAN2 연결, IP주소 할당 &amp; fa0/0.3 생성, VLAN3 연결, IP주소 할당</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b2QZaS/btsMb1M28tD/PwRCtfFGc9U9WdizCjU6pk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:691,”style”:”alignCenter”,”width”:790,”height”:426}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>3. switch1 fa0/4를 트렁크 모드로 설정</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bGoCk8/btsMdHT860Z/dwqr98u0ihaJDerscGQ7j1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1248,”originHeight”:546,”style”:”alignCenter”,”width”:718,”height”:314}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>4. Router의 서브 인터페이스 상태 확인</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bnyTgA/btsMevrWYog/pDkKHGHiWCNLKzR85a7Qn1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:219,”style”:”alignCenter”,”width”:819,”height”:140}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>5. 게이트웨이 설정</p>\n\n<p>- VLAN 2 (PC0, 1, 2) → 203.237.20.254</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bjr2GX/btsMey9WnrP/zNHfPdHwYlhyUSeIwsz6n0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:384,”style”:”alignCenter”,”width”:767,”height”:230}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>- VLAN 3 (Laptop0, 1, 2) → 203.237.30.254</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@9Pp8f/btsMcxY6pxv/toN6xYeoWLuqsvp1xIlJ90/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:606,”style”:”alignCenter”,”width”:773,”height”:366}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h1 id=\"스위치\">스위치</h1>\n\n<hr />\n\n<h2 id=\"스위치의-동작-원리\">스위치의 동작 원리</h2>\n\n<h2 id=\"mac-주소-테이블-동작-원리\">MAC 주소 테이블 동작 원리</h2>\n\n<ul>\n  <li>스위치와 노드들이 <strong>ARP</strong>를 통해 MAC 주소 정보를 지속적으로 교환한다.\n    <ul>\n      <li>ARP 프로토콜에 포함된 MAC 주소 정보를 기반으로 스위치의 MAC 주소 테이블이 구축된다.</li>\n      <li>실제 데이터 전송 (ping 등)이 발생하면, 이 MAC 주소 테이블을 참조하여 패킷을 적절한 포트로 전달</li>\n    </ul>\n  </li>\n  <li>MAC 주소 테이블은 네트워크 토폴리지 변화를 반영하기 위해 일정 주기로 초기화되며, 최신 정보로 동적 갱신된다.</li>\n</ul>\n\n<h2 id=\"arp란\">ARP란?</h2>\n\n<ul>\n  <li>IP 네트워크에서 IP 주소를 물리적인 MAC 주소로 변환하는 핵심 프로토콜</li>\n  <li>컴퓨터가 같은 네트워크 상의 다른 장치와 통신하려면 반드시 상대방의 MAC 주소를 알아야 하는데,<br />\nARP가 이 주소 변환 과정을 자동으로 처리해준다.</li>\n</ul>\n\n<h2 id=\"arp를-활용한-동작-원리\">ARP를 활용한 동작 원리</h2>\n\n<p><em>PC0에서 Laptop0으로 ping을 보낸다고 가정</em></p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cDoPQ4/btsMdLhTSuP/NdTWBqnwp8pAXYoKUrWZrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:988,”originHeight”:436,”style”:”alignCenter”,”width”:742,”height”:327}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li>ARP Request (PC0 → Switch0)\n    <ul>\n      <li>PC0이 Laptop0의 MAC 주소를 알아내기 위해 ARP 요청 패킷 전송</li>\n      <li>패킷 내용:\n        <ul>\n          <li>출발지: PC0의 IP 주소와 MAC 주소</li>\n          <li>목적지: Laptop0의 IP 주소 (MAC 주소는 미확인 상태)</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>스위치 <strong>브로드캐스트</strong> (Switch0 → 모든 노드)\n    <ul>\n      <li>Switch0은 PC0의 <strong>MAC 주소를 자신의 테이블에 기록</strong></li>\n      <li>수신한 ARP 요청 패킷을 모든 포트로 브로드캐스트</li>\n    </ul>\n  </li>\n  <li>ARP reply (Laptop0 → Switch0)\n    <ul>\n      <li>Laptop0이 자신의 IP 주소를 확인하고 ARP 응답 패킷 생성</li>\n      <li>패킷 내용:\n        <ul>\n          <li>출발지: Laptop0의 IP 주소와 MAC 주소</li>\n          <li>목적지: PC0의 IP 주소와 MAC 주소</li>\n        </ul>\n      </li>\n      <li>Laptop0은 PC0의 MAC 주소를 자신의 ARP 캐시에 저장</li>\n    </ul>\n  </li>\n  <li>스위치 전달 단계 (Switch0 → PC0)\n    <ul>\n      <li>Switch0은 수신한 응답 패킷을 PC0에게 전달</li>\n      <li>PC0과 Laptop0의 MAC 주소 정보를 MAC 주소 테이블에 저장</li>\n    </ul>\n  </li>\n  <li>통신 시작\n    <ul>\n      <li>PC0이 Laptop0의 MAC 주소를 획득하여 실제 데이터 통신 가능</li>\n    </ul>\n  </li>\n</ol>\n\n<h2 id=\"시뮬레이션\">시뮬레이션</h2>\n\n<ul>\n  <li>시뮬레이션을 눌러서 이벤트 목록창을 볼 수 있다.</li>\n  <li>편지봉투 모양의 [Add Simple PDU] → ICMP 패킷 전송 시뮬레이션</li>\n  <li>송신노드와 수신 노드를 클릭하고 Show All/None 클릭 후 ARP, ICMP 패킷만 클릭한다.</li>\n  <li><em>PC0에서 Laptop0으로 편지를 보낸다.</em></li>\n  <li>ARP - ICMP 순으로 통신이 이루어진다.</li>\n</ul>\n\n<h2 id=\"1-arp-패킷-분석\">1) ARP 패킷 분석</h2>\n\n<p>1. PC0 → Switch0 ARP Request</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cwVj4Z/btsMcHN0AZ1/QtiRKPTAkw5cwMHngIJq5K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:900,”originHeight”:1158,”style”:”alignCenter”,”width”:522,”height”:672}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>ARP\n    <ul>\n      <li>Source MAC<br />\n= PC0 의 MAC 주소</li>\n      <li>Source IP<br />\n= PC0의 IP 주소</li>\n      <li>Target MAC<br />\n= Laptop 의 MAC 주소 [모르는 주소]</li>\n      <li>Target IP<br />\n= Laptop0의 IP주소</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2. Switch0 → 모든 노드 (브로드캐스트)</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dvlpX3/btsMdr43c4X/YNHxFWmjmqgayudoXkG1l0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:818,”originHeight”:124,”style”:”alignCenter”,”width”:594,”height”:90}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch0은 수신한 ARP Request를 모든 포트로 전달</li>\n  <li>Switch0의 MAC 주소 테이블에 PC0의 정보 기록\n    <ul>\n      <li>포트 번호와 PC0의 MAC 주소 매핑</li>\n    </ul>\n  </li>\n</ul>\n\n<p>3. Laptop0→ Switch0 ARP Reply</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@K4KvV/btsMcdUawiw/VpUysCPR5W9T4yYTKTcqJK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1002,”originHeight”:1242,”style”:”alignCenter”,”width”:627,”height”:777}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>ARP\n    <ul>\n      <li>Source MAC<br />\n= Laptop0 의 MAC 주소</li>\n      <li>Source IP<br />\n= Laptop0의 IP 주소</li>\n      <li>Target MAC<br />\n= PC0 의 MAC 주소</li>\n      <li>Target IP<br />\n= Laptop0의 IP주소</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"2-icmp-패킷-분석\">2. ICMP 패킷 분석</h2>\n\n<ol>\n  <li>PC → Laptop</li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@6AWAV/btsMdMA4Jmh/dd2ilCfmHRbqRt9DFVNWhK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2056,”originHeight”:1186,”style”:”alignCenter”,”width”:690,”height”:398}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>SRC ADDR = PC0의 MAC 주소</li>\n  <li>DEST ADDR = Laptop0의 MAC 주소</li>\n</ul>\n\n<h2 id=\"3-switch0의-mac-주소-테이블-변화\">3) Switch0의 MAC 주소 테이블 변화</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dEbxME/btsMdnn7IXG/koFfWfejqCW9bxxbzaYPb0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1080,”originHeight”:611,”style”:”alignCenter”,”width”:747,”height”:423}_#][#_Image</td>\n      <td>kage@WjEAg/btsMdmbIixx/in3AqgZZ7OkLwPpGkcb270/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1080,”originHeight”:734,”style”:”alignCenter”,”width”:727,”height”:494}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>위를 보니 Fa0/1 Fa0/4에 연결된 PC0과 Laptop0의 MAC 주소가 테이블에 기재되었다.</li>\n</ul>\n\n<p>🤔 갑자기 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>Switch0 → 모든 노드로 BroadCast할 때 각자의 MAC 주소 받아오면 되는거 아닌가?</li>\n  <li>해답은 ARP를 이용해 MAC 주소 테이블이 어떻게 유지하는지의 방법에 있다.\n    <ul>\n      <li>스위치의 MAC 주소 학습은 ‘출발지(Source) MAC 주소’만을 대상으로 한다.\n        <ul>\n          <li>PC0이 ARP Request를 보낼 때</li>\n          <li>Laptop0이 ARP Reply를 보낼 때</li>\n        </ul>\n      </li>\n      <li>모든 노드로 전달된 ARP-Request 패킷에 대해 수신 노드가 아니면 응답하지 않는다.</li>\n      <li>PC1과 Laptop1은 Swtich0이 전달한 ARP-Request에 대해 Reply 하지 않는다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>그런데 이런 ‘고민’도 떠오른다.</p>\n\n<p>1.효율성</p>\n\n<ul>\n  <li>ARP는 매우 짧은 시간 간격으로 반복 실행한다.\n    <ul>\n      <li>노드들이 많은 네트워크에서는 통신량으로 부하 가중</li>\n      <li>특히 스위치가 모든 노드에게 BroadCast하는 ARP-Request에서</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2. 보안상의 문제</p>\n\n<ul>\n  <li>Laptop1이 악의적인 공격자라고 가정해보자.\n    <ul>\n      <li>ARP Reply가 실제로 해당 IP 주소를 가진 정당한 장치에서 온 것인지 확인하지 않는다. (보안 X)</li>\n      <li>이 때 Laptop0의 IP에 Laptop1 MAC 주소를 실어서 Reply한다면?</li>\n      <li>테이블이 제대로 갱신되기 전까지 PC0은 Laptop0인 줄 알고 모든 패킷을 보낸다.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"vlan을-통한-해결\">VLAN을 통한 해결</h2>\n\n<ul>\n  <li>MAC 주소를 이용한 라우팅\n    <ul>\n      <li>동일한 네트워크(LAN)에서 스위치를 통해서만 발생한다.</li>\n      <li>라우터를 통한 외부 네트워크로의 통신에는 사용되지 않는다.\n        <ul>\n          <li>ARP 패킷은 하나의 네트워크에서만 송수신한다.</li>\n          <li>LAN을 논리적으로 분리된 가상의 VLAN으로 관리한다.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h1 id=\"라우터\">라우터</h1>\n\n<hr />\n\n<h2 id=\"라우터란\">라우터란?</h2>\n\n<ul>\n  <li>라우터는 서로 다른 네트워크를 연결하는 3계층 장비.</li>\n  <li>IP 주소를 기반으로 패킷의 최적 경로를 결정하고 전달한다.\n    <ul>\n      <li>스위치가 같은 네트워크 내에서 MAC 주소를 기반으로 통신을 담당한다면,</li>\n      <li>라우터는 서로 다른 네트워크 간의 통신을 가능하게 만드는 일종의 ‘네트워크 간의 다리’ 역할을 한다.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"라우터의-mode\">라우터의 Mode</h2>\n\n<ul>\n  <li><strong>사용자 모드(User EXEC Mode)</strong>\n    <ul>\n      <li>기본적인 정보 조회만 가능, 설정 변경 불가</li>\n      <li>&gt; 로 표시</li>\n    </ul>\n  </li>\n  <li><strong>관리자 모드(Privileged EXEC Mode)</strong>\n    <ul>\n      <li>라우터 설정을 변경할 순 없지만 시스템 정보 상세조회 가능</li>\n      <li># 으로 표시</li>\n    </ul>\n  </li>\n  <li><strong>글로벌 모드(Global Configuration Mode)</strong>\n    <ul>\n      <li>라우터 설정(이름, 보안, 인터페이스 등)을 변경</li>\n      <li>(config)# 로 표시</li>\n      <li><strong>라인 모드(Line Configuration Mode)</strong>\n        <ul>\n          <li>콘솔, 원격 접속(Telnet, SSH 등) 관련 설정 변경</li>\n          <li>(config-line)# 로 표시</li>\n        </ul>\n      </li>\n      <li><strong>인터페이스 모드(Interface Configuration Mode)</strong>\n        <ul>\n          <li>라우터의 네트워크 인터페이스(이더넷, 시리얼 등) 설정을 변경</li>\n          <li>라우터의 인터페이스에 IP 주소를 설정하고 활성화/비활성화</li>\n          <li>(config-if)# 로 표시</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"목표-네트워크-구성\">목표 네트워크 구성</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@FrASQ/btsMeLVCXVC/1wKsZjYPW9BikRxL7DFtC1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:813,”originHeight”:495,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"기본-설정\">기본 설정</h2>\n\n<ul>\n  <li>라우터 3대: [Network Devices] → [Routers] → [2811]</li>\n  <li>스위치 1대 : [Network Devices] → [Switches] → [2960]</li>\n  <li>PC 3대, 노트북 1대, 서버 1대 : [End Devices] → [PC], [Laptop], [Server]</li>\n</ul>\n\n<h2 id=\"라우터---시리얼-인터페이스-장착\">라우터 - 시리얼 인터페이스 장착</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@zgPDU/btsMd3bDPMR/E6TXH94lrMz3OrUR6TF5hK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:1293,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC와 달리 두 라우터 간에 데이터를 주고받기 위한 동기화가 필요</li>\n  <li>FastEthernet이 아닌 Serial 인터페이스를 사용하므로 모듈을 추가해야 한다.\n    <ul>\n      <li>HWIC-2T 추가</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"노드-간-연결하기\">노드 간 연결하기</h2>\n\n<ul>\n  <li>Laptop0은 통신용이 아니라 Router0을 설정하기 위한 콘솔\n    <ul>\n      <li>FastEthernet 케이블이 아닌 RS232(하늘색) 케이블로 연결</li>\n    </ul>\n  </li>\n  <li>라우더들끼리 Serial DCE 연결\n    <ul>\n      <li>먼저 클릭한 쪽에 시계 모양 - 두 라우터 간 데이터를 주고받기 위한 동기화가 필요</li>\n      <li>Serial DCE(Data Communication Equipment): 시간 동기화를 주도하는 노드 (시계 있는 쪽)</li>\n      <li>Serial DTE(Data Terminal Equipment): 그에 따라 동기화하는 노드 (시계 없는 쪽)</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@evpmpX/btsMdMnzPql/PLX7aieEhAKMJ6N99C2j5K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2184,”originHeight”:1246,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"ip-설정\">IP 설정</h2>\n\n<ul>\n  <li>컴퓨터들은 203.237.nnn.nnn/24 사용(C클래스)\n    <ul>\n      <li>1번부터 시작</li>\n    </ul>\n  </li>\n  <li>원격 관리가 필요한 스위치나 서버는 100번 부터</li>\n  <li>라우터는 광역의 랜들을 연결하므로 A클래스 IP 사용\n    <ul>\n      <li>규모가 작아 30비트 서브넷 마스크를 사용하여 최대 4개의 라우터를 묶을 수 있도록</li>\n    </ul>\n  </li>\n  <li>스위치는 2계층 장비\n    <ul>\n      <li>IP 주소 설정 불필요</li>\n      <li>원격 접속으로 스위치 관리\n        <ul>\n          <li>IP 주소 할당 필요</li>\n          <li>VLAN1에 할당</li>\n        </ul>\n      </li>\n      <li>스위치 IP 주소 설정</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bk8xpK/btsMd7Sxxul/dQMOVhudaYmzsa519EoeQK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1374,”originHeight”:164,”style”:”alignCenter”,”width”:635,”height”:76}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>총 6개의 LAN</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@UGTSj/btsMcKRyRRh/QFOQKnpr0nm0a6K8eUWWKk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1762,”originHeight”:1000,”style”:”alignCenter”,”width”:698,”height”:396}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"연결-확인\">연결 확인</h2>\n\n<ul>\n  <li>PC0에서 테스트</li>\n</ul>\n\n<ol>\n  <li>PC0 로컬 호스트(127.0.0.1)</li>\n  <li>PC0 → Switch1(VLAN1, 203.237.10.100)</li>\n  <li>PC0 → Server0(203.237.10.101)</li>\n  <li>PC0 → Router0(203.237.10.254)\n    <ul>\n      <li>모두 통신 성공</li>\n    </ul>\n  </li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@s9v2J/btsMcYPw7T1/QedNlAylJ9wAnApW81hp3K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1000,”originHeight”:1605,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>5. PC0 → PC2(203.237.30.1)</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@mi021/btsMdHGFlHG/cChGsiN9Pw0rWY0kG0w7q1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:996,”originHeight”:374,”style”:”alignCenter”,”width”:684,”height”:257}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><strong>unreachable</strong> 이 발생한다\n    <ul>\n      <li>PC0으로 부터 받은 패킷을 Router0이 어느 인터페이스로 보내야할지 모르기 때문</li>\n      <li>→ <strong>라우팅 테이블</strong>이 필요하다</li>\n      <li>아래는 Router0의 라우팅 정보</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@beagrf/btsMdMujNSG/uzGad36EzxcCPqRZ3PJy21/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1260,”originHeight”:698,”style”:”alignCenter”,”width”:746,”height”:413}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"정적-라우팅-설정\">정적 라우팅 설정</h2>\n\n<ul>\n  <li>정적 라우팅 대상\n    <ul>\n      <li>1번 PC0 입장에서 목적지가\n        <ul>\n          <li><strong>2번</strong> 네트워크(203.237.20.nnn/24)인 패킷 : serial0/3/0 (혹은 1.1.1.2)</li>\n          <li><strong>3번</strong> 네트워크(203.237.30.nnn/24)인 패킷 : serial0/3/1 (혹은 2.2.2.2)</li>\n          <li>6번 네트워크(3.3.3.nnn/30)인 패킷 : serial0/3/0 혹은 serial0/3/1</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>Router1의 정적 라우팅 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@JLnX1/btsMckFDkMJ/ik8vROKAHLaZQPxINyMSmK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1226,”originHeight”:442,”style”:”alignCenter”,”width”:694,”height”:250}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Router2의 정적 라우팅 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@k4yPj/btsMexiTcvl/Ewo59hWdxO2tOqMp9GTtNK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1248,”originHeight”:504,”style”:”alignCenter”,”width”:736,”height”:297}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Router3의 정적 라우팅 설정 + route 확인</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cnu0SN/btsMdH0043d/jjkekr1KEkmqtXM0E7LRUK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1270,”originHeight”:1186,”style”:”alignCenter”,”width”:756,”height”:706}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"통신테스트-by-ping\">통신테스트 by ping</h2>\n\n<ul>\n  <li>PC0 ↔ PC1</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dD0uXu/btsMb0Hnvj9/50DKkNchVlTaBfBiYNEMiK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:962,”originHeight”:422,”style”:”alignCenter”,”width”:730,”height”:320}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC0 ↔ PC2</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cEoaLU/btsMdGgIz36/93lJ36D1HjrKK9gQaOKvb1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:432,”style”:”alignCenter”,”width”:780,”height”:350}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h1 id=\"방화벽---네트워크-구성\">방화벽 - 네트워크 구성</h1>\n\n<hr />\n\n<h2 id=\"망구성\">망구성</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@kO9qL/btsMengxOIb/FFIVXRjKkeW6JnSOKHGXqk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:524,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"asa0-구성-설정\">ASA0 구성 설정</h2>\n\n<p>1. 인터페이스 통신 상태</p>\n\n<ul>\n  <li>내부망 : 통신 가능</li>\n  <li>외부망 : 통신 불가\n    <ul>\n      <li>inPC → outPC 불가능</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bh2bBN/btsMd7rqkl0/g4AYl1hwkqpXZ1NDwCwO30/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1278,”originHeight”:266,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>2. IP 주소 설정</p>\n\n<ul>\n  <li>Inside : 설정됨</li>\n  <li>outside : 설정되어있지 않음\n    <ul>\n      <li>→ VLAN에서 203.237.20.253으로 설정</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cormPm/btsMc1r1E8A/LKXIkkQ8YcBwbHGgFGWQIk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1406,”originHeight”:342,”style”:”alignCenter”,”width”:807,”height”:196}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>3. Config 확인</p>\n\n<ul>\n  <li>내부망 Security-level : 100</li>\n  <li>외부망 Security-level : 0</li>\n  <li>보안 레벨이 높은 곳 → 낮은 곳 : 허용 (반대는 불가능)</li>\n  <li>내부망 노드들은 DHCP를 이용하여 IP 할당받는다.</li>\n</ul>\n\n<h2 id=\"inpc-dhcp-설정\">inPC DHCP 설정</h2>\n\n<ul>\n  <li>inPC는 ASA가 DHCP로 주소를 할당해준다고 했다.\n    <ul>\n      <li>게이트웨이는 ASA0 inside의 ip 주소로 고정된다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@HAypL/btsMemIHLU2/tcja6hVK1aurUDoEGiKLAK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1388,”originHeight”:636,”style”:”alignCenter”,”width”:703,”height”:322}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>outPC는 고정 주소 사용 중</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@lNS8u/btsMdHzVPu4/iHvbzNmifAq1gElLiDlpW1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1304,”originHeight”:546,”style”:”alignCenter”,”width”:707,”height”:296}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"router0-설정\">Router0 설정</h2>\n\n<ul>\n  <li>fa0/0 IP 설정 &amp; 활성화\n    <ul>\n      <li>203.237.10.254/24</li>\n    </ul>\n  </li>\n  <li>fa0/0 IP 설정 &amp; 활성화\n    <ul>\n      <li>203.237.20.253/24</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"rna-설정\">RNA 설정</h2>\n\n<h2 id=\"routing\">Routing</h2>\n\n<ul>\n  <li>라우터의 정적라우팅\n    <ul>\n      <li>네트워크 디바이스들이 서로 다른 네트워크에 있을 때, 그들 사이의 통신 경로를 명확히 지정해줘야 한다.</li>\n      <li>예를 들어, 내부 네트워크의 PC가 다른 네트워크의 서버와 통신하려면, 그 경로를 알아야 한다.</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">ip route &lt;목적지 네트워크 주소&gt; &lt;목적지 서브넷 마스크&gt; &lt;다음 홉 IP 주소/출구 인터페이스&gt;</code></li>\n    </ul>\n  </li>\n  <li>방화벽의 정적라우팅\n    <ul>\n      <li>트래픽이 반드시 방화벽을 통과하도록 하여 보안 정책을 적용할 수 있게 한다.</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">route &lt;VLAN명&gt; &lt;외부망 네트워크 주소&gt; &lt;외부망 서브넷마스크&gt; &lt;다음 홉 IP 주소&gt;</code></li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@UMo4w/btsMemPruKw/su6TBN30w2NLPGdTiu8nN0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2110,”originHeight”:1000,”style”:”alignCenter”,”width”:734,”height”:348}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>→ 어떤 목적지 주소를 갖는 패킷이든 외부망의 Router0인 203.207.20.254로 전송한다.</p>\n\n<ul>\n  <li>통신확인</li>\n  <li>inPC ↔ ASA0</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@ea7sUx/btsMcHURKDV/D3ikyzQhpSkEa8QCBP2sK1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:972,”originHeight”:428,”style”:”alignCenter”,”width”:708,”height”:312}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>inPC ↔ outPC</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b7mUIE/btsMcfqYrdM/SvtR3wkJNdKRzXgHMUMtIK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:986,”originHeight”:368,”style”:”alignCenter”,”width”:702,”height”:262}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"nat\">NAT</h2>\n\n<ul>\n  <li>inPC → outPC 까지는 패킷 전달이 잘 되지만,</li>\n  <li>Router0 → ASA0으로 전달이 되지 않는다.</li>\n</ul>\n\n<p><strong>outPC → Router1로 전달되는 패킷</strong></p>\n\n<ul>\n  <li>outPC(203.237.10.10)가 inPC(192.168.1.5)로 통신을 시도할 때, Router는 문제에 직면한다.\n    <ul>\n      <li>목적지 주소가 사설IP이기 때문에 외부에서 인식이 불가능하다.</li>\n      <li>→ Rotuer 입장에서 어디로 보내야 할 지 모른다.\n        <ul>\n          <li>(마치 동 호수만 알고, 택배 기사가 서울에서 배달을 하려는 상황과 마찬가지)</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@xD2B6/btsMeR9g8xQ/eG7q1kOXNaBGJdcSFREQoK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2080,”originHeight”:1270,”style”:”alignCenter”,”width”:783,”height”:478}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>⇒ ASA가 사설 IP를 공인 IP로 변경해서 보내줘야 한다.</li>\n  <li>ASA의 <strong>NAT</strong></li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@tUl9o/btsMeRVJT2O/PJFvZxKK7bVxaO8Vexhkt0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:414,”originHeight”:143,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>들어오는 패킷의 처리\n    <ul>\n      <li>외부 노드들은 내부 네트워크의 실제 사설 IP를 알 필요가 없다.\n        <ul>\n          <li>대신 ASA의 공인 IP 주소로 통신을 시도</li>\n        </ul>\n      </li>\n      <li>ASA는 NAT 테이블을 유지하면서, 어떤 외부 통신이 어떤 내부 노드를 위한 것인지 추적</li>\n      <li>수신된 패킷의 목적지 주소를 적절한 내부 사설 IP로 변환하여 전달</li>\n    </ul>\n  </li>\n  <li>나가는 패킷의 처리\n    <ul>\n      <li>내부 노드가 외부로 통신을 시도할 때, ASA는 출발지의 사설 IP를 자신의 공인 IP로 변환</li>\n      <li>이 과정에서 ASA는 어떤 내부 노드가 어떤 통신을 시작했는지 NAT 테이블에 기록</li>\n      <li>나중에 응답이 돌아오면, 이 테이블을 참조하여 올바른 내부 노드에게 전달</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"nat-설정\">NAT 설정</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@czZH5n/btsMc0fu60D/gU0ev4kVhViqehGSDDt6K0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1220,”originHeight”:196,”style”:”alignCenter”,”width”:742,”height”:119}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>in2out 객체 생성 (네트워크 객체 모드)</li>\n  <li>대상 서브넷을 지정해준다.</li>\n  <li>NAT 지정\n    <ul>\n      <li>내외부망을 연결하는 (inside, outside)를 동적 매핑</li>\n      <li>공인 Ip 주소는 인터페이스에 할당된 IP 주소를 사용한다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@ccZXOd/btsMcjzZe4x/9s6nimQ80LBoH1dkmToAWK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:942,”originHeight”:138,”style”:”alignCenter”,”width”:676,”height”:99}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>그래도 inPC → outPC의 통신이 실패하게 된다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bajXRR/btsMcZgFpCY/BFAnMrFdvAP1aAJVnNh9z0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:600,”originHeight”:157,”style”:”alignCenter”,”width”:524,”height”:137}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"acl\">ACL</h2>\n\n<ul>\n  <li>패킷을 보면 목적지 주소는 공인 IP 주소로 정확히 설정되어 있으나,</li>\n  <li>외부망에서 내부망으로 들어오는 트래픽의 흐름을 방화벽이 모두 Block하고 있기 때문</li>\n  <li><strong>즉, 인터페이스마다 어떤 출발지 &amp; 어떤 목적지 를 가지는 트래픽을 허용 / 거부 할 것인지 정의해줘야 한다.</strong></li>\n  <li>→ ACL : 이러한 Allow/Deny 접근 제어 목록</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>access-list &lt;ACL명&gt; &lt;타입&gt; &lt;동작&gt; &lt;프로토콜&gt; &lt;출발지&gt; &lt;목적지&gt;\naccess-group &lt;ACL명&gt; &lt;트래픽&gt; &lt;인터페이스 키워드&gt; &lt;VLAN 명&gt;\n</code></pre></div></div>\n\n<ul>\n  <li>ACL 설정\n    <ul>\n      <li>모든 출발지에서 모든 목적지로 가는 ICMP(ping) 트래픽을 허용하는 규칙을 만든다.</li>\n      <li>만든 규칙을 외부 인터페이스의 인바운드 방향에 적용</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@eklCj3/btsMeUZeeor/0St67walf4cyejJZvVb2N0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1224,”originHeight”:300,”style”:”alignCenter”,”width”:767,”height”:188}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>inPC → outPC Ping 확인</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bMTQzA/btsMeyozeji/a8vxJ4pw0kExxZ6GUmDnRk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:962,”originHeight”:434,”style”:”alignCenter”,”width”:749,”height”:338}_#]</td>\n    </tr>\n  </tbody>\n</table>\n",
                        "tags": ["Network","PacketTracer","LAN","Switch","Router","Firewall","VLAN","Topology"]
                    }
                
            ],
        
            "VLAN": [
                
                    {
                        "title": "Packet Tracer로 네트워크 이해하기",
                        "url": "/2025/02/08/packet-tracer-network.html",
                        "subtitle": "LAN 토폴로지, 스위치, 라우터, 방화벽",
                        "excerpt": "LAN 토폴로지와 스위치\n",
                        "author": "Jinho",
                        "date": "February 08, 2025",
                        "background": "/img/posts/network_topology.jpeg",
                        "content": "<h1 id=\"lan-토폴로지와-스위치\">LAN 토폴로지와 스위치</h1>\n\n<hr />\n\n<h2 id=\"packet-tracer에-들어가기-전\">Packet Tracer에 들어가기 전</h2>\n\n<p>먼저 네트워크의 기본 구성 요소부터 이해해보자.</p>\n\n<p><strong>라우터, 스위치, 엔드 디바이스(PC, 서버 등)가 어떻게 상호 작용</strong>하는지 알아보자.</p>\n\n<ul>\n  <li>가장 기본적인 두 대의 디바이스(<code class=\"language-plaintext highlighter-rouge\">PC</code>)가 있다고 가정해보자.</li>\n  <li>두 PC를 연결하고, IP 주소 설정, 서브넷 마스크 설정을 하고 ping 테스트를 통해 연결.\n    <ul>\n      <li>이 과정에서 TCP/IP의 기본 개념을 이해해보자.</li>\n    </ul>\n  </li>\n  <li>그 다음 단계로 <code class=\"language-plaintext highlighter-rouge\">스위치</code>를 추가하여 여러 대의 <code class=\"language-plaintext highlighter-rouge\">PC</code>를 연결.\n    <ul>\n      <li>L2 통신의 개념과 MAC 주소의 역할을 이해해보자.</li>\n    </ul>\n  </li>\n  <li>마지막으로 <code class=\"language-plaintext highlighter-rouge\">라우터</code>를 추가하여 서로 다른 네트워크 간의 통신을 구현.\n    <ul>\n      <li>라우팅 테이블, 게이트웨이 등의 개념을 학습해보자.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"사용법\">사용법</h2>\n\n<h2 id=\"pc\">PC</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@tdMGa/btsMchWsAbo/pXUJ5sc1Jn5zlePiDz1mrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:264,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>장치 타입 → End Devices → PC / LAPTOP 등 Drag &amp; Drop</li>\n</ul>\n\n<h2 id=\"switch\">Switch</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bdJ1mb/btsMedLRoGJ/cpMkbVJahG5gP3qwnew9Uk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:194,”originHeight”:256,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"router\">Router</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@A02nQ/btsMeKJcj9q/usIeZ7q3BDrYQHVk4TpOuk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:208,”originHeight”:276,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"connection\">Connection</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@rOlnO/btsMdkEVmv0/U1xgvAbp826OCElZjbp2Sk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:280,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>실선은 Copper Straight [PC - Switch/Router]</li>\n  <li>점선은 Copper Cross - Over [Switch/Router … Switch/Router]</li>\n  <li>번개 모양은 Automatic</li>\n</ul>\n\n<h2 id=\"기본-사용-방법\">기본 사용 방법</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@mamWH/btsMdM8WmZV/J6Eve21yZP8cKJkdv8KQrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:666,”originHeight”:558,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>장치(PC 와 Laptop)들을 놓는다.</li>\n  <li>각 디바이스 개수만큼 연결한 스위치 추가</li>\n  <li>실선과 점선으로 연결</li>\n  <li>스위치 0 → 메뉴에서 FastEthernet0/1 선택</li>\n  <li>PC 0 → 메뉴에서 FastEthernet0 선택</li>\n  <li>(나머지도 동일하게 연결)</li>\n  <li>왼쪽 스위치 : <code class=\"language-plaintext highlighter-rouge\">FastEthernet0/2</code> 오른쪽 스위치 : <code class=\"language-plaintext highlighter-rouge\">FastEthernet0/3</code></li>\n  <li>PC 클릭 → Desktop → IP Configuration → IP Address에 <code class=\"language-plaintext highlighter-rouge\">198.168.0.1</code><br />\nSubnet Mask에 <code class=\"language-plaintext highlighter-rouge\">255.255.255.0</code>\n    <ul>\n      <li>나머지 장치는 IP 주소 ~0.2, ~0.3 순으로 입력</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dhy2rZ/btsMczo0VIn/LHz5KS8UijOguFkFqLdSSk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:338,”style”:”alignCenter”,”width”:780,”height”:206}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Desktop → Command Prompt로 ping 테스트</li>\n  <li>작업 공간에서 Simulation 가능 [실제 이동 경로 &amp; 헤더 정보 등을 볼 수 있다.]</li>\n</ul>\n\n<h2 id=\"lan-topology\">LAN Topology</h2>\n\n<ul>\n  <li>같은 로컬 에이리어 네트워크 (LAN) 내에서 네트워크 장비와 디바이스들이 어떻게 물리적 혹은 논리적으로 연결되어 있는지 나타내는 구조</li>\n</ul>\n\n<h2 id=\"lan과-wan\">LAN과 WAN</h2>\n\n<ul>\n  <li><strong>LAN (로컬 영역 네트워크)</strong>:\n    <ul>\n      <li>제한된 지역 내에서 연결된 네트워크</li>\n      <li><strong>스위치</strong>는 MAC 주소를 사용하여 네트워크 내 장치들 간에 데이터를 전달합니다. 스위치는 <strong>MAC 주소 테이블</strong>을 사용해 데이터를 해당 장치로 정확하게 전달</li>\n    </ul>\n  </li>\n  <li><strong>WAN (광역 네트워크)</strong>:\n    <ul>\n      <li>더 넓은 지역, 심지어 전 세계적으로 연결된 네트워크\n        <ul>\n          <li>인터넷이 대표적인 WAN 예시</li>\n        </ul>\n      </li>\n      <li>WAN에서는 서로 MAC 주소를 알 수 없음</li>\n      <li>WAN에서 라우터는 <strong>IP 주소</strong>를 기반으로 데이터를 전달하는데, 각 네트워크 간의 경로를 찾기 위해 <strong>라우팅 테이블</strong>을 사용\n        <ul>\n          <li>NAT / PAT</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cyma1b/btsMcdGGX7j/3HjkxSXXuguLBaXiMCtKp1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:933,”style”:”alignCenter”,”width”:757,”height”:552}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"1-bus-형\">1) Bus 형</h2>\n\n<ul>\n  <li>하나의 메인 케이블(백본)에 모든 노드가 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>구조가 단순하고 설치 비용이 저렴</li>\n      <li>노드 추가/제거가 쉽고 유연함</li>\n      <li>케이블 길이가 짧아 경제적</li>\n      <li>소규모 네트워크에 적합</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>트래픽 증가 시 성능 저하</li>\n      <li>메인 케이블 장애 시 전체 영향</li>\n      <li>데이터 충돌 발생 가능</li>\n      <li>보안 취약점 존재</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cdwQWE/btsMctoZGjP/YoLinRs4T7sWM3Iv3xCkfK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1138,”originHeight”:650,”style”:”alignCenter”,”width”:690,”height”:394}_#][#_Image</td>\n      <td>kage@XghRi/btsMc2doIc4/cDKKGHIAwzkFizYIthmvX1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:978,”originHeight”:456,”style”:”alignCenter”,”width”:620,”height”:289}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"2-ring-형\">2) Ring 형</h2>\n\n<ul>\n  <li>각 노드가 양옆의 두 노드와 연결되어 원형을 이루는 구조</li>\n  <li>자동선택 기능을 사용한 링</li>\n  <li>장점 :\n    <ul>\n      <li>데이터 흐름이 일정하고 예측 가능</li>\n      <li>충돌이 적고 전송이 안정적</li>\n      <li>각 노드가 리피터 역할 수행</li>\n      <li>장거리 전송에 유리</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>단일 노드 장애가 전체에 영향</li>\n      <li>네트워크 확장이 제한적</li>\n      <li>설치/제거 시 네트워크 중단</li>\n      <li>양방향 링 구성 시 비용 증가</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@lYUdr/btsMetVb0e8/23KtOkSs1PeRKuNml0S2AK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1108,”originHeight”:642,”style”:”alignCenter”,”width”:598,”height”:346}_#][#_Image</td>\n      <td>kage@rYlFs/btsMeKWHZEC/wFs32hn23rG7rKA9WFyKxK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:982,”originHeight”:460,”style”:”alignCenter”,”width”:621,”height”:291}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"3-star-형\">3) Star 형</h2>\n\n<ul>\n  <li>중앙에 허브가 있고 모든 노드가 이 허브에 직접 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>구현과 유지보수가 단순하고 직관적</li>\n      <li>개별 노드 장애가 다른 노드에 영향 없음</li>\n      <li>높은 성능과 데이터 전송 속도</li>\n      <li>중앙 집중적 보안 관리 용이</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>중앙 허브 장애 시 전체 네트워크 마비 - 단일 장애 지점 (SPOF)</li>\n      <li>허브에 과부하 발생 가능</li>\n      <li>케이블 설치 비용이 높음</li>\n      <li>허브 용량에 따른 확장성 제한</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@NJ0T7/btsMdF26Hzf/aEmXKMDwoG1TwsmUekA04K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1088,”originHeight”:678,”style”:”alignCenter”,”width”:627,”height”:391}_#][#_Image</td>\n      <td>kage@vFDga/btsMcTgvpqn/IDhAPb27H9xt3kN9pDOB7k/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:456,”style”:”alignCenter”,”width”:585,”height”:277}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"4-mesh-형\">4) Mesh 형</h2>\n\n<ul>\n  <li>모든 노드가 서로 직접 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>높은 안정성과 이중화 구성</li>\n      <li>효율적인 트래픽 분산</li>\n      <li>우회 경로 확보로 신뢰성 높음</li>\n      <li>뛰어난 보안성</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>설치/유지보수 비용이 매우 높음</li>\n      <li>구현과 설정이 매우 복잡</li>\n      <li>케이블 연결 관리가 어려움</li>\n      <li>노드 수 증가에 따른 복잡도 급증</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bb9BX4/btsMeahgXHL/gVJ4LgKjyCG8M1I6DkkbP0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1070,”originHeight”:674,”style”:”alignCenter”,”width”:628,”height”:396}_#][#_Image</td>\n      <td>kage@ovOWb/btsMb2rFLwg/Qi0orK06gCRkfnrkBXhvyK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:432,”style”:”alignCenter”,”width”:677,”height”:303}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"5-tree-형\">5) Tree 형</h2>\n\n<ul>\n  <li>계층적 구조로, 상위 노드에서 하위 노드로 분기되는 형태</li>\n  <li>장점 :\n    <ul>\n      <li>네트워크 확장이 용이</li>\n      <li>체계적인 계층 구조 관리</li>\n      <li>하위 네트워크 독립성</li>\n      <li>효율적인 트래픽 관리</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>루트 노드 장애 시 전체 영향</li>\n      <li>계층 증가에 따른 관리 복잡성</li>\n      <li>상위 노드 병목 현상 가능</li>\n      <li>깊이가 깊어질수록 지연 증가</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@wounf/btsMcywRCH9/2KnaYgagHLQKp4cBdcumy0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:985,”style”:”alignCenter”,”width”:765,”height”:589}_#][#_Image</td>\n      <td>kage@dI6An5/btsMd4hh7vI/Gxr1Nv7uKXeDV0vrZs1qT0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:960,”originHeight”:458,”style”:”alignCenter”,”width”:642,”height”:306}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>192.168.0.1 to 192.168.0.12</li>\n</ul>\n\n<h2 id=\"vlanvirtual-lan-case-1--switch-1개\">VLAN(Virtual LAN) (case 1 : Switch 1개)</h2>\n\n<h2 id=\"vlan이란\">VLAN이란?</h2>\n\n<p>“<strong>논리적인 구조의 속임수로 같은 물리적 공간에 있는 네트워크를 다른 네트워크에 있는 것처럼 속이는 기술</strong>”</p>\n\n<ul>\n  <li>먼저, 물리적인 LAN을 먼저 생각해보면, 같은 건물이나 같은 층에 있는 컴퓨터들이 하나의 네트워크로 연결되어 있는 구조이다.</li>\n  <li>그런데 예를 들면, 마케팅팀과 개발팀이 다른 네트워크에 있어야 한다고 가정해보자.\n    <ul>\n      <li>전통적인 방식이라면 물리적으로 별도의 네트워크 장비와 케이블을 설치해야 했다.</li>\n      <li>하지만, VLAN은 이런 물리적 제약을 소프트웨어적으로 해결한다.</li>\n    </ul>\n  </li>\n  <li>하나의 물리적인 스위치를 마치 여러 개의 독립된 스위치처럼 동작하게 만드는 기술이다.</li>\n  <li>예를 들어, 같은 스위치에 연결된 컴퓨터라도 서로 다른 VLAN에 속하면 마치 다른 네트워크에 있는 것처럼 통신이 분리된다.</li>\n</ul>\n\n<h2 id=\"초기-default-vlan-설정\">초기 default VLAN 설정</h2>\n\n<ul>\n  <li>show vlan으로 확인해보자.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bTHrGF/btsMea2FcPL/VagNQtcNTnfvH7OWzcKevk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1250,”originHeight”:974,”style”:”alignCenter”,”width”:670,”height”:522}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>처음 VLAN 1은 ‘기본 VLAN’이다.</li>\n  <li>모든 스위치 포트는 처음에 이 VLAN 1에 속하도록 설정되어 있다.\n    <ul>\n      <li>그래서 별다른 설정 없이는 같은 물리적인 공간에 있다면 한 네트워크에 속하도록 설정이 된다.</li>\n    </ul>\n  </li>\n  <li>그리고 VLAN 1002부터 1005까지는 특별한 목적으로 예약된 VLAN이다. (사용 불가)\n    <ul>\n      <li>FDDI, 토큰링 등으로 고정되어 있다.</li>\n    </ul>\n  </li>\n  <li>우리가 새로운 VLAN을 할당하려고 하면 “2 ~ 1001” 의 VLAN을 사용해서 나누면 된다.</li>\n</ul>\n\n<h2 id=\"vlan-구성하기\">VLAN 구성하기</h2>\n\n<ul>\n  <li>먼저 VLAN 2개를 생성한다.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch#enable\nSwitch#config terminal\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#vlan 2\nSwitch(config-if)#name VLAN_2\nSwitch(config-if)#exit\n</code></pre></div></div>\n\n<ul>\n  <li>enable : 관리자 모드 진입</li>\n  <li>config terminal : 글로벌 모드 진입</li>\n  <li>vlan 2 : vlan 모드 진입</li>\n  <li>name <이름> : 진입되어 있는 vlan의 이름 설정</이름></li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dsQlbd/btsMdqdX0ps/kPhix6BIWT0KDKtVJzq3NK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1185,”originHeight”:1000,”style”:”alignCenter”,”width”:734,”height”:619}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>결과</p>\n\n<ul>\n  <li>그리고, <code class=\"language-plaintext highlighter-rouge\">VLAN_2</code>엔 <code class=\"language-plaintext highlighter-rouge\">Fa0/1</code> 과 <code class=\"language-plaintext highlighter-rouge\">Fa0/2</code>, <code class=\"language-plaintext highlighter-rouge\">VLAN_3</code>엔 <code class=\"language-plaintext highlighter-rouge\">Fa0/3</code> 과 <code class=\"language-plaintext highlighter-rouge\">Fa0/4</code> 포트를 배정시킨다.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch#enable\nSwitch#config terminal\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#interface fa0/1\nSwitch(config-if)#switchport mode access\nSwitch(config-if)#switchport access vlan 2\n</code></pre></div></div>\n\n<ul>\n  <li>inteface fa0/1 : 인터페이스 모드 진입</li>\n  <li>switchport mode access : 해당 포트를 VLAN 전용으로 사용함을 선언</li>\n  <li>switchport access vlan 2 : 해당 포트가 속한 VLAN 번호 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@GEPhJ/btsMcd0ZUA9/NJfHXH7fr603Pozrp0XUN1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:779,”style”:”alignCenter”,”width”:697,”height”:424,”caption”:”결과”}_#][#_Image</td>\n      <td>kage@ZktHy/btsMceFDArB/GmkkKk7xrFmJK5XI7GNxS1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:975,”style”:”alignCenter”,”width”:686,”height”:523}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"vlan-통신-테스트\">VLAN 통신 테스트</h2>\n\n<ol>\n  <li><code class=\"language-plaintext highlighter-rouge\">192.168.0.1</code> to <code class=\"language-plaintext highlighter-rouge\">192.168.0.2</code>\n    <ul>\n      <li>같은 VLAN 내에서는 통신 가능</li>\n    </ul>\n  </li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@BqqF9/btsMceevW1X/38cHtm9y7VtBM8yRsEMKb1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:742,”originHeight”:340,”style”:”alignCenter”,”width”:653,”height”:299}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li><code class=\"language-plaintext highlighter-rouge\">192.168.0.1</code> to <code class=\"language-plaintext highlighter-rouge\">192.168.0.2</code></li>\n</ol>\n\n<ul>\n  <li>다른 VLAN 끼리는 통신 불가능</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@905VT/btsMcKD1XhO/HVQpVtHJXEQCpfTAUkHWYk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1060,”originHeight”:502,”style”:”alignCenter”,”width”:668,”height”:316}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"vlanvirtual-lan-case-2--switch-여러-개\">VLAN(Virtual LAN) (case 2 : Switch 여러 개)</h2>\n\n<ul>\n  <li>그렇다면 네트워크를 확장하고 좀 더 현실적인 아키텍쳐로 바뀌면 어떨까?</li>\n  <li>먼저 Switch를 하나 더 두어보자.</li>\n  <li><em>들어가기전</em>\n    <ul>\n      <li>VLAN 설정 자체는 IP 주소를 직접 변경하지 않는다.\n        <ul>\n          <li>VLAN은 Layer 2(데이터 링크 계층)에서 작동하는 반면,<br />\nIP 주소는 Layer 3(네트워크 계층)에서 작동하기 때문.</li>\n        </ul>\n      </li>\n      <li>그러나, 실제 네트워크 운영에서는 일반적으로 각 VLAN마다 서로 다른 IP 대역을 할당한다.\n        <ul>\n          <li>네트워크 관리와 보안을 위한 설계</li>\n        </ul>\n      </li>\n      <li>그러므로 VLAN 별로 다른 대역을 할당해보자.\n        <ul>\n          <li>VLAN 2: 203.237.20.nnn</li>\n          <li>VLAN 3: 203.237.30.nnn</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@pcw1H/btsMc0NoTlz/v9c56wkkpb2qWxKk6BEsq0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1031,”originHeight”:1000,”style”:”alignCenter”,”width”:680,”height”:660}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 0 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@d5TDWZ/btsMekcZbAx/1meC8Kjg2Niht4JKNpWjE1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:325,”style”:”alignCenter”,”width”:757,”height”:192}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 1 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bxI7Ez/btsMcsXSPgC/McV65YvUN8ELGhZbpqxaEK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:336,”style”:”alignCenter”,”width”:750,”height”:197}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>여기서 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>🤔 과연 PC2는 PC0과 통신이 가능할까?\n    <ul>\n      <li>결과를 보면, PC1과는 통신이 가능하지만, 다른 스위치로 넘어가면서 통신이 불가능해진다</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cdqmkw/btsMeSmNMeI/jnvpXenhi6dV8W4U8oGWaK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:994,”originHeight”:806,”style”:”alignCenter”,”width”:664,”height”:538}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>이런 논리적인 흐름의 질문이 든다.\n    <ol>\n      <li>오히려 VLAN 설정하기 전에 그냥 여러 스위치를 건너 뛰어도 통신이 됐음.</li>\n      <li>그리고 같은 VLAN 끼리는 통신이 된다고 했다.</li>\n      <li>그런데 갑자기 같은 VLAN에서 여러 스위치를 건너뛰면 왜 통신이 안될까?</li>\n    </ol>\n  </li>\n  <li>여기서 <strong>VLAN 태그</strong>라는 개념이 등장한다.\n    <ul>\n      <li>VLAN을 설정하면 각 패킷에는 특별한 VLAN ID가 붙게 된다.\n        <ul>\n          <li>(마치 우편물에 부서명을 적는 것과 같다.)</li>\n        </ul>\n      </li>\n      <li>일반적인 스위치의 Port(Access Port)는 VLAN 태그를 처리하는 방법에 대해 1가지 밖에 모른다.\n        <ul>\n          <li>PACKET 들어올 때 : 자신의 VLAN 번호를 태그로 붙인다.</li>\n          <li>PACKET 나갈 때 : 태그를 제거하고 보낸다.</li>\n        </ul>\n      </li>\n      <li>그럼 여기서 문제가 발생한다.\n        <ul>\n          <li>PC2에서 나온 패킷\n            <ul>\n              <li>Switch 0으로 들어올 때 : fa0/2에서 VLAN 2 태그를 붙임</li>\n            </ul>\n          </li>\n          <li>이 패킷이 fa0/5로 가면서 VLAN 1의 통신으로 취급됨 [VLAN 2 태그가 떨어짐]</li>\n          <li>다른 스위치의 fa0/3에 도착했을 때도 VLAN 1의 통신으로 인식됨</li>\n          <li>결과적으로 원래의 VLAN 2 통신이 의도대로 전달되지 못함.</li>\n        </ul>\n      </li>\n      <li>[즉, <strong>Switch0의 fa0/와 Switch1의 fa0/3이 VLAN 1이기 때문</strong>]</li>\n    </ul>\n  </li>\n</ul>\n\n<p>→ <strong>스위치 간 VLAN 전용 통로가 필요하다!</strong></p>\n\n<h2 id=\"트렁크trunk\">트렁크(Trunk)</h2>\n\n<p>[먼저 PC2가 PC0과 통신이 가능하도록 해결해보자]</p>\n\n<ul>\n  <li>Switch0과 Switch1간에 VLAN 2,3 전용 포트 따로 설정!</li>\n  <li>switch0의 fa0/5, fa0/6을 각각 VLAN 2,3 전용으로 설정</li>\n  <li>switch1의 fa0/3, fa0/4를 각각 VLAN 2,3 전용으로 설정</li>\n  <li>Switch 0 포트의 VLAN 상태</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b3x84T/btsMei0AEyD/DYcMw88NkSnY9eQ8B22zcK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1154,”originHeight”:64,”style”:”alignCenter”,”width”:699,”height”:39}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 1 포트의 VLAN 상태</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@URbjM/btsMdIyMTr2/uZ7hOtRQPSYbugPuyZe3s1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1064,”originHeight”:74,”style”:”alignCenter”,”width”:731,”height”:51}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC2에서 PC0로 통신이 가능하다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@AcI9Y/btsMeveoKpG/MRkQDsbDHXP76MV9pLzZR0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:956,”originHeight”:432,”style”:”alignCenter”,”width”:727,”height”:329}_#][#_Image</td>\n      <td>kage@cav9Br/btsMdpMVs7n/kO9tRv5kLVsRKP9bNXqDuK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:714,”originHeight”:510,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>그런데 또 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>🤔 과연 VLAN 별 통신 라인 추가가 바람직한 해결인가?\n    <ul>\n      <li>만약 VLAN이 수백개라면..?</li>\n      <li>일일이 연결해줄 수 없다</li>\n      <li>또한 추가 가능한 VLAN ID는 1000개.\n        <ul>\n          <li>→ <strong>Trunk</strong> 가 해결책</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"트렁크란\">트렁크란?</h2>\n\n<ul>\n  <li><strong>트렁크는 모든 VLAN 패킷을 하나의 포트로 통과시키는 것</strong></li>\n  <li>스위치 간 프레임 전달에 하나의 물리적 연결(포트)를 공유하는 것.</li>\n  <li>VLAN 트렁킹된 스위치들 간에 여러 VLAN에서 나온 프레임들을 이 트렁크를 통해 전달한다.</li>\n  <li>즉, 스위치와 스위치 간 프레임 전달 시 하나의 포트에 다수의 VLAN이 지나갈 수 있도록하는 링크.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch(config)#interface fa0/5\nSwitch(config-if)#switchport mode trunk\n\nSwitch(config-if)#\n%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to down\n\n%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to up\nexit\nSwitch(config)#exit\nSwitch#\n%SYS-5-CONFIG_I: Configured from console by console\nshow interface trunk\nPort        Mode         Encapsulation  Status        Native vlan\nFa0/5       on           802.1q         trunking      1\n\nPort        Vlans allowed on trunk\nFa0/5       1-1005\n\nPort        Vlans allowed and active in management domain\nFa0/5       1,2,3\n\nPort        Vlans in spanning tree forwarding state and not pruned\nFa0/5       none\n</code></pre></div></div>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cj9Kft/btsMcrLrqjC/NZkK8P615yIbq5LWFeBswk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:839,”style”:”alignCenter”,”caption”:”Switch0의 Fa0/5 포트 Trunk 설정”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li>Fa0/5가 트렁크 포트로 on (강제로 트렁크 모드로 설정) 되었다.</li>\n  <li>1~1005는 이론적으로 모든 VLAN 범위가 통과 가능하다.</li>\n  <li>실제 현재 사용 중인 VLAN : 1, 2, 3이 현재 활성화되어 있다.</li>\n  <li>Vlans in spanning tree forwarding state and not pruned : None<br />\n(활성화된 VLAN들이 여기 나타나야 한다. - 없다.)</li>\n</ol>\n\n<ul>\n  <li>Fa0/5 포트는 Native VLAN이 1로 설정됨</li>\n  <li>반대편 Fa0/3 포트는 Native VLAN이 2로 설정됨\n    <ul>\n      <li>Switch1의 Fa0/3 포트도 Trunk로 설정해준다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@kzW3S/btsMec7cVIK/IBXxcLCh7BYeCYd9J2nScK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1136,”originHeight”:414,”style”:”alignCenter”,”width”:654,”height”:238}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>물론 PC2에서 PC0로 통신이 가능해졌다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bryfWp/btsMcPE65aP/UGX9KHYfm1QMvME24buAtk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:956,”originHeight”:428,”style”:”alignCenter”,”width”:706,”height”:316}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"inter-vlan\">Inter-VLAN</h2>\n\n<ul>\n  <li>놓치면 안되는 것의 “<strong>기술의 도입에 대한 목적</strong>”이다.\n    <ul>\n      <li>VLAN의 목적은 가상의 LAN으로서 관리의 편리성 추구이며,<br />\n다른 VLAN과의 통신 제한이 아니다.</li>\n    </ul>\n  </li>\n  <li>그럼, 서로 다른 VLAN 간의 통신이 가능하도록 하는 방법은 없을까?</li>\n  <li>VLAN 간 통신을 하려면 라우터(게이트웨이)가 있어야 한다.\n    <ul>\n      <li>라우터를 경유하여 마치 다른 LAN으로 통신하는 것처럼 동작한다.</li>\n    </ul>\n  </li>\n  <li>[다른 네트워크 영역은 라우터가 필요!!!]</li>\n</ul>\n\n<h2 id=\"서브-인터페이스\">서브 인터페이스</h2>\n\n<ul>\n  <li>단순히 생각하면 이런 생각이 든다.</li>\n  <li>전통적인 라우터 방식: 각 VLAN마다 라우터의 물리적 인터페이스를 하나씩 사용</li>\n  <li>그러나 이런 생각의 전환을 해본다.\n    <ul>\n      <li><strong>하나의 물리적 라우터 인터페이스에 여러 개의 논리적 인터페이스를 생성하여 각각 다른 VLAN을 처리할 수 있도록 할 수 있다면?</strong></li>\n      <li>그런데, Fa0/0이라는 물리적 라우터 인터페이스에 어떻게 여러 개의 논리적 인터페이스를 생성할까?</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@Y1VKx/btsMeSUECM4/0Qz0wbAb4G4UBmT0SLhXYk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:260,”originHeight”:298,”style”:”alignCenter”,”width”:167,”height”:191}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>서브 인터페이스: 하나의 인터페이스에 여러 VLAN들의 인터페이스를 논리적으로 나누는 것</li>\n  <li>2811 모델을 추가해준다!\n    <ul>\n      <li>참고 :</li>\n      <li><em>2811 라우터는 Cisco의 중급 라우터로, Inter-VLAN 라우팅을 위한 서브인터페이스 구성을 지원합니다. 서브인터페이스란 하나의 물리적 인터페이스를 여러 개의 논리적 인터페이스로 나누어 사용할 수 있게 해주는 기능입니다. 이는 마치 하나의 도로를 여러 개의 차선으로 나누어 서로 다른 목적지로 가는 차들을 효율적으로 처리하는 것과 비슷합니다.</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p>1. fa0/0 활성화</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dysMoj/btsMcdzWje7/FkpECQDsjzhv7gtsA3SGI1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:846,”originHeight”:200,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>2. fa0/0.2 생성, VLAN2 연결, IP주소 할당 &amp; fa0/0.3 생성, VLAN3 연결, IP주소 할당</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b2QZaS/btsMb1M28tD/PwRCtfFGc9U9WdizCjU6pk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:691,”style”:”alignCenter”,”width”:790,”height”:426}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>3. switch1 fa0/4를 트렁크 모드로 설정</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bGoCk8/btsMdHT860Z/dwqr98u0ihaJDerscGQ7j1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1248,”originHeight”:546,”style”:”alignCenter”,”width”:718,”height”:314}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>4. Router의 서브 인터페이스 상태 확인</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bnyTgA/btsMevrWYog/pDkKHGHiWCNLKzR85a7Qn1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:219,”style”:”alignCenter”,”width”:819,”height”:140}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>5. 게이트웨이 설정</p>\n\n<p>- VLAN 2 (PC0, 1, 2) → 203.237.20.254</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bjr2GX/btsMey9WnrP/zNHfPdHwYlhyUSeIwsz6n0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:384,”style”:”alignCenter”,”width”:767,”height”:230}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>- VLAN 3 (Laptop0, 1, 2) → 203.237.30.254</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@9Pp8f/btsMcxY6pxv/toN6xYeoWLuqsvp1xIlJ90/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:606,”style”:”alignCenter”,”width”:773,”height”:366}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h1 id=\"스위치\">스위치</h1>\n\n<hr />\n\n<h2 id=\"스위치의-동작-원리\">스위치의 동작 원리</h2>\n\n<h2 id=\"mac-주소-테이블-동작-원리\">MAC 주소 테이블 동작 원리</h2>\n\n<ul>\n  <li>스위치와 노드들이 <strong>ARP</strong>를 통해 MAC 주소 정보를 지속적으로 교환한다.\n    <ul>\n      <li>ARP 프로토콜에 포함된 MAC 주소 정보를 기반으로 스위치의 MAC 주소 테이블이 구축된다.</li>\n      <li>실제 데이터 전송 (ping 등)이 발생하면, 이 MAC 주소 테이블을 참조하여 패킷을 적절한 포트로 전달</li>\n    </ul>\n  </li>\n  <li>MAC 주소 테이블은 네트워크 토폴리지 변화를 반영하기 위해 일정 주기로 초기화되며, 최신 정보로 동적 갱신된다.</li>\n</ul>\n\n<h2 id=\"arp란\">ARP란?</h2>\n\n<ul>\n  <li>IP 네트워크에서 IP 주소를 물리적인 MAC 주소로 변환하는 핵심 프로토콜</li>\n  <li>컴퓨터가 같은 네트워크 상의 다른 장치와 통신하려면 반드시 상대방의 MAC 주소를 알아야 하는데,<br />\nARP가 이 주소 변환 과정을 자동으로 처리해준다.</li>\n</ul>\n\n<h2 id=\"arp를-활용한-동작-원리\">ARP를 활용한 동작 원리</h2>\n\n<p><em>PC0에서 Laptop0으로 ping을 보낸다고 가정</em></p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cDoPQ4/btsMdLhTSuP/NdTWBqnwp8pAXYoKUrWZrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:988,”originHeight”:436,”style”:”alignCenter”,”width”:742,”height”:327}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li>ARP Request (PC0 → Switch0)\n    <ul>\n      <li>PC0이 Laptop0의 MAC 주소를 알아내기 위해 ARP 요청 패킷 전송</li>\n      <li>패킷 내용:\n        <ul>\n          <li>출발지: PC0의 IP 주소와 MAC 주소</li>\n          <li>목적지: Laptop0의 IP 주소 (MAC 주소는 미확인 상태)</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>스위치 <strong>브로드캐스트</strong> (Switch0 → 모든 노드)\n    <ul>\n      <li>Switch0은 PC0의 <strong>MAC 주소를 자신의 테이블에 기록</strong></li>\n      <li>수신한 ARP 요청 패킷을 모든 포트로 브로드캐스트</li>\n    </ul>\n  </li>\n  <li>ARP reply (Laptop0 → Switch0)\n    <ul>\n      <li>Laptop0이 자신의 IP 주소를 확인하고 ARP 응답 패킷 생성</li>\n      <li>패킷 내용:\n        <ul>\n          <li>출발지: Laptop0의 IP 주소와 MAC 주소</li>\n          <li>목적지: PC0의 IP 주소와 MAC 주소</li>\n        </ul>\n      </li>\n      <li>Laptop0은 PC0의 MAC 주소를 자신의 ARP 캐시에 저장</li>\n    </ul>\n  </li>\n  <li>스위치 전달 단계 (Switch0 → PC0)\n    <ul>\n      <li>Switch0은 수신한 응답 패킷을 PC0에게 전달</li>\n      <li>PC0과 Laptop0의 MAC 주소 정보를 MAC 주소 테이블에 저장</li>\n    </ul>\n  </li>\n  <li>통신 시작\n    <ul>\n      <li>PC0이 Laptop0의 MAC 주소를 획득하여 실제 데이터 통신 가능</li>\n    </ul>\n  </li>\n</ol>\n\n<h2 id=\"시뮬레이션\">시뮬레이션</h2>\n\n<ul>\n  <li>시뮬레이션을 눌러서 이벤트 목록창을 볼 수 있다.</li>\n  <li>편지봉투 모양의 [Add Simple PDU] → ICMP 패킷 전송 시뮬레이션</li>\n  <li>송신노드와 수신 노드를 클릭하고 Show All/None 클릭 후 ARP, ICMP 패킷만 클릭한다.</li>\n  <li><em>PC0에서 Laptop0으로 편지를 보낸다.</em></li>\n  <li>ARP - ICMP 순으로 통신이 이루어진다.</li>\n</ul>\n\n<h2 id=\"1-arp-패킷-분석\">1) ARP 패킷 분석</h2>\n\n<p>1. PC0 → Switch0 ARP Request</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cwVj4Z/btsMcHN0AZ1/QtiRKPTAkw5cwMHngIJq5K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:900,”originHeight”:1158,”style”:”alignCenter”,”width”:522,”height”:672}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>ARP\n    <ul>\n      <li>Source MAC<br />\n= PC0 의 MAC 주소</li>\n      <li>Source IP<br />\n= PC0의 IP 주소</li>\n      <li>Target MAC<br />\n= Laptop 의 MAC 주소 [모르는 주소]</li>\n      <li>Target IP<br />\n= Laptop0의 IP주소</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2. Switch0 → 모든 노드 (브로드캐스트)</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dvlpX3/btsMdr43c4X/YNHxFWmjmqgayudoXkG1l0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:818,”originHeight”:124,”style”:”alignCenter”,”width”:594,”height”:90}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch0은 수신한 ARP Request를 모든 포트로 전달</li>\n  <li>Switch0의 MAC 주소 테이블에 PC0의 정보 기록\n    <ul>\n      <li>포트 번호와 PC0의 MAC 주소 매핑</li>\n    </ul>\n  </li>\n</ul>\n\n<p>3. Laptop0→ Switch0 ARP Reply</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@K4KvV/btsMcdUawiw/VpUysCPR5W9T4yYTKTcqJK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1002,”originHeight”:1242,”style”:”alignCenter”,”width”:627,”height”:777}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>ARP\n    <ul>\n      <li>Source MAC<br />\n= Laptop0 의 MAC 주소</li>\n      <li>Source IP<br />\n= Laptop0의 IP 주소</li>\n      <li>Target MAC<br />\n= PC0 의 MAC 주소</li>\n      <li>Target IP<br />\n= Laptop0의 IP주소</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"2-icmp-패킷-분석\">2. ICMP 패킷 분석</h2>\n\n<ol>\n  <li>PC → Laptop</li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@6AWAV/btsMdMA4Jmh/dd2ilCfmHRbqRt9DFVNWhK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2056,”originHeight”:1186,”style”:”alignCenter”,”width”:690,”height”:398}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>SRC ADDR = PC0의 MAC 주소</li>\n  <li>DEST ADDR = Laptop0의 MAC 주소</li>\n</ul>\n\n<h2 id=\"3-switch0의-mac-주소-테이블-변화\">3) Switch0의 MAC 주소 테이블 변화</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dEbxME/btsMdnn7IXG/koFfWfejqCW9bxxbzaYPb0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1080,”originHeight”:611,”style”:”alignCenter”,”width”:747,”height”:423}_#][#_Image</td>\n      <td>kage@WjEAg/btsMdmbIixx/in3AqgZZ7OkLwPpGkcb270/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1080,”originHeight”:734,”style”:”alignCenter”,”width”:727,”height”:494}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>위를 보니 Fa0/1 Fa0/4에 연결된 PC0과 Laptop0의 MAC 주소가 테이블에 기재되었다.</li>\n</ul>\n\n<p>🤔 갑자기 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>Switch0 → 모든 노드로 BroadCast할 때 각자의 MAC 주소 받아오면 되는거 아닌가?</li>\n  <li>해답은 ARP를 이용해 MAC 주소 테이블이 어떻게 유지하는지의 방법에 있다.\n    <ul>\n      <li>스위치의 MAC 주소 학습은 ‘출발지(Source) MAC 주소’만을 대상으로 한다.\n        <ul>\n          <li>PC0이 ARP Request를 보낼 때</li>\n          <li>Laptop0이 ARP Reply를 보낼 때</li>\n        </ul>\n      </li>\n      <li>모든 노드로 전달된 ARP-Request 패킷에 대해 수신 노드가 아니면 응답하지 않는다.</li>\n      <li>PC1과 Laptop1은 Swtich0이 전달한 ARP-Request에 대해 Reply 하지 않는다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>그런데 이런 ‘고민’도 떠오른다.</p>\n\n<p>1.효율성</p>\n\n<ul>\n  <li>ARP는 매우 짧은 시간 간격으로 반복 실행한다.\n    <ul>\n      <li>노드들이 많은 네트워크에서는 통신량으로 부하 가중</li>\n      <li>특히 스위치가 모든 노드에게 BroadCast하는 ARP-Request에서</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2. 보안상의 문제</p>\n\n<ul>\n  <li>Laptop1이 악의적인 공격자라고 가정해보자.\n    <ul>\n      <li>ARP Reply가 실제로 해당 IP 주소를 가진 정당한 장치에서 온 것인지 확인하지 않는다. (보안 X)</li>\n      <li>이 때 Laptop0의 IP에 Laptop1 MAC 주소를 실어서 Reply한다면?</li>\n      <li>테이블이 제대로 갱신되기 전까지 PC0은 Laptop0인 줄 알고 모든 패킷을 보낸다.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"vlan을-통한-해결\">VLAN을 통한 해결</h2>\n\n<ul>\n  <li>MAC 주소를 이용한 라우팅\n    <ul>\n      <li>동일한 네트워크(LAN)에서 스위치를 통해서만 발생한다.</li>\n      <li>라우터를 통한 외부 네트워크로의 통신에는 사용되지 않는다.\n        <ul>\n          <li>ARP 패킷은 하나의 네트워크에서만 송수신한다.</li>\n          <li>LAN을 논리적으로 분리된 가상의 VLAN으로 관리한다.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h1 id=\"라우터\">라우터</h1>\n\n<hr />\n\n<h2 id=\"라우터란\">라우터란?</h2>\n\n<ul>\n  <li>라우터는 서로 다른 네트워크를 연결하는 3계층 장비.</li>\n  <li>IP 주소를 기반으로 패킷의 최적 경로를 결정하고 전달한다.\n    <ul>\n      <li>스위치가 같은 네트워크 내에서 MAC 주소를 기반으로 통신을 담당한다면,</li>\n      <li>라우터는 서로 다른 네트워크 간의 통신을 가능하게 만드는 일종의 ‘네트워크 간의 다리’ 역할을 한다.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"라우터의-mode\">라우터의 Mode</h2>\n\n<ul>\n  <li><strong>사용자 모드(User EXEC Mode)</strong>\n    <ul>\n      <li>기본적인 정보 조회만 가능, 설정 변경 불가</li>\n      <li>&gt; 로 표시</li>\n    </ul>\n  </li>\n  <li><strong>관리자 모드(Privileged EXEC Mode)</strong>\n    <ul>\n      <li>라우터 설정을 변경할 순 없지만 시스템 정보 상세조회 가능</li>\n      <li># 으로 표시</li>\n    </ul>\n  </li>\n  <li><strong>글로벌 모드(Global Configuration Mode)</strong>\n    <ul>\n      <li>라우터 설정(이름, 보안, 인터페이스 등)을 변경</li>\n      <li>(config)# 로 표시</li>\n      <li><strong>라인 모드(Line Configuration Mode)</strong>\n        <ul>\n          <li>콘솔, 원격 접속(Telnet, SSH 등) 관련 설정 변경</li>\n          <li>(config-line)# 로 표시</li>\n        </ul>\n      </li>\n      <li><strong>인터페이스 모드(Interface Configuration Mode)</strong>\n        <ul>\n          <li>라우터의 네트워크 인터페이스(이더넷, 시리얼 등) 설정을 변경</li>\n          <li>라우터의 인터페이스에 IP 주소를 설정하고 활성화/비활성화</li>\n          <li>(config-if)# 로 표시</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"목표-네트워크-구성\">목표 네트워크 구성</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@FrASQ/btsMeLVCXVC/1wKsZjYPW9BikRxL7DFtC1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:813,”originHeight”:495,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"기본-설정\">기본 설정</h2>\n\n<ul>\n  <li>라우터 3대: [Network Devices] → [Routers] → [2811]</li>\n  <li>스위치 1대 : [Network Devices] → [Switches] → [2960]</li>\n  <li>PC 3대, 노트북 1대, 서버 1대 : [End Devices] → [PC], [Laptop], [Server]</li>\n</ul>\n\n<h2 id=\"라우터---시리얼-인터페이스-장착\">라우터 - 시리얼 인터페이스 장착</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@zgPDU/btsMd3bDPMR/E6TXH94lrMz3OrUR6TF5hK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:1293,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC와 달리 두 라우터 간에 데이터를 주고받기 위한 동기화가 필요</li>\n  <li>FastEthernet이 아닌 Serial 인터페이스를 사용하므로 모듈을 추가해야 한다.\n    <ul>\n      <li>HWIC-2T 추가</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"노드-간-연결하기\">노드 간 연결하기</h2>\n\n<ul>\n  <li>Laptop0은 통신용이 아니라 Router0을 설정하기 위한 콘솔\n    <ul>\n      <li>FastEthernet 케이블이 아닌 RS232(하늘색) 케이블로 연결</li>\n    </ul>\n  </li>\n  <li>라우더들끼리 Serial DCE 연결\n    <ul>\n      <li>먼저 클릭한 쪽에 시계 모양 - 두 라우터 간 데이터를 주고받기 위한 동기화가 필요</li>\n      <li>Serial DCE(Data Communication Equipment): 시간 동기화를 주도하는 노드 (시계 있는 쪽)</li>\n      <li>Serial DTE(Data Terminal Equipment): 그에 따라 동기화하는 노드 (시계 없는 쪽)</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@evpmpX/btsMdMnzPql/PLX7aieEhAKMJ6N99C2j5K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2184,”originHeight”:1246,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"ip-설정\">IP 설정</h2>\n\n<ul>\n  <li>컴퓨터들은 203.237.nnn.nnn/24 사용(C클래스)\n    <ul>\n      <li>1번부터 시작</li>\n    </ul>\n  </li>\n  <li>원격 관리가 필요한 스위치나 서버는 100번 부터</li>\n  <li>라우터는 광역의 랜들을 연결하므로 A클래스 IP 사용\n    <ul>\n      <li>규모가 작아 30비트 서브넷 마스크를 사용하여 최대 4개의 라우터를 묶을 수 있도록</li>\n    </ul>\n  </li>\n  <li>스위치는 2계층 장비\n    <ul>\n      <li>IP 주소 설정 불필요</li>\n      <li>원격 접속으로 스위치 관리\n        <ul>\n          <li>IP 주소 할당 필요</li>\n          <li>VLAN1에 할당</li>\n        </ul>\n      </li>\n      <li>스위치 IP 주소 설정</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bk8xpK/btsMd7Sxxul/dQMOVhudaYmzsa519EoeQK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1374,”originHeight”:164,”style”:”alignCenter”,”width”:635,”height”:76}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>총 6개의 LAN</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@UGTSj/btsMcKRyRRh/QFOQKnpr0nm0a6K8eUWWKk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1762,”originHeight”:1000,”style”:”alignCenter”,”width”:698,”height”:396}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"연결-확인\">연결 확인</h2>\n\n<ul>\n  <li>PC0에서 테스트</li>\n</ul>\n\n<ol>\n  <li>PC0 로컬 호스트(127.0.0.1)</li>\n  <li>PC0 → Switch1(VLAN1, 203.237.10.100)</li>\n  <li>PC0 → Server0(203.237.10.101)</li>\n  <li>PC0 → Router0(203.237.10.254)\n    <ul>\n      <li>모두 통신 성공</li>\n    </ul>\n  </li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@s9v2J/btsMcYPw7T1/QedNlAylJ9wAnApW81hp3K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1000,”originHeight”:1605,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>5. PC0 → PC2(203.237.30.1)</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@mi021/btsMdHGFlHG/cChGsiN9Pw0rWY0kG0w7q1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:996,”originHeight”:374,”style”:”alignCenter”,”width”:684,”height”:257}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><strong>unreachable</strong> 이 발생한다\n    <ul>\n      <li>PC0으로 부터 받은 패킷을 Router0이 어느 인터페이스로 보내야할지 모르기 때문</li>\n      <li>→ <strong>라우팅 테이블</strong>이 필요하다</li>\n      <li>아래는 Router0의 라우팅 정보</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@beagrf/btsMdMujNSG/uzGad36EzxcCPqRZ3PJy21/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1260,”originHeight”:698,”style”:”alignCenter”,”width”:746,”height”:413}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"정적-라우팅-설정\">정적 라우팅 설정</h2>\n\n<ul>\n  <li>정적 라우팅 대상\n    <ul>\n      <li>1번 PC0 입장에서 목적지가\n        <ul>\n          <li><strong>2번</strong> 네트워크(203.237.20.nnn/24)인 패킷 : serial0/3/0 (혹은 1.1.1.2)</li>\n          <li><strong>3번</strong> 네트워크(203.237.30.nnn/24)인 패킷 : serial0/3/1 (혹은 2.2.2.2)</li>\n          <li>6번 네트워크(3.3.3.nnn/30)인 패킷 : serial0/3/0 혹은 serial0/3/1</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>Router1의 정적 라우팅 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@JLnX1/btsMckFDkMJ/ik8vROKAHLaZQPxINyMSmK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1226,”originHeight”:442,”style”:”alignCenter”,”width”:694,”height”:250}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Router2의 정적 라우팅 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@k4yPj/btsMexiTcvl/Ewo59hWdxO2tOqMp9GTtNK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1248,”originHeight”:504,”style”:”alignCenter”,”width”:736,”height”:297}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Router3의 정적 라우팅 설정 + route 확인</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cnu0SN/btsMdH0043d/jjkekr1KEkmqtXM0E7LRUK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1270,”originHeight”:1186,”style”:”alignCenter”,”width”:756,”height”:706}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"통신테스트-by-ping\">통신테스트 by ping</h2>\n\n<ul>\n  <li>PC0 ↔ PC1</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dD0uXu/btsMb0Hnvj9/50DKkNchVlTaBfBiYNEMiK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:962,”originHeight”:422,”style”:”alignCenter”,”width”:730,”height”:320}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC0 ↔ PC2</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cEoaLU/btsMdGgIz36/93lJ36D1HjrKK9gQaOKvb1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:432,”style”:”alignCenter”,”width”:780,”height”:350}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h1 id=\"방화벽---네트워크-구성\">방화벽 - 네트워크 구성</h1>\n\n<hr />\n\n<h2 id=\"망구성\">망구성</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@kO9qL/btsMengxOIb/FFIVXRjKkeW6JnSOKHGXqk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:524,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"asa0-구성-설정\">ASA0 구성 설정</h2>\n\n<p>1. 인터페이스 통신 상태</p>\n\n<ul>\n  <li>내부망 : 통신 가능</li>\n  <li>외부망 : 통신 불가\n    <ul>\n      <li>inPC → outPC 불가능</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bh2bBN/btsMd7rqkl0/g4AYl1hwkqpXZ1NDwCwO30/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1278,”originHeight”:266,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>2. IP 주소 설정</p>\n\n<ul>\n  <li>Inside : 설정됨</li>\n  <li>outside : 설정되어있지 않음\n    <ul>\n      <li>→ VLAN에서 203.237.20.253으로 설정</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cormPm/btsMc1r1E8A/LKXIkkQ8YcBwbHGgFGWQIk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1406,”originHeight”:342,”style”:”alignCenter”,”width”:807,”height”:196}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>3. Config 확인</p>\n\n<ul>\n  <li>내부망 Security-level : 100</li>\n  <li>외부망 Security-level : 0</li>\n  <li>보안 레벨이 높은 곳 → 낮은 곳 : 허용 (반대는 불가능)</li>\n  <li>내부망 노드들은 DHCP를 이용하여 IP 할당받는다.</li>\n</ul>\n\n<h2 id=\"inpc-dhcp-설정\">inPC DHCP 설정</h2>\n\n<ul>\n  <li>inPC는 ASA가 DHCP로 주소를 할당해준다고 했다.\n    <ul>\n      <li>게이트웨이는 ASA0 inside의 ip 주소로 고정된다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@HAypL/btsMemIHLU2/tcja6hVK1aurUDoEGiKLAK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1388,”originHeight”:636,”style”:”alignCenter”,”width”:703,”height”:322}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>outPC는 고정 주소 사용 중</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@lNS8u/btsMdHzVPu4/iHvbzNmifAq1gElLiDlpW1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1304,”originHeight”:546,”style”:”alignCenter”,”width”:707,”height”:296}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"router0-설정\">Router0 설정</h2>\n\n<ul>\n  <li>fa0/0 IP 설정 &amp; 활성화\n    <ul>\n      <li>203.237.10.254/24</li>\n    </ul>\n  </li>\n  <li>fa0/0 IP 설정 &amp; 활성화\n    <ul>\n      <li>203.237.20.253/24</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"rna-설정\">RNA 설정</h2>\n\n<h2 id=\"routing\">Routing</h2>\n\n<ul>\n  <li>라우터의 정적라우팅\n    <ul>\n      <li>네트워크 디바이스들이 서로 다른 네트워크에 있을 때, 그들 사이의 통신 경로를 명확히 지정해줘야 한다.</li>\n      <li>예를 들어, 내부 네트워크의 PC가 다른 네트워크의 서버와 통신하려면, 그 경로를 알아야 한다.</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">ip route &lt;목적지 네트워크 주소&gt; &lt;목적지 서브넷 마스크&gt; &lt;다음 홉 IP 주소/출구 인터페이스&gt;</code></li>\n    </ul>\n  </li>\n  <li>방화벽의 정적라우팅\n    <ul>\n      <li>트래픽이 반드시 방화벽을 통과하도록 하여 보안 정책을 적용할 수 있게 한다.</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">route &lt;VLAN명&gt; &lt;외부망 네트워크 주소&gt; &lt;외부망 서브넷마스크&gt; &lt;다음 홉 IP 주소&gt;</code></li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@UMo4w/btsMemPruKw/su6TBN30w2NLPGdTiu8nN0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2110,”originHeight”:1000,”style”:”alignCenter”,”width”:734,”height”:348}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>→ 어떤 목적지 주소를 갖는 패킷이든 외부망의 Router0인 203.207.20.254로 전송한다.</p>\n\n<ul>\n  <li>통신확인</li>\n  <li>inPC ↔ ASA0</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@ea7sUx/btsMcHURKDV/D3ikyzQhpSkEa8QCBP2sK1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:972,”originHeight”:428,”style”:”alignCenter”,”width”:708,”height”:312}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>inPC ↔ outPC</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b7mUIE/btsMcfqYrdM/SvtR3wkJNdKRzXgHMUMtIK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:986,”originHeight”:368,”style”:”alignCenter”,”width”:702,”height”:262}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"nat\">NAT</h2>\n\n<ul>\n  <li>inPC → outPC 까지는 패킷 전달이 잘 되지만,</li>\n  <li>Router0 → ASA0으로 전달이 되지 않는다.</li>\n</ul>\n\n<p><strong>outPC → Router1로 전달되는 패킷</strong></p>\n\n<ul>\n  <li>outPC(203.237.10.10)가 inPC(192.168.1.5)로 통신을 시도할 때, Router는 문제에 직면한다.\n    <ul>\n      <li>목적지 주소가 사설IP이기 때문에 외부에서 인식이 불가능하다.</li>\n      <li>→ Rotuer 입장에서 어디로 보내야 할 지 모른다.\n        <ul>\n          <li>(마치 동 호수만 알고, 택배 기사가 서울에서 배달을 하려는 상황과 마찬가지)</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@xD2B6/btsMeR9g8xQ/eG7q1kOXNaBGJdcSFREQoK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2080,”originHeight”:1270,”style”:”alignCenter”,”width”:783,”height”:478}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>⇒ ASA가 사설 IP를 공인 IP로 변경해서 보내줘야 한다.</li>\n  <li>ASA의 <strong>NAT</strong></li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@tUl9o/btsMeRVJT2O/PJFvZxKK7bVxaO8Vexhkt0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:414,”originHeight”:143,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>들어오는 패킷의 처리\n    <ul>\n      <li>외부 노드들은 내부 네트워크의 실제 사설 IP를 알 필요가 없다.\n        <ul>\n          <li>대신 ASA의 공인 IP 주소로 통신을 시도</li>\n        </ul>\n      </li>\n      <li>ASA는 NAT 테이블을 유지하면서, 어떤 외부 통신이 어떤 내부 노드를 위한 것인지 추적</li>\n      <li>수신된 패킷의 목적지 주소를 적절한 내부 사설 IP로 변환하여 전달</li>\n    </ul>\n  </li>\n  <li>나가는 패킷의 처리\n    <ul>\n      <li>내부 노드가 외부로 통신을 시도할 때, ASA는 출발지의 사설 IP를 자신의 공인 IP로 변환</li>\n      <li>이 과정에서 ASA는 어떤 내부 노드가 어떤 통신을 시작했는지 NAT 테이블에 기록</li>\n      <li>나중에 응답이 돌아오면, 이 테이블을 참조하여 올바른 내부 노드에게 전달</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"nat-설정\">NAT 설정</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@czZH5n/btsMc0fu60D/gU0ev4kVhViqehGSDDt6K0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1220,”originHeight”:196,”style”:”alignCenter”,”width”:742,”height”:119}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>in2out 객체 생성 (네트워크 객체 모드)</li>\n  <li>대상 서브넷을 지정해준다.</li>\n  <li>NAT 지정\n    <ul>\n      <li>내외부망을 연결하는 (inside, outside)를 동적 매핑</li>\n      <li>공인 Ip 주소는 인터페이스에 할당된 IP 주소를 사용한다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@ccZXOd/btsMcjzZe4x/9s6nimQ80LBoH1dkmToAWK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:942,”originHeight”:138,”style”:”alignCenter”,”width”:676,”height”:99}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>그래도 inPC → outPC의 통신이 실패하게 된다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bajXRR/btsMcZgFpCY/BFAnMrFdvAP1aAJVnNh9z0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:600,”originHeight”:157,”style”:”alignCenter”,”width”:524,”height”:137}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"acl\">ACL</h2>\n\n<ul>\n  <li>패킷을 보면 목적지 주소는 공인 IP 주소로 정확히 설정되어 있으나,</li>\n  <li>외부망에서 내부망으로 들어오는 트래픽의 흐름을 방화벽이 모두 Block하고 있기 때문</li>\n  <li><strong>즉, 인터페이스마다 어떤 출발지 &amp; 어떤 목적지 를 가지는 트래픽을 허용 / 거부 할 것인지 정의해줘야 한다.</strong></li>\n  <li>→ ACL : 이러한 Allow/Deny 접근 제어 목록</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>access-list &lt;ACL명&gt; &lt;타입&gt; &lt;동작&gt; &lt;프로토콜&gt; &lt;출발지&gt; &lt;목적지&gt;\naccess-group &lt;ACL명&gt; &lt;트래픽&gt; &lt;인터페이스 키워드&gt; &lt;VLAN 명&gt;\n</code></pre></div></div>\n\n<ul>\n  <li>ACL 설정\n    <ul>\n      <li>모든 출발지에서 모든 목적지로 가는 ICMP(ping) 트래픽을 허용하는 규칙을 만든다.</li>\n      <li>만든 규칙을 외부 인터페이스의 인바운드 방향에 적용</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@eklCj3/btsMeUZeeor/0St67walf4cyejJZvVb2N0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1224,”originHeight”:300,”style”:”alignCenter”,”width”:767,”height”:188}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>inPC → outPC Ping 확인</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bMTQzA/btsMeyozeji/a8vxJ4pw0kExxZ6GUmDnRk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:962,”originHeight”:434,”style”:”alignCenter”,”width”:749,”height”:338}_#]</td>\n    </tr>\n  </tbody>\n</table>\n",
                        "tags": ["Network","PacketTracer","LAN","Switch","Router","Firewall","VLAN","Topology"]
                    }
                
            ],
        
            "Topology": [
                
                    {
                        "title": "Packet Tracer로 네트워크 이해하기",
                        "url": "/2025/02/08/packet-tracer-network.html",
                        "subtitle": "LAN 토폴로지, 스위치, 라우터, 방화벽",
                        "excerpt": "LAN 토폴로지와 스위치\n",
                        "author": "Jinho",
                        "date": "February 08, 2025",
                        "background": "/img/posts/network_topology.jpeg",
                        "content": "<h1 id=\"lan-토폴로지와-스위치\">LAN 토폴로지와 스위치</h1>\n\n<hr />\n\n<h2 id=\"packet-tracer에-들어가기-전\">Packet Tracer에 들어가기 전</h2>\n\n<p>먼저 네트워크의 기본 구성 요소부터 이해해보자.</p>\n\n<p><strong>라우터, 스위치, 엔드 디바이스(PC, 서버 등)가 어떻게 상호 작용</strong>하는지 알아보자.</p>\n\n<ul>\n  <li>가장 기본적인 두 대의 디바이스(<code class=\"language-plaintext highlighter-rouge\">PC</code>)가 있다고 가정해보자.</li>\n  <li>두 PC를 연결하고, IP 주소 설정, 서브넷 마스크 설정을 하고 ping 테스트를 통해 연결.\n    <ul>\n      <li>이 과정에서 TCP/IP의 기본 개념을 이해해보자.</li>\n    </ul>\n  </li>\n  <li>그 다음 단계로 <code class=\"language-plaintext highlighter-rouge\">스위치</code>를 추가하여 여러 대의 <code class=\"language-plaintext highlighter-rouge\">PC</code>를 연결.\n    <ul>\n      <li>L2 통신의 개념과 MAC 주소의 역할을 이해해보자.</li>\n    </ul>\n  </li>\n  <li>마지막으로 <code class=\"language-plaintext highlighter-rouge\">라우터</code>를 추가하여 서로 다른 네트워크 간의 통신을 구현.\n    <ul>\n      <li>라우팅 테이블, 게이트웨이 등의 개념을 학습해보자.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"사용법\">사용법</h2>\n\n<h2 id=\"pc\">PC</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@tdMGa/btsMchWsAbo/pXUJ5sc1Jn5zlePiDz1mrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:264,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>장치 타입 → End Devices → PC / LAPTOP 등 Drag &amp; Drop</li>\n</ul>\n\n<h2 id=\"switch\">Switch</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bdJ1mb/btsMedLRoGJ/cpMkbVJahG5gP3qwnew9Uk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:194,”originHeight”:256,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"router\">Router</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@A02nQ/btsMeKJcj9q/usIeZ7q3BDrYQHVk4TpOuk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:208,”originHeight”:276,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"connection\">Connection</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@rOlnO/btsMdkEVmv0/U1xgvAbp826OCElZjbp2Sk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:280,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>실선은 Copper Straight [PC - Switch/Router]</li>\n  <li>점선은 Copper Cross - Over [Switch/Router … Switch/Router]</li>\n  <li>번개 모양은 Automatic</li>\n</ul>\n\n<h2 id=\"기본-사용-방법\">기본 사용 방법</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@mamWH/btsMdM8WmZV/J6Eve21yZP8cKJkdv8KQrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:666,”originHeight”:558,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>장치(PC 와 Laptop)들을 놓는다.</li>\n  <li>각 디바이스 개수만큼 연결한 스위치 추가</li>\n  <li>실선과 점선으로 연결</li>\n  <li>스위치 0 → 메뉴에서 FastEthernet0/1 선택</li>\n  <li>PC 0 → 메뉴에서 FastEthernet0 선택</li>\n  <li>(나머지도 동일하게 연결)</li>\n  <li>왼쪽 스위치 : <code class=\"language-plaintext highlighter-rouge\">FastEthernet0/2</code> 오른쪽 스위치 : <code class=\"language-plaintext highlighter-rouge\">FastEthernet0/3</code></li>\n  <li>PC 클릭 → Desktop → IP Configuration → IP Address에 <code class=\"language-plaintext highlighter-rouge\">198.168.0.1</code><br />\nSubnet Mask에 <code class=\"language-plaintext highlighter-rouge\">255.255.255.0</code>\n    <ul>\n      <li>나머지 장치는 IP 주소 ~0.2, ~0.3 순으로 입력</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dhy2rZ/btsMczo0VIn/LHz5KS8UijOguFkFqLdSSk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:338,”style”:”alignCenter”,”width”:780,”height”:206}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Desktop → Command Prompt로 ping 테스트</li>\n  <li>작업 공간에서 Simulation 가능 [실제 이동 경로 &amp; 헤더 정보 등을 볼 수 있다.]</li>\n</ul>\n\n<h2 id=\"lan-topology\">LAN Topology</h2>\n\n<ul>\n  <li>같은 로컬 에이리어 네트워크 (LAN) 내에서 네트워크 장비와 디바이스들이 어떻게 물리적 혹은 논리적으로 연결되어 있는지 나타내는 구조</li>\n</ul>\n\n<h2 id=\"lan과-wan\">LAN과 WAN</h2>\n\n<ul>\n  <li><strong>LAN (로컬 영역 네트워크)</strong>:\n    <ul>\n      <li>제한된 지역 내에서 연결된 네트워크</li>\n      <li><strong>스위치</strong>는 MAC 주소를 사용하여 네트워크 내 장치들 간에 데이터를 전달합니다. 스위치는 <strong>MAC 주소 테이블</strong>을 사용해 데이터를 해당 장치로 정확하게 전달</li>\n    </ul>\n  </li>\n  <li><strong>WAN (광역 네트워크)</strong>:\n    <ul>\n      <li>더 넓은 지역, 심지어 전 세계적으로 연결된 네트워크\n        <ul>\n          <li>인터넷이 대표적인 WAN 예시</li>\n        </ul>\n      </li>\n      <li>WAN에서는 서로 MAC 주소를 알 수 없음</li>\n      <li>WAN에서 라우터는 <strong>IP 주소</strong>를 기반으로 데이터를 전달하는데, 각 네트워크 간의 경로를 찾기 위해 <strong>라우팅 테이블</strong>을 사용\n        <ul>\n          <li>NAT / PAT</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cyma1b/btsMcdGGX7j/3HjkxSXXuguLBaXiMCtKp1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:933,”style”:”alignCenter”,”width”:757,”height”:552}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"1-bus-형\">1) Bus 형</h2>\n\n<ul>\n  <li>하나의 메인 케이블(백본)에 모든 노드가 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>구조가 단순하고 설치 비용이 저렴</li>\n      <li>노드 추가/제거가 쉽고 유연함</li>\n      <li>케이블 길이가 짧아 경제적</li>\n      <li>소규모 네트워크에 적합</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>트래픽 증가 시 성능 저하</li>\n      <li>메인 케이블 장애 시 전체 영향</li>\n      <li>데이터 충돌 발생 가능</li>\n      <li>보안 취약점 존재</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cdwQWE/btsMctoZGjP/YoLinRs4T7sWM3Iv3xCkfK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1138,”originHeight”:650,”style”:”alignCenter”,”width”:690,”height”:394}_#][#_Image</td>\n      <td>kage@XghRi/btsMc2doIc4/cDKKGHIAwzkFizYIthmvX1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:978,”originHeight”:456,”style”:”alignCenter”,”width”:620,”height”:289}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"2-ring-형\">2) Ring 형</h2>\n\n<ul>\n  <li>각 노드가 양옆의 두 노드와 연결되어 원형을 이루는 구조</li>\n  <li>자동선택 기능을 사용한 링</li>\n  <li>장점 :\n    <ul>\n      <li>데이터 흐름이 일정하고 예측 가능</li>\n      <li>충돌이 적고 전송이 안정적</li>\n      <li>각 노드가 리피터 역할 수행</li>\n      <li>장거리 전송에 유리</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>단일 노드 장애가 전체에 영향</li>\n      <li>네트워크 확장이 제한적</li>\n      <li>설치/제거 시 네트워크 중단</li>\n      <li>양방향 링 구성 시 비용 증가</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@lYUdr/btsMetVb0e8/23KtOkSs1PeRKuNml0S2AK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1108,”originHeight”:642,”style”:”alignCenter”,”width”:598,”height”:346}_#][#_Image</td>\n      <td>kage@rYlFs/btsMeKWHZEC/wFs32hn23rG7rKA9WFyKxK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:982,”originHeight”:460,”style”:”alignCenter”,”width”:621,”height”:291}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"3-star-형\">3) Star 형</h2>\n\n<ul>\n  <li>중앙에 허브가 있고 모든 노드가 이 허브에 직접 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>구현과 유지보수가 단순하고 직관적</li>\n      <li>개별 노드 장애가 다른 노드에 영향 없음</li>\n      <li>높은 성능과 데이터 전송 속도</li>\n      <li>중앙 집중적 보안 관리 용이</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>중앙 허브 장애 시 전체 네트워크 마비 - 단일 장애 지점 (SPOF)</li>\n      <li>허브에 과부하 발생 가능</li>\n      <li>케이블 설치 비용이 높음</li>\n      <li>허브 용량에 따른 확장성 제한</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@NJ0T7/btsMdF26Hzf/aEmXKMDwoG1TwsmUekA04K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1088,”originHeight”:678,”style”:”alignCenter”,”width”:627,”height”:391}_#][#_Image</td>\n      <td>kage@vFDga/btsMcTgvpqn/IDhAPb27H9xt3kN9pDOB7k/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:456,”style”:”alignCenter”,”width”:585,”height”:277}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"4-mesh-형\">4) Mesh 형</h2>\n\n<ul>\n  <li>모든 노드가 서로 직접 연결되는 구조</li>\n  <li>장점 :\n    <ul>\n      <li>높은 안정성과 이중화 구성</li>\n      <li>효율적인 트래픽 분산</li>\n      <li>우회 경로 확보로 신뢰성 높음</li>\n      <li>뛰어난 보안성</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>설치/유지보수 비용이 매우 높음</li>\n      <li>구현과 설정이 매우 복잡</li>\n      <li>케이블 연결 관리가 어려움</li>\n      <li>노드 수 증가에 따른 복잡도 급증</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bb9BX4/btsMeahgXHL/gVJ4LgKjyCG8M1I6DkkbP0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1070,”originHeight”:674,”style”:”alignCenter”,”width”:628,”height”:396}_#][#_Image</td>\n      <td>kage@ovOWb/btsMb2rFLwg/Qi0orK06gCRkfnrkBXhvyK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:432,”style”:”alignCenter”,”width”:677,”height”:303}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ping 192.168.0.4</code></li>\n</ul>\n\n<h2 id=\"5-tree-형\">5) Tree 형</h2>\n\n<ul>\n  <li>계층적 구조로, 상위 노드에서 하위 노드로 분기되는 형태</li>\n  <li>장점 :\n    <ul>\n      <li>네트워크 확장이 용이</li>\n      <li>체계적인 계층 구조 관리</li>\n      <li>하위 네트워크 독립성</li>\n      <li>효율적인 트래픽 관리</li>\n    </ul>\n  </li>\n  <li>단점 :\n    <ul>\n      <li>루트 노드 장애 시 전체 영향</li>\n      <li>계층 증가에 따른 관리 복잡성</li>\n      <li>상위 노드 병목 현상 가능</li>\n      <li>깊이가 깊어질수록 지연 증가</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@wounf/btsMcywRCH9/2KnaYgagHLQKp4cBdcumy0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:985,”style”:”alignCenter”,”width”:765,”height”:589}_#][#_Image</td>\n      <td>kage@dI6An5/btsMd4hh7vI/Gxr1Nv7uKXeDV0vrZs1qT0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:960,”originHeight”:458,”style”:”alignCenter”,”width”:642,”height”:306}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>192.168.0.1 to 192.168.0.12</li>\n</ul>\n\n<h2 id=\"vlanvirtual-lan-case-1--switch-1개\">VLAN(Virtual LAN) (case 1 : Switch 1개)</h2>\n\n<h2 id=\"vlan이란\">VLAN이란?</h2>\n\n<p>“<strong>논리적인 구조의 속임수로 같은 물리적 공간에 있는 네트워크를 다른 네트워크에 있는 것처럼 속이는 기술</strong>”</p>\n\n<ul>\n  <li>먼저, 물리적인 LAN을 먼저 생각해보면, 같은 건물이나 같은 층에 있는 컴퓨터들이 하나의 네트워크로 연결되어 있는 구조이다.</li>\n  <li>그런데 예를 들면, 마케팅팀과 개발팀이 다른 네트워크에 있어야 한다고 가정해보자.\n    <ul>\n      <li>전통적인 방식이라면 물리적으로 별도의 네트워크 장비와 케이블을 설치해야 했다.</li>\n      <li>하지만, VLAN은 이런 물리적 제약을 소프트웨어적으로 해결한다.</li>\n    </ul>\n  </li>\n  <li>하나의 물리적인 스위치를 마치 여러 개의 독립된 스위치처럼 동작하게 만드는 기술이다.</li>\n  <li>예를 들어, 같은 스위치에 연결된 컴퓨터라도 서로 다른 VLAN에 속하면 마치 다른 네트워크에 있는 것처럼 통신이 분리된다.</li>\n</ul>\n\n<h2 id=\"초기-default-vlan-설정\">초기 default VLAN 설정</h2>\n\n<ul>\n  <li>show vlan으로 확인해보자.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bTHrGF/btsMea2FcPL/VagNQtcNTnfvH7OWzcKevk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1250,”originHeight”:974,”style”:”alignCenter”,”width”:670,”height”:522}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>처음 VLAN 1은 ‘기본 VLAN’이다.</li>\n  <li>모든 스위치 포트는 처음에 이 VLAN 1에 속하도록 설정되어 있다.\n    <ul>\n      <li>그래서 별다른 설정 없이는 같은 물리적인 공간에 있다면 한 네트워크에 속하도록 설정이 된다.</li>\n    </ul>\n  </li>\n  <li>그리고 VLAN 1002부터 1005까지는 특별한 목적으로 예약된 VLAN이다. (사용 불가)\n    <ul>\n      <li>FDDI, 토큰링 등으로 고정되어 있다.</li>\n    </ul>\n  </li>\n  <li>우리가 새로운 VLAN을 할당하려고 하면 “2 ~ 1001” 의 VLAN을 사용해서 나누면 된다.</li>\n</ul>\n\n<h2 id=\"vlan-구성하기\">VLAN 구성하기</h2>\n\n<ul>\n  <li>먼저 VLAN 2개를 생성한다.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch#enable\nSwitch#config terminal\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#vlan 2\nSwitch(config-if)#name VLAN_2\nSwitch(config-if)#exit\n</code></pre></div></div>\n\n<ul>\n  <li>enable : 관리자 모드 진입</li>\n  <li>config terminal : 글로벌 모드 진입</li>\n  <li>vlan 2 : vlan 모드 진입</li>\n  <li>name <이름> : 진입되어 있는 vlan의 이름 설정</이름></li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dsQlbd/btsMdqdX0ps/kPhix6BIWT0KDKtVJzq3NK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1185,”originHeight”:1000,”style”:”alignCenter”,”width”:734,”height”:619}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>결과</p>\n\n<ul>\n  <li>그리고, <code class=\"language-plaintext highlighter-rouge\">VLAN_2</code>엔 <code class=\"language-plaintext highlighter-rouge\">Fa0/1</code> 과 <code class=\"language-plaintext highlighter-rouge\">Fa0/2</code>, <code class=\"language-plaintext highlighter-rouge\">VLAN_3</code>엔 <code class=\"language-plaintext highlighter-rouge\">Fa0/3</code> 과 <code class=\"language-plaintext highlighter-rouge\">Fa0/4</code> 포트를 배정시킨다.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch#enable\nSwitch#config terminal\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#interface fa0/1\nSwitch(config-if)#switchport mode access\nSwitch(config-if)#switchport access vlan 2\n</code></pre></div></div>\n\n<ul>\n  <li>inteface fa0/1 : 인터페이스 모드 진입</li>\n  <li>switchport mode access : 해당 포트를 VLAN 전용으로 사용함을 선언</li>\n  <li>switchport access vlan 2 : 해당 포트가 속한 VLAN 번호 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@GEPhJ/btsMcd0ZUA9/NJfHXH7fr603Pozrp0XUN1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:779,”style”:”alignCenter”,”width”:697,”height”:424,”caption”:”결과”}_#][#_Image</td>\n      <td>kage@ZktHy/btsMceFDArB/GmkkKk7xrFmJK5XI7GNxS1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:975,”style”:”alignCenter”,”width”:686,”height”:523}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"vlan-통신-테스트\">VLAN 통신 테스트</h2>\n\n<ol>\n  <li><code class=\"language-plaintext highlighter-rouge\">192.168.0.1</code> to <code class=\"language-plaintext highlighter-rouge\">192.168.0.2</code>\n    <ul>\n      <li>같은 VLAN 내에서는 통신 가능</li>\n    </ul>\n  </li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@BqqF9/btsMceevW1X/38cHtm9y7VtBM8yRsEMKb1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:742,”originHeight”:340,”style”:”alignCenter”,”width”:653,”height”:299}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li><code class=\"language-plaintext highlighter-rouge\">192.168.0.1</code> to <code class=\"language-plaintext highlighter-rouge\">192.168.0.2</code></li>\n</ol>\n\n<ul>\n  <li>다른 VLAN 끼리는 통신 불가능</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@905VT/btsMcKD1XhO/HVQpVtHJXEQCpfTAUkHWYk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1060,”originHeight”:502,”style”:”alignCenter”,”width”:668,”height”:316}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"vlanvirtual-lan-case-2--switch-여러-개\">VLAN(Virtual LAN) (case 2 : Switch 여러 개)</h2>\n\n<ul>\n  <li>그렇다면 네트워크를 확장하고 좀 더 현실적인 아키텍쳐로 바뀌면 어떨까?</li>\n  <li>먼저 Switch를 하나 더 두어보자.</li>\n  <li><em>들어가기전</em>\n    <ul>\n      <li>VLAN 설정 자체는 IP 주소를 직접 변경하지 않는다.\n        <ul>\n          <li>VLAN은 Layer 2(데이터 링크 계층)에서 작동하는 반면,<br />\nIP 주소는 Layer 3(네트워크 계층)에서 작동하기 때문.</li>\n        </ul>\n      </li>\n      <li>그러나, 실제 네트워크 운영에서는 일반적으로 각 VLAN마다 서로 다른 IP 대역을 할당한다.\n        <ul>\n          <li>네트워크 관리와 보안을 위한 설계</li>\n        </ul>\n      </li>\n      <li>그러므로 VLAN 별로 다른 대역을 할당해보자.\n        <ul>\n          <li>VLAN 2: 203.237.20.nnn</li>\n          <li>VLAN 3: 203.237.30.nnn</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@pcw1H/btsMc0NoTlz/v9c56wkkpb2qWxKk6BEsq0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1031,”originHeight”:1000,”style”:”alignCenter”,”width”:680,”height”:660}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 0 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@d5TDWZ/btsMekcZbAx/1meC8Kjg2Niht4JKNpWjE1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:325,”style”:”alignCenter”,”width”:757,”height”:192}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 1 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bxI7Ez/btsMcsXSPgC/McV65YvUN8ELGhZbpqxaEK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:336,”style”:”alignCenter”,”width”:750,”height”:197}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>여기서 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>🤔 과연 PC2는 PC0과 통신이 가능할까?\n    <ul>\n      <li>결과를 보면, PC1과는 통신이 가능하지만, 다른 스위치로 넘어가면서 통신이 불가능해진다</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cdqmkw/btsMeSmNMeI/jnvpXenhi6dV8W4U8oGWaK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:994,”originHeight”:806,”style”:”alignCenter”,”width”:664,”height”:538}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>이런 논리적인 흐름의 질문이 든다.\n    <ol>\n      <li>오히려 VLAN 설정하기 전에 그냥 여러 스위치를 건너 뛰어도 통신이 됐음.</li>\n      <li>그리고 같은 VLAN 끼리는 통신이 된다고 했다.</li>\n      <li>그런데 갑자기 같은 VLAN에서 여러 스위치를 건너뛰면 왜 통신이 안될까?</li>\n    </ol>\n  </li>\n  <li>여기서 <strong>VLAN 태그</strong>라는 개념이 등장한다.\n    <ul>\n      <li>VLAN을 설정하면 각 패킷에는 특별한 VLAN ID가 붙게 된다.\n        <ul>\n          <li>(마치 우편물에 부서명을 적는 것과 같다.)</li>\n        </ul>\n      </li>\n      <li>일반적인 스위치의 Port(Access Port)는 VLAN 태그를 처리하는 방법에 대해 1가지 밖에 모른다.\n        <ul>\n          <li>PACKET 들어올 때 : 자신의 VLAN 번호를 태그로 붙인다.</li>\n          <li>PACKET 나갈 때 : 태그를 제거하고 보낸다.</li>\n        </ul>\n      </li>\n      <li>그럼 여기서 문제가 발생한다.\n        <ul>\n          <li>PC2에서 나온 패킷\n            <ul>\n              <li>Switch 0으로 들어올 때 : fa0/2에서 VLAN 2 태그를 붙임</li>\n            </ul>\n          </li>\n          <li>이 패킷이 fa0/5로 가면서 VLAN 1의 통신으로 취급됨 [VLAN 2 태그가 떨어짐]</li>\n          <li>다른 스위치의 fa0/3에 도착했을 때도 VLAN 1의 통신으로 인식됨</li>\n          <li>결과적으로 원래의 VLAN 2 통신이 의도대로 전달되지 못함.</li>\n        </ul>\n      </li>\n      <li>[즉, <strong>Switch0의 fa0/와 Switch1의 fa0/3이 VLAN 1이기 때문</strong>]</li>\n    </ul>\n  </li>\n</ul>\n\n<p>→ <strong>스위치 간 VLAN 전용 통로가 필요하다!</strong></p>\n\n<h2 id=\"트렁크trunk\">트렁크(Trunk)</h2>\n\n<p>[먼저 PC2가 PC0과 통신이 가능하도록 해결해보자]</p>\n\n<ul>\n  <li>Switch0과 Switch1간에 VLAN 2,3 전용 포트 따로 설정!</li>\n  <li>switch0의 fa0/5, fa0/6을 각각 VLAN 2,3 전용으로 설정</li>\n  <li>switch1의 fa0/3, fa0/4를 각각 VLAN 2,3 전용으로 설정</li>\n  <li>Switch 0 포트의 VLAN 상태</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b3x84T/btsMei0AEyD/DYcMw88NkSnY9eQ8B22zcK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1154,”originHeight”:64,”style”:”alignCenter”,”width”:699,”height”:39}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch 1 포트의 VLAN 상태</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@URbjM/btsMdIyMTr2/uZ7hOtRQPSYbugPuyZe3s1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1064,”originHeight”:74,”style”:”alignCenter”,”width”:731,”height”:51}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC2에서 PC0로 통신이 가능하다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@AcI9Y/btsMeveoKpG/MRkQDsbDHXP76MV9pLzZR0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:956,”originHeight”:432,”style”:”alignCenter”,”width”:727,”height”:329}_#][#_Image</td>\n      <td>kage@cav9Br/btsMdpMVs7n/kO9tRv5kLVsRKP9bNXqDuK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:714,”originHeight”:510,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>그런데 또 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>🤔 과연 VLAN 별 통신 라인 추가가 바람직한 해결인가?\n    <ul>\n      <li>만약 VLAN이 수백개라면..?</li>\n      <li>일일이 연결해줄 수 없다</li>\n      <li>또한 추가 가능한 VLAN ID는 1000개.\n        <ul>\n          <li>→ <strong>Trunk</strong> 가 해결책</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"트렁크란\">트렁크란?</h2>\n\n<ul>\n  <li><strong>트렁크는 모든 VLAN 패킷을 하나의 포트로 통과시키는 것</strong></li>\n  <li>스위치 간 프레임 전달에 하나의 물리적 연결(포트)를 공유하는 것.</li>\n  <li>VLAN 트렁킹된 스위치들 간에 여러 VLAN에서 나온 프레임들을 이 트렁크를 통해 전달한다.</li>\n  <li>즉, 스위치와 스위치 간 프레임 전달 시 하나의 포트에 다수의 VLAN이 지나갈 수 있도록하는 링크.</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Switch(config)#interface fa0/5\nSwitch(config-if)#switchport mode trunk\n\nSwitch(config-if)#\n%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to down\n\n%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to up\nexit\nSwitch(config)#exit\nSwitch#\n%SYS-5-CONFIG_I: Configured from console by console\nshow interface trunk\nPort        Mode         Encapsulation  Status        Native vlan\nFa0/5       on           802.1q         trunking      1\n\nPort        Vlans allowed on trunk\nFa0/5       1-1005\n\nPort        Vlans allowed and active in management domain\nFa0/5       1,2,3\n\nPort        Vlans in spanning tree forwarding state and not pruned\nFa0/5       none\n</code></pre></div></div>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cj9Kft/btsMcrLrqjC/NZkK8P615yIbq5LWFeBswk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:839,”style”:”alignCenter”,”caption”:”Switch0의 Fa0/5 포트 Trunk 설정”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li>Fa0/5가 트렁크 포트로 on (강제로 트렁크 모드로 설정) 되었다.</li>\n  <li>1~1005는 이론적으로 모든 VLAN 범위가 통과 가능하다.</li>\n  <li>실제 현재 사용 중인 VLAN : 1, 2, 3이 현재 활성화되어 있다.</li>\n  <li>Vlans in spanning tree forwarding state and not pruned : None<br />\n(활성화된 VLAN들이 여기 나타나야 한다. - 없다.)</li>\n</ol>\n\n<ul>\n  <li>Fa0/5 포트는 Native VLAN이 1로 설정됨</li>\n  <li>반대편 Fa0/3 포트는 Native VLAN이 2로 설정됨\n    <ul>\n      <li>Switch1의 Fa0/3 포트도 Trunk로 설정해준다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@kzW3S/btsMec7cVIK/IBXxcLCh7BYeCYd9J2nScK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1136,”originHeight”:414,”style”:”alignCenter”,”width”:654,”height”:238}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>물론 PC2에서 PC0로 통신이 가능해졌다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bryfWp/btsMcPE65aP/UGX9KHYfm1QMvME24buAtk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:956,”originHeight”:428,”style”:”alignCenter”,”width”:706,”height”:316}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"inter-vlan\">Inter-VLAN</h2>\n\n<ul>\n  <li>놓치면 안되는 것의 “<strong>기술의 도입에 대한 목적</strong>”이다.\n    <ul>\n      <li>VLAN의 목적은 가상의 LAN으로서 관리의 편리성 추구이며,<br />\n다른 VLAN과의 통신 제한이 아니다.</li>\n    </ul>\n  </li>\n  <li>그럼, 서로 다른 VLAN 간의 통신이 가능하도록 하는 방법은 없을까?</li>\n  <li>VLAN 간 통신을 하려면 라우터(게이트웨이)가 있어야 한다.\n    <ul>\n      <li>라우터를 경유하여 마치 다른 LAN으로 통신하는 것처럼 동작한다.</li>\n    </ul>\n  </li>\n  <li>[다른 네트워크 영역은 라우터가 필요!!!]</li>\n</ul>\n\n<h2 id=\"서브-인터페이스\">서브 인터페이스</h2>\n\n<ul>\n  <li>단순히 생각하면 이런 생각이 든다.</li>\n  <li>전통적인 라우터 방식: 각 VLAN마다 라우터의 물리적 인터페이스를 하나씩 사용</li>\n  <li>그러나 이런 생각의 전환을 해본다.\n    <ul>\n      <li><strong>하나의 물리적 라우터 인터페이스에 여러 개의 논리적 인터페이스를 생성하여 각각 다른 VLAN을 처리할 수 있도록 할 수 있다면?</strong></li>\n      <li>그런데, Fa0/0이라는 물리적 라우터 인터페이스에 어떻게 여러 개의 논리적 인터페이스를 생성할까?</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@Y1VKx/btsMeSUECM4/0Qz0wbAb4G4UBmT0SLhXYk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:260,”originHeight”:298,”style”:”alignCenter”,”width”:167,”height”:191}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>서브 인터페이스: 하나의 인터페이스에 여러 VLAN들의 인터페이스를 논리적으로 나누는 것</li>\n  <li>2811 모델을 추가해준다!\n    <ul>\n      <li>참고 :</li>\n      <li><em>2811 라우터는 Cisco의 중급 라우터로, Inter-VLAN 라우팅을 위한 서브인터페이스 구성을 지원합니다. 서브인터페이스란 하나의 물리적 인터페이스를 여러 개의 논리적 인터페이스로 나누어 사용할 수 있게 해주는 기능입니다. 이는 마치 하나의 도로를 여러 개의 차선으로 나누어 서로 다른 목적지로 가는 차들을 효율적으로 처리하는 것과 비슷합니다.</em></li>\n    </ul>\n  </li>\n</ul>\n\n<p>1. fa0/0 활성화</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dysMoj/btsMcdzWje7/FkpECQDsjzhv7gtsA3SGI1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:846,”originHeight”:200,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>2. fa0/0.2 생성, VLAN2 연결, IP주소 할당 &amp; fa0/0.3 생성, VLAN3 연결, IP주소 할당</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b2QZaS/btsMb1M28tD/PwRCtfFGc9U9WdizCjU6pk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:691,”style”:”alignCenter”,”width”:790,”height”:426}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>3. switch1 fa0/4를 트렁크 모드로 설정</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bGoCk8/btsMdHT860Z/dwqr98u0ihaJDerscGQ7j1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1248,”originHeight”:546,”style”:”alignCenter”,”width”:718,”height”:314}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>4. Router의 서브 인터페이스 상태 확인</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bnyTgA/btsMevrWYog/pDkKHGHiWCNLKzR85a7Qn1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:219,”style”:”alignCenter”,”width”:819,”height”:140}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>5. 게이트웨이 설정</p>\n\n<p>- VLAN 2 (PC0, 1, 2) → 203.237.20.254</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bjr2GX/btsMey9WnrP/zNHfPdHwYlhyUSeIwsz6n0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:384,”style”:”alignCenter”,”width”:767,”height”:230}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>- VLAN 3 (Laptop0, 1, 2) → 203.237.30.254</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@9Pp8f/btsMcxY6pxv/toN6xYeoWLuqsvp1xIlJ90/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:606,”style”:”alignCenter”,”width”:773,”height”:366}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h1 id=\"스위치\">스위치</h1>\n\n<hr />\n\n<h2 id=\"스위치의-동작-원리\">스위치의 동작 원리</h2>\n\n<h2 id=\"mac-주소-테이블-동작-원리\">MAC 주소 테이블 동작 원리</h2>\n\n<ul>\n  <li>스위치와 노드들이 <strong>ARP</strong>를 통해 MAC 주소 정보를 지속적으로 교환한다.\n    <ul>\n      <li>ARP 프로토콜에 포함된 MAC 주소 정보를 기반으로 스위치의 MAC 주소 테이블이 구축된다.</li>\n      <li>실제 데이터 전송 (ping 등)이 발생하면, 이 MAC 주소 테이블을 참조하여 패킷을 적절한 포트로 전달</li>\n    </ul>\n  </li>\n  <li>MAC 주소 테이블은 네트워크 토폴리지 변화를 반영하기 위해 일정 주기로 초기화되며, 최신 정보로 동적 갱신된다.</li>\n</ul>\n\n<h2 id=\"arp란\">ARP란?</h2>\n\n<ul>\n  <li>IP 네트워크에서 IP 주소를 물리적인 MAC 주소로 변환하는 핵심 프로토콜</li>\n  <li>컴퓨터가 같은 네트워크 상의 다른 장치와 통신하려면 반드시 상대방의 MAC 주소를 알아야 하는데,<br />\nARP가 이 주소 변환 과정을 자동으로 처리해준다.</li>\n</ul>\n\n<h2 id=\"arp를-활용한-동작-원리\">ARP를 활용한 동작 원리</h2>\n\n<p><em>PC0에서 Laptop0으로 ping을 보낸다고 가정</em></p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cDoPQ4/btsMdLhTSuP/NdTWBqnwp8pAXYoKUrWZrK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:988,”originHeight”:436,”style”:”alignCenter”,”width”:742,”height”:327}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ol>\n  <li>ARP Request (PC0 → Switch0)\n    <ul>\n      <li>PC0이 Laptop0의 MAC 주소를 알아내기 위해 ARP 요청 패킷 전송</li>\n      <li>패킷 내용:\n        <ul>\n          <li>출발지: PC0의 IP 주소와 MAC 주소</li>\n          <li>목적지: Laptop0의 IP 주소 (MAC 주소는 미확인 상태)</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>스위치 <strong>브로드캐스트</strong> (Switch0 → 모든 노드)\n    <ul>\n      <li>Switch0은 PC0의 <strong>MAC 주소를 자신의 테이블에 기록</strong></li>\n      <li>수신한 ARP 요청 패킷을 모든 포트로 브로드캐스트</li>\n    </ul>\n  </li>\n  <li>ARP reply (Laptop0 → Switch0)\n    <ul>\n      <li>Laptop0이 자신의 IP 주소를 확인하고 ARP 응답 패킷 생성</li>\n      <li>패킷 내용:\n        <ul>\n          <li>출발지: Laptop0의 IP 주소와 MAC 주소</li>\n          <li>목적지: PC0의 IP 주소와 MAC 주소</li>\n        </ul>\n      </li>\n      <li>Laptop0은 PC0의 MAC 주소를 자신의 ARP 캐시에 저장</li>\n    </ul>\n  </li>\n  <li>스위치 전달 단계 (Switch0 → PC0)\n    <ul>\n      <li>Switch0은 수신한 응답 패킷을 PC0에게 전달</li>\n      <li>PC0과 Laptop0의 MAC 주소 정보를 MAC 주소 테이블에 저장</li>\n    </ul>\n  </li>\n  <li>통신 시작\n    <ul>\n      <li>PC0이 Laptop0의 MAC 주소를 획득하여 실제 데이터 통신 가능</li>\n    </ul>\n  </li>\n</ol>\n\n<h2 id=\"시뮬레이션\">시뮬레이션</h2>\n\n<ul>\n  <li>시뮬레이션을 눌러서 이벤트 목록창을 볼 수 있다.</li>\n  <li>편지봉투 모양의 [Add Simple PDU] → ICMP 패킷 전송 시뮬레이션</li>\n  <li>송신노드와 수신 노드를 클릭하고 Show All/None 클릭 후 ARP, ICMP 패킷만 클릭한다.</li>\n  <li><em>PC0에서 Laptop0으로 편지를 보낸다.</em></li>\n  <li>ARP - ICMP 순으로 통신이 이루어진다.</li>\n</ul>\n\n<h2 id=\"1-arp-패킷-분석\">1) ARP 패킷 분석</h2>\n\n<p>1. PC0 → Switch0 ARP Request</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cwVj4Z/btsMcHN0AZ1/QtiRKPTAkw5cwMHngIJq5K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:900,”originHeight”:1158,”style”:”alignCenter”,”width”:522,”height”:672}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>ARP\n    <ul>\n      <li>Source MAC<br />\n= PC0 의 MAC 주소</li>\n      <li>Source IP<br />\n= PC0의 IP 주소</li>\n      <li>Target MAC<br />\n= Laptop 의 MAC 주소 [모르는 주소]</li>\n      <li>Target IP<br />\n= Laptop0의 IP주소</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2. Switch0 → 모든 노드 (브로드캐스트)</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dvlpX3/btsMdr43c4X/YNHxFWmjmqgayudoXkG1l0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:818,”originHeight”:124,”style”:”alignCenter”,”width”:594,”height”:90}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Switch0은 수신한 ARP Request를 모든 포트로 전달</li>\n  <li>Switch0의 MAC 주소 테이블에 PC0의 정보 기록\n    <ul>\n      <li>포트 번호와 PC0의 MAC 주소 매핑</li>\n    </ul>\n  </li>\n</ul>\n\n<p>3. Laptop0→ Switch0 ARP Reply</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@K4KvV/btsMcdUawiw/VpUysCPR5W9T4yYTKTcqJK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1002,”originHeight”:1242,”style”:”alignCenter”,”width”:627,”height”:777}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>ARP\n    <ul>\n      <li>Source MAC<br />\n= Laptop0 의 MAC 주소</li>\n      <li>Source IP<br />\n= Laptop0의 IP 주소</li>\n      <li>Target MAC<br />\n= PC0 의 MAC 주소</li>\n      <li>Target IP<br />\n= Laptop0의 IP주소</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"2-icmp-패킷-분석\">2. ICMP 패킷 분석</h2>\n\n<ol>\n  <li>PC → Laptop</li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@6AWAV/btsMdMA4Jmh/dd2ilCfmHRbqRt9DFVNWhK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2056,”originHeight”:1186,”style”:”alignCenter”,”width”:690,”height”:398}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>SRC ADDR = PC0의 MAC 주소</li>\n  <li>DEST ADDR = Laptop0의 MAC 주소</li>\n</ul>\n\n<h2 id=\"3-switch0의-mac-주소-테이블-변화\">3) Switch0의 MAC 주소 테이블 변화</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dEbxME/btsMdnn7IXG/koFfWfejqCW9bxxbzaYPb0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1080,”originHeight”:611,”style”:”alignCenter”,”width”:747,”height”:423}_#][#_Image</td>\n      <td>kage@WjEAg/btsMdmbIixx/in3AqgZZ7OkLwPpGkcb270/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1080,”originHeight”:734,”style”:”alignCenter”,”width”:727,”height”:494}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>위를 보니 Fa0/1 Fa0/4에 연결된 PC0과 Laptop0의 MAC 주소가 테이블에 기재되었다.</li>\n</ul>\n\n<p>🤔 갑자기 이런 궁금증이 든다.</p>\n\n<ul>\n  <li>Switch0 → 모든 노드로 BroadCast할 때 각자의 MAC 주소 받아오면 되는거 아닌가?</li>\n  <li>해답은 ARP를 이용해 MAC 주소 테이블이 어떻게 유지하는지의 방법에 있다.\n    <ul>\n      <li>스위치의 MAC 주소 학습은 ‘출발지(Source) MAC 주소’만을 대상으로 한다.\n        <ul>\n          <li>PC0이 ARP Request를 보낼 때</li>\n          <li>Laptop0이 ARP Reply를 보낼 때</li>\n        </ul>\n      </li>\n      <li>모든 노드로 전달된 ARP-Request 패킷에 대해 수신 노드가 아니면 응답하지 않는다.</li>\n      <li>PC1과 Laptop1은 Swtich0이 전달한 ARP-Request에 대해 Reply 하지 않는다.</li>\n    </ul>\n  </li>\n</ul>\n\n<p>그런데 이런 ‘고민’도 떠오른다.</p>\n\n<p>1.효율성</p>\n\n<ul>\n  <li>ARP는 매우 짧은 시간 간격으로 반복 실행한다.\n    <ul>\n      <li>노드들이 많은 네트워크에서는 통신량으로 부하 가중</li>\n      <li>특히 스위치가 모든 노드에게 BroadCast하는 ARP-Request에서</li>\n    </ul>\n  </li>\n</ul>\n\n<p>2. 보안상의 문제</p>\n\n<ul>\n  <li>Laptop1이 악의적인 공격자라고 가정해보자.\n    <ul>\n      <li>ARP Reply가 실제로 해당 IP 주소를 가진 정당한 장치에서 온 것인지 확인하지 않는다. (보안 X)</li>\n      <li>이 때 Laptop0의 IP에 Laptop1 MAC 주소를 실어서 Reply한다면?</li>\n      <li>테이블이 제대로 갱신되기 전까지 PC0은 Laptop0인 줄 알고 모든 패킷을 보낸다.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"vlan을-통한-해결\">VLAN을 통한 해결</h2>\n\n<ul>\n  <li>MAC 주소를 이용한 라우팅\n    <ul>\n      <li>동일한 네트워크(LAN)에서 스위치를 통해서만 발생한다.</li>\n      <li>라우터를 통한 외부 네트워크로의 통신에는 사용되지 않는다.\n        <ul>\n          <li>ARP 패킷은 하나의 네트워크에서만 송수신한다.</li>\n          <li>LAN을 논리적으로 분리된 가상의 VLAN으로 관리한다.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h1 id=\"라우터\">라우터</h1>\n\n<hr />\n\n<h2 id=\"라우터란\">라우터란?</h2>\n\n<ul>\n  <li>라우터는 서로 다른 네트워크를 연결하는 3계층 장비.</li>\n  <li>IP 주소를 기반으로 패킷의 최적 경로를 결정하고 전달한다.\n    <ul>\n      <li>스위치가 같은 네트워크 내에서 MAC 주소를 기반으로 통신을 담당한다면,</li>\n      <li>라우터는 서로 다른 네트워크 간의 통신을 가능하게 만드는 일종의 ‘네트워크 간의 다리’ 역할을 한다.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"라우터의-mode\">라우터의 Mode</h2>\n\n<ul>\n  <li><strong>사용자 모드(User EXEC Mode)</strong>\n    <ul>\n      <li>기본적인 정보 조회만 가능, 설정 변경 불가</li>\n      <li>&gt; 로 표시</li>\n    </ul>\n  </li>\n  <li><strong>관리자 모드(Privileged EXEC Mode)</strong>\n    <ul>\n      <li>라우터 설정을 변경할 순 없지만 시스템 정보 상세조회 가능</li>\n      <li># 으로 표시</li>\n    </ul>\n  </li>\n  <li><strong>글로벌 모드(Global Configuration Mode)</strong>\n    <ul>\n      <li>라우터 설정(이름, 보안, 인터페이스 등)을 변경</li>\n      <li>(config)# 로 표시</li>\n      <li><strong>라인 모드(Line Configuration Mode)</strong>\n        <ul>\n          <li>콘솔, 원격 접속(Telnet, SSH 등) 관련 설정 변경</li>\n          <li>(config-line)# 로 표시</li>\n        </ul>\n      </li>\n      <li><strong>인터페이스 모드(Interface Configuration Mode)</strong>\n        <ul>\n          <li>라우터의 네트워크 인터페이스(이더넷, 시리얼 등) 설정을 변경</li>\n          <li>라우터의 인터페이스에 IP 주소를 설정하고 활성화/비활성화</li>\n          <li>(config-if)# 로 표시</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"목표-네트워크-구성\">목표 네트워크 구성</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@FrASQ/btsMeLVCXVC/1wKsZjYPW9BikRxL7DFtC1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:813,”originHeight”:495,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"기본-설정\">기본 설정</h2>\n\n<ul>\n  <li>라우터 3대: [Network Devices] → [Routers] → [2811]</li>\n  <li>스위치 1대 : [Network Devices] → [Switches] → [2960]</li>\n  <li>PC 3대, 노트북 1대, 서버 1대 : [End Devices] → [PC], [Laptop], [Server]</li>\n</ul>\n\n<h2 id=\"라우터---시리얼-인터페이스-장착\">라우터 - 시리얼 인터페이스 장착</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@zgPDU/btsMd3bDPMR/E6TXH94lrMz3OrUR6TF5hK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:1293,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC와 달리 두 라우터 간에 데이터를 주고받기 위한 동기화가 필요</li>\n  <li>FastEthernet이 아닌 Serial 인터페이스를 사용하므로 모듈을 추가해야 한다.\n    <ul>\n      <li>HWIC-2T 추가</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"노드-간-연결하기\">노드 간 연결하기</h2>\n\n<ul>\n  <li>Laptop0은 통신용이 아니라 Router0을 설정하기 위한 콘솔\n    <ul>\n      <li>FastEthernet 케이블이 아닌 RS232(하늘색) 케이블로 연결</li>\n    </ul>\n  </li>\n  <li>라우더들끼리 Serial DCE 연결\n    <ul>\n      <li>먼저 클릭한 쪽에 시계 모양 - 두 라우터 간 데이터를 주고받기 위한 동기화가 필요</li>\n      <li>Serial DCE(Data Communication Equipment): 시간 동기화를 주도하는 노드 (시계 있는 쪽)</li>\n      <li>Serial DTE(Data Terminal Equipment): 그에 따라 동기화하는 노드 (시계 없는 쪽)</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@evpmpX/btsMdMnzPql/PLX7aieEhAKMJ6N99C2j5K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2184,”originHeight”:1246,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"ip-설정\">IP 설정</h2>\n\n<ul>\n  <li>컴퓨터들은 203.237.nnn.nnn/24 사용(C클래스)\n    <ul>\n      <li>1번부터 시작</li>\n    </ul>\n  </li>\n  <li>원격 관리가 필요한 스위치나 서버는 100번 부터</li>\n  <li>라우터는 광역의 랜들을 연결하므로 A클래스 IP 사용\n    <ul>\n      <li>규모가 작아 30비트 서브넷 마스크를 사용하여 최대 4개의 라우터를 묶을 수 있도록</li>\n    </ul>\n  </li>\n  <li>스위치는 2계층 장비\n    <ul>\n      <li>IP 주소 설정 불필요</li>\n      <li>원격 접속으로 스위치 관리\n        <ul>\n          <li>IP 주소 할당 필요</li>\n          <li>VLAN1에 할당</li>\n        </ul>\n      </li>\n      <li>스위치 IP 주소 설정</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bk8xpK/btsMd7Sxxul/dQMOVhudaYmzsa519EoeQK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1374,”originHeight”:164,”style”:”alignCenter”,”width”:635,”height”:76}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>총 6개의 LAN</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@UGTSj/btsMcKRyRRh/QFOQKnpr0nm0a6K8eUWWKk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1762,”originHeight”:1000,”style”:”alignCenter”,”width”:698,”height”:396}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"연결-확인\">연결 확인</h2>\n\n<ul>\n  <li>PC0에서 테스트</li>\n</ul>\n\n<ol>\n  <li>PC0 로컬 호스트(127.0.0.1)</li>\n  <li>PC0 → Switch1(VLAN1, 203.237.10.100)</li>\n  <li>PC0 → Server0(203.237.10.101)</li>\n  <li>PC0 → Router0(203.237.10.254)\n    <ul>\n      <li>모두 통신 성공</li>\n    </ul>\n  </li>\n</ol>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@s9v2J/btsMcYPw7T1/QedNlAylJ9wAnApW81hp3K/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1000,”originHeight”:1605,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>5. PC0 → PC2(203.237.30.1)</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@mi021/btsMdHGFlHG/cChGsiN9Pw0rWY0kG0w7q1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:996,”originHeight”:374,”style”:”alignCenter”,”width”:684,”height”:257}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li><strong>unreachable</strong> 이 발생한다\n    <ul>\n      <li>PC0으로 부터 받은 패킷을 Router0이 어느 인터페이스로 보내야할지 모르기 때문</li>\n      <li>→ <strong>라우팅 테이블</strong>이 필요하다</li>\n      <li>아래는 Router0의 라우팅 정보</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@beagrf/btsMdMujNSG/uzGad36EzxcCPqRZ3PJy21/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1260,”originHeight”:698,”style”:”alignCenter”,”width”:746,”height”:413}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"정적-라우팅-설정\">정적 라우팅 설정</h2>\n\n<ul>\n  <li>정적 라우팅 대상\n    <ul>\n      <li>1번 PC0 입장에서 목적지가\n        <ul>\n          <li><strong>2번</strong> 네트워크(203.237.20.nnn/24)인 패킷 : serial0/3/0 (혹은 1.1.1.2)</li>\n          <li><strong>3번</strong> 네트워크(203.237.30.nnn/24)인 패킷 : serial0/3/1 (혹은 2.2.2.2)</li>\n          <li>6번 네트워크(3.3.3.nnn/30)인 패킷 : serial0/3/0 혹은 serial0/3/1</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>Router1의 정적 라우팅 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@JLnX1/btsMckFDkMJ/ik8vROKAHLaZQPxINyMSmK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1226,”originHeight”:442,”style”:”alignCenter”,”width”:694,”height”:250}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Router2의 정적 라우팅 설정</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@k4yPj/btsMexiTcvl/Ewo59hWdxO2tOqMp9GTtNK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1248,”originHeight”:504,”style”:”alignCenter”,”width”:736,”height”:297}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>Router3의 정적 라우팅 설정 + route 확인</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cnu0SN/btsMdH0043d/jjkekr1KEkmqtXM0E7LRUK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1270,”originHeight”:1186,”style”:”alignCenter”,”width”:756,”height”:706}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"통신테스트-by-ping\">통신테스트 by ping</h2>\n\n<ul>\n  <li>PC0 ↔ PC1</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@dD0uXu/btsMb0Hnvj9/50DKkNchVlTaBfBiYNEMiK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:962,”originHeight”:422,”style”:”alignCenter”,”width”:730,”height”:320}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>PC0 ↔ PC2</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cEoaLU/btsMdGgIz36/93lJ36D1HjrKK9gQaOKvb1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:964,”originHeight”:432,”style”:”alignCenter”,”width”:780,”height”:350}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h1 id=\"방화벽---네트워크-구성\">방화벽 - 네트워크 구성</h1>\n\n<hr />\n\n<h2 id=\"망구성\">망구성</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@kO9qL/btsMengxOIb/FFIVXRjKkeW6JnSOKHGXqk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1280,”originHeight”:524,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"asa0-구성-설정\">ASA0 구성 설정</h2>\n\n<p>1. 인터페이스 통신 상태</p>\n\n<ul>\n  <li>내부망 : 통신 가능</li>\n  <li>외부망 : 통신 불가\n    <ul>\n      <li>inPC → outPC 불가능</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bh2bBN/btsMd7rqkl0/g4AYl1hwkqpXZ1NDwCwO30/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1278,”originHeight”:266,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>2. IP 주소 설정</p>\n\n<ul>\n  <li>Inside : 설정됨</li>\n  <li>outside : 설정되어있지 않음\n    <ul>\n      <li>→ VLAN에서 203.237.20.253으로 설정</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@cormPm/btsMc1r1E8A/LKXIkkQ8YcBwbHGgFGWQIk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1406,”originHeight”:342,”style”:”alignCenter”,”width”:807,”height”:196}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>3. Config 확인</p>\n\n<ul>\n  <li>내부망 Security-level : 100</li>\n  <li>외부망 Security-level : 0</li>\n  <li>보안 레벨이 높은 곳 → 낮은 곳 : 허용 (반대는 불가능)</li>\n  <li>내부망 노드들은 DHCP를 이용하여 IP 할당받는다.</li>\n</ul>\n\n<h2 id=\"inpc-dhcp-설정\">inPC DHCP 설정</h2>\n\n<ul>\n  <li>inPC는 ASA가 DHCP로 주소를 할당해준다고 했다.\n    <ul>\n      <li>게이트웨이는 ASA0 inside의 ip 주소로 고정된다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@HAypL/btsMemIHLU2/tcja6hVK1aurUDoEGiKLAK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1388,”originHeight”:636,”style”:”alignCenter”,”width”:703,”height”:322}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>outPC는 고정 주소 사용 중</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@lNS8u/btsMdHzVPu4/iHvbzNmifAq1gElLiDlpW1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1304,”originHeight”:546,”style”:”alignCenter”,”width”:707,”height”:296}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"router0-설정\">Router0 설정</h2>\n\n<ul>\n  <li>fa0/0 IP 설정 &amp; 활성화\n    <ul>\n      <li>203.237.10.254/24</li>\n    </ul>\n  </li>\n  <li>fa0/0 IP 설정 &amp; 활성화\n    <ul>\n      <li>203.237.20.253/24</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"rna-설정\">RNA 설정</h2>\n\n<h2 id=\"routing\">Routing</h2>\n\n<ul>\n  <li>라우터의 정적라우팅\n    <ul>\n      <li>네트워크 디바이스들이 서로 다른 네트워크에 있을 때, 그들 사이의 통신 경로를 명확히 지정해줘야 한다.</li>\n      <li>예를 들어, 내부 네트워크의 PC가 다른 네트워크의 서버와 통신하려면, 그 경로를 알아야 한다.</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">ip route &lt;목적지 네트워크 주소&gt; &lt;목적지 서브넷 마스크&gt; &lt;다음 홉 IP 주소/출구 인터페이스&gt;</code></li>\n    </ul>\n  </li>\n  <li>방화벽의 정적라우팅\n    <ul>\n      <li>트래픽이 반드시 방화벽을 통과하도록 하여 보안 정책을 적용할 수 있게 한다.</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">route &lt;VLAN명&gt; &lt;외부망 네트워크 주소&gt; &lt;외부망 서브넷마스크&gt; &lt;다음 홉 IP 주소&gt;</code></li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@UMo4w/btsMemPruKw/su6TBN30w2NLPGdTiu8nN0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2110,”originHeight”:1000,”style”:”alignCenter”,”width”:734,”height”:348}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>→ 어떤 목적지 주소를 갖는 패킷이든 외부망의 Router0인 203.207.20.254로 전송한다.</p>\n\n<ul>\n  <li>통신확인</li>\n  <li>inPC ↔ ASA0</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@ea7sUx/btsMcHURKDV/D3ikyzQhpSkEa8QCBP2sK1/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:972,”originHeight”:428,”style”:”alignCenter”,”width”:708,”height”:312}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>inPC ↔ outPC</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@b7mUIE/btsMcfqYrdM/SvtR3wkJNdKRzXgHMUMtIK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:986,”originHeight”:368,”style”:”alignCenter”,”width”:702,”height”:262}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"nat\">NAT</h2>\n\n<ul>\n  <li>inPC → outPC 까지는 패킷 전달이 잘 되지만,</li>\n  <li>Router0 → ASA0으로 전달이 되지 않는다.</li>\n</ul>\n\n<p><strong>outPC → Router1로 전달되는 패킷</strong></p>\n\n<ul>\n  <li>outPC(203.237.10.10)가 inPC(192.168.1.5)로 통신을 시도할 때, Router는 문제에 직면한다.\n    <ul>\n      <li>목적지 주소가 사설IP이기 때문에 외부에서 인식이 불가능하다.</li>\n      <li>→ Rotuer 입장에서 어디로 보내야 할 지 모른다.\n        <ul>\n          <li>(마치 동 호수만 알고, 택배 기사가 서울에서 배달을 하려는 상황과 마찬가지)</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@xD2B6/btsMeR9g8xQ/eG7q1kOXNaBGJdcSFREQoK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:2080,”originHeight”:1270,”style”:”alignCenter”,”width”:783,”height”:478}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>⇒ ASA가 사설 IP를 공인 IP로 변경해서 보내줘야 한다.</li>\n  <li>ASA의 <strong>NAT</strong></li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@tUl9o/btsMeRVJT2O/PJFvZxKK7bVxaO8Vexhkt0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:414,”originHeight”:143,”style”:”alignCenter”}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>들어오는 패킷의 처리\n    <ul>\n      <li>외부 노드들은 내부 네트워크의 실제 사설 IP를 알 필요가 없다.\n        <ul>\n          <li>대신 ASA의 공인 IP 주소로 통신을 시도</li>\n        </ul>\n      </li>\n      <li>ASA는 NAT 테이블을 유지하면서, 어떤 외부 통신이 어떤 내부 노드를 위한 것인지 추적</li>\n      <li>수신된 패킷의 목적지 주소를 적절한 내부 사설 IP로 변환하여 전달</li>\n    </ul>\n  </li>\n  <li>나가는 패킷의 처리\n    <ul>\n      <li>내부 노드가 외부로 통신을 시도할 때, ASA는 출발지의 사설 IP를 자신의 공인 IP로 변환</li>\n      <li>이 과정에서 ASA는 어떤 내부 노드가 어떤 통신을 시작했는지 NAT 테이블에 기록</li>\n      <li>나중에 응답이 돌아오면, 이 테이블을 참조하여 올바른 내부 노드에게 전달</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"nat-설정\">NAT 설정</h2>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@czZH5n/btsMc0fu60D/gU0ev4kVhViqehGSDDt6K0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1220,”originHeight”:196,”style”:”alignCenter”,”width”:742,”height”:119}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>in2out 객체 생성 (네트워크 객체 모드)</li>\n  <li>대상 서브넷을 지정해준다.</li>\n  <li>NAT 지정\n    <ul>\n      <li>내외부망을 연결하는 (inside, outside)를 동적 매핑</li>\n      <li>공인 Ip 주소는 인터페이스에 할당된 IP 주소를 사용한다.</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@ccZXOd/btsMcjzZe4x/9s6nimQ80LBoH1dkmToAWK/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:942,”originHeight”:138,”style”:”alignCenter”,”width”:676,”height”:99}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>그래도 inPC → outPC의 통신이 실패하게 된다.</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bajXRR/btsMcZgFpCY/BFAnMrFdvAP1aAJVnNh9z0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:600,”originHeight”:157,”style”:”alignCenter”,”width”:524,”height”:137}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"acl\">ACL</h2>\n\n<ul>\n  <li>패킷을 보면 목적지 주소는 공인 IP 주소로 정확히 설정되어 있으나,</li>\n  <li>외부망에서 내부망으로 들어오는 트래픽의 흐름을 방화벽이 모두 Block하고 있기 때문</li>\n  <li><strong>즉, 인터페이스마다 어떤 출발지 &amp; 어떤 목적지 를 가지는 트래픽을 허용 / 거부 할 것인지 정의해줘야 한다.</strong></li>\n  <li>→ ACL : 이러한 Allow/Deny 접근 제어 목록</li>\n</ul>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>access-list &lt;ACL명&gt; &lt;타입&gt; &lt;동작&gt; &lt;프로토콜&gt; &lt;출발지&gt; &lt;목적지&gt;\naccess-group &lt;ACL명&gt; &lt;트래픽&gt; &lt;인터페이스 키워드&gt; &lt;VLAN 명&gt;\n</code></pre></div></div>\n\n<ul>\n  <li>ACL 설정\n    <ul>\n      <li>모든 출발지에서 모든 목적지로 가는 ICMP(ping) 트래픽을 허용하는 규칙을 만든다.</li>\n      <li>만든 규칙을 외부 인터페이스의 인바운드 방향에 적용</li>\n    </ul>\n  </li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@eklCj3/btsMeUZeeor/0St67walf4cyejJZvVb2N0/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:1224,”originHeight”:300,”style”:”alignCenter”,”width”:767,”height”:188}_#]</td>\n    </tr>\n  </tbody>\n</table>\n\n<ul>\n  <li>inPC → outPC Ping 확인</li>\n</ul>\n\n<table>\n  <tbody>\n    <tr>\n      <td>[#_Image</td>\n      <td>kage@bMTQzA/btsMeyozeji/a8vxJ4pw0kExxZ6GUmDnRk/img.png</td>\n      <td>CDM</td>\n      <td>1.3</td>\n      <td>{“originWidth”:962,”originHeight”:434,”style”:”alignCenter”,”width”:749,”height”:338}_#]</td>\n    </tr>\n  </tbody>\n</table>\n",
                        "tags": ["Network","PacketTracer","LAN","Switch","Router","Firewall","VLAN","Topology"]
                    }
                
            ]
        
    };

    const posts = postsData[decodeURIComponent(tag)] || [];
    const postList = document.getElementById('post-list');
    
    if (posts.length > 0) {
        const postElements = posts.map(post => `
            <div class="post-item">
                <article class="post-preview">
                    <a href="${post.url}">
                        <h2 class="post-title">${post.title}</h2>
                        ${post.subtitle ? 
                            `<h3 class="post-subtitle">${post.subtitle}</h3>` :
                            `<h3 class="post-subtitle">${post.excerpt}</h3>`
                        }
                    </a>
                    <p class="post-meta">Posted by
                        ${post.author}
                        on
                        ${post.date} &middot; ${calculateReadTime(post.content)}
                    </p>
                    ${post.tags && post.tags.length > 0 ? `
                        <ul class="post-tags">
                            <li class="tags-label">Tags:</li>
                            ${post.tags.map(t => `
                                <a href="/tag/?tag=${encodeURIComponent(t)}" class="tag">${t}</a>
                            `).join(' ')}
                        </ul>
                    ` : ''}
                </article>

                ${post.background ? `
                    <div class="post-thumbnail">
                        <a href="${post.url}">
                            <img src="${post.background}" alt="Post Thumbnail" />
                        </a>
                    </div>
                ` : ''}
            </div>
            <hr>
        `).join('');
        
        postList.innerHTML = postElements;
    } else {
        postList.innerHTML = '<p>No posts found with this tag.</p>';
    }
}

function calculateReadTime(content) {
    const wordsPerMinute = 200;
    const wordCount = content.trim().split(/\s+/).length;
    const readTime = Math.ceil(wordCount / wordsPerMinute);
    return `${readTime} min read`;
}
</script>

  <!-- Footer -->

<hr>

<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        <ul class="list-inline text-center">
          
          <li class="list-inline-item">
            <a href="mailto:jh7524jh7524@gmail.com">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="far fa-envelope fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
          
          
          
          
          <li class="list-inline-item">
            <a href="https://github.com/jinho7">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
          
        </ul>
        <p class="copyright text-muted">Copyright &copy; Jinho 2025</p>
      </div>
    </div>
  </div>
</footer>


  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js"></script>
<script src="/assets/vendor/startbootstrap-clean-blog/js/scripts.js"></script>
<script src="/assets/vendor/startbootstrap-clean-blog/js/code-block.js"></script>
<script src="/assets/scripts.js"></script>






  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXXXX-X"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-XXXXXXXXX-X');
</script>



</body>

</html>
