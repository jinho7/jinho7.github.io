<!DOCTYPE html>
<html>

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>
    Tag Posts - Jinho&#39;s Tech Blog
    
  </title>

  <meta name="description" content="개발에 대한 이야기를 담아내다">

  <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

  <script src="https://use.fontawesome.com/releases/v5.15.3/js/all.js" crossorigin="anonymous"></script>

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/tag/">
  <link rel="alternate" type="application/rss+xml" title="Jinho&#39;s Tech Blog" href="/feed.xml">

</head>


<body>

  <!-- Navigation -->
<nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="/">Jinho&#39;s Tech Blog</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
      Menu
      <i class="fa fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        <li class="nav-item">
          <a class="nav-link" href="/">Home</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/about">About</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/posts">Posts</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/contact">Contact</a>
        </li>
      </ul>
    </div>
  </div>
</nav>


  <!-- Page Header -->

<header class="masthead">

  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        <div class="page-heading">
          <h1 id="tag-title" style="font-size: 50px;"></h1>
        </div>
      </div>
    </div>
  </div>
</header>

<div class="container">
  <div class="row">
    <div class="col-lg-8 col-md-10 mx-auto" id="post-list">
      <!-- 포스트 목록이 여기에 동적으로 추가됨 -->
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const urlParams = new URLSearchParams(window.location.search);
    const tag = urlParams.get('tag');
    
    if (tag) {
        document.getElementById('tag-title').textContent = `Posts tagged with "${decodeURIComponent(tag)}"`;
        showTagPosts(tag);
    } else {
        window.location.href = '/tags/';
    }
});

function showTagPosts(tag) {
    const postsData = {
        
            "Java": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    },
                
                    {
                        "title": "동기/비동기와 블로킹/논블로킹에 대해 깊이 파헤치기",
                        "url": "/2025/01/12/understanding-sync-async-blocking-non-blocking.html",
                        "subtitle": "Java/SpringBoot에서의 비동기 처리",
                        "excerpt": "1. 개념적 이해\n",
                        "author": "Jinho",
                        "date": "January 12, 2025",
                        "background": "/img/posts/sync-async-concept.jpeg",
                        "content": "<h1 id=\"1-개념적-이해\">1. 개념적 이해</h1>\n\n<p>비동기 처리에 대해 이야기하기 앞서, 과연 “동기”란 어떤 것인지부터 바로 잡고 가려고한다.</p>\n\n<p>왜냐하면 <strong>비(非)동기</strong>란 동기가 아니다라는 의미이기 때문에 동기가 무엇인지부터 정확히 하고 싶었다.</p>\n\n<p>또한 나는 처음에 ‘동기=블로킹, 비동기=논블로킹’이라고 단순하게 이해하고 있었다.</p>\n\n<p>하지만 실제로는 두 개념이 분류 기준이 전혀 다른 독립적인 개념이라는 것을 알게 되었다.</p>\n\n<p>이렇듯 서로 혼동되어 쓰이는 각 명칭은 어떤 의미인지 알아보려고 한다.</p>\n\n<p>이에 대해 자세히 알아보자.</p>\n\n<p><br /></p>\n\n<h1 id=\"2-동기와-비동기\">2. 동기와 비동기</h1>\n\n<p><img src=\"https://velog.velcdn.com/images/jinho7/post/a47f1973-3895-4438-a47f-80dd80245e41/image.png\" alt=\"\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<blockquote>\n  <p>동기와 비동기는 “작업의 처리 방식”을 나타내는 개념이다. <br />\n결론부터 말하자면, 이둘의 주요한 차이점은 “작업 순서 처리 차이”이다.</p>\n</blockquote>\n\n<h2 id=\"2-1-동기-순차적으로-실행\">2-1. 동기: 순차적으로 실행</h2>\n<p>필자는 이전에 동기를 <strong>겹치지 않고 순차적으로 작업을 진행하는 것</strong> 정도로 이해하고 있었다.</p>\n\n<p>영어 사전을 참고해보자.</p>\n\n<blockquote>\n  <p>synchronous\nadjective\nhappening or done at the same time or speed:</p>\n</blockquote>\n\n<p><strong>Synchronous</strong> 는 동시에 발생하는 두 개 이상의 사건이나 프로세스가 동일한 시간에서 진행되는 것을 의미하는 형용사이다.</p>\n\n<p>중요한 워딩은 [동일한 시간에 여러 개의 사건이 진행] 된다는 것이다.</p>\n\n<p>‘순차적’과 ‘동시’라는 단어가 서로 상충된다고 생각할 수 있다.</p>\n\n<p>여기서 오해하면 안되는 것이 이는 <strong>병렬적인 작업방식을 말하는 것이 아니다.</strong></p>\n\n<p>“어떠한 일정 시점에 현재 작업의 Response과 다음 작업의 Request이 함께 진행되는 것”</p>\n\n<p>위의 그림을 참고하면 이해가 쉽다.\n작업 A가 끝나는 시간과 작업 B가 시작하는 시간이 동기화된다고 이해하면 좋을 것 같다.</p>\n\n<p>이는 <strong>작업이 순차적으로 처리되며, 이전 작업이 완료될 때까지는 다음 작업이 시작되지 않음을 나타낸다.</strong></p>\n\n<p>즉, <strong>작업들이 서로 시간적 의존성을 가지고 실행된다</strong>는 뜻이다.</p>\n\n<p>동기 방식은 실행 순서가 보장되며 예측 가능하다는 장점이 있지만, <br />\n앞선 작업이 오래 걸리면 전체 작업이 지연된다는 단점도 있다.</p>\n\n<h2 id=\"2-2-비동기-독립적으로-실행\">2-2. 비동기: 독립적으로 실행</h2>\n<p>그렇다면 비동기 방식은 무엇일까?</p>\n\n<p>반대의 경우를 생각하면 된다.</p>\n\n<p>위의 그림을 참고하면 작업들이 병렬적으로 일어나고 있음을 알 수 있다.</p>\n\n<p>동기와 반대로 <strong>“요청을 보냈을 때 응답 상태와 상관없이 다른 동작을 수행할 수 있다.”</strong>는 점이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/0a188e4a-b35f-41aa-9953-94504330dd9f\" alt=\"다운로드\" width=\"68%\" height=\"50%\" class=\"center\" />\n<em class=\"image-caption\">파일 다운로드가 동기 방식이라면?</em></p>\n\n<p>만약에 파일 다운로드를 동기적으로 처리한다고 해보자.</p>\n\n<p>아마 파일이 다운로드될 때까지 아무런 작업도 수행할 수 없을 것이고,\n파일이 완전히 다운로드된 후에 다음 작업을 진행할 수 있을 것이다. 😅</p>\n\n<p>매우 비효율적인 방식이다…</p>\n\n<p>그러나 비동기적인 방식을 활용한다면, 파일 다운로드 작업을 시작시켜놓고, 다른 작업을 수행할 수 있다.</p>\n\n<p>파일이 다운로드되면 특정 콜백 함수를 호출하여, 다운로드된 파일을 처리하거나 결과를 반환받을 수 있다.</p>\n\n<p>콜백 뿐만이 아니고, 그 결과는 콜백 함수, Promise, 이벤트 등을 통해 전달받을 수 있다.</p>\n\n<p>마치 택배를 주문하고 배송 알림을 받는 것과 비슷하다고 할 수 있다.</p>\n\n<h3 id=\"비동기-동작-방식에-대한-오해\">비동기 동작 방식에 대한 오해</h3>\n<p>많은 개발자들이 <strong>비동기 = 멀티 쓰레드</strong>라고 이해하고 있다.</p>\n\n<p>단순히 생각해보아도, 여러 작업이 동시에 처리되는 비동기 동작을 구현하기 위해서는 당연히 여러 개의 쓰레드가 필요할 것 같기 때문이다.</p>\n\n<p>또한, 특히나 대부분의 Java 개발자들이 비동기 프로그래밍을 접할 때 아래와 같은 코드를 통해 배우기 때문이다.</p>\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 여기서 실제로 별도의 스레드에서 실행됨</span>\n    <span class=\"k\">return</span> <span class=\"nf\">heavyTask</span><span class=\"o\">();</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p>우리는 Java에서 비동기 처리에 대해 다룰 때, ExecutorService나 CompletableFuture와 같은 도구들을 함께 배운다.</p>\n\n<p>이들은 내부적으로 <strong>스레드 풀</strong>을 사용하기 때문에, 자연스럽게 비동기 처리와 멀티 쓰레드를 동일시하게 된다.</p>\n\n<p>실제로 Spring Framework의 @Async 어노테이션도 비동기 처리를 위해 기본적으로 스레드 풀을 사용한다.</p>\n\n<p>하지만 비동기 처리의 본질은 <strong>“작업의 완료를 기다리지 않고 다른 작업을 수행할 수 있는 것”</strong>이다.</p>\n\n<p>이는 반드시 멀티스레드로만 구현되어야 하는 것이 아니며, Node.js가 좋은 예시다.</p>\n\n<p>Node.js는 싱글 스레드 기반의 이벤트 루프를 사용하여 비동기 처리를 구현한다.</p>\n\n<p>이벤트 루프는 OS의 비동기 I/O 기능을 활용하여 실제 I/O 작업을 커널 레벨에서 처리하고,</p>\n\n<p>작업이 완료되면 이벤트를 통해 알림을 받는 방식으로 동작한다.</p>\n\n<div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Node.js의 비동기 처리 (싱글스레드)</span>\n<span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nf\">readFile</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">file.txt</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">파일 읽기 완료</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">다음 작업 실행</span><span class=\"dl\">'</span><span class=\"p\">);</span>  <span class=\"c1\">// 파일 읽기를 기다리지 않고 실행</span>\n</code></pre></div></div>\n<p>이러한 이벤트 루프 기반의 비동기 처리는 멀티스레드 없이도 효율적인 비동기 처리를 가능하게 한다.\nOS의 비동기 I/O 기능을 활용하여, 실제 I/O 작업은 커널 레벨에서 처리되고, 완료되면 이벤트를 통해 알림을 받는 방식이다.\n<em>정확히는 JavaScript 엔진이 싱글 스레드 기반이다</em>\n<em>해당 내용에 대해 더 자세히 알고 싶다면 <a href=\"https://puleugo.tistory.com/133\">해당 블로그</a>를 참고하자</em></p>\n\n<p><br /></p>\n\n<h1 id=\"3-블로킹과-논블로킹\">3. 블로킹과 논블로킹</h1>\n<blockquote>\n  <p>블로킹과 논블로킹은 “제어권의 이동” 관점에서 바라보는 개념이다.</p>\n</blockquote>\n\n<p>결국 “호출한 함수가 다른 일을 할 수 있는가?”의 여부를 의미한다.</p>\n\n<h2 id=\"3-1-제어권control-flow의-의미\">3-1. 제어권(Control Flow)의 의미</h2>\n<p>여기서 <strong>제어권</strong>이란 어떤 의미를 갖는지 먼저 보자.\nOS적인 관점에서 보자면, <strong>현재 작업을 진행하고 있는 함수가 CPU를 점유하는 것</strong>을 의미한다.\n쉽게 말해 “코드를 실행시킬 수 있는 권한” 정도로 말할 수 있다.</p>\n\n<p>동기 와 비동기는 Jobs 들이 순서대로 혹은 독립적으로 처리되는가에 관한 이야기라면,\n이번에는 호출한 함수가 별개의 일을 할 수 있는지의 이야기이다.</p>\n\n<h2 id=\"3-2-블로킹-제어권을-넘겨주는-방식\">3-2. 블로킹: 제어권을 넘겨주는 방식</h2>\n<p>마치 시험지를 넘겨주는 방식을 생각하면 편할 것 같다.\n<img src=\"https://github.com/user-attachments/assets/6eb36e86-150c-4144-86ce-6080ef86bece\" alt=\"image\" width=\"60%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : https://www.veritas-a.com/news/articleView.html?idxno=156699</em></p>\n\n<p>내가 뒷 사람에게 시험지를 넘겨줄 때,\n나는 아무런 행동도 하지 않고 <strong>뒷 사람(호출된 함수)가 시험지를 가져가는(자신의 작업을 완료)할 때 까지</strong> 나는 손에 시험지를 쥐고 뒷사람을 바라보고 대기할 수 밖에 없다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d799e31b-9406-44f3-8dcc-9df15b8f8a79\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>둘 간의 구분 방법은 제어권이 누구에게 있는지로 결정된다.</p>\n\n<p>블로킹에서는 함수 A가 함수 B를 호출할 때 제어권이 B로 넘어간다.</p>\n\n<p>제어권을 넘겨준 A는 B의 작업이 완료될 때까지 아무 작업도 수행할 수 없는 상태, 즉 블로킹 상태가 된다.</p>\n\n<p>즉, 위의 사진에서 A함수는 B함수에게 제어권을 넘겨줌과 동시에 함수 실행이 일시 정지된다. = Blocking</p>\n\n<h2 id=\"3-3-논블로킹-제어권을-유지하는-방식\">3-3. 논블로킹: 제어권을 유지하는 방식</h2>\n<p>하지만 시험지를 그냥 뒷 사람 책상에 올려 놓는다면 어떨까.</p>\n\n<p>나는 실제 뒷 사람이 받는 것을 대기할 필요없이, 바로 나의 다른 작업을 할 수 있다.</p>\n\n<p>즉, 뒷 사람(호출된 함수)이 나에 대한 제어권을 바로 반환해줌으로, 호출한 쪽(나)에서는 계속 다른 작업을 할 수 있는 것이다.</p>\n\n<p>같은 “읽기” 작업이어도 동기와 비동기 처리에 따라 어떻게 다르게 동작하는지 보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹: 제어권을 넘겨줌</span>\n<span class=\"nc\">String</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">readFile</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 파일 읽을 때까지 다른 일 못함</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                          <span class=\"c1\">// 파일 다 읽고 나서야 실행</span>\n\n<span class=\"c1\">// 논블로킹: 제어권을 유지</span>\n<span class=\"nc\">Future</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">readFileAsync</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 요청만 하고</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                               <span class=\"c1\">// 바로 다른 일 할 수 있음</span>\n</code></pre></div></div>\n<p><img src=\"https://github.com/user-attachments/assets/4a59addb-b12d-4eaa-90c9-fe783a7556e0\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>반면 논블로킹에서는 A함수가 B함수를 호출하더라도 제어권을 계속 유지한다.</p>\n\n<p>따라서 B함수가 실행되는 동안에도, A함수는 제어권을 가지고 있기 때문에 다른 작업을 수행할 수 있다.</p>\n\n<p>이렇게 호출자(caller)인 A함수는 B함수의 작업 완료 여부와 관계없이 자신의 작업을 계속 수행할 수 있다.</p>\n\n<p><br /></p>\n\n<h1 id=\"4-네-가지-조합의-동작-방식\">4. 네 가지 조합의 동작 방식</h1>\n\n<p>가끔 동기 처리에서는 무조건적으로 블로킹이 일어나고, 비동기에서는 논블로킹이 일어난다고 오해하는 경우가 많다.</p>\n\n<p>하지만 두 쌍의 개념은 서로 다른 관점에서 바라보는 개념이라는 것을 확실하게 하고 넘어가자.</p>\n\n<blockquote>\n  <p>동기/비동기 : 작업들의 시간적 관계성 <br />\n블로킹/논블로킹 : 제어권의 소재</p>\n</blockquote>\n\n<p>하지만 이 개념들이 오해가 잦은 이유는 실제 구현에서 [동기/볼로킹 &amp; 비동기/논블로킹]이 <strong>자주 함께 사용</strong>되기 때문이다.</p>\n\n<p>다음 그림을 보고 4가지 조합에 대해 천천히 살펴보자.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b894be55-d296-424d-913f-ee989233eb60\" alt=\"image\" width=\"100%\" class=\"center\" /></p>\n\n<p>먼저 흔히 쓰이는 [동기/볼로킹 &amp; 비동기/논블로킹] 에 대해 보자.</p>\n\n<h2 id=\"4-1-동기--블로킹\">4-1. 동기 + 블로킹</h2>\n\n<p>작업의 흐름이 순차적으로 진행되는 것이 보장된다. (<strong>동기</strong>)</p>\n\n<p>제어권을 함수 B에게 넘겨준 후 함수 A는 대기하게 된다. (<strong>블로킹</strong>)</p>\n\n<p>함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄 때까지 함수 A는 기다리는 것이다.</p>\n\n<blockquote>\n  <p>이러한 조합은 <strong>작업이 완료될 때까지 기다려야 하는 경우</strong>에 사용된다. <br />\n예를 들면, 파일을 읽은 후 이를 처리하는 코드를 생각해보자. <br />\n파일을 처리하는 과정은 <strong>필연적으로 파일을 모두 읽은 후에 작업이 가능</strong>하기 때문이다. <br />\n또한, 일반적으로 작업이 간단하거나 작업량이 적은 경우에 사용된다. <br />\n작업량이 많거나 오래 걸리는 작업을 해당 방식으로 처리하면 <strong>전체 프로그램이 멈춘 것 처럼 보여</strong> 사용자 경험 측면에서 나빠질 수 있다.</p>\n</blockquote>\n\n<h2 id=\"4-2-비동기--논블로킹\">4-2. 비동기 + 논블로킹</h2>\n\n<p>비동기 + 논블로킹 방식도 비교적 이해가 쉽다.</p>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다. (<strong>논블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 방식이다. (<strong>동기</strong>)</p>\n\n<p>함수 B를 호출 할 때, 콜백 함수를 함께 줌으로써, 함수 B는 자신의 작업이 끝났을 때 <strong>함수 A에게 준 콜백 함수를 실행시켜 자신의 작업이 끝났음</strong>을 알려준다.</p>\n\n<p>작업 A는 함수 B의 종료 여부에는 일단 관심이 없다.</p>\n\n<p>B 함수가 자신의 실행을 완료했다면, A 함수의 어깨를 톡톡 쳐서 알려주면 되는 것이다.</p>\n\n<blockquote>\n  <p>다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우에 활용할 수 있다. <br />\n또한, 대용량의 데이터를 처리하는 서비스에서 흔히 사용된다. <br />\n가장 큰 특징은 호출 함수에 콜백 함수를 넣었다는 점이다.</p>\n</blockquote>\n\n<h2 id=\"4-3-동기--논블로킹\">4-3. 동기 + 논블로킹</h2>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다.</p>\n\n<p>이후 바로 자신의 코드를 실행한다. (<strong>논블로킹</strong>)</p>\n\n<p>즉, 다른 작업이 진행되는 동안에도 자신의 작업을 별개로 처리할 수 있다.</p>\n\n<p>조심할 것이 함수 A는 함수 B의 Return 값을 필요로 하는 것은 변함이 없다는 점이다.</p>\n\n<p>A 함수는 B 함수의 리턴값이 필요하기 때문에, 중간중간 B 함수에게 함수 실행을 완료했는지 물어본다.</p>\n\n<p>즉, A 함수(caller)가 B 함수(callee)의 실행이 종료되었는지 계속 예의 주시해야 한다. (순서 보장을 위해)</p>\n\n<p>이로써 작업을 순차대로 수행할 수 있는 것이다. (<strong>동기</strong>)</p>\n\n<p>여기서 조금 더 깊게 생각해보자.</p>\n\n<p>어떻게 동기적으로 진행되면서 메인 쓰레드가 논블로킹이 될 수 있을까?</p>\n\n<p>이 조합의 특징은 “작업 완료는 비동기로 처리하지만, 호출자는 필요할 때 결과를 동기적으로 받는다.”로 정리할 수 있다.</p>\n\n<p>즉, <strong>순서를 유지하면서 결과를 사용해야 할 때 동기적으로 기다릴 수 있다.</strong></p>\n\n<p>결국 <strong>동기적</strong> 이라는 말은 <strong>호출자의 결과가 필요한 시점에서 순서를 보장</strong>하며 작업을 진행한다는 것이다.</p>\n\n<p>다음 JAVA 코드의 예시를 봐보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SimpleDownloader</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>  <span class=\"c1\">// 다운로드 진행률</span>\n        \n        <span class=\"c1\">// 다운로드 시작</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"파일 다운로드를 시작합니다.\"</span><span class=\"o\">);</span>\n        \n        <span class=\"c1\">// 진행률 확인하면서 다른 작업 수행 (논블로킹)</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">downloadProgress</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">{</span>  <span class=\"c1\">// 동기적: 순서 보장</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"진행률: \"</span> <span class=\"o\">+</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">+</span> <span class=\"s\">\"%\"</span><span class=\"o\">);</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다른 작업을 할 수 있어요!\"</span><span class=\"o\">);</span>\n            \n            <span class=\"c1\">// 진행률이 증가한다고 가정</span>\n            <span class=\"n\">downloadProgress</span> <span class=\"o\">+=</span> <span class=\"mi\">20</span><span class=\"o\">;</span>\n            \n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>  <span class=\"c1\">// 1초 대기</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        \n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다운로드 완료!\"</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><em>🚨 주의: 이 예시 코드는 Thread를 사용하고 있다. <br />\nThread는 기본적으로 작업을 병렬적으로 처리하기 위한 도구이다. <br />\n비동기 프로그래밍에서는 이러한 Thread의 병렬 처리 능력을 활용하여 비동기 작업을 구현하는 것이 일반적이다. <br />\n하지만 이 예시의 주된 목적은 작업이 어떻게 논블로킹하면서도 동기적으로 처리될 수 있는지를 시각적으로 보여주는 것이다. <br />\nThread를 사용한 것은 개념을 쉽게 설명하기 위한 것이다.</em></p>\n\n<p>이 코드의 결과는 다음과 같을 것이다.</p>\n<div class=\"language-css highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">나는</span> <span class=\"nt\">다른</span> <span class=\"nt\">작업을</span> <span class=\"nt\">진행할게</span><span class=\"o\">.</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">시작</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">0</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">1</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">2</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">완료</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드</span> <span class=\"nt\">종료</span> <span class=\"nt\">확인</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">모든</span> <span class=\"nt\">작업</span> <span class=\"nt\">완료</span><span class=\"o\">.</span>\n</code></pre></div></div>\n\n<p>물론, 논블로킹 메서드로 비동기 작업을 시작하더라도, 결과를 기다려야 하는 시점에서는 블로킹처럼 동작할 수 있다. <br />\n왜냐하면 메인 스레드가 결과를 받아야만 다음 작업을 진행할 수 있기 때문에, 그 시점에서는 블로킹이 되는 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b43ec8c4-9783-4fbf-9f7a-3736dff051bb\" alt=\"image\" width=\"80%\" class=\"center\" /></p>\n\n<p>사실 이러한 방식의 구현은 흔치 않다. <br />\n하지만, 몇 가지 활용 예를 알아보자면 <strong>게임 로딩화면 구성</strong> 등에 활용될 수 있다. <br />\n보통 게임에서 패치나 다운로드를 할 때, 사용자에게 ProgressBar나 게임 Tip등을 띄워줘야 할 때가 있다. <br />\n이 때는 Load 하는 동작이 완료될 때 까지 (작업 순서는 보장 = Sync) <br />\n다른 작업이 진행될 수 있다. (Non-Blocking)\n즉, 사용자 경험 측면에서 유용하게 활용될 수 있다.</p>\n\n<blockquote>\n  <p>언어 간에는 구현 방식에 차이가 있을 수 있다. <br />\n이는 각 언어의 특성과 제공되는 라이브러리나 기술에 따라 달라질 수 있다. <br />\n예를 들어, JavaScript는 단일 스레드 기반으로 동작하며, 콜백 함수, 프로미스(Promise), async/await 등의 메커니즘을 사용해 동기와 논블로킹 처리를 구현할 수 있다. <br />\n기본적으로 Promise.then 방식은 비동기적이고 논블로킹 방식으로 처리된다. <br />\n그러나 async/await 키워드를 사용하면, 비동기 작업의 순서를 지정할 수 있다.<br />\n중요한 점은, async 함수가 내부적으로 비동기적으로 동작하며, 메인 콜 스택이 모두 비워져야 실행된다는 것이다. <br />\n이로 인해 async/await도 내부적으로는 여전히 비동기적이고 논블로킹 방식으로 동작한다는 점을 유의해야 한다.\n(동기적인 코드 흐름처럼 보이게 하는 트릭)</p>\n</blockquote>\n\n<h2 id=\"4-4-비동기--블로킹\">4-4. 비동기 + 블로킹</h2>\n\n<p>이러한 방식은 사실 실무에서 마주치기 더더욱 흔치 않다.</p>\n\n<p>개념만 간단히 설명하자면,</p>\n\n<p>다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다린다. (<strong>블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않고, 콜백함수를 보낸 후 기다린다.</p>\n\n<p>이로써 작업 완료의 순서는 보장되지 않을 수 있다. (<strong>비동기</strong>)</p>\n\n<p><strong>즉, 함수 A는 자신과 관련없는 함수 B의 작업이 끝날 때까지 기다려야 한다.</strong>\n<em>매우 비효율적인 로직…</em></p>\n\n<p>1 작업 중에 2 작업을 해야지 Async의 이점을 살릴 수 있는 것인데,\n이것을 다시 Blocking 방식을 사용함여 대기시킴으로써 이점을 제거해버린 것이다…😅\n대부분의 경우 비동기+논블로킹 모델이 더 효율적인 선택이 될 것이다.</p>\n\n<p><br /></p>\n\n<h1 id=\"5-현대-프로그래밍에서-이러한-개념이-왜-중요한가\">5. 현대 프로그래밍에서 이러한 개념이 왜 중요한가?</h1>\n\n<p>이러한 이해는 현대 소프트웨어 개발에서 매우 중요하다. 오늘날의 애플리케이션들은 수많은 동시다발적인 작업을 처리해야 한다. 사용자는 파일을 다운로드하면서 동시에 문서를 편집하길 원하고, 데이터가 백그라운드에서 처리되는 동안에도 끊김 없는 인터페이스 사용을 기대한다.</p>\n\n<p>더군다나 클라우드 컴퓨팅과 마이크로서비스 아키텍처가 보편화된 현대 개발 환경에서는, 네트워크를 통한 수많은 비동기 작업들이 동시에 발생한다. 이때 각 작업을 어떻게 처리할지, 작업 간의 의존성은 어떻게 관리할지를 결정하는 것은 시스템의 성능과 사용자 경험을 좌우하는 핵심 요소가 된다.</p>\n\n<p>결국 이러한 개념들의 이해는 단순히 기술적인 지식을 넘어서, 현대 소프트웨어가 직면한 복잡성과 사용자 경험의 요구사항을 어떻게 조화롭게 해결할 수 있을지에 대한 통찰을 제공한다. 이는 우리가 더 효율적이고, 반응성 높은, 그리고 사용자 친화적인 소프트웨어를 설계하고 구현하는 데 있어 필수적인 기반이 될 것이다.</p>\n\n<h1 id=\"6-마무리\">6. 마무리</h1>\n<p>그렇다면 Java에서는 이러한 비동기 처리를 어떻게 구현할 수 있을까?</p>\n\n<p>Java의 비동기 프로그래밍은 Thread를 시작으로, 현대적인 CompletableFuture까지 꾸준히 발전해왔다.</p>\n\n<p>이제 각각의 방식을 자세히 살펴보겠다.</p>\n",
                        "tags": ["Java","Spring-Boot","Backend","Sync","Async","Concurrency","Blocking","NonBlocking"]
                    }
                
            ],
        
            "Spring-Boot": [
                
                    {
                        "title": "동기/비동기와 블로킹/논블로킹에 대해 깊이 파헤치기",
                        "url": "/2025/01/12/understanding-sync-async-blocking-non-blocking.html",
                        "subtitle": "Java/SpringBoot에서의 비동기 처리",
                        "excerpt": "1. 개념적 이해\n",
                        "author": "Jinho",
                        "date": "January 12, 2025",
                        "background": "/img/posts/sync-async-concept.jpeg",
                        "content": "<h1 id=\"1-개념적-이해\">1. 개념적 이해</h1>\n\n<p>비동기 처리에 대해 이야기하기 앞서, 과연 “동기”란 어떤 것인지부터 바로 잡고 가려고한다.</p>\n\n<p>왜냐하면 <strong>비(非)동기</strong>란 동기가 아니다라는 의미이기 때문에 동기가 무엇인지부터 정확히 하고 싶었다.</p>\n\n<p>또한 나는 처음에 ‘동기=블로킹, 비동기=논블로킹’이라고 단순하게 이해하고 있었다.</p>\n\n<p>하지만 실제로는 두 개념이 분류 기준이 전혀 다른 독립적인 개념이라는 것을 알게 되었다.</p>\n\n<p>이렇듯 서로 혼동되어 쓰이는 각 명칭은 어떤 의미인지 알아보려고 한다.</p>\n\n<p>이에 대해 자세히 알아보자.</p>\n\n<p><br /></p>\n\n<h1 id=\"2-동기와-비동기\">2. 동기와 비동기</h1>\n\n<p><img src=\"https://velog.velcdn.com/images/jinho7/post/a47f1973-3895-4438-a47f-80dd80245e41/image.png\" alt=\"\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<blockquote>\n  <p>동기와 비동기는 “작업의 처리 방식”을 나타내는 개념이다. <br />\n결론부터 말하자면, 이둘의 주요한 차이점은 “작업 순서 처리 차이”이다.</p>\n</blockquote>\n\n<h2 id=\"2-1-동기-순차적으로-실행\">2-1. 동기: 순차적으로 실행</h2>\n<p>필자는 이전에 동기를 <strong>겹치지 않고 순차적으로 작업을 진행하는 것</strong> 정도로 이해하고 있었다.</p>\n\n<p>영어 사전을 참고해보자.</p>\n\n<blockquote>\n  <p>synchronous\nadjective\nhappening or done at the same time or speed:</p>\n</blockquote>\n\n<p><strong>Synchronous</strong> 는 동시에 발생하는 두 개 이상의 사건이나 프로세스가 동일한 시간에서 진행되는 것을 의미하는 형용사이다.</p>\n\n<p>중요한 워딩은 [동일한 시간에 여러 개의 사건이 진행] 된다는 것이다.</p>\n\n<p>‘순차적’과 ‘동시’라는 단어가 서로 상충된다고 생각할 수 있다.</p>\n\n<p>여기서 오해하면 안되는 것이 이는 <strong>병렬적인 작업방식을 말하는 것이 아니다.</strong></p>\n\n<p>“어떠한 일정 시점에 현재 작업의 Response과 다음 작업의 Request이 함께 진행되는 것”</p>\n\n<p>위의 그림을 참고하면 이해가 쉽다.\n작업 A가 끝나는 시간과 작업 B가 시작하는 시간이 동기화된다고 이해하면 좋을 것 같다.</p>\n\n<p>이는 <strong>작업이 순차적으로 처리되며, 이전 작업이 완료될 때까지는 다음 작업이 시작되지 않음을 나타낸다.</strong></p>\n\n<p>즉, <strong>작업들이 서로 시간적 의존성을 가지고 실행된다</strong>는 뜻이다.</p>\n\n<p>동기 방식은 실행 순서가 보장되며 예측 가능하다는 장점이 있지만, <br />\n앞선 작업이 오래 걸리면 전체 작업이 지연된다는 단점도 있다.</p>\n\n<h2 id=\"2-2-비동기-독립적으로-실행\">2-2. 비동기: 독립적으로 실행</h2>\n<p>그렇다면 비동기 방식은 무엇일까?</p>\n\n<p>반대의 경우를 생각하면 된다.</p>\n\n<p>위의 그림을 참고하면 작업들이 병렬적으로 일어나고 있음을 알 수 있다.</p>\n\n<p>동기와 반대로 <strong>“요청을 보냈을 때 응답 상태와 상관없이 다른 동작을 수행할 수 있다.”</strong>는 점이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/0a188e4a-b35f-41aa-9953-94504330dd9f\" alt=\"다운로드\" width=\"68%\" height=\"50%\" class=\"center\" />\n<em class=\"image-caption\">파일 다운로드가 동기 방식이라면?</em></p>\n\n<p>만약에 파일 다운로드를 동기적으로 처리한다고 해보자.</p>\n\n<p>아마 파일이 다운로드될 때까지 아무런 작업도 수행할 수 없을 것이고,\n파일이 완전히 다운로드된 후에 다음 작업을 진행할 수 있을 것이다. 😅</p>\n\n<p>매우 비효율적인 방식이다…</p>\n\n<p>그러나 비동기적인 방식을 활용한다면, 파일 다운로드 작업을 시작시켜놓고, 다른 작업을 수행할 수 있다.</p>\n\n<p>파일이 다운로드되면 특정 콜백 함수를 호출하여, 다운로드된 파일을 처리하거나 결과를 반환받을 수 있다.</p>\n\n<p>콜백 뿐만이 아니고, 그 결과는 콜백 함수, Promise, 이벤트 등을 통해 전달받을 수 있다.</p>\n\n<p>마치 택배를 주문하고 배송 알림을 받는 것과 비슷하다고 할 수 있다.</p>\n\n<h3 id=\"비동기-동작-방식에-대한-오해\">비동기 동작 방식에 대한 오해</h3>\n<p>많은 개발자들이 <strong>비동기 = 멀티 쓰레드</strong>라고 이해하고 있다.</p>\n\n<p>단순히 생각해보아도, 여러 작업이 동시에 처리되는 비동기 동작을 구현하기 위해서는 당연히 여러 개의 쓰레드가 필요할 것 같기 때문이다.</p>\n\n<p>또한, 특히나 대부분의 Java 개발자들이 비동기 프로그래밍을 접할 때 아래와 같은 코드를 통해 배우기 때문이다.</p>\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 여기서 실제로 별도의 스레드에서 실행됨</span>\n    <span class=\"k\">return</span> <span class=\"nf\">heavyTask</span><span class=\"o\">();</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p>우리는 Java에서 비동기 처리에 대해 다룰 때, ExecutorService나 CompletableFuture와 같은 도구들을 함께 배운다.</p>\n\n<p>이들은 내부적으로 <strong>스레드 풀</strong>을 사용하기 때문에, 자연스럽게 비동기 처리와 멀티 쓰레드를 동일시하게 된다.</p>\n\n<p>실제로 Spring Framework의 @Async 어노테이션도 비동기 처리를 위해 기본적으로 스레드 풀을 사용한다.</p>\n\n<p>하지만 비동기 처리의 본질은 <strong>“작업의 완료를 기다리지 않고 다른 작업을 수행할 수 있는 것”</strong>이다.</p>\n\n<p>이는 반드시 멀티스레드로만 구현되어야 하는 것이 아니며, Node.js가 좋은 예시다.</p>\n\n<p>Node.js는 싱글 스레드 기반의 이벤트 루프를 사용하여 비동기 처리를 구현한다.</p>\n\n<p>이벤트 루프는 OS의 비동기 I/O 기능을 활용하여 실제 I/O 작업을 커널 레벨에서 처리하고,</p>\n\n<p>작업이 완료되면 이벤트를 통해 알림을 받는 방식으로 동작한다.</p>\n\n<div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Node.js의 비동기 처리 (싱글스레드)</span>\n<span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nf\">readFile</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">file.txt</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">파일 읽기 완료</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">다음 작업 실행</span><span class=\"dl\">'</span><span class=\"p\">);</span>  <span class=\"c1\">// 파일 읽기를 기다리지 않고 실행</span>\n</code></pre></div></div>\n<p>이러한 이벤트 루프 기반의 비동기 처리는 멀티스레드 없이도 효율적인 비동기 처리를 가능하게 한다.\nOS의 비동기 I/O 기능을 활용하여, 실제 I/O 작업은 커널 레벨에서 처리되고, 완료되면 이벤트를 통해 알림을 받는 방식이다.\n<em>정확히는 JavaScript 엔진이 싱글 스레드 기반이다</em>\n<em>해당 내용에 대해 더 자세히 알고 싶다면 <a href=\"https://puleugo.tistory.com/133\">해당 블로그</a>를 참고하자</em></p>\n\n<p><br /></p>\n\n<h1 id=\"3-블로킹과-논블로킹\">3. 블로킹과 논블로킹</h1>\n<blockquote>\n  <p>블로킹과 논블로킹은 “제어권의 이동” 관점에서 바라보는 개념이다.</p>\n</blockquote>\n\n<p>결국 “호출한 함수가 다른 일을 할 수 있는가?”의 여부를 의미한다.</p>\n\n<h2 id=\"3-1-제어권control-flow의-의미\">3-1. 제어권(Control Flow)의 의미</h2>\n<p>여기서 <strong>제어권</strong>이란 어떤 의미를 갖는지 먼저 보자.\nOS적인 관점에서 보자면, <strong>현재 작업을 진행하고 있는 함수가 CPU를 점유하는 것</strong>을 의미한다.\n쉽게 말해 “코드를 실행시킬 수 있는 권한” 정도로 말할 수 있다.</p>\n\n<p>동기 와 비동기는 Jobs 들이 순서대로 혹은 독립적으로 처리되는가에 관한 이야기라면,\n이번에는 호출한 함수가 별개의 일을 할 수 있는지의 이야기이다.</p>\n\n<h2 id=\"3-2-블로킹-제어권을-넘겨주는-방식\">3-2. 블로킹: 제어권을 넘겨주는 방식</h2>\n<p>마치 시험지를 넘겨주는 방식을 생각하면 편할 것 같다.\n<img src=\"https://github.com/user-attachments/assets/6eb36e86-150c-4144-86ce-6080ef86bece\" alt=\"image\" width=\"60%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : https://www.veritas-a.com/news/articleView.html?idxno=156699</em></p>\n\n<p>내가 뒷 사람에게 시험지를 넘겨줄 때,\n나는 아무런 행동도 하지 않고 <strong>뒷 사람(호출된 함수)가 시험지를 가져가는(자신의 작업을 완료)할 때 까지</strong> 나는 손에 시험지를 쥐고 뒷사람을 바라보고 대기할 수 밖에 없다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d799e31b-9406-44f3-8dcc-9df15b8f8a79\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>둘 간의 구분 방법은 제어권이 누구에게 있는지로 결정된다.</p>\n\n<p>블로킹에서는 함수 A가 함수 B를 호출할 때 제어권이 B로 넘어간다.</p>\n\n<p>제어권을 넘겨준 A는 B의 작업이 완료될 때까지 아무 작업도 수행할 수 없는 상태, 즉 블로킹 상태가 된다.</p>\n\n<p>즉, 위의 사진에서 A함수는 B함수에게 제어권을 넘겨줌과 동시에 함수 실행이 일시 정지된다. = Blocking</p>\n\n<h2 id=\"3-3-논블로킹-제어권을-유지하는-방식\">3-3. 논블로킹: 제어권을 유지하는 방식</h2>\n<p>하지만 시험지를 그냥 뒷 사람 책상에 올려 놓는다면 어떨까.</p>\n\n<p>나는 실제 뒷 사람이 받는 것을 대기할 필요없이, 바로 나의 다른 작업을 할 수 있다.</p>\n\n<p>즉, 뒷 사람(호출된 함수)이 나에 대한 제어권을 바로 반환해줌으로, 호출한 쪽(나)에서는 계속 다른 작업을 할 수 있는 것이다.</p>\n\n<p>같은 “읽기” 작업이어도 동기와 비동기 처리에 따라 어떻게 다르게 동작하는지 보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹: 제어권을 넘겨줌</span>\n<span class=\"nc\">String</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">readFile</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 파일 읽을 때까지 다른 일 못함</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                          <span class=\"c1\">// 파일 다 읽고 나서야 실행</span>\n\n<span class=\"c1\">// 논블로킹: 제어권을 유지</span>\n<span class=\"nc\">Future</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">readFileAsync</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 요청만 하고</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                               <span class=\"c1\">// 바로 다른 일 할 수 있음</span>\n</code></pre></div></div>\n<p><img src=\"https://github.com/user-attachments/assets/4a59addb-b12d-4eaa-90c9-fe783a7556e0\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>반면 논블로킹에서는 A함수가 B함수를 호출하더라도 제어권을 계속 유지한다.</p>\n\n<p>따라서 B함수가 실행되는 동안에도, A함수는 제어권을 가지고 있기 때문에 다른 작업을 수행할 수 있다.</p>\n\n<p>이렇게 호출자(caller)인 A함수는 B함수의 작업 완료 여부와 관계없이 자신의 작업을 계속 수행할 수 있다.</p>\n\n<p><br /></p>\n\n<h1 id=\"4-네-가지-조합의-동작-방식\">4. 네 가지 조합의 동작 방식</h1>\n\n<p>가끔 동기 처리에서는 무조건적으로 블로킹이 일어나고, 비동기에서는 논블로킹이 일어난다고 오해하는 경우가 많다.</p>\n\n<p>하지만 두 쌍의 개념은 서로 다른 관점에서 바라보는 개념이라는 것을 확실하게 하고 넘어가자.</p>\n\n<blockquote>\n  <p>동기/비동기 : 작업들의 시간적 관계성 <br />\n블로킹/논블로킹 : 제어권의 소재</p>\n</blockquote>\n\n<p>하지만 이 개념들이 오해가 잦은 이유는 실제 구현에서 [동기/볼로킹 &amp; 비동기/논블로킹]이 <strong>자주 함께 사용</strong>되기 때문이다.</p>\n\n<p>다음 그림을 보고 4가지 조합에 대해 천천히 살펴보자.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b894be55-d296-424d-913f-ee989233eb60\" alt=\"image\" width=\"100%\" class=\"center\" /></p>\n\n<p>먼저 흔히 쓰이는 [동기/볼로킹 &amp; 비동기/논블로킹] 에 대해 보자.</p>\n\n<h2 id=\"4-1-동기--블로킹\">4-1. 동기 + 블로킹</h2>\n\n<p>작업의 흐름이 순차적으로 진행되는 것이 보장된다. (<strong>동기</strong>)</p>\n\n<p>제어권을 함수 B에게 넘겨준 후 함수 A는 대기하게 된다. (<strong>블로킹</strong>)</p>\n\n<p>함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄 때까지 함수 A는 기다리는 것이다.</p>\n\n<blockquote>\n  <p>이러한 조합은 <strong>작업이 완료될 때까지 기다려야 하는 경우</strong>에 사용된다. <br />\n예를 들면, 파일을 읽은 후 이를 처리하는 코드를 생각해보자. <br />\n파일을 처리하는 과정은 <strong>필연적으로 파일을 모두 읽은 후에 작업이 가능</strong>하기 때문이다. <br />\n또한, 일반적으로 작업이 간단하거나 작업량이 적은 경우에 사용된다. <br />\n작업량이 많거나 오래 걸리는 작업을 해당 방식으로 처리하면 <strong>전체 프로그램이 멈춘 것 처럼 보여</strong> 사용자 경험 측면에서 나빠질 수 있다.</p>\n</blockquote>\n\n<h2 id=\"4-2-비동기--논블로킹\">4-2. 비동기 + 논블로킹</h2>\n\n<p>비동기 + 논블로킹 방식도 비교적 이해가 쉽다.</p>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다. (<strong>논블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 방식이다. (<strong>동기</strong>)</p>\n\n<p>함수 B를 호출 할 때, 콜백 함수를 함께 줌으로써, 함수 B는 자신의 작업이 끝났을 때 <strong>함수 A에게 준 콜백 함수를 실행시켜 자신의 작업이 끝났음</strong>을 알려준다.</p>\n\n<p>작업 A는 함수 B의 종료 여부에는 일단 관심이 없다.</p>\n\n<p>B 함수가 자신의 실행을 완료했다면, A 함수의 어깨를 톡톡 쳐서 알려주면 되는 것이다.</p>\n\n<blockquote>\n  <p>다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우에 활용할 수 있다. <br />\n또한, 대용량의 데이터를 처리하는 서비스에서 흔히 사용된다. <br />\n가장 큰 특징은 호출 함수에 콜백 함수를 넣었다는 점이다.</p>\n</blockquote>\n\n<h2 id=\"4-3-동기--논블로킹\">4-3. 동기 + 논블로킹</h2>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다.</p>\n\n<p>이후 바로 자신의 코드를 실행한다. (<strong>논블로킹</strong>)</p>\n\n<p>즉, 다른 작업이 진행되는 동안에도 자신의 작업을 별개로 처리할 수 있다.</p>\n\n<p>조심할 것이 함수 A는 함수 B의 Return 값을 필요로 하는 것은 변함이 없다는 점이다.</p>\n\n<p>A 함수는 B 함수의 리턴값이 필요하기 때문에, 중간중간 B 함수에게 함수 실행을 완료했는지 물어본다.</p>\n\n<p>즉, A 함수(caller)가 B 함수(callee)의 실행이 종료되었는지 계속 예의 주시해야 한다. (순서 보장을 위해)</p>\n\n<p>이로써 작업을 순차대로 수행할 수 있는 것이다. (<strong>동기</strong>)</p>\n\n<p>여기서 조금 더 깊게 생각해보자.</p>\n\n<p>어떻게 동기적으로 진행되면서 메인 쓰레드가 논블로킹이 될 수 있을까?</p>\n\n<p>이 조합의 특징은 “작업 완료는 비동기로 처리하지만, 호출자는 필요할 때 결과를 동기적으로 받는다.”로 정리할 수 있다.</p>\n\n<p>즉, <strong>순서를 유지하면서 결과를 사용해야 할 때 동기적으로 기다릴 수 있다.</strong></p>\n\n<p>결국 <strong>동기적</strong> 이라는 말은 <strong>호출자의 결과가 필요한 시점에서 순서를 보장</strong>하며 작업을 진행한다는 것이다.</p>\n\n<p>다음 JAVA 코드의 예시를 봐보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SimpleDownloader</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>  <span class=\"c1\">// 다운로드 진행률</span>\n        \n        <span class=\"c1\">// 다운로드 시작</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"파일 다운로드를 시작합니다.\"</span><span class=\"o\">);</span>\n        \n        <span class=\"c1\">// 진행률 확인하면서 다른 작업 수행 (논블로킹)</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">downloadProgress</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">{</span>  <span class=\"c1\">// 동기적: 순서 보장</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"진행률: \"</span> <span class=\"o\">+</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">+</span> <span class=\"s\">\"%\"</span><span class=\"o\">);</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다른 작업을 할 수 있어요!\"</span><span class=\"o\">);</span>\n            \n            <span class=\"c1\">// 진행률이 증가한다고 가정</span>\n            <span class=\"n\">downloadProgress</span> <span class=\"o\">+=</span> <span class=\"mi\">20</span><span class=\"o\">;</span>\n            \n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>  <span class=\"c1\">// 1초 대기</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        \n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다운로드 완료!\"</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><em>🚨 주의: 이 예시 코드는 Thread를 사용하고 있다. <br />\nThread는 기본적으로 작업을 병렬적으로 처리하기 위한 도구이다. <br />\n비동기 프로그래밍에서는 이러한 Thread의 병렬 처리 능력을 활용하여 비동기 작업을 구현하는 것이 일반적이다. <br />\n하지만 이 예시의 주된 목적은 작업이 어떻게 논블로킹하면서도 동기적으로 처리될 수 있는지를 시각적으로 보여주는 것이다. <br />\nThread를 사용한 것은 개념을 쉽게 설명하기 위한 것이다.</em></p>\n\n<p>이 코드의 결과는 다음과 같을 것이다.</p>\n<div class=\"language-css highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">나는</span> <span class=\"nt\">다른</span> <span class=\"nt\">작업을</span> <span class=\"nt\">진행할게</span><span class=\"o\">.</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">시작</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">0</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">1</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">2</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">완료</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드</span> <span class=\"nt\">종료</span> <span class=\"nt\">확인</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">모든</span> <span class=\"nt\">작업</span> <span class=\"nt\">완료</span><span class=\"o\">.</span>\n</code></pre></div></div>\n\n<p>물론, 논블로킹 메서드로 비동기 작업을 시작하더라도, 결과를 기다려야 하는 시점에서는 블로킹처럼 동작할 수 있다. <br />\n왜냐하면 메인 스레드가 결과를 받아야만 다음 작업을 진행할 수 있기 때문에, 그 시점에서는 블로킹이 되는 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b43ec8c4-9783-4fbf-9f7a-3736dff051bb\" alt=\"image\" width=\"80%\" class=\"center\" /></p>\n\n<p>사실 이러한 방식의 구현은 흔치 않다. <br />\n하지만, 몇 가지 활용 예를 알아보자면 <strong>게임 로딩화면 구성</strong> 등에 활용될 수 있다. <br />\n보통 게임에서 패치나 다운로드를 할 때, 사용자에게 ProgressBar나 게임 Tip등을 띄워줘야 할 때가 있다. <br />\n이 때는 Load 하는 동작이 완료될 때 까지 (작업 순서는 보장 = Sync) <br />\n다른 작업이 진행될 수 있다. (Non-Blocking)\n즉, 사용자 경험 측면에서 유용하게 활용될 수 있다.</p>\n\n<blockquote>\n  <p>언어 간에는 구현 방식에 차이가 있을 수 있다. <br />\n이는 각 언어의 특성과 제공되는 라이브러리나 기술에 따라 달라질 수 있다. <br />\n예를 들어, JavaScript는 단일 스레드 기반으로 동작하며, 콜백 함수, 프로미스(Promise), async/await 등의 메커니즘을 사용해 동기와 논블로킹 처리를 구현할 수 있다. <br />\n기본적으로 Promise.then 방식은 비동기적이고 논블로킹 방식으로 처리된다. <br />\n그러나 async/await 키워드를 사용하면, 비동기 작업의 순서를 지정할 수 있다.<br />\n중요한 점은, async 함수가 내부적으로 비동기적으로 동작하며, 메인 콜 스택이 모두 비워져야 실행된다는 것이다. <br />\n이로 인해 async/await도 내부적으로는 여전히 비동기적이고 논블로킹 방식으로 동작한다는 점을 유의해야 한다.\n(동기적인 코드 흐름처럼 보이게 하는 트릭)</p>\n</blockquote>\n\n<h2 id=\"4-4-비동기--블로킹\">4-4. 비동기 + 블로킹</h2>\n\n<p>이러한 방식은 사실 실무에서 마주치기 더더욱 흔치 않다.</p>\n\n<p>개념만 간단히 설명하자면,</p>\n\n<p>다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다린다. (<strong>블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않고, 콜백함수를 보낸 후 기다린다.</p>\n\n<p>이로써 작업 완료의 순서는 보장되지 않을 수 있다. (<strong>비동기</strong>)</p>\n\n<p><strong>즉, 함수 A는 자신과 관련없는 함수 B의 작업이 끝날 때까지 기다려야 한다.</strong>\n<em>매우 비효율적인 로직…</em></p>\n\n<p>1 작업 중에 2 작업을 해야지 Async의 이점을 살릴 수 있는 것인데,\n이것을 다시 Blocking 방식을 사용함여 대기시킴으로써 이점을 제거해버린 것이다…😅\n대부분의 경우 비동기+논블로킹 모델이 더 효율적인 선택이 될 것이다.</p>\n\n<p><br /></p>\n\n<h1 id=\"5-현대-프로그래밍에서-이러한-개념이-왜-중요한가\">5. 현대 프로그래밍에서 이러한 개념이 왜 중요한가?</h1>\n\n<p>이러한 이해는 현대 소프트웨어 개발에서 매우 중요하다. 오늘날의 애플리케이션들은 수많은 동시다발적인 작업을 처리해야 한다. 사용자는 파일을 다운로드하면서 동시에 문서를 편집하길 원하고, 데이터가 백그라운드에서 처리되는 동안에도 끊김 없는 인터페이스 사용을 기대한다.</p>\n\n<p>더군다나 클라우드 컴퓨팅과 마이크로서비스 아키텍처가 보편화된 현대 개발 환경에서는, 네트워크를 통한 수많은 비동기 작업들이 동시에 발생한다. 이때 각 작업을 어떻게 처리할지, 작업 간의 의존성은 어떻게 관리할지를 결정하는 것은 시스템의 성능과 사용자 경험을 좌우하는 핵심 요소가 된다.</p>\n\n<p>결국 이러한 개념들의 이해는 단순히 기술적인 지식을 넘어서, 현대 소프트웨어가 직면한 복잡성과 사용자 경험의 요구사항을 어떻게 조화롭게 해결할 수 있을지에 대한 통찰을 제공한다. 이는 우리가 더 효율적이고, 반응성 높은, 그리고 사용자 친화적인 소프트웨어를 설계하고 구현하는 데 있어 필수적인 기반이 될 것이다.</p>\n\n<h1 id=\"6-마무리\">6. 마무리</h1>\n<p>그렇다면 Java에서는 이러한 비동기 처리를 어떻게 구현할 수 있을까?</p>\n\n<p>Java의 비동기 프로그래밍은 Thread를 시작으로, 현대적인 CompletableFuture까지 꾸준히 발전해왔다.</p>\n\n<p>이제 각각의 방식을 자세히 살펴보겠다.</p>\n",
                        "tags": ["Java","Spring-Boot","Backend","Sync","Async","Concurrency","Blocking","NonBlocking"]
                    }
                
            ],
        
            "Backend": [
                
                    {
                        "title": "동기/비동기와 블로킹/논블로킹에 대해 깊이 파헤치기",
                        "url": "/2025/01/12/understanding-sync-async-blocking-non-blocking.html",
                        "subtitle": "Java/SpringBoot에서의 비동기 처리",
                        "excerpt": "1. 개념적 이해\n",
                        "author": "Jinho",
                        "date": "January 12, 2025",
                        "background": "/img/posts/sync-async-concept.jpeg",
                        "content": "<h1 id=\"1-개념적-이해\">1. 개념적 이해</h1>\n\n<p>비동기 처리에 대해 이야기하기 앞서, 과연 “동기”란 어떤 것인지부터 바로 잡고 가려고한다.</p>\n\n<p>왜냐하면 <strong>비(非)동기</strong>란 동기가 아니다라는 의미이기 때문에 동기가 무엇인지부터 정확히 하고 싶었다.</p>\n\n<p>또한 나는 처음에 ‘동기=블로킹, 비동기=논블로킹’이라고 단순하게 이해하고 있었다.</p>\n\n<p>하지만 실제로는 두 개념이 분류 기준이 전혀 다른 독립적인 개념이라는 것을 알게 되었다.</p>\n\n<p>이렇듯 서로 혼동되어 쓰이는 각 명칭은 어떤 의미인지 알아보려고 한다.</p>\n\n<p>이에 대해 자세히 알아보자.</p>\n\n<p><br /></p>\n\n<h1 id=\"2-동기와-비동기\">2. 동기와 비동기</h1>\n\n<p><img src=\"https://velog.velcdn.com/images/jinho7/post/a47f1973-3895-4438-a47f-80dd80245e41/image.png\" alt=\"\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<blockquote>\n  <p>동기와 비동기는 “작업의 처리 방식”을 나타내는 개념이다. <br />\n결론부터 말하자면, 이둘의 주요한 차이점은 “작업 순서 처리 차이”이다.</p>\n</blockquote>\n\n<h2 id=\"2-1-동기-순차적으로-실행\">2-1. 동기: 순차적으로 실행</h2>\n<p>필자는 이전에 동기를 <strong>겹치지 않고 순차적으로 작업을 진행하는 것</strong> 정도로 이해하고 있었다.</p>\n\n<p>영어 사전을 참고해보자.</p>\n\n<blockquote>\n  <p>synchronous\nadjective\nhappening or done at the same time or speed:</p>\n</blockquote>\n\n<p><strong>Synchronous</strong> 는 동시에 발생하는 두 개 이상의 사건이나 프로세스가 동일한 시간에서 진행되는 것을 의미하는 형용사이다.</p>\n\n<p>중요한 워딩은 [동일한 시간에 여러 개의 사건이 진행] 된다는 것이다.</p>\n\n<p>‘순차적’과 ‘동시’라는 단어가 서로 상충된다고 생각할 수 있다.</p>\n\n<p>여기서 오해하면 안되는 것이 이는 <strong>병렬적인 작업방식을 말하는 것이 아니다.</strong></p>\n\n<p>“어떠한 일정 시점에 현재 작업의 Response과 다음 작업의 Request이 함께 진행되는 것”</p>\n\n<p>위의 그림을 참고하면 이해가 쉽다.\n작업 A가 끝나는 시간과 작업 B가 시작하는 시간이 동기화된다고 이해하면 좋을 것 같다.</p>\n\n<p>이는 <strong>작업이 순차적으로 처리되며, 이전 작업이 완료될 때까지는 다음 작업이 시작되지 않음을 나타낸다.</strong></p>\n\n<p>즉, <strong>작업들이 서로 시간적 의존성을 가지고 실행된다</strong>는 뜻이다.</p>\n\n<p>동기 방식은 실행 순서가 보장되며 예측 가능하다는 장점이 있지만, <br />\n앞선 작업이 오래 걸리면 전체 작업이 지연된다는 단점도 있다.</p>\n\n<h2 id=\"2-2-비동기-독립적으로-실행\">2-2. 비동기: 독립적으로 실행</h2>\n<p>그렇다면 비동기 방식은 무엇일까?</p>\n\n<p>반대의 경우를 생각하면 된다.</p>\n\n<p>위의 그림을 참고하면 작업들이 병렬적으로 일어나고 있음을 알 수 있다.</p>\n\n<p>동기와 반대로 <strong>“요청을 보냈을 때 응답 상태와 상관없이 다른 동작을 수행할 수 있다.”</strong>는 점이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/0a188e4a-b35f-41aa-9953-94504330dd9f\" alt=\"다운로드\" width=\"68%\" height=\"50%\" class=\"center\" />\n<em class=\"image-caption\">파일 다운로드가 동기 방식이라면?</em></p>\n\n<p>만약에 파일 다운로드를 동기적으로 처리한다고 해보자.</p>\n\n<p>아마 파일이 다운로드될 때까지 아무런 작업도 수행할 수 없을 것이고,\n파일이 완전히 다운로드된 후에 다음 작업을 진행할 수 있을 것이다. 😅</p>\n\n<p>매우 비효율적인 방식이다…</p>\n\n<p>그러나 비동기적인 방식을 활용한다면, 파일 다운로드 작업을 시작시켜놓고, 다른 작업을 수행할 수 있다.</p>\n\n<p>파일이 다운로드되면 특정 콜백 함수를 호출하여, 다운로드된 파일을 처리하거나 결과를 반환받을 수 있다.</p>\n\n<p>콜백 뿐만이 아니고, 그 결과는 콜백 함수, Promise, 이벤트 등을 통해 전달받을 수 있다.</p>\n\n<p>마치 택배를 주문하고 배송 알림을 받는 것과 비슷하다고 할 수 있다.</p>\n\n<h3 id=\"비동기-동작-방식에-대한-오해\">비동기 동작 방식에 대한 오해</h3>\n<p>많은 개발자들이 <strong>비동기 = 멀티 쓰레드</strong>라고 이해하고 있다.</p>\n\n<p>단순히 생각해보아도, 여러 작업이 동시에 처리되는 비동기 동작을 구현하기 위해서는 당연히 여러 개의 쓰레드가 필요할 것 같기 때문이다.</p>\n\n<p>또한, 특히나 대부분의 Java 개발자들이 비동기 프로그래밍을 접할 때 아래와 같은 코드를 통해 배우기 때문이다.</p>\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 여기서 실제로 별도의 스레드에서 실행됨</span>\n    <span class=\"k\">return</span> <span class=\"nf\">heavyTask</span><span class=\"o\">();</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p>우리는 Java에서 비동기 처리에 대해 다룰 때, ExecutorService나 CompletableFuture와 같은 도구들을 함께 배운다.</p>\n\n<p>이들은 내부적으로 <strong>스레드 풀</strong>을 사용하기 때문에, 자연스럽게 비동기 처리와 멀티 쓰레드를 동일시하게 된다.</p>\n\n<p>실제로 Spring Framework의 @Async 어노테이션도 비동기 처리를 위해 기본적으로 스레드 풀을 사용한다.</p>\n\n<p>하지만 비동기 처리의 본질은 <strong>“작업의 완료를 기다리지 않고 다른 작업을 수행할 수 있는 것”</strong>이다.</p>\n\n<p>이는 반드시 멀티스레드로만 구현되어야 하는 것이 아니며, Node.js가 좋은 예시다.</p>\n\n<p>Node.js는 싱글 스레드 기반의 이벤트 루프를 사용하여 비동기 처리를 구현한다.</p>\n\n<p>이벤트 루프는 OS의 비동기 I/O 기능을 활용하여 실제 I/O 작업을 커널 레벨에서 처리하고,</p>\n\n<p>작업이 완료되면 이벤트를 통해 알림을 받는 방식으로 동작한다.</p>\n\n<div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Node.js의 비동기 처리 (싱글스레드)</span>\n<span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nf\">readFile</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">file.txt</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">파일 읽기 완료</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">다음 작업 실행</span><span class=\"dl\">'</span><span class=\"p\">);</span>  <span class=\"c1\">// 파일 읽기를 기다리지 않고 실행</span>\n</code></pre></div></div>\n<p>이러한 이벤트 루프 기반의 비동기 처리는 멀티스레드 없이도 효율적인 비동기 처리를 가능하게 한다.\nOS의 비동기 I/O 기능을 활용하여, 실제 I/O 작업은 커널 레벨에서 처리되고, 완료되면 이벤트를 통해 알림을 받는 방식이다.\n<em>정확히는 JavaScript 엔진이 싱글 스레드 기반이다</em>\n<em>해당 내용에 대해 더 자세히 알고 싶다면 <a href=\"https://puleugo.tistory.com/133\">해당 블로그</a>를 참고하자</em></p>\n\n<p><br /></p>\n\n<h1 id=\"3-블로킹과-논블로킹\">3. 블로킹과 논블로킹</h1>\n<blockquote>\n  <p>블로킹과 논블로킹은 “제어권의 이동” 관점에서 바라보는 개념이다.</p>\n</blockquote>\n\n<p>결국 “호출한 함수가 다른 일을 할 수 있는가?”의 여부를 의미한다.</p>\n\n<h2 id=\"3-1-제어권control-flow의-의미\">3-1. 제어권(Control Flow)의 의미</h2>\n<p>여기서 <strong>제어권</strong>이란 어떤 의미를 갖는지 먼저 보자.\nOS적인 관점에서 보자면, <strong>현재 작업을 진행하고 있는 함수가 CPU를 점유하는 것</strong>을 의미한다.\n쉽게 말해 “코드를 실행시킬 수 있는 권한” 정도로 말할 수 있다.</p>\n\n<p>동기 와 비동기는 Jobs 들이 순서대로 혹은 독립적으로 처리되는가에 관한 이야기라면,\n이번에는 호출한 함수가 별개의 일을 할 수 있는지의 이야기이다.</p>\n\n<h2 id=\"3-2-블로킹-제어권을-넘겨주는-방식\">3-2. 블로킹: 제어권을 넘겨주는 방식</h2>\n<p>마치 시험지를 넘겨주는 방식을 생각하면 편할 것 같다.\n<img src=\"https://github.com/user-attachments/assets/6eb36e86-150c-4144-86ce-6080ef86bece\" alt=\"image\" width=\"60%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : https://www.veritas-a.com/news/articleView.html?idxno=156699</em></p>\n\n<p>내가 뒷 사람에게 시험지를 넘겨줄 때,\n나는 아무런 행동도 하지 않고 <strong>뒷 사람(호출된 함수)가 시험지를 가져가는(자신의 작업을 완료)할 때 까지</strong> 나는 손에 시험지를 쥐고 뒷사람을 바라보고 대기할 수 밖에 없다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d799e31b-9406-44f3-8dcc-9df15b8f8a79\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>둘 간의 구분 방법은 제어권이 누구에게 있는지로 결정된다.</p>\n\n<p>블로킹에서는 함수 A가 함수 B를 호출할 때 제어권이 B로 넘어간다.</p>\n\n<p>제어권을 넘겨준 A는 B의 작업이 완료될 때까지 아무 작업도 수행할 수 없는 상태, 즉 블로킹 상태가 된다.</p>\n\n<p>즉, 위의 사진에서 A함수는 B함수에게 제어권을 넘겨줌과 동시에 함수 실행이 일시 정지된다. = Blocking</p>\n\n<h2 id=\"3-3-논블로킹-제어권을-유지하는-방식\">3-3. 논블로킹: 제어권을 유지하는 방식</h2>\n<p>하지만 시험지를 그냥 뒷 사람 책상에 올려 놓는다면 어떨까.</p>\n\n<p>나는 실제 뒷 사람이 받는 것을 대기할 필요없이, 바로 나의 다른 작업을 할 수 있다.</p>\n\n<p>즉, 뒷 사람(호출된 함수)이 나에 대한 제어권을 바로 반환해줌으로, 호출한 쪽(나)에서는 계속 다른 작업을 할 수 있는 것이다.</p>\n\n<p>같은 “읽기” 작업이어도 동기와 비동기 처리에 따라 어떻게 다르게 동작하는지 보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹: 제어권을 넘겨줌</span>\n<span class=\"nc\">String</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">readFile</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 파일 읽을 때까지 다른 일 못함</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                          <span class=\"c1\">// 파일 다 읽고 나서야 실행</span>\n\n<span class=\"c1\">// 논블로킹: 제어권을 유지</span>\n<span class=\"nc\">Future</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">readFileAsync</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 요청만 하고</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                               <span class=\"c1\">// 바로 다른 일 할 수 있음</span>\n</code></pre></div></div>\n<p><img src=\"https://github.com/user-attachments/assets/4a59addb-b12d-4eaa-90c9-fe783a7556e0\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>반면 논블로킹에서는 A함수가 B함수를 호출하더라도 제어권을 계속 유지한다.</p>\n\n<p>따라서 B함수가 실행되는 동안에도, A함수는 제어권을 가지고 있기 때문에 다른 작업을 수행할 수 있다.</p>\n\n<p>이렇게 호출자(caller)인 A함수는 B함수의 작업 완료 여부와 관계없이 자신의 작업을 계속 수행할 수 있다.</p>\n\n<p><br /></p>\n\n<h1 id=\"4-네-가지-조합의-동작-방식\">4. 네 가지 조합의 동작 방식</h1>\n\n<p>가끔 동기 처리에서는 무조건적으로 블로킹이 일어나고, 비동기에서는 논블로킹이 일어난다고 오해하는 경우가 많다.</p>\n\n<p>하지만 두 쌍의 개념은 서로 다른 관점에서 바라보는 개념이라는 것을 확실하게 하고 넘어가자.</p>\n\n<blockquote>\n  <p>동기/비동기 : 작업들의 시간적 관계성 <br />\n블로킹/논블로킹 : 제어권의 소재</p>\n</blockquote>\n\n<p>하지만 이 개념들이 오해가 잦은 이유는 실제 구현에서 [동기/볼로킹 &amp; 비동기/논블로킹]이 <strong>자주 함께 사용</strong>되기 때문이다.</p>\n\n<p>다음 그림을 보고 4가지 조합에 대해 천천히 살펴보자.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b894be55-d296-424d-913f-ee989233eb60\" alt=\"image\" width=\"100%\" class=\"center\" /></p>\n\n<p>먼저 흔히 쓰이는 [동기/볼로킹 &amp; 비동기/논블로킹] 에 대해 보자.</p>\n\n<h2 id=\"4-1-동기--블로킹\">4-1. 동기 + 블로킹</h2>\n\n<p>작업의 흐름이 순차적으로 진행되는 것이 보장된다. (<strong>동기</strong>)</p>\n\n<p>제어권을 함수 B에게 넘겨준 후 함수 A는 대기하게 된다. (<strong>블로킹</strong>)</p>\n\n<p>함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄 때까지 함수 A는 기다리는 것이다.</p>\n\n<blockquote>\n  <p>이러한 조합은 <strong>작업이 완료될 때까지 기다려야 하는 경우</strong>에 사용된다. <br />\n예를 들면, 파일을 읽은 후 이를 처리하는 코드를 생각해보자. <br />\n파일을 처리하는 과정은 <strong>필연적으로 파일을 모두 읽은 후에 작업이 가능</strong>하기 때문이다. <br />\n또한, 일반적으로 작업이 간단하거나 작업량이 적은 경우에 사용된다. <br />\n작업량이 많거나 오래 걸리는 작업을 해당 방식으로 처리하면 <strong>전체 프로그램이 멈춘 것 처럼 보여</strong> 사용자 경험 측면에서 나빠질 수 있다.</p>\n</blockquote>\n\n<h2 id=\"4-2-비동기--논블로킹\">4-2. 비동기 + 논블로킹</h2>\n\n<p>비동기 + 논블로킹 방식도 비교적 이해가 쉽다.</p>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다. (<strong>논블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 방식이다. (<strong>동기</strong>)</p>\n\n<p>함수 B를 호출 할 때, 콜백 함수를 함께 줌으로써, 함수 B는 자신의 작업이 끝났을 때 <strong>함수 A에게 준 콜백 함수를 실행시켜 자신의 작업이 끝났음</strong>을 알려준다.</p>\n\n<p>작업 A는 함수 B의 종료 여부에는 일단 관심이 없다.</p>\n\n<p>B 함수가 자신의 실행을 완료했다면, A 함수의 어깨를 톡톡 쳐서 알려주면 되는 것이다.</p>\n\n<blockquote>\n  <p>다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우에 활용할 수 있다. <br />\n또한, 대용량의 데이터를 처리하는 서비스에서 흔히 사용된다. <br />\n가장 큰 특징은 호출 함수에 콜백 함수를 넣었다는 점이다.</p>\n</blockquote>\n\n<h2 id=\"4-3-동기--논블로킹\">4-3. 동기 + 논블로킹</h2>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다.</p>\n\n<p>이후 바로 자신의 코드를 실행한다. (<strong>논블로킹</strong>)</p>\n\n<p>즉, 다른 작업이 진행되는 동안에도 자신의 작업을 별개로 처리할 수 있다.</p>\n\n<p>조심할 것이 함수 A는 함수 B의 Return 값을 필요로 하는 것은 변함이 없다는 점이다.</p>\n\n<p>A 함수는 B 함수의 리턴값이 필요하기 때문에, 중간중간 B 함수에게 함수 실행을 완료했는지 물어본다.</p>\n\n<p>즉, A 함수(caller)가 B 함수(callee)의 실행이 종료되었는지 계속 예의 주시해야 한다. (순서 보장을 위해)</p>\n\n<p>이로써 작업을 순차대로 수행할 수 있는 것이다. (<strong>동기</strong>)</p>\n\n<p>여기서 조금 더 깊게 생각해보자.</p>\n\n<p>어떻게 동기적으로 진행되면서 메인 쓰레드가 논블로킹이 될 수 있을까?</p>\n\n<p>이 조합의 특징은 “작업 완료는 비동기로 처리하지만, 호출자는 필요할 때 결과를 동기적으로 받는다.”로 정리할 수 있다.</p>\n\n<p>즉, <strong>순서를 유지하면서 결과를 사용해야 할 때 동기적으로 기다릴 수 있다.</strong></p>\n\n<p>결국 <strong>동기적</strong> 이라는 말은 <strong>호출자의 결과가 필요한 시점에서 순서를 보장</strong>하며 작업을 진행한다는 것이다.</p>\n\n<p>다음 JAVA 코드의 예시를 봐보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SimpleDownloader</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>  <span class=\"c1\">// 다운로드 진행률</span>\n        \n        <span class=\"c1\">// 다운로드 시작</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"파일 다운로드를 시작합니다.\"</span><span class=\"o\">);</span>\n        \n        <span class=\"c1\">// 진행률 확인하면서 다른 작업 수행 (논블로킹)</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">downloadProgress</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">{</span>  <span class=\"c1\">// 동기적: 순서 보장</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"진행률: \"</span> <span class=\"o\">+</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">+</span> <span class=\"s\">\"%\"</span><span class=\"o\">);</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다른 작업을 할 수 있어요!\"</span><span class=\"o\">);</span>\n            \n            <span class=\"c1\">// 진행률이 증가한다고 가정</span>\n            <span class=\"n\">downloadProgress</span> <span class=\"o\">+=</span> <span class=\"mi\">20</span><span class=\"o\">;</span>\n            \n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>  <span class=\"c1\">// 1초 대기</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        \n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다운로드 완료!\"</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><em>🚨 주의: 이 예시 코드는 Thread를 사용하고 있다. <br />\nThread는 기본적으로 작업을 병렬적으로 처리하기 위한 도구이다. <br />\n비동기 프로그래밍에서는 이러한 Thread의 병렬 처리 능력을 활용하여 비동기 작업을 구현하는 것이 일반적이다. <br />\n하지만 이 예시의 주된 목적은 작업이 어떻게 논블로킹하면서도 동기적으로 처리될 수 있는지를 시각적으로 보여주는 것이다. <br />\nThread를 사용한 것은 개념을 쉽게 설명하기 위한 것이다.</em></p>\n\n<p>이 코드의 결과는 다음과 같을 것이다.</p>\n<div class=\"language-css highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">나는</span> <span class=\"nt\">다른</span> <span class=\"nt\">작업을</span> <span class=\"nt\">진행할게</span><span class=\"o\">.</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">시작</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">0</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">1</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">2</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">완료</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드</span> <span class=\"nt\">종료</span> <span class=\"nt\">확인</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">모든</span> <span class=\"nt\">작업</span> <span class=\"nt\">완료</span><span class=\"o\">.</span>\n</code></pre></div></div>\n\n<p>물론, 논블로킹 메서드로 비동기 작업을 시작하더라도, 결과를 기다려야 하는 시점에서는 블로킹처럼 동작할 수 있다. <br />\n왜냐하면 메인 스레드가 결과를 받아야만 다음 작업을 진행할 수 있기 때문에, 그 시점에서는 블로킹이 되는 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b43ec8c4-9783-4fbf-9f7a-3736dff051bb\" alt=\"image\" width=\"80%\" class=\"center\" /></p>\n\n<p>사실 이러한 방식의 구현은 흔치 않다. <br />\n하지만, 몇 가지 활용 예를 알아보자면 <strong>게임 로딩화면 구성</strong> 등에 활용될 수 있다. <br />\n보통 게임에서 패치나 다운로드를 할 때, 사용자에게 ProgressBar나 게임 Tip등을 띄워줘야 할 때가 있다. <br />\n이 때는 Load 하는 동작이 완료될 때 까지 (작업 순서는 보장 = Sync) <br />\n다른 작업이 진행될 수 있다. (Non-Blocking)\n즉, 사용자 경험 측면에서 유용하게 활용될 수 있다.</p>\n\n<blockquote>\n  <p>언어 간에는 구현 방식에 차이가 있을 수 있다. <br />\n이는 각 언어의 특성과 제공되는 라이브러리나 기술에 따라 달라질 수 있다. <br />\n예를 들어, JavaScript는 단일 스레드 기반으로 동작하며, 콜백 함수, 프로미스(Promise), async/await 등의 메커니즘을 사용해 동기와 논블로킹 처리를 구현할 수 있다. <br />\n기본적으로 Promise.then 방식은 비동기적이고 논블로킹 방식으로 처리된다. <br />\n그러나 async/await 키워드를 사용하면, 비동기 작업의 순서를 지정할 수 있다.<br />\n중요한 점은, async 함수가 내부적으로 비동기적으로 동작하며, 메인 콜 스택이 모두 비워져야 실행된다는 것이다. <br />\n이로 인해 async/await도 내부적으로는 여전히 비동기적이고 논블로킹 방식으로 동작한다는 점을 유의해야 한다.\n(동기적인 코드 흐름처럼 보이게 하는 트릭)</p>\n</blockquote>\n\n<h2 id=\"4-4-비동기--블로킹\">4-4. 비동기 + 블로킹</h2>\n\n<p>이러한 방식은 사실 실무에서 마주치기 더더욱 흔치 않다.</p>\n\n<p>개념만 간단히 설명하자면,</p>\n\n<p>다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다린다. (<strong>블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않고, 콜백함수를 보낸 후 기다린다.</p>\n\n<p>이로써 작업 완료의 순서는 보장되지 않을 수 있다. (<strong>비동기</strong>)</p>\n\n<p><strong>즉, 함수 A는 자신과 관련없는 함수 B의 작업이 끝날 때까지 기다려야 한다.</strong>\n<em>매우 비효율적인 로직…</em></p>\n\n<p>1 작업 중에 2 작업을 해야지 Async의 이점을 살릴 수 있는 것인데,\n이것을 다시 Blocking 방식을 사용함여 대기시킴으로써 이점을 제거해버린 것이다…😅\n대부분의 경우 비동기+논블로킹 모델이 더 효율적인 선택이 될 것이다.</p>\n\n<p><br /></p>\n\n<h1 id=\"5-현대-프로그래밍에서-이러한-개념이-왜-중요한가\">5. 현대 프로그래밍에서 이러한 개념이 왜 중요한가?</h1>\n\n<p>이러한 이해는 현대 소프트웨어 개발에서 매우 중요하다. 오늘날의 애플리케이션들은 수많은 동시다발적인 작업을 처리해야 한다. 사용자는 파일을 다운로드하면서 동시에 문서를 편집하길 원하고, 데이터가 백그라운드에서 처리되는 동안에도 끊김 없는 인터페이스 사용을 기대한다.</p>\n\n<p>더군다나 클라우드 컴퓨팅과 마이크로서비스 아키텍처가 보편화된 현대 개발 환경에서는, 네트워크를 통한 수많은 비동기 작업들이 동시에 발생한다. 이때 각 작업을 어떻게 처리할지, 작업 간의 의존성은 어떻게 관리할지를 결정하는 것은 시스템의 성능과 사용자 경험을 좌우하는 핵심 요소가 된다.</p>\n\n<p>결국 이러한 개념들의 이해는 단순히 기술적인 지식을 넘어서, 현대 소프트웨어가 직면한 복잡성과 사용자 경험의 요구사항을 어떻게 조화롭게 해결할 수 있을지에 대한 통찰을 제공한다. 이는 우리가 더 효율적이고, 반응성 높은, 그리고 사용자 친화적인 소프트웨어를 설계하고 구현하는 데 있어 필수적인 기반이 될 것이다.</p>\n\n<h1 id=\"6-마무리\">6. 마무리</h1>\n<p>그렇다면 Java에서는 이러한 비동기 처리를 어떻게 구현할 수 있을까?</p>\n\n<p>Java의 비동기 프로그래밍은 Thread를 시작으로, 현대적인 CompletableFuture까지 꾸준히 발전해왔다.</p>\n\n<p>이제 각각의 방식을 자세히 살펴보겠다.</p>\n",
                        "tags": ["Java","Spring-Boot","Backend","Sync","Async","Concurrency","Blocking","NonBlocking"]
                    }
                
            ],
        
            "Sync": [
                
                    {
                        "title": "동기/비동기와 블로킹/논블로킹에 대해 깊이 파헤치기",
                        "url": "/2025/01/12/understanding-sync-async-blocking-non-blocking.html",
                        "subtitle": "Java/SpringBoot에서의 비동기 처리",
                        "excerpt": "1. 개념적 이해\n",
                        "author": "Jinho",
                        "date": "January 12, 2025",
                        "background": "/img/posts/sync-async-concept.jpeg",
                        "content": "<h1 id=\"1-개념적-이해\">1. 개념적 이해</h1>\n\n<p>비동기 처리에 대해 이야기하기 앞서, 과연 “동기”란 어떤 것인지부터 바로 잡고 가려고한다.</p>\n\n<p>왜냐하면 <strong>비(非)동기</strong>란 동기가 아니다라는 의미이기 때문에 동기가 무엇인지부터 정확히 하고 싶었다.</p>\n\n<p>또한 나는 처음에 ‘동기=블로킹, 비동기=논블로킹’이라고 단순하게 이해하고 있었다.</p>\n\n<p>하지만 실제로는 두 개념이 분류 기준이 전혀 다른 독립적인 개념이라는 것을 알게 되었다.</p>\n\n<p>이렇듯 서로 혼동되어 쓰이는 각 명칭은 어떤 의미인지 알아보려고 한다.</p>\n\n<p>이에 대해 자세히 알아보자.</p>\n\n<p><br /></p>\n\n<h1 id=\"2-동기와-비동기\">2. 동기와 비동기</h1>\n\n<p><img src=\"https://velog.velcdn.com/images/jinho7/post/a47f1973-3895-4438-a47f-80dd80245e41/image.png\" alt=\"\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<blockquote>\n  <p>동기와 비동기는 “작업의 처리 방식”을 나타내는 개념이다. <br />\n결론부터 말하자면, 이둘의 주요한 차이점은 “작업 순서 처리 차이”이다.</p>\n</blockquote>\n\n<h2 id=\"2-1-동기-순차적으로-실행\">2-1. 동기: 순차적으로 실행</h2>\n<p>필자는 이전에 동기를 <strong>겹치지 않고 순차적으로 작업을 진행하는 것</strong> 정도로 이해하고 있었다.</p>\n\n<p>영어 사전을 참고해보자.</p>\n\n<blockquote>\n  <p>synchronous\nadjective\nhappening or done at the same time or speed:</p>\n</blockquote>\n\n<p><strong>Synchronous</strong> 는 동시에 발생하는 두 개 이상의 사건이나 프로세스가 동일한 시간에서 진행되는 것을 의미하는 형용사이다.</p>\n\n<p>중요한 워딩은 [동일한 시간에 여러 개의 사건이 진행] 된다는 것이다.</p>\n\n<p>‘순차적’과 ‘동시’라는 단어가 서로 상충된다고 생각할 수 있다.</p>\n\n<p>여기서 오해하면 안되는 것이 이는 <strong>병렬적인 작업방식을 말하는 것이 아니다.</strong></p>\n\n<p>“어떠한 일정 시점에 현재 작업의 Response과 다음 작업의 Request이 함께 진행되는 것”</p>\n\n<p>위의 그림을 참고하면 이해가 쉽다.\n작업 A가 끝나는 시간과 작업 B가 시작하는 시간이 동기화된다고 이해하면 좋을 것 같다.</p>\n\n<p>이는 <strong>작업이 순차적으로 처리되며, 이전 작업이 완료될 때까지는 다음 작업이 시작되지 않음을 나타낸다.</strong></p>\n\n<p>즉, <strong>작업들이 서로 시간적 의존성을 가지고 실행된다</strong>는 뜻이다.</p>\n\n<p>동기 방식은 실행 순서가 보장되며 예측 가능하다는 장점이 있지만, <br />\n앞선 작업이 오래 걸리면 전체 작업이 지연된다는 단점도 있다.</p>\n\n<h2 id=\"2-2-비동기-독립적으로-실행\">2-2. 비동기: 독립적으로 실행</h2>\n<p>그렇다면 비동기 방식은 무엇일까?</p>\n\n<p>반대의 경우를 생각하면 된다.</p>\n\n<p>위의 그림을 참고하면 작업들이 병렬적으로 일어나고 있음을 알 수 있다.</p>\n\n<p>동기와 반대로 <strong>“요청을 보냈을 때 응답 상태와 상관없이 다른 동작을 수행할 수 있다.”</strong>는 점이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/0a188e4a-b35f-41aa-9953-94504330dd9f\" alt=\"다운로드\" width=\"68%\" height=\"50%\" class=\"center\" />\n<em class=\"image-caption\">파일 다운로드가 동기 방식이라면?</em></p>\n\n<p>만약에 파일 다운로드를 동기적으로 처리한다고 해보자.</p>\n\n<p>아마 파일이 다운로드될 때까지 아무런 작업도 수행할 수 없을 것이고,\n파일이 완전히 다운로드된 후에 다음 작업을 진행할 수 있을 것이다. 😅</p>\n\n<p>매우 비효율적인 방식이다…</p>\n\n<p>그러나 비동기적인 방식을 활용한다면, 파일 다운로드 작업을 시작시켜놓고, 다른 작업을 수행할 수 있다.</p>\n\n<p>파일이 다운로드되면 특정 콜백 함수를 호출하여, 다운로드된 파일을 처리하거나 결과를 반환받을 수 있다.</p>\n\n<p>콜백 뿐만이 아니고, 그 결과는 콜백 함수, Promise, 이벤트 등을 통해 전달받을 수 있다.</p>\n\n<p>마치 택배를 주문하고 배송 알림을 받는 것과 비슷하다고 할 수 있다.</p>\n\n<h3 id=\"비동기-동작-방식에-대한-오해\">비동기 동작 방식에 대한 오해</h3>\n<p>많은 개발자들이 <strong>비동기 = 멀티 쓰레드</strong>라고 이해하고 있다.</p>\n\n<p>단순히 생각해보아도, 여러 작업이 동시에 처리되는 비동기 동작을 구현하기 위해서는 당연히 여러 개의 쓰레드가 필요할 것 같기 때문이다.</p>\n\n<p>또한, 특히나 대부분의 Java 개발자들이 비동기 프로그래밍을 접할 때 아래와 같은 코드를 통해 배우기 때문이다.</p>\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 여기서 실제로 별도의 스레드에서 실행됨</span>\n    <span class=\"k\">return</span> <span class=\"nf\">heavyTask</span><span class=\"o\">();</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p>우리는 Java에서 비동기 처리에 대해 다룰 때, ExecutorService나 CompletableFuture와 같은 도구들을 함께 배운다.</p>\n\n<p>이들은 내부적으로 <strong>스레드 풀</strong>을 사용하기 때문에, 자연스럽게 비동기 처리와 멀티 쓰레드를 동일시하게 된다.</p>\n\n<p>실제로 Spring Framework의 @Async 어노테이션도 비동기 처리를 위해 기본적으로 스레드 풀을 사용한다.</p>\n\n<p>하지만 비동기 처리의 본질은 <strong>“작업의 완료를 기다리지 않고 다른 작업을 수행할 수 있는 것”</strong>이다.</p>\n\n<p>이는 반드시 멀티스레드로만 구현되어야 하는 것이 아니며, Node.js가 좋은 예시다.</p>\n\n<p>Node.js는 싱글 스레드 기반의 이벤트 루프를 사용하여 비동기 처리를 구현한다.</p>\n\n<p>이벤트 루프는 OS의 비동기 I/O 기능을 활용하여 실제 I/O 작업을 커널 레벨에서 처리하고,</p>\n\n<p>작업이 완료되면 이벤트를 통해 알림을 받는 방식으로 동작한다.</p>\n\n<div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Node.js의 비동기 처리 (싱글스레드)</span>\n<span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nf\">readFile</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">file.txt</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">파일 읽기 완료</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">다음 작업 실행</span><span class=\"dl\">'</span><span class=\"p\">);</span>  <span class=\"c1\">// 파일 읽기를 기다리지 않고 실행</span>\n</code></pre></div></div>\n<p>이러한 이벤트 루프 기반의 비동기 처리는 멀티스레드 없이도 효율적인 비동기 처리를 가능하게 한다.\nOS의 비동기 I/O 기능을 활용하여, 실제 I/O 작업은 커널 레벨에서 처리되고, 완료되면 이벤트를 통해 알림을 받는 방식이다.\n<em>정확히는 JavaScript 엔진이 싱글 스레드 기반이다</em>\n<em>해당 내용에 대해 더 자세히 알고 싶다면 <a href=\"https://puleugo.tistory.com/133\">해당 블로그</a>를 참고하자</em></p>\n\n<p><br /></p>\n\n<h1 id=\"3-블로킹과-논블로킹\">3. 블로킹과 논블로킹</h1>\n<blockquote>\n  <p>블로킹과 논블로킹은 “제어권의 이동” 관점에서 바라보는 개념이다.</p>\n</blockquote>\n\n<p>결국 “호출한 함수가 다른 일을 할 수 있는가?”의 여부를 의미한다.</p>\n\n<h2 id=\"3-1-제어권control-flow의-의미\">3-1. 제어권(Control Flow)의 의미</h2>\n<p>여기서 <strong>제어권</strong>이란 어떤 의미를 갖는지 먼저 보자.\nOS적인 관점에서 보자면, <strong>현재 작업을 진행하고 있는 함수가 CPU를 점유하는 것</strong>을 의미한다.\n쉽게 말해 “코드를 실행시킬 수 있는 권한” 정도로 말할 수 있다.</p>\n\n<p>동기 와 비동기는 Jobs 들이 순서대로 혹은 독립적으로 처리되는가에 관한 이야기라면,\n이번에는 호출한 함수가 별개의 일을 할 수 있는지의 이야기이다.</p>\n\n<h2 id=\"3-2-블로킹-제어권을-넘겨주는-방식\">3-2. 블로킹: 제어권을 넘겨주는 방식</h2>\n<p>마치 시험지를 넘겨주는 방식을 생각하면 편할 것 같다.\n<img src=\"https://github.com/user-attachments/assets/6eb36e86-150c-4144-86ce-6080ef86bece\" alt=\"image\" width=\"60%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : https://www.veritas-a.com/news/articleView.html?idxno=156699</em></p>\n\n<p>내가 뒷 사람에게 시험지를 넘겨줄 때,\n나는 아무런 행동도 하지 않고 <strong>뒷 사람(호출된 함수)가 시험지를 가져가는(자신의 작업을 완료)할 때 까지</strong> 나는 손에 시험지를 쥐고 뒷사람을 바라보고 대기할 수 밖에 없다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d799e31b-9406-44f3-8dcc-9df15b8f8a79\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>둘 간의 구분 방법은 제어권이 누구에게 있는지로 결정된다.</p>\n\n<p>블로킹에서는 함수 A가 함수 B를 호출할 때 제어권이 B로 넘어간다.</p>\n\n<p>제어권을 넘겨준 A는 B의 작업이 완료될 때까지 아무 작업도 수행할 수 없는 상태, 즉 블로킹 상태가 된다.</p>\n\n<p>즉, 위의 사진에서 A함수는 B함수에게 제어권을 넘겨줌과 동시에 함수 실행이 일시 정지된다. = Blocking</p>\n\n<h2 id=\"3-3-논블로킹-제어권을-유지하는-방식\">3-3. 논블로킹: 제어권을 유지하는 방식</h2>\n<p>하지만 시험지를 그냥 뒷 사람 책상에 올려 놓는다면 어떨까.</p>\n\n<p>나는 실제 뒷 사람이 받는 것을 대기할 필요없이, 바로 나의 다른 작업을 할 수 있다.</p>\n\n<p>즉, 뒷 사람(호출된 함수)이 나에 대한 제어권을 바로 반환해줌으로, 호출한 쪽(나)에서는 계속 다른 작업을 할 수 있는 것이다.</p>\n\n<p>같은 “읽기” 작업이어도 동기와 비동기 처리에 따라 어떻게 다르게 동작하는지 보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹: 제어권을 넘겨줌</span>\n<span class=\"nc\">String</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">readFile</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 파일 읽을 때까지 다른 일 못함</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                          <span class=\"c1\">// 파일 다 읽고 나서야 실행</span>\n\n<span class=\"c1\">// 논블로킹: 제어권을 유지</span>\n<span class=\"nc\">Future</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">readFileAsync</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 요청만 하고</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                               <span class=\"c1\">// 바로 다른 일 할 수 있음</span>\n</code></pre></div></div>\n<p><img src=\"https://github.com/user-attachments/assets/4a59addb-b12d-4eaa-90c9-fe783a7556e0\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>반면 논블로킹에서는 A함수가 B함수를 호출하더라도 제어권을 계속 유지한다.</p>\n\n<p>따라서 B함수가 실행되는 동안에도, A함수는 제어권을 가지고 있기 때문에 다른 작업을 수행할 수 있다.</p>\n\n<p>이렇게 호출자(caller)인 A함수는 B함수의 작업 완료 여부와 관계없이 자신의 작업을 계속 수행할 수 있다.</p>\n\n<p><br /></p>\n\n<h1 id=\"4-네-가지-조합의-동작-방식\">4. 네 가지 조합의 동작 방식</h1>\n\n<p>가끔 동기 처리에서는 무조건적으로 블로킹이 일어나고, 비동기에서는 논블로킹이 일어난다고 오해하는 경우가 많다.</p>\n\n<p>하지만 두 쌍의 개념은 서로 다른 관점에서 바라보는 개념이라는 것을 확실하게 하고 넘어가자.</p>\n\n<blockquote>\n  <p>동기/비동기 : 작업들의 시간적 관계성 <br />\n블로킹/논블로킹 : 제어권의 소재</p>\n</blockquote>\n\n<p>하지만 이 개념들이 오해가 잦은 이유는 실제 구현에서 [동기/볼로킹 &amp; 비동기/논블로킹]이 <strong>자주 함께 사용</strong>되기 때문이다.</p>\n\n<p>다음 그림을 보고 4가지 조합에 대해 천천히 살펴보자.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b894be55-d296-424d-913f-ee989233eb60\" alt=\"image\" width=\"100%\" class=\"center\" /></p>\n\n<p>먼저 흔히 쓰이는 [동기/볼로킹 &amp; 비동기/논블로킹] 에 대해 보자.</p>\n\n<h2 id=\"4-1-동기--블로킹\">4-1. 동기 + 블로킹</h2>\n\n<p>작업의 흐름이 순차적으로 진행되는 것이 보장된다. (<strong>동기</strong>)</p>\n\n<p>제어권을 함수 B에게 넘겨준 후 함수 A는 대기하게 된다. (<strong>블로킹</strong>)</p>\n\n<p>함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄 때까지 함수 A는 기다리는 것이다.</p>\n\n<blockquote>\n  <p>이러한 조합은 <strong>작업이 완료될 때까지 기다려야 하는 경우</strong>에 사용된다. <br />\n예를 들면, 파일을 읽은 후 이를 처리하는 코드를 생각해보자. <br />\n파일을 처리하는 과정은 <strong>필연적으로 파일을 모두 읽은 후에 작업이 가능</strong>하기 때문이다. <br />\n또한, 일반적으로 작업이 간단하거나 작업량이 적은 경우에 사용된다. <br />\n작업량이 많거나 오래 걸리는 작업을 해당 방식으로 처리하면 <strong>전체 프로그램이 멈춘 것 처럼 보여</strong> 사용자 경험 측면에서 나빠질 수 있다.</p>\n</blockquote>\n\n<h2 id=\"4-2-비동기--논블로킹\">4-2. 비동기 + 논블로킹</h2>\n\n<p>비동기 + 논블로킹 방식도 비교적 이해가 쉽다.</p>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다. (<strong>논블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 방식이다. (<strong>동기</strong>)</p>\n\n<p>함수 B를 호출 할 때, 콜백 함수를 함께 줌으로써, 함수 B는 자신의 작업이 끝났을 때 <strong>함수 A에게 준 콜백 함수를 실행시켜 자신의 작업이 끝났음</strong>을 알려준다.</p>\n\n<p>작업 A는 함수 B의 종료 여부에는 일단 관심이 없다.</p>\n\n<p>B 함수가 자신의 실행을 완료했다면, A 함수의 어깨를 톡톡 쳐서 알려주면 되는 것이다.</p>\n\n<blockquote>\n  <p>다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우에 활용할 수 있다. <br />\n또한, 대용량의 데이터를 처리하는 서비스에서 흔히 사용된다. <br />\n가장 큰 특징은 호출 함수에 콜백 함수를 넣었다는 점이다.</p>\n</blockquote>\n\n<h2 id=\"4-3-동기--논블로킹\">4-3. 동기 + 논블로킹</h2>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다.</p>\n\n<p>이후 바로 자신의 코드를 실행한다. (<strong>논블로킹</strong>)</p>\n\n<p>즉, 다른 작업이 진행되는 동안에도 자신의 작업을 별개로 처리할 수 있다.</p>\n\n<p>조심할 것이 함수 A는 함수 B의 Return 값을 필요로 하는 것은 변함이 없다는 점이다.</p>\n\n<p>A 함수는 B 함수의 리턴값이 필요하기 때문에, 중간중간 B 함수에게 함수 실행을 완료했는지 물어본다.</p>\n\n<p>즉, A 함수(caller)가 B 함수(callee)의 실행이 종료되었는지 계속 예의 주시해야 한다. (순서 보장을 위해)</p>\n\n<p>이로써 작업을 순차대로 수행할 수 있는 것이다. (<strong>동기</strong>)</p>\n\n<p>여기서 조금 더 깊게 생각해보자.</p>\n\n<p>어떻게 동기적으로 진행되면서 메인 쓰레드가 논블로킹이 될 수 있을까?</p>\n\n<p>이 조합의 특징은 “작업 완료는 비동기로 처리하지만, 호출자는 필요할 때 결과를 동기적으로 받는다.”로 정리할 수 있다.</p>\n\n<p>즉, <strong>순서를 유지하면서 결과를 사용해야 할 때 동기적으로 기다릴 수 있다.</strong></p>\n\n<p>결국 <strong>동기적</strong> 이라는 말은 <strong>호출자의 결과가 필요한 시점에서 순서를 보장</strong>하며 작업을 진행한다는 것이다.</p>\n\n<p>다음 JAVA 코드의 예시를 봐보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SimpleDownloader</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>  <span class=\"c1\">// 다운로드 진행률</span>\n        \n        <span class=\"c1\">// 다운로드 시작</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"파일 다운로드를 시작합니다.\"</span><span class=\"o\">);</span>\n        \n        <span class=\"c1\">// 진행률 확인하면서 다른 작업 수행 (논블로킹)</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">downloadProgress</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">{</span>  <span class=\"c1\">// 동기적: 순서 보장</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"진행률: \"</span> <span class=\"o\">+</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">+</span> <span class=\"s\">\"%\"</span><span class=\"o\">);</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다른 작업을 할 수 있어요!\"</span><span class=\"o\">);</span>\n            \n            <span class=\"c1\">// 진행률이 증가한다고 가정</span>\n            <span class=\"n\">downloadProgress</span> <span class=\"o\">+=</span> <span class=\"mi\">20</span><span class=\"o\">;</span>\n            \n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>  <span class=\"c1\">// 1초 대기</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        \n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다운로드 완료!\"</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><em>🚨 주의: 이 예시 코드는 Thread를 사용하고 있다. <br />\nThread는 기본적으로 작업을 병렬적으로 처리하기 위한 도구이다. <br />\n비동기 프로그래밍에서는 이러한 Thread의 병렬 처리 능력을 활용하여 비동기 작업을 구현하는 것이 일반적이다. <br />\n하지만 이 예시의 주된 목적은 작업이 어떻게 논블로킹하면서도 동기적으로 처리될 수 있는지를 시각적으로 보여주는 것이다. <br />\nThread를 사용한 것은 개념을 쉽게 설명하기 위한 것이다.</em></p>\n\n<p>이 코드의 결과는 다음과 같을 것이다.</p>\n<div class=\"language-css highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">나는</span> <span class=\"nt\">다른</span> <span class=\"nt\">작업을</span> <span class=\"nt\">진행할게</span><span class=\"o\">.</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">시작</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">0</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">1</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">2</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">완료</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드</span> <span class=\"nt\">종료</span> <span class=\"nt\">확인</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">모든</span> <span class=\"nt\">작업</span> <span class=\"nt\">완료</span><span class=\"o\">.</span>\n</code></pre></div></div>\n\n<p>물론, 논블로킹 메서드로 비동기 작업을 시작하더라도, 결과를 기다려야 하는 시점에서는 블로킹처럼 동작할 수 있다. <br />\n왜냐하면 메인 스레드가 결과를 받아야만 다음 작업을 진행할 수 있기 때문에, 그 시점에서는 블로킹이 되는 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b43ec8c4-9783-4fbf-9f7a-3736dff051bb\" alt=\"image\" width=\"80%\" class=\"center\" /></p>\n\n<p>사실 이러한 방식의 구현은 흔치 않다. <br />\n하지만, 몇 가지 활용 예를 알아보자면 <strong>게임 로딩화면 구성</strong> 등에 활용될 수 있다. <br />\n보통 게임에서 패치나 다운로드를 할 때, 사용자에게 ProgressBar나 게임 Tip등을 띄워줘야 할 때가 있다. <br />\n이 때는 Load 하는 동작이 완료될 때 까지 (작업 순서는 보장 = Sync) <br />\n다른 작업이 진행될 수 있다. (Non-Blocking)\n즉, 사용자 경험 측면에서 유용하게 활용될 수 있다.</p>\n\n<blockquote>\n  <p>언어 간에는 구현 방식에 차이가 있을 수 있다. <br />\n이는 각 언어의 특성과 제공되는 라이브러리나 기술에 따라 달라질 수 있다. <br />\n예를 들어, JavaScript는 단일 스레드 기반으로 동작하며, 콜백 함수, 프로미스(Promise), async/await 등의 메커니즘을 사용해 동기와 논블로킹 처리를 구현할 수 있다. <br />\n기본적으로 Promise.then 방식은 비동기적이고 논블로킹 방식으로 처리된다. <br />\n그러나 async/await 키워드를 사용하면, 비동기 작업의 순서를 지정할 수 있다.<br />\n중요한 점은, async 함수가 내부적으로 비동기적으로 동작하며, 메인 콜 스택이 모두 비워져야 실행된다는 것이다. <br />\n이로 인해 async/await도 내부적으로는 여전히 비동기적이고 논블로킹 방식으로 동작한다는 점을 유의해야 한다.\n(동기적인 코드 흐름처럼 보이게 하는 트릭)</p>\n</blockquote>\n\n<h2 id=\"4-4-비동기--블로킹\">4-4. 비동기 + 블로킹</h2>\n\n<p>이러한 방식은 사실 실무에서 마주치기 더더욱 흔치 않다.</p>\n\n<p>개념만 간단히 설명하자면,</p>\n\n<p>다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다린다. (<strong>블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않고, 콜백함수를 보낸 후 기다린다.</p>\n\n<p>이로써 작업 완료의 순서는 보장되지 않을 수 있다. (<strong>비동기</strong>)</p>\n\n<p><strong>즉, 함수 A는 자신과 관련없는 함수 B의 작업이 끝날 때까지 기다려야 한다.</strong>\n<em>매우 비효율적인 로직…</em></p>\n\n<p>1 작업 중에 2 작업을 해야지 Async의 이점을 살릴 수 있는 것인데,\n이것을 다시 Blocking 방식을 사용함여 대기시킴으로써 이점을 제거해버린 것이다…😅\n대부분의 경우 비동기+논블로킹 모델이 더 효율적인 선택이 될 것이다.</p>\n\n<p><br /></p>\n\n<h1 id=\"5-현대-프로그래밍에서-이러한-개념이-왜-중요한가\">5. 현대 프로그래밍에서 이러한 개념이 왜 중요한가?</h1>\n\n<p>이러한 이해는 현대 소프트웨어 개발에서 매우 중요하다. 오늘날의 애플리케이션들은 수많은 동시다발적인 작업을 처리해야 한다. 사용자는 파일을 다운로드하면서 동시에 문서를 편집하길 원하고, 데이터가 백그라운드에서 처리되는 동안에도 끊김 없는 인터페이스 사용을 기대한다.</p>\n\n<p>더군다나 클라우드 컴퓨팅과 마이크로서비스 아키텍처가 보편화된 현대 개발 환경에서는, 네트워크를 통한 수많은 비동기 작업들이 동시에 발생한다. 이때 각 작업을 어떻게 처리할지, 작업 간의 의존성은 어떻게 관리할지를 결정하는 것은 시스템의 성능과 사용자 경험을 좌우하는 핵심 요소가 된다.</p>\n\n<p>결국 이러한 개념들의 이해는 단순히 기술적인 지식을 넘어서, 현대 소프트웨어가 직면한 복잡성과 사용자 경험의 요구사항을 어떻게 조화롭게 해결할 수 있을지에 대한 통찰을 제공한다. 이는 우리가 더 효율적이고, 반응성 높은, 그리고 사용자 친화적인 소프트웨어를 설계하고 구현하는 데 있어 필수적인 기반이 될 것이다.</p>\n\n<h1 id=\"6-마무리\">6. 마무리</h1>\n<p>그렇다면 Java에서는 이러한 비동기 처리를 어떻게 구현할 수 있을까?</p>\n\n<p>Java의 비동기 프로그래밍은 Thread를 시작으로, 현대적인 CompletableFuture까지 꾸준히 발전해왔다.</p>\n\n<p>이제 각각의 방식을 자세히 살펴보겠다.</p>\n",
                        "tags": ["Java","Spring-Boot","Backend","Sync","Async","Concurrency","Blocking","NonBlocking"]
                    }
                
            ],
        
            "Async": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    },
                
                    {
                        "title": "동기/비동기와 블로킹/논블로킹에 대해 깊이 파헤치기",
                        "url": "/2025/01/12/understanding-sync-async-blocking-non-blocking.html",
                        "subtitle": "Java/SpringBoot에서의 비동기 처리",
                        "excerpt": "1. 개념적 이해\n",
                        "author": "Jinho",
                        "date": "January 12, 2025",
                        "background": "/img/posts/sync-async-concept.jpeg",
                        "content": "<h1 id=\"1-개념적-이해\">1. 개념적 이해</h1>\n\n<p>비동기 처리에 대해 이야기하기 앞서, 과연 “동기”란 어떤 것인지부터 바로 잡고 가려고한다.</p>\n\n<p>왜냐하면 <strong>비(非)동기</strong>란 동기가 아니다라는 의미이기 때문에 동기가 무엇인지부터 정확히 하고 싶었다.</p>\n\n<p>또한 나는 처음에 ‘동기=블로킹, 비동기=논블로킹’이라고 단순하게 이해하고 있었다.</p>\n\n<p>하지만 실제로는 두 개념이 분류 기준이 전혀 다른 독립적인 개념이라는 것을 알게 되었다.</p>\n\n<p>이렇듯 서로 혼동되어 쓰이는 각 명칭은 어떤 의미인지 알아보려고 한다.</p>\n\n<p>이에 대해 자세히 알아보자.</p>\n\n<p><br /></p>\n\n<h1 id=\"2-동기와-비동기\">2. 동기와 비동기</h1>\n\n<p><img src=\"https://velog.velcdn.com/images/jinho7/post/a47f1973-3895-4438-a47f-80dd80245e41/image.png\" alt=\"\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<blockquote>\n  <p>동기와 비동기는 “작업의 처리 방식”을 나타내는 개념이다. <br />\n결론부터 말하자면, 이둘의 주요한 차이점은 “작업 순서 처리 차이”이다.</p>\n</blockquote>\n\n<h2 id=\"2-1-동기-순차적으로-실행\">2-1. 동기: 순차적으로 실행</h2>\n<p>필자는 이전에 동기를 <strong>겹치지 않고 순차적으로 작업을 진행하는 것</strong> 정도로 이해하고 있었다.</p>\n\n<p>영어 사전을 참고해보자.</p>\n\n<blockquote>\n  <p>synchronous\nadjective\nhappening or done at the same time or speed:</p>\n</blockquote>\n\n<p><strong>Synchronous</strong> 는 동시에 발생하는 두 개 이상의 사건이나 프로세스가 동일한 시간에서 진행되는 것을 의미하는 형용사이다.</p>\n\n<p>중요한 워딩은 [동일한 시간에 여러 개의 사건이 진행] 된다는 것이다.</p>\n\n<p>‘순차적’과 ‘동시’라는 단어가 서로 상충된다고 생각할 수 있다.</p>\n\n<p>여기서 오해하면 안되는 것이 이는 <strong>병렬적인 작업방식을 말하는 것이 아니다.</strong></p>\n\n<p>“어떠한 일정 시점에 현재 작업의 Response과 다음 작업의 Request이 함께 진행되는 것”</p>\n\n<p>위의 그림을 참고하면 이해가 쉽다.\n작업 A가 끝나는 시간과 작업 B가 시작하는 시간이 동기화된다고 이해하면 좋을 것 같다.</p>\n\n<p>이는 <strong>작업이 순차적으로 처리되며, 이전 작업이 완료될 때까지는 다음 작업이 시작되지 않음을 나타낸다.</strong></p>\n\n<p>즉, <strong>작업들이 서로 시간적 의존성을 가지고 실행된다</strong>는 뜻이다.</p>\n\n<p>동기 방식은 실행 순서가 보장되며 예측 가능하다는 장점이 있지만, <br />\n앞선 작업이 오래 걸리면 전체 작업이 지연된다는 단점도 있다.</p>\n\n<h2 id=\"2-2-비동기-독립적으로-실행\">2-2. 비동기: 독립적으로 실행</h2>\n<p>그렇다면 비동기 방식은 무엇일까?</p>\n\n<p>반대의 경우를 생각하면 된다.</p>\n\n<p>위의 그림을 참고하면 작업들이 병렬적으로 일어나고 있음을 알 수 있다.</p>\n\n<p>동기와 반대로 <strong>“요청을 보냈을 때 응답 상태와 상관없이 다른 동작을 수행할 수 있다.”</strong>는 점이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/0a188e4a-b35f-41aa-9953-94504330dd9f\" alt=\"다운로드\" width=\"68%\" height=\"50%\" class=\"center\" />\n<em class=\"image-caption\">파일 다운로드가 동기 방식이라면?</em></p>\n\n<p>만약에 파일 다운로드를 동기적으로 처리한다고 해보자.</p>\n\n<p>아마 파일이 다운로드될 때까지 아무런 작업도 수행할 수 없을 것이고,\n파일이 완전히 다운로드된 후에 다음 작업을 진행할 수 있을 것이다. 😅</p>\n\n<p>매우 비효율적인 방식이다…</p>\n\n<p>그러나 비동기적인 방식을 활용한다면, 파일 다운로드 작업을 시작시켜놓고, 다른 작업을 수행할 수 있다.</p>\n\n<p>파일이 다운로드되면 특정 콜백 함수를 호출하여, 다운로드된 파일을 처리하거나 결과를 반환받을 수 있다.</p>\n\n<p>콜백 뿐만이 아니고, 그 결과는 콜백 함수, Promise, 이벤트 등을 통해 전달받을 수 있다.</p>\n\n<p>마치 택배를 주문하고 배송 알림을 받는 것과 비슷하다고 할 수 있다.</p>\n\n<h3 id=\"비동기-동작-방식에-대한-오해\">비동기 동작 방식에 대한 오해</h3>\n<p>많은 개발자들이 <strong>비동기 = 멀티 쓰레드</strong>라고 이해하고 있다.</p>\n\n<p>단순히 생각해보아도, 여러 작업이 동시에 처리되는 비동기 동작을 구현하기 위해서는 당연히 여러 개의 쓰레드가 필요할 것 같기 때문이다.</p>\n\n<p>또한, 특히나 대부분의 Java 개발자들이 비동기 프로그래밍을 접할 때 아래와 같은 코드를 통해 배우기 때문이다.</p>\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 여기서 실제로 별도의 스레드에서 실행됨</span>\n    <span class=\"k\">return</span> <span class=\"nf\">heavyTask</span><span class=\"o\">();</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p>우리는 Java에서 비동기 처리에 대해 다룰 때, ExecutorService나 CompletableFuture와 같은 도구들을 함께 배운다.</p>\n\n<p>이들은 내부적으로 <strong>스레드 풀</strong>을 사용하기 때문에, 자연스럽게 비동기 처리와 멀티 쓰레드를 동일시하게 된다.</p>\n\n<p>실제로 Spring Framework의 @Async 어노테이션도 비동기 처리를 위해 기본적으로 스레드 풀을 사용한다.</p>\n\n<p>하지만 비동기 처리의 본질은 <strong>“작업의 완료를 기다리지 않고 다른 작업을 수행할 수 있는 것”</strong>이다.</p>\n\n<p>이는 반드시 멀티스레드로만 구현되어야 하는 것이 아니며, Node.js가 좋은 예시다.</p>\n\n<p>Node.js는 싱글 스레드 기반의 이벤트 루프를 사용하여 비동기 처리를 구현한다.</p>\n\n<p>이벤트 루프는 OS의 비동기 I/O 기능을 활용하여 실제 I/O 작업을 커널 레벨에서 처리하고,</p>\n\n<p>작업이 완료되면 이벤트를 통해 알림을 받는 방식으로 동작한다.</p>\n\n<div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Node.js의 비동기 처리 (싱글스레드)</span>\n<span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nf\">readFile</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">file.txt</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">파일 읽기 완료</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">다음 작업 실행</span><span class=\"dl\">'</span><span class=\"p\">);</span>  <span class=\"c1\">// 파일 읽기를 기다리지 않고 실행</span>\n</code></pre></div></div>\n<p>이러한 이벤트 루프 기반의 비동기 처리는 멀티스레드 없이도 효율적인 비동기 처리를 가능하게 한다.\nOS의 비동기 I/O 기능을 활용하여, 실제 I/O 작업은 커널 레벨에서 처리되고, 완료되면 이벤트를 통해 알림을 받는 방식이다.\n<em>정확히는 JavaScript 엔진이 싱글 스레드 기반이다</em>\n<em>해당 내용에 대해 더 자세히 알고 싶다면 <a href=\"https://puleugo.tistory.com/133\">해당 블로그</a>를 참고하자</em></p>\n\n<p><br /></p>\n\n<h1 id=\"3-블로킹과-논블로킹\">3. 블로킹과 논블로킹</h1>\n<blockquote>\n  <p>블로킹과 논블로킹은 “제어권의 이동” 관점에서 바라보는 개념이다.</p>\n</blockquote>\n\n<p>결국 “호출한 함수가 다른 일을 할 수 있는가?”의 여부를 의미한다.</p>\n\n<h2 id=\"3-1-제어권control-flow의-의미\">3-1. 제어권(Control Flow)의 의미</h2>\n<p>여기서 <strong>제어권</strong>이란 어떤 의미를 갖는지 먼저 보자.\nOS적인 관점에서 보자면, <strong>현재 작업을 진행하고 있는 함수가 CPU를 점유하는 것</strong>을 의미한다.\n쉽게 말해 “코드를 실행시킬 수 있는 권한” 정도로 말할 수 있다.</p>\n\n<p>동기 와 비동기는 Jobs 들이 순서대로 혹은 독립적으로 처리되는가에 관한 이야기라면,\n이번에는 호출한 함수가 별개의 일을 할 수 있는지의 이야기이다.</p>\n\n<h2 id=\"3-2-블로킹-제어권을-넘겨주는-방식\">3-2. 블로킹: 제어권을 넘겨주는 방식</h2>\n<p>마치 시험지를 넘겨주는 방식을 생각하면 편할 것 같다.\n<img src=\"https://github.com/user-attachments/assets/6eb36e86-150c-4144-86ce-6080ef86bece\" alt=\"image\" width=\"60%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : https://www.veritas-a.com/news/articleView.html?idxno=156699</em></p>\n\n<p>내가 뒷 사람에게 시험지를 넘겨줄 때,\n나는 아무런 행동도 하지 않고 <strong>뒷 사람(호출된 함수)가 시험지를 가져가는(자신의 작업을 완료)할 때 까지</strong> 나는 손에 시험지를 쥐고 뒷사람을 바라보고 대기할 수 밖에 없다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d799e31b-9406-44f3-8dcc-9df15b8f8a79\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>둘 간의 구분 방법은 제어권이 누구에게 있는지로 결정된다.</p>\n\n<p>블로킹에서는 함수 A가 함수 B를 호출할 때 제어권이 B로 넘어간다.</p>\n\n<p>제어권을 넘겨준 A는 B의 작업이 완료될 때까지 아무 작업도 수행할 수 없는 상태, 즉 블로킹 상태가 된다.</p>\n\n<p>즉, 위의 사진에서 A함수는 B함수에게 제어권을 넘겨줌과 동시에 함수 실행이 일시 정지된다. = Blocking</p>\n\n<h2 id=\"3-3-논블로킹-제어권을-유지하는-방식\">3-3. 논블로킹: 제어권을 유지하는 방식</h2>\n<p>하지만 시험지를 그냥 뒷 사람 책상에 올려 놓는다면 어떨까.</p>\n\n<p>나는 실제 뒷 사람이 받는 것을 대기할 필요없이, 바로 나의 다른 작업을 할 수 있다.</p>\n\n<p>즉, 뒷 사람(호출된 함수)이 나에 대한 제어권을 바로 반환해줌으로, 호출한 쪽(나)에서는 계속 다른 작업을 할 수 있는 것이다.</p>\n\n<p>같은 “읽기” 작업이어도 동기와 비동기 처리에 따라 어떻게 다르게 동작하는지 보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹: 제어권을 넘겨줌</span>\n<span class=\"nc\">String</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">readFile</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 파일 읽을 때까지 다른 일 못함</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                          <span class=\"c1\">// 파일 다 읽고 나서야 실행</span>\n\n<span class=\"c1\">// 논블로킹: 제어권을 유지</span>\n<span class=\"nc\">Future</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">readFileAsync</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 요청만 하고</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                               <span class=\"c1\">// 바로 다른 일 할 수 있음</span>\n</code></pre></div></div>\n<p><img src=\"https://github.com/user-attachments/assets/4a59addb-b12d-4eaa-90c9-fe783a7556e0\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>반면 논블로킹에서는 A함수가 B함수를 호출하더라도 제어권을 계속 유지한다.</p>\n\n<p>따라서 B함수가 실행되는 동안에도, A함수는 제어권을 가지고 있기 때문에 다른 작업을 수행할 수 있다.</p>\n\n<p>이렇게 호출자(caller)인 A함수는 B함수의 작업 완료 여부와 관계없이 자신의 작업을 계속 수행할 수 있다.</p>\n\n<p><br /></p>\n\n<h1 id=\"4-네-가지-조합의-동작-방식\">4. 네 가지 조합의 동작 방식</h1>\n\n<p>가끔 동기 처리에서는 무조건적으로 블로킹이 일어나고, 비동기에서는 논블로킹이 일어난다고 오해하는 경우가 많다.</p>\n\n<p>하지만 두 쌍의 개념은 서로 다른 관점에서 바라보는 개념이라는 것을 확실하게 하고 넘어가자.</p>\n\n<blockquote>\n  <p>동기/비동기 : 작업들의 시간적 관계성 <br />\n블로킹/논블로킹 : 제어권의 소재</p>\n</blockquote>\n\n<p>하지만 이 개념들이 오해가 잦은 이유는 실제 구현에서 [동기/볼로킹 &amp; 비동기/논블로킹]이 <strong>자주 함께 사용</strong>되기 때문이다.</p>\n\n<p>다음 그림을 보고 4가지 조합에 대해 천천히 살펴보자.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b894be55-d296-424d-913f-ee989233eb60\" alt=\"image\" width=\"100%\" class=\"center\" /></p>\n\n<p>먼저 흔히 쓰이는 [동기/볼로킹 &amp; 비동기/논블로킹] 에 대해 보자.</p>\n\n<h2 id=\"4-1-동기--블로킹\">4-1. 동기 + 블로킹</h2>\n\n<p>작업의 흐름이 순차적으로 진행되는 것이 보장된다. (<strong>동기</strong>)</p>\n\n<p>제어권을 함수 B에게 넘겨준 후 함수 A는 대기하게 된다. (<strong>블로킹</strong>)</p>\n\n<p>함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄 때까지 함수 A는 기다리는 것이다.</p>\n\n<blockquote>\n  <p>이러한 조합은 <strong>작업이 완료될 때까지 기다려야 하는 경우</strong>에 사용된다. <br />\n예를 들면, 파일을 읽은 후 이를 처리하는 코드를 생각해보자. <br />\n파일을 처리하는 과정은 <strong>필연적으로 파일을 모두 읽은 후에 작업이 가능</strong>하기 때문이다. <br />\n또한, 일반적으로 작업이 간단하거나 작업량이 적은 경우에 사용된다. <br />\n작업량이 많거나 오래 걸리는 작업을 해당 방식으로 처리하면 <strong>전체 프로그램이 멈춘 것 처럼 보여</strong> 사용자 경험 측면에서 나빠질 수 있다.</p>\n</blockquote>\n\n<h2 id=\"4-2-비동기--논블로킹\">4-2. 비동기 + 논블로킹</h2>\n\n<p>비동기 + 논블로킹 방식도 비교적 이해가 쉽다.</p>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다. (<strong>논블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 방식이다. (<strong>동기</strong>)</p>\n\n<p>함수 B를 호출 할 때, 콜백 함수를 함께 줌으로써, 함수 B는 자신의 작업이 끝났을 때 <strong>함수 A에게 준 콜백 함수를 실행시켜 자신의 작업이 끝났음</strong>을 알려준다.</p>\n\n<p>작업 A는 함수 B의 종료 여부에는 일단 관심이 없다.</p>\n\n<p>B 함수가 자신의 실행을 완료했다면, A 함수의 어깨를 톡톡 쳐서 알려주면 되는 것이다.</p>\n\n<blockquote>\n  <p>다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우에 활용할 수 있다. <br />\n또한, 대용량의 데이터를 처리하는 서비스에서 흔히 사용된다. <br />\n가장 큰 특징은 호출 함수에 콜백 함수를 넣었다는 점이다.</p>\n</blockquote>\n\n<h2 id=\"4-3-동기--논블로킹\">4-3. 동기 + 논블로킹</h2>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다.</p>\n\n<p>이후 바로 자신의 코드를 실행한다. (<strong>논블로킹</strong>)</p>\n\n<p>즉, 다른 작업이 진행되는 동안에도 자신의 작업을 별개로 처리할 수 있다.</p>\n\n<p>조심할 것이 함수 A는 함수 B의 Return 값을 필요로 하는 것은 변함이 없다는 점이다.</p>\n\n<p>A 함수는 B 함수의 리턴값이 필요하기 때문에, 중간중간 B 함수에게 함수 실행을 완료했는지 물어본다.</p>\n\n<p>즉, A 함수(caller)가 B 함수(callee)의 실행이 종료되었는지 계속 예의 주시해야 한다. (순서 보장을 위해)</p>\n\n<p>이로써 작업을 순차대로 수행할 수 있는 것이다. (<strong>동기</strong>)</p>\n\n<p>여기서 조금 더 깊게 생각해보자.</p>\n\n<p>어떻게 동기적으로 진행되면서 메인 쓰레드가 논블로킹이 될 수 있을까?</p>\n\n<p>이 조합의 특징은 “작업 완료는 비동기로 처리하지만, 호출자는 필요할 때 결과를 동기적으로 받는다.”로 정리할 수 있다.</p>\n\n<p>즉, <strong>순서를 유지하면서 결과를 사용해야 할 때 동기적으로 기다릴 수 있다.</strong></p>\n\n<p>결국 <strong>동기적</strong> 이라는 말은 <strong>호출자의 결과가 필요한 시점에서 순서를 보장</strong>하며 작업을 진행한다는 것이다.</p>\n\n<p>다음 JAVA 코드의 예시를 봐보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SimpleDownloader</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>  <span class=\"c1\">// 다운로드 진행률</span>\n        \n        <span class=\"c1\">// 다운로드 시작</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"파일 다운로드를 시작합니다.\"</span><span class=\"o\">);</span>\n        \n        <span class=\"c1\">// 진행률 확인하면서 다른 작업 수행 (논블로킹)</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">downloadProgress</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">{</span>  <span class=\"c1\">// 동기적: 순서 보장</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"진행률: \"</span> <span class=\"o\">+</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">+</span> <span class=\"s\">\"%\"</span><span class=\"o\">);</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다른 작업을 할 수 있어요!\"</span><span class=\"o\">);</span>\n            \n            <span class=\"c1\">// 진행률이 증가한다고 가정</span>\n            <span class=\"n\">downloadProgress</span> <span class=\"o\">+=</span> <span class=\"mi\">20</span><span class=\"o\">;</span>\n            \n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>  <span class=\"c1\">// 1초 대기</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        \n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다운로드 완료!\"</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><em>🚨 주의: 이 예시 코드는 Thread를 사용하고 있다. <br />\nThread는 기본적으로 작업을 병렬적으로 처리하기 위한 도구이다. <br />\n비동기 프로그래밍에서는 이러한 Thread의 병렬 처리 능력을 활용하여 비동기 작업을 구현하는 것이 일반적이다. <br />\n하지만 이 예시의 주된 목적은 작업이 어떻게 논블로킹하면서도 동기적으로 처리될 수 있는지를 시각적으로 보여주는 것이다. <br />\nThread를 사용한 것은 개념을 쉽게 설명하기 위한 것이다.</em></p>\n\n<p>이 코드의 결과는 다음과 같을 것이다.</p>\n<div class=\"language-css highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">나는</span> <span class=\"nt\">다른</span> <span class=\"nt\">작업을</span> <span class=\"nt\">진행할게</span><span class=\"o\">.</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">시작</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">0</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">1</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">2</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">완료</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드</span> <span class=\"nt\">종료</span> <span class=\"nt\">확인</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">모든</span> <span class=\"nt\">작업</span> <span class=\"nt\">완료</span><span class=\"o\">.</span>\n</code></pre></div></div>\n\n<p>물론, 논블로킹 메서드로 비동기 작업을 시작하더라도, 결과를 기다려야 하는 시점에서는 블로킹처럼 동작할 수 있다. <br />\n왜냐하면 메인 스레드가 결과를 받아야만 다음 작업을 진행할 수 있기 때문에, 그 시점에서는 블로킹이 되는 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b43ec8c4-9783-4fbf-9f7a-3736dff051bb\" alt=\"image\" width=\"80%\" class=\"center\" /></p>\n\n<p>사실 이러한 방식의 구현은 흔치 않다. <br />\n하지만, 몇 가지 활용 예를 알아보자면 <strong>게임 로딩화면 구성</strong> 등에 활용될 수 있다. <br />\n보통 게임에서 패치나 다운로드를 할 때, 사용자에게 ProgressBar나 게임 Tip등을 띄워줘야 할 때가 있다. <br />\n이 때는 Load 하는 동작이 완료될 때 까지 (작업 순서는 보장 = Sync) <br />\n다른 작업이 진행될 수 있다. (Non-Blocking)\n즉, 사용자 경험 측면에서 유용하게 활용될 수 있다.</p>\n\n<blockquote>\n  <p>언어 간에는 구현 방식에 차이가 있을 수 있다. <br />\n이는 각 언어의 특성과 제공되는 라이브러리나 기술에 따라 달라질 수 있다. <br />\n예를 들어, JavaScript는 단일 스레드 기반으로 동작하며, 콜백 함수, 프로미스(Promise), async/await 등의 메커니즘을 사용해 동기와 논블로킹 처리를 구현할 수 있다. <br />\n기본적으로 Promise.then 방식은 비동기적이고 논블로킹 방식으로 처리된다. <br />\n그러나 async/await 키워드를 사용하면, 비동기 작업의 순서를 지정할 수 있다.<br />\n중요한 점은, async 함수가 내부적으로 비동기적으로 동작하며, 메인 콜 스택이 모두 비워져야 실행된다는 것이다. <br />\n이로 인해 async/await도 내부적으로는 여전히 비동기적이고 논블로킹 방식으로 동작한다는 점을 유의해야 한다.\n(동기적인 코드 흐름처럼 보이게 하는 트릭)</p>\n</blockquote>\n\n<h2 id=\"4-4-비동기--블로킹\">4-4. 비동기 + 블로킹</h2>\n\n<p>이러한 방식은 사실 실무에서 마주치기 더더욱 흔치 않다.</p>\n\n<p>개념만 간단히 설명하자면,</p>\n\n<p>다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다린다. (<strong>블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않고, 콜백함수를 보낸 후 기다린다.</p>\n\n<p>이로써 작업 완료의 순서는 보장되지 않을 수 있다. (<strong>비동기</strong>)</p>\n\n<p><strong>즉, 함수 A는 자신과 관련없는 함수 B의 작업이 끝날 때까지 기다려야 한다.</strong>\n<em>매우 비효율적인 로직…</em></p>\n\n<p>1 작업 중에 2 작업을 해야지 Async의 이점을 살릴 수 있는 것인데,\n이것을 다시 Blocking 방식을 사용함여 대기시킴으로써 이점을 제거해버린 것이다…😅\n대부분의 경우 비동기+논블로킹 모델이 더 효율적인 선택이 될 것이다.</p>\n\n<p><br /></p>\n\n<h1 id=\"5-현대-프로그래밍에서-이러한-개념이-왜-중요한가\">5. 현대 프로그래밍에서 이러한 개념이 왜 중요한가?</h1>\n\n<p>이러한 이해는 현대 소프트웨어 개발에서 매우 중요하다. 오늘날의 애플리케이션들은 수많은 동시다발적인 작업을 처리해야 한다. 사용자는 파일을 다운로드하면서 동시에 문서를 편집하길 원하고, 데이터가 백그라운드에서 처리되는 동안에도 끊김 없는 인터페이스 사용을 기대한다.</p>\n\n<p>더군다나 클라우드 컴퓨팅과 마이크로서비스 아키텍처가 보편화된 현대 개발 환경에서는, 네트워크를 통한 수많은 비동기 작업들이 동시에 발생한다. 이때 각 작업을 어떻게 처리할지, 작업 간의 의존성은 어떻게 관리할지를 결정하는 것은 시스템의 성능과 사용자 경험을 좌우하는 핵심 요소가 된다.</p>\n\n<p>결국 이러한 개념들의 이해는 단순히 기술적인 지식을 넘어서, 현대 소프트웨어가 직면한 복잡성과 사용자 경험의 요구사항을 어떻게 조화롭게 해결할 수 있을지에 대한 통찰을 제공한다. 이는 우리가 더 효율적이고, 반응성 높은, 그리고 사용자 친화적인 소프트웨어를 설계하고 구현하는 데 있어 필수적인 기반이 될 것이다.</p>\n\n<h1 id=\"6-마무리\">6. 마무리</h1>\n<p>그렇다면 Java에서는 이러한 비동기 처리를 어떻게 구현할 수 있을까?</p>\n\n<p>Java의 비동기 프로그래밍은 Thread를 시작으로, 현대적인 CompletableFuture까지 꾸준히 발전해왔다.</p>\n\n<p>이제 각각의 방식을 자세히 살펴보겠다.</p>\n",
                        "tags": ["Java","Spring-Boot","Backend","Sync","Async","Concurrency","Blocking","NonBlocking"]
                    }
                
            ],
        
            "Concurrency": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    },
                
                    {
                        "title": "동기/비동기와 블로킹/논블로킹에 대해 깊이 파헤치기",
                        "url": "/2025/01/12/understanding-sync-async-blocking-non-blocking.html",
                        "subtitle": "Java/SpringBoot에서의 비동기 처리",
                        "excerpt": "1. 개념적 이해\n",
                        "author": "Jinho",
                        "date": "January 12, 2025",
                        "background": "/img/posts/sync-async-concept.jpeg",
                        "content": "<h1 id=\"1-개념적-이해\">1. 개념적 이해</h1>\n\n<p>비동기 처리에 대해 이야기하기 앞서, 과연 “동기”란 어떤 것인지부터 바로 잡고 가려고한다.</p>\n\n<p>왜냐하면 <strong>비(非)동기</strong>란 동기가 아니다라는 의미이기 때문에 동기가 무엇인지부터 정확히 하고 싶었다.</p>\n\n<p>또한 나는 처음에 ‘동기=블로킹, 비동기=논블로킹’이라고 단순하게 이해하고 있었다.</p>\n\n<p>하지만 실제로는 두 개념이 분류 기준이 전혀 다른 독립적인 개념이라는 것을 알게 되었다.</p>\n\n<p>이렇듯 서로 혼동되어 쓰이는 각 명칭은 어떤 의미인지 알아보려고 한다.</p>\n\n<p>이에 대해 자세히 알아보자.</p>\n\n<p><br /></p>\n\n<h1 id=\"2-동기와-비동기\">2. 동기와 비동기</h1>\n\n<p><img src=\"https://velog.velcdn.com/images/jinho7/post/a47f1973-3895-4438-a47f-80dd80245e41/image.png\" alt=\"\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<blockquote>\n  <p>동기와 비동기는 “작업의 처리 방식”을 나타내는 개념이다. <br />\n결론부터 말하자면, 이둘의 주요한 차이점은 “작업 순서 처리 차이”이다.</p>\n</blockquote>\n\n<h2 id=\"2-1-동기-순차적으로-실행\">2-1. 동기: 순차적으로 실행</h2>\n<p>필자는 이전에 동기를 <strong>겹치지 않고 순차적으로 작업을 진행하는 것</strong> 정도로 이해하고 있었다.</p>\n\n<p>영어 사전을 참고해보자.</p>\n\n<blockquote>\n  <p>synchronous\nadjective\nhappening or done at the same time or speed:</p>\n</blockquote>\n\n<p><strong>Synchronous</strong> 는 동시에 발생하는 두 개 이상의 사건이나 프로세스가 동일한 시간에서 진행되는 것을 의미하는 형용사이다.</p>\n\n<p>중요한 워딩은 [동일한 시간에 여러 개의 사건이 진행] 된다는 것이다.</p>\n\n<p>‘순차적’과 ‘동시’라는 단어가 서로 상충된다고 생각할 수 있다.</p>\n\n<p>여기서 오해하면 안되는 것이 이는 <strong>병렬적인 작업방식을 말하는 것이 아니다.</strong></p>\n\n<p>“어떠한 일정 시점에 현재 작업의 Response과 다음 작업의 Request이 함께 진행되는 것”</p>\n\n<p>위의 그림을 참고하면 이해가 쉽다.\n작업 A가 끝나는 시간과 작업 B가 시작하는 시간이 동기화된다고 이해하면 좋을 것 같다.</p>\n\n<p>이는 <strong>작업이 순차적으로 처리되며, 이전 작업이 완료될 때까지는 다음 작업이 시작되지 않음을 나타낸다.</strong></p>\n\n<p>즉, <strong>작업들이 서로 시간적 의존성을 가지고 실행된다</strong>는 뜻이다.</p>\n\n<p>동기 방식은 실행 순서가 보장되며 예측 가능하다는 장점이 있지만, <br />\n앞선 작업이 오래 걸리면 전체 작업이 지연된다는 단점도 있다.</p>\n\n<h2 id=\"2-2-비동기-독립적으로-실행\">2-2. 비동기: 독립적으로 실행</h2>\n<p>그렇다면 비동기 방식은 무엇일까?</p>\n\n<p>반대의 경우를 생각하면 된다.</p>\n\n<p>위의 그림을 참고하면 작업들이 병렬적으로 일어나고 있음을 알 수 있다.</p>\n\n<p>동기와 반대로 <strong>“요청을 보냈을 때 응답 상태와 상관없이 다른 동작을 수행할 수 있다.”</strong>는 점이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/0a188e4a-b35f-41aa-9953-94504330dd9f\" alt=\"다운로드\" width=\"68%\" height=\"50%\" class=\"center\" />\n<em class=\"image-caption\">파일 다운로드가 동기 방식이라면?</em></p>\n\n<p>만약에 파일 다운로드를 동기적으로 처리한다고 해보자.</p>\n\n<p>아마 파일이 다운로드될 때까지 아무런 작업도 수행할 수 없을 것이고,\n파일이 완전히 다운로드된 후에 다음 작업을 진행할 수 있을 것이다. 😅</p>\n\n<p>매우 비효율적인 방식이다…</p>\n\n<p>그러나 비동기적인 방식을 활용한다면, 파일 다운로드 작업을 시작시켜놓고, 다른 작업을 수행할 수 있다.</p>\n\n<p>파일이 다운로드되면 특정 콜백 함수를 호출하여, 다운로드된 파일을 처리하거나 결과를 반환받을 수 있다.</p>\n\n<p>콜백 뿐만이 아니고, 그 결과는 콜백 함수, Promise, 이벤트 등을 통해 전달받을 수 있다.</p>\n\n<p>마치 택배를 주문하고 배송 알림을 받는 것과 비슷하다고 할 수 있다.</p>\n\n<h3 id=\"비동기-동작-방식에-대한-오해\">비동기 동작 방식에 대한 오해</h3>\n<p>많은 개발자들이 <strong>비동기 = 멀티 쓰레드</strong>라고 이해하고 있다.</p>\n\n<p>단순히 생각해보아도, 여러 작업이 동시에 처리되는 비동기 동작을 구현하기 위해서는 당연히 여러 개의 쓰레드가 필요할 것 같기 때문이다.</p>\n\n<p>또한, 특히나 대부분의 Java 개발자들이 비동기 프로그래밍을 접할 때 아래와 같은 코드를 통해 배우기 때문이다.</p>\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 여기서 실제로 별도의 스레드에서 실행됨</span>\n    <span class=\"k\">return</span> <span class=\"nf\">heavyTask</span><span class=\"o\">();</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p>우리는 Java에서 비동기 처리에 대해 다룰 때, ExecutorService나 CompletableFuture와 같은 도구들을 함께 배운다.</p>\n\n<p>이들은 내부적으로 <strong>스레드 풀</strong>을 사용하기 때문에, 자연스럽게 비동기 처리와 멀티 쓰레드를 동일시하게 된다.</p>\n\n<p>실제로 Spring Framework의 @Async 어노테이션도 비동기 처리를 위해 기본적으로 스레드 풀을 사용한다.</p>\n\n<p>하지만 비동기 처리의 본질은 <strong>“작업의 완료를 기다리지 않고 다른 작업을 수행할 수 있는 것”</strong>이다.</p>\n\n<p>이는 반드시 멀티스레드로만 구현되어야 하는 것이 아니며, Node.js가 좋은 예시다.</p>\n\n<p>Node.js는 싱글 스레드 기반의 이벤트 루프를 사용하여 비동기 처리를 구현한다.</p>\n\n<p>이벤트 루프는 OS의 비동기 I/O 기능을 활용하여 실제 I/O 작업을 커널 레벨에서 처리하고,</p>\n\n<p>작업이 완료되면 이벤트를 통해 알림을 받는 방식으로 동작한다.</p>\n\n<div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Node.js의 비동기 처리 (싱글스레드)</span>\n<span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nf\">readFile</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">file.txt</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">파일 읽기 완료</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">다음 작업 실행</span><span class=\"dl\">'</span><span class=\"p\">);</span>  <span class=\"c1\">// 파일 읽기를 기다리지 않고 실행</span>\n</code></pre></div></div>\n<p>이러한 이벤트 루프 기반의 비동기 처리는 멀티스레드 없이도 효율적인 비동기 처리를 가능하게 한다.\nOS의 비동기 I/O 기능을 활용하여, 실제 I/O 작업은 커널 레벨에서 처리되고, 완료되면 이벤트를 통해 알림을 받는 방식이다.\n<em>정확히는 JavaScript 엔진이 싱글 스레드 기반이다</em>\n<em>해당 내용에 대해 더 자세히 알고 싶다면 <a href=\"https://puleugo.tistory.com/133\">해당 블로그</a>를 참고하자</em></p>\n\n<p><br /></p>\n\n<h1 id=\"3-블로킹과-논블로킹\">3. 블로킹과 논블로킹</h1>\n<blockquote>\n  <p>블로킹과 논블로킹은 “제어권의 이동” 관점에서 바라보는 개념이다.</p>\n</blockquote>\n\n<p>결국 “호출한 함수가 다른 일을 할 수 있는가?”의 여부를 의미한다.</p>\n\n<h2 id=\"3-1-제어권control-flow의-의미\">3-1. 제어권(Control Flow)의 의미</h2>\n<p>여기서 <strong>제어권</strong>이란 어떤 의미를 갖는지 먼저 보자.\nOS적인 관점에서 보자면, <strong>현재 작업을 진행하고 있는 함수가 CPU를 점유하는 것</strong>을 의미한다.\n쉽게 말해 “코드를 실행시킬 수 있는 권한” 정도로 말할 수 있다.</p>\n\n<p>동기 와 비동기는 Jobs 들이 순서대로 혹은 독립적으로 처리되는가에 관한 이야기라면,\n이번에는 호출한 함수가 별개의 일을 할 수 있는지의 이야기이다.</p>\n\n<h2 id=\"3-2-블로킹-제어권을-넘겨주는-방식\">3-2. 블로킹: 제어권을 넘겨주는 방식</h2>\n<p>마치 시험지를 넘겨주는 방식을 생각하면 편할 것 같다.\n<img src=\"https://github.com/user-attachments/assets/6eb36e86-150c-4144-86ce-6080ef86bece\" alt=\"image\" width=\"60%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : https://www.veritas-a.com/news/articleView.html?idxno=156699</em></p>\n\n<p>내가 뒷 사람에게 시험지를 넘겨줄 때,\n나는 아무런 행동도 하지 않고 <strong>뒷 사람(호출된 함수)가 시험지를 가져가는(자신의 작업을 완료)할 때 까지</strong> 나는 손에 시험지를 쥐고 뒷사람을 바라보고 대기할 수 밖에 없다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d799e31b-9406-44f3-8dcc-9df15b8f8a79\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>둘 간의 구분 방법은 제어권이 누구에게 있는지로 결정된다.</p>\n\n<p>블로킹에서는 함수 A가 함수 B를 호출할 때 제어권이 B로 넘어간다.</p>\n\n<p>제어권을 넘겨준 A는 B의 작업이 완료될 때까지 아무 작업도 수행할 수 없는 상태, 즉 블로킹 상태가 된다.</p>\n\n<p>즉, 위의 사진에서 A함수는 B함수에게 제어권을 넘겨줌과 동시에 함수 실행이 일시 정지된다. = Blocking</p>\n\n<h2 id=\"3-3-논블로킹-제어권을-유지하는-방식\">3-3. 논블로킹: 제어권을 유지하는 방식</h2>\n<p>하지만 시험지를 그냥 뒷 사람 책상에 올려 놓는다면 어떨까.</p>\n\n<p>나는 실제 뒷 사람이 받는 것을 대기할 필요없이, 바로 나의 다른 작업을 할 수 있다.</p>\n\n<p>즉, 뒷 사람(호출된 함수)이 나에 대한 제어권을 바로 반환해줌으로, 호출한 쪽(나)에서는 계속 다른 작업을 할 수 있는 것이다.</p>\n\n<p>같은 “읽기” 작업이어도 동기와 비동기 처리에 따라 어떻게 다르게 동작하는지 보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹: 제어권을 넘겨줌</span>\n<span class=\"nc\">String</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">readFile</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 파일 읽을 때까지 다른 일 못함</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                          <span class=\"c1\">// 파일 다 읽고 나서야 실행</span>\n\n<span class=\"c1\">// 논블로킹: 제어권을 유지</span>\n<span class=\"nc\">Future</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">readFileAsync</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 요청만 하고</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                               <span class=\"c1\">// 바로 다른 일 할 수 있음</span>\n</code></pre></div></div>\n<p><img src=\"https://github.com/user-attachments/assets/4a59addb-b12d-4eaa-90c9-fe783a7556e0\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>반면 논블로킹에서는 A함수가 B함수를 호출하더라도 제어권을 계속 유지한다.</p>\n\n<p>따라서 B함수가 실행되는 동안에도, A함수는 제어권을 가지고 있기 때문에 다른 작업을 수행할 수 있다.</p>\n\n<p>이렇게 호출자(caller)인 A함수는 B함수의 작업 완료 여부와 관계없이 자신의 작업을 계속 수행할 수 있다.</p>\n\n<p><br /></p>\n\n<h1 id=\"4-네-가지-조합의-동작-방식\">4. 네 가지 조합의 동작 방식</h1>\n\n<p>가끔 동기 처리에서는 무조건적으로 블로킹이 일어나고, 비동기에서는 논블로킹이 일어난다고 오해하는 경우가 많다.</p>\n\n<p>하지만 두 쌍의 개념은 서로 다른 관점에서 바라보는 개념이라는 것을 확실하게 하고 넘어가자.</p>\n\n<blockquote>\n  <p>동기/비동기 : 작업들의 시간적 관계성 <br />\n블로킹/논블로킹 : 제어권의 소재</p>\n</blockquote>\n\n<p>하지만 이 개념들이 오해가 잦은 이유는 실제 구현에서 [동기/볼로킹 &amp; 비동기/논블로킹]이 <strong>자주 함께 사용</strong>되기 때문이다.</p>\n\n<p>다음 그림을 보고 4가지 조합에 대해 천천히 살펴보자.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b894be55-d296-424d-913f-ee989233eb60\" alt=\"image\" width=\"100%\" class=\"center\" /></p>\n\n<p>먼저 흔히 쓰이는 [동기/볼로킹 &amp; 비동기/논블로킹] 에 대해 보자.</p>\n\n<h2 id=\"4-1-동기--블로킹\">4-1. 동기 + 블로킹</h2>\n\n<p>작업의 흐름이 순차적으로 진행되는 것이 보장된다. (<strong>동기</strong>)</p>\n\n<p>제어권을 함수 B에게 넘겨준 후 함수 A는 대기하게 된다. (<strong>블로킹</strong>)</p>\n\n<p>함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄 때까지 함수 A는 기다리는 것이다.</p>\n\n<blockquote>\n  <p>이러한 조합은 <strong>작업이 완료될 때까지 기다려야 하는 경우</strong>에 사용된다. <br />\n예를 들면, 파일을 읽은 후 이를 처리하는 코드를 생각해보자. <br />\n파일을 처리하는 과정은 <strong>필연적으로 파일을 모두 읽은 후에 작업이 가능</strong>하기 때문이다. <br />\n또한, 일반적으로 작업이 간단하거나 작업량이 적은 경우에 사용된다. <br />\n작업량이 많거나 오래 걸리는 작업을 해당 방식으로 처리하면 <strong>전체 프로그램이 멈춘 것 처럼 보여</strong> 사용자 경험 측면에서 나빠질 수 있다.</p>\n</blockquote>\n\n<h2 id=\"4-2-비동기--논블로킹\">4-2. 비동기 + 논블로킹</h2>\n\n<p>비동기 + 논블로킹 방식도 비교적 이해가 쉽다.</p>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다. (<strong>논블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 방식이다. (<strong>동기</strong>)</p>\n\n<p>함수 B를 호출 할 때, 콜백 함수를 함께 줌으로써, 함수 B는 자신의 작업이 끝났을 때 <strong>함수 A에게 준 콜백 함수를 실행시켜 자신의 작업이 끝났음</strong>을 알려준다.</p>\n\n<p>작업 A는 함수 B의 종료 여부에는 일단 관심이 없다.</p>\n\n<p>B 함수가 자신의 실행을 완료했다면, A 함수의 어깨를 톡톡 쳐서 알려주면 되는 것이다.</p>\n\n<blockquote>\n  <p>다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우에 활용할 수 있다. <br />\n또한, 대용량의 데이터를 처리하는 서비스에서 흔히 사용된다. <br />\n가장 큰 특징은 호출 함수에 콜백 함수를 넣었다는 점이다.</p>\n</blockquote>\n\n<h2 id=\"4-3-동기--논블로킹\">4-3. 동기 + 논블로킹</h2>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다.</p>\n\n<p>이후 바로 자신의 코드를 실행한다. (<strong>논블로킹</strong>)</p>\n\n<p>즉, 다른 작업이 진행되는 동안에도 자신의 작업을 별개로 처리할 수 있다.</p>\n\n<p>조심할 것이 함수 A는 함수 B의 Return 값을 필요로 하는 것은 변함이 없다는 점이다.</p>\n\n<p>A 함수는 B 함수의 리턴값이 필요하기 때문에, 중간중간 B 함수에게 함수 실행을 완료했는지 물어본다.</p>\n\n<p>즉, A 함수(caller)가 B 함수(callee)의 실행이 종료되었는지 계속 예의 주시해야 한다. (순서 보장을 위해)</p>\n\n<p>이로써 작업을 순차대로 수행할 수 있는 것이다. (<strong>동기</strong>)</p>\n\n<p>여기서 조금 더 깊게 생각해보자.</p>\n\n<p>어떻게 동기적으로 진행되면서 메인 쓰레드가 논블로킹이 될 수 있을까?</p>\n\n<p>이 조합의 특징은 “작업 완료는 비동기로 처리하지만, 호출자는 필요할 때 결과를 동기적으로 받는다.”로 정리할 수 있다.</p>\n\n<p>즉, <strong>순서를 유지하면서 결과를 사용해야 할 때 동기적으로 기다릴 수 있다.</strong></p>\n\n<p>결국 <strong>동기적</strong> 이라는 말은 <strong>호출자의 결과가 필요한 시점에서 순서를 보장</strong>하며 작업을 진행한다는 것이다.</p>\n\n<p>다음 JAVA 코드의 예시를 봐보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SimpleDownloader</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>  <span class=\"c1\">// 다운로드 진행률</span>\n        \n        <span class=\"c1\">// 다운로드 시작</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"파일 다운로드를 시작합니다.\"</span><span class=\"o\">);</span>\n        \n        <span class=\"c1\">// 진행률 확인하면서 다른 작업 수행 (논블로킹)</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">downloadProgress</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">{</span>  <span class=\"c1\">// 동기적: 순서 보장</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"진행률: \"</span> <span class=\"o\">+</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">+</span> <span class=\"s\">\"%\"</span><span class=\"o\">);</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다른 작업을 할 수 있어요!\"</span><span class=\"o\">);</span>\n            \n            <span class=\"c1\">// 진행률이 증가한다고 가정</span>\n            <span class=\"n\">downloadProgress</span> <span class=\"o\">+=</span> <span class=\"mi\">20</span><span class=\"o\">;</span>\n            \n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>  <span class=\"c1\">// 1초 대기</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        \n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다운로드 완료!\"</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><em>🚨 주의: 이 예시 코드는 Thread를 사용하고 있다. <br />\nThread는 기본적으로 작업을 병렬적으로 처리하기 위한 도구이다. <br />\n비동기 프로그래밍에서는 이러한 Thread의 병렬 처리 능력을 활용하여 비동기 작업을 구현하는 것이 일반적이다. <br />\n하지만 이 예시의 주된 목적은 작업이 어떻게 논블로킹하면서도 동기적으로 처리될 수 있는지를 시각적으로 보여주는 것이다. <br />\nThread를 사용한 것은 개념을 쉽게 설명하기 위한 것이다.</em></p>\n\n<p>이 코드의 결과는 다음과 같을 것이다.</p>\n<div class=\"language-css highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">나는</span> <span class=\"nt\">다른</span> <span class=\"nt\">작업을</span> <span class=\"nt\">진행할게</span><span class=\"o\">.</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">시작</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">0</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">1</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">2</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">완료</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드</span> <span class=\"nt\">종료</span> <span class=\"nt\">확인</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">모든</span> <span class=\"nt\">작업</span> <span class=\"nt\">완료</span><span class=\"o\">.</span>\n</code></pre></div></div>\n\n<p>물론, 논블로킹 메서드로 비동기 작업을 시작하더라도, 결과를 기다려야 하는 시점에서는 블로킹처럼 동작할 수 있다. <br />\n왜냐하면 메인 스레드가 결과를 받아야만 다음 작업을 진행할 수 있기 때문에, 그 시점에서는 블로킹이 되는 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b43ec8c4-9783-4fbf-9f7a-3736dff051bb\" alt=\"image\" width=\"80%\" class=\"center\" /></p>\n\n<p>사실 이러한 방식의 구현은 흔치 않다. <br />\n하지만, 몇 가지 활용 예를 알아보자면 <strong>게임 로딩화면 구성</strong> 등에 활용될 수 있다. <br />\n보통 게임에서 패치나 다운로드를 할 때, 사용자에게 ProgressBar나 게임 Tip등을 띄워줘야 할 때가 있다. <br />\n이 때는 Load 하는 동작이 완료될 때 까지 (작업 순서는 보장 = Sync) <br />\n다른 작업이 진행될 수 있다. (Non-Blocking)\n즉, 사용자 경험 측면에서 유용하게 활용될 수 있다.</p>\n\n<blockquote>\n  <p>언어 간에는 구현 방식에 차이가 있을 수 있다. <br />\n이는 각 언어의 특성과 제공되는 라이브러리나 기술에 따라 달라질 수 있다. <br />\n예를 들어, JavaScript는 단일 스레드 기반으로 동작하며, 콜백 함수, 프로미스(Promise), async/await 등의 메커니즘을 사용해 동기와 논블로킹 처리를 구현할 수 있다. <br />\n기본적으로 Promise.then 방식은 비동기적이고 논블로킹 방식으로 처리된다. <br />\n그러나 async/await 키워드를 사용하면, 비동기 작업의 순서를 지정할 수 있다.<br />\n중요한 점은, async 함수가 내부적으로 비동기적으로 동작하며, 메인 콜 스택이 모두 비워져야 실행된다는 것이다. <br />\n이로 인해 async/await도 내부적으로는 여전히 비동기적이고 논블로킹 방식으로 동작한다는 점을 유의해야 한다.\n(동기적인 코드 흐름처럼 보이게 하는 트릭)</p>\n</blockquote>\n\n<h2 id=\"4-4-비동기--블로킹\">4-4. 비동기 + 블로킹</h2>\n\n<p>이러한 방식은 사실 실무에서 마주치기 더더욱 흔치 않다.</p>\n\n<p>개념만 간단히 설명하자면,</p>\n\n<p>다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다린다. (<strong>블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않고, 콜백함수를 보낸 후 기다린다.</p>\n\n<p>이로써 작업 완료의 순서는 보장되지 않을 수 있다. (<strong>비동기</strong>)</p>\n\n<p><strong>즉, 함수 A는 자신과 관련없는 함수 B의 작업이 끝날 때까지 기다려야 한다.</strong>\n<em>매우 비효율적인 로직…</em></p>\n\n<p>1 작업 중에 2 작업을 해야지 Async의 이점을 살릴 수 있는 것인데,\n이것을 다시 Blocking 방식을 사용함여 대기시킴으로써 이점을 제거해버린 것이다…😅\n대부분의 경우 비동기+논블로킹 모델이 더 효율적인 선택이 될 것이다.</p>\n\n<p><br /></p>\n\n<h1 id=\"5-현대-프로그래밍에서-이러한-개념이-왜-중요한가\">5. 현대 프로그래밍에서 이러한 개념이 왜 중요한가?</h1>\n\n<p>이러한 이해는 현대 소프트웨어 개발에서 매우 중요하다. 오늘날의 애플리케이션들은 수많은 동시다발적인 작업을 처리해야 한다. 사용자는 파일을 다운로드하면서 동시에 문서를 편집하길 원하고, 데이터가 백그라운드에서 처리되는 동안에도 끊김 없는 인터페이스 사용을 기대한다.</p>\n\n<p>더군다나 클라우드 컴퓨팅과 마이크로서비스 아키텍처가 보편화된 현대 개발 환경에서는, 네트워크를 통한 수많은 비동기 작업들이 동시에 발생한다. 이때 각 작업을 어떻게 처리할지, 작업 간의 의존성은 어떻게 관리할지를 결정하는 것은 시스템의 성능과 사용자 경험을 좌우하는 핵심 요소가 된다.</p>\n\n<p>결국 이러한 개념들의 이해는 단순히 기술적인 지식을 넘어서, 현대 소프트웨어가 직면한 복잡성과 사용자 경험의 요구사항을 어떻게 조화롭게 해결할 수 있을지에 대한 통찰을 제공한다. 이는 우리가 더 효율적이고, 반응성 높은, 그리고 사용자 친화적인 소프트웨어를 설계하고 구현하는 데 있어 필수적인 기반이 될 것이다.</p>\n\n<h1 id=\"6-마무리\">6. 마무리</h1>\n<p>그렇다면 Java에서는 이러한 비동기 처리를 어떻게 구현할 수 있을까?</p>\n\n<p>Java의 비동기 프로그래밍은 Thread를 시작으로, 현대적인 CompletableFuture까지 꾸준히 발전해왔다.</p>\n\n<p>이제 각각의 방식을 자세히 살펴보겠다.</p>\n",
                        "tags": ["Java","Spring-Boot","Backend","Sync","Async","Concurrency","Blocking","NonBlocking"]
                    }
                
            ],
        
            "Blocking": [
                
                    {
                        "title": "동기/비동기와 블로킹/논블로킹에 대해 깊이 파헤치기",
                        "url": "/2025/01/12/understanding-sync-async-blocking-non-blocking.html",
                        "subtitle": "Java/SpringBoot에서의 비동기 처리",
                        "excerpt": "1. 개념적 이해\n",
                        "author": "Jinho",
                        "date": "January 12, 2025",
                        "background": "/img/posts/sync-async-concept.jpeg",
                        "content": "<h1 id=\"1-개념적-이해\">1. 개념적 이해</h1>\n\n<p>비동기 처리에 대해 이야기하기 앞서, 과연 “동기”란 어떤 것인지부터 바로 잡고 가려고한다.</p>\n\n<p>왜냐하면 <strong>비(非)동기</strong>란 동기가 아니다라는 의미이기 때문에 동기가 무엇인지부터 정확히 하고 싶었다.</p>\n\n<p>또한 나는 처음에 ‘동기=블로킹, 비동기=논블로킹’이라고 단순하게 이해하고 있었다.</p>\n\n<p>하지만 실제로는 두 개념이 분류 기준이 전혀 다른 독립적인 개념이라는 것을 알게 되었다.</p>\n\n<p>이렇듯 서로 혼동되어 쓰이는 각 명칭은 어떤 의미인지 알아보려고 한다.</p>\n\n<p>이에 대해 자세히 알아보자.</p>\n\n<p><br /></p>\n\n<h1 id=\"2-동기와-비동기\">2. 동기와 비동기</h1>\n\n<p><img src=\"https://velog.velcdn.com/images/jinho7/post/a47f1973-3895-4438-a47f-80dd80245e41/image.png\" alt=\"\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<blockquote>\n  <p>동기와 비동기는 “작업의 처리 방식”을 나타내는 개념이다. <br />\n결론부터 말하자면, 이둘의 주요한 차이점은 “작업 순서 처리 차이”이다.</p>\n</blockquote>\n\n<h2 id=\"2-1-동기-순차적으로-실행\">2-1. 동기: 순차적으로 실행</h2>\n<p>필자는 이전에 동기를 <strong>겹치지 않고 순차적으로 작업을 진행하는 것</strong> 정도로 이해하고 있었다.</p>\n\n<p>영어 사전을 참고해보자.</p>\n\n<blockquote>\n  <p>synchronous\nadjective\nhappening or done at the same time or speed:</p>\n</blockquote>\n\n<p><strong>Synchronous</strong> 는 동시에 발생하는 두 개 이상의 사건이나 프로세스가 동일한 시간에서 진행되는 것을 의미하는 형용사이다.</p>\n\n<p>중요한 워딩은 [동일한 시간에 여러 개의 사건이 진행] 된다는 것이다.</p>\n\n<p>‘순차적’과 ‘동시’라는 단어가 서로 상충된다고 생각할 수 있다.</p>\n\n<p>여기서 오해하면 안되는 것이 이는 <strong>병렬적인 작업방식을 말하는 것이 아니다.</strong></p>\n\n<p>“어떠한 일정 시점에 현재 작업의 Response과 다음 작업의 Request이 함께 진행되는 것”</p>\n\n<p>위의 그림을 참고하면 이해가 쉽다.\n작업 A가 끝나는 시간과 작업 B가 시작하는 시간이 동기화된다고 이해하면 좋을 것 같다.</p>\n\n<p>이는 <strong>작업이 순차적으로 처리되며, 이전 작업이 완료될 때까지는 다음 작업이 시작되지 않음을 나타낸다.</strong></p>\n\n<p>즉, <strong>작업들이 서로 시간적 의존성을 가지고 실행된다</strong>는 뜻이다.</p>\n\n<p>동기 방식은 실행 순서가 보장되며 예측 가능하다는 장점이 있지만, <br />\n앞선 작업이 오래 걸리면 전체 작업이 지연된다는 단점도 있다.</p>\n\n<h2 id=\"2-2-비동기-독립적으로-실행\">2-2. 비동기: 독립적으로 실행</h2>\n<p>그렇다면 비동기 방식은 무엇일까?</p>\n\n<p>반대의 경우를 생각하면 된다.</p>\n\n<p>위의 그림을 참고하면 작업들이 병렬적으로 일어나고 있음을 알 수 있다.</p>\n\n<p>동기와 반대로 <strong>“요청을 보냈을 때 응답 상태와 상관없이 다른 동작을 수행할 수 있다.”</strong>는 점이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/0a188e4a-b35f-41aa-9953-94504330dd9f\" alt=\"다운로드\" width=\"68%\" height=\"50%\" class=\"center\" />\n<em class=\"image-caption\">파일 다운로드가 동기 방식이라면?</em></p>\n\n<p>만약에 파일 다운로드를 동기적으로 처리한다고 해보자.</p>\n\n<p>아마 파일이 다운로드될 때까지 아무런 작업도 수행할 수 없을 것이고,\n파일이 완전히 다운로드된 후에 다음 작업을 진행할 수 있을 것이다. 😅</p>\n\n<p>매우 비효율적인 방식이다…</p>\n\n<p>그러나 비동기적인 방식을 활용한다면, 파일 다운로드 작업을 시작시켜놓고, 다른 작업을 수행할 수 있다.</p>\n\n<p>파일이 다운로드되면 특정 콜백 함수를 호출하여, 다운로드된 파일을 처리하거나 결과를 반환받을 수 있다.</p>\n\n<p>콜백 뿐만이 아니고, 그 결과는 콜백 함수, Promise, 이벤트 등을 통해 전달받을 수 있다.</p>\n\n<p>마치 택배를 주문하고 배송 알림을 받는 것과 비슷하다고 할 수 있다.</p>\n\n<h3 id=\"비동기-동작-방식에-대한-오해\">비동기 동작 방식에 대한 오해</h3>\n<p>많은 개발자들이 <strong>비동기 = 멀티 쓰레드</strong>라고 이해하고 있다.</p>\n\n<p>단순히 생각해보아도, 여러 작업이 동시에 처리되는 비동기 동작을 구현하기 위해서는 당연히 여러 개의 쓰레드가 필요할 것 같기 때문이다.</p>\n\n<p>또한, 특히나 대부분의 Java 개발자들이 비동기 프로그래밍을 접할 때 아래와 같은 코드를 통해 배우기 때문이다.</p>\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 여기서 실제로 별도의 스레드에서 실행됨</span>\n    <span class=\"k\">return</span> <span class=\"nf\">heavyTask</span><span class=\"o\">();</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p>우리는 Java에서 비동기 처리에 대해 다룰 때, ExecutorService나 CompletableFuture와 같은 도구들을 함께 배운다.</p>\n\n<p>이들은 내부적으로 <strong>스레드 풀</strong>을 사용하기 때문에, 자연스럽게 비동기 처리와 멀티 쓰레드를 동일시하게 된다.</p>\n\n<p>실제로 Spring Framework의 @Async 어노테이션도 비동기 처리를 위해 기본적으로 스레드 풀을 사용한다.</p>\n\n<p>하지만 비동기 처리의 본질은 <strong>“작업의 완료를 기다리지 않고 다른 작업을 수행할 수 있는 것”</strong>이다.</p>\n\n<p>이는 반드시 멀티스레드로만 구현되어야 하는 것이 아니며, Node.js가 좋은 예시다.</p>\n\n<p>Node.js는 싱글 스레드 기반의 이벤트 루프를 사용하여 비동기 처리를 구현한다.</p>\n\n<p>이벤트 루프는 OS의 비동기 I/O 기능을 활용하여 실제 I/O 작업을 커널 레벨에서 처리하고,</p>\n\n<p>작업이 완료되면 이벤트를 통해 알림을 받는 방식으로 동작한다.</p>\n\n<div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Node.js의 비동기 처리 (싱글스레드)</span>\n<span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nf\">readFile</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">file.txt</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">파일 읽기 완료</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">다음 작업 실행</span><span class=\"dl\">'</span><span class=\"p\">);</span>  <span class=\"c1\">// 파일 읽기를 기다리지 않고 실행</span>\n</code></pre></div></div>\n<p>이러한 이벤트 루프 기반의 비동기 처리는 멀티스레드 없이도 효율적인 비동기 처리를 가능하게 한다.\nOS의 비동기 I/O 기능을 활용하여, 실제 I/O 작업은 커널 레벨에서 처리되고, 완료되면 이벤트를 통해 알림을 받는 방식이다.\n<em>정확히는 JavaScript 엔진이 싱글 스레드 기반이다</em>\n<em>해당 내용에 대해 더 자세히 알고 싶다면 <a href=\"https://puleugo.tistory.com/133\">해당 블로그</a>를 참고하자</em></p>\n\n<p><br /></p>\n\n<h1 id=\"3-블로킹과-논블로킹\">3. 블로킹과 논블로킹</h1>\n<blockquote>\n  <p>블로킹과 논블로킹은 “제어권의 이동” 관점에서 바라보는 개념이다.</p>\n</blockquote>\n\n<p>결국 “호출한 함수가 다른 일을 할 수 있는가?”의 여부를 의미한다.</p>\n\n<h2 id=\"3-1-제어권control-flow의-의미\">3-1. 제어권(Control Flow)의 의미</h2>\n<p>여기서 <strong>제어권</strong>이란 어떤 의미를 갖는지 먼저 보자.\nOS적인 관점에서 보자면, <strong>현재 작업을 진행하고 있는 함수가 CPU를 점유하는 것</strong>을 의미한다.\n쉽게 말해 “코드를 실행시킬 수 있는 권한” 정도로 말할 수 있다.</p>\n\n<p>동기 와 비동기는 Jobs 들이 순서대로 혹은 독립적으로 처리되는가에 관한 이야기라면,\n이번에는 호출한 함수가 별개의 일을 할 수 있는지의 이야기이다.</p>\n\n<h2 id=\"3-2-블로킹-제어권을-넘겨주는-방식\">3-2. 블로킹: 제어권을 넘겨주는 방식</h2>\n<p>마치 시험지를 넘겨주는 방식을 생각하면 편할 것 같다.\n<img src=\"https://github.com/user-attachments/assets/6eb36e86-150c-4144-86ce-6080ef86bece\" alt=\"image\" width=\"60%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : https://www.veritas-a.com/news/articleView.html?idxno=156699</em></p>\n\n<p>내가 뒷 사람에게 시험지를 넘겨줄 때,\n나는 아무런 행동도 하지 않고 <strong>뒷 사람(호출된 함수)가 시험지를 가져가는(자신의 작업을 완료)할 때 까지</strong> 나는 손에 시험지를 쥐고 뒷사람을 바라보고 대기할 수 밖에 없다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d799e31b-9406-44f3-8dcc-9df15b8f8a79\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>둘 간의 구분 방법은 제어권이 누구에게 있는지로 결정된다.</p>\n\n<p>블로킹에서는 함수 A가 함수 B를 호출할 때 제어권이 B로 넘어간다.</p>\n\n<p>제어권을 넘겨준 A는 B의 작업이 완료될 때까지 아무 작업도 수행할 수 없는 상태, 즉 블로킹 상태가 된다.</p>\n\n<p>즉, 위의 사진에서 A함수는 B함수에게 제어권을 넘겨줌과 동시에 함수 실행이 일시 정지된다. = Blocking</p>\n\n<h2 id=\"3-3-논블로킹-제어권을-유지하는-방식\">3-3. 논블로킹: 제어권을 유지하는 방식</h2>\n<p>하지만 시험지를 그냥 뒷 사람 책상에 올려 놓는다면 어떨까.</p>\n\n<p>나는 실제 뒷 사람이 받는 것을 대기할 필요없이, 바로 나의 다른 작업을 할 수 있다.</p>\n\n<p>즉, 뒷 사람(호출된 함수)이 나에 대한 제어권을 바로 반환해줌으로, 호출한 쪽(나)에서는 계속 다른 작업을 할 수 있는 것이다.</p>\n\n<p>같은 “읽기” 작업이어도 동기와 비동기 처리에 따라 어떻게 다르게 동작하는지 보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹: 제어권을 넘겨줌</span>\n<span class=\"nc\">String</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">readFile</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 파일 읽을 때까지 다른 일 못함</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                          <span class=\"c1\">// 파일 다 읽고 나서야 실행</span>\n\n<span class=\"c1\">// 논블로킹: 제어권을 유지</span>\n<span class=\"nc\">Future</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">readFileAsync</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 요청만 하고</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                               <span class=\"c1\">// 바로 다른 일 할 수 있음</span>\n</code></pre></div></div>\n<p><img src=\"https://github.com/user-attachments/assets/4a59addb-b12d-4eaa-90c9-fe783a7556e0\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>반면 논블로킹에서는 A함수가 B함수를 호출하더라도 제어권을 계속 유지한다.</p>\n\n<p>따라서 B함수가 실행되는 동안에도, A함수는 제어권을 가지고 있기 때문에 다른 작업을 수행할 수 있다.</p>\n\n<p>이렇게 호출자(caller)인 A함수는 B함수의 작업 완료 여부와 관계없이 자신의 작업을 계속 수행할 수 있다.</p>\n\n<p><br /></p>\n\n<h1 id=\"4-네-가지-조합의-동작-방식\">4. 네 가지 조합의 동작 방식</h1>\n\n<p>가끔 동기 처리에서는 무조건적으로 블로킹이 일어나고, 비동기에서는 논블로킹이 일어난다고 오해하는 경우가 많다.</p>\n\n<p>하지만 두 쌍의 개념은 서로 다른 관점에서 바라보는 개념이라는 것을 확실하게 하고 넘어가자.</p>\n\n<blockquote>\n  <p>동기/비동기 : 작업들의 시간적 관계성 <br />\n블로킹/논블로킹 : 제어권의 소재</p>\n</blockquote>\n\n<p>하지만 이 개념들이 오해가 잦은 이유는 실제 구현에서 [동기/볼로킹 &amp; 비동기/논블로킹]이 <strong>자주 함께 사용</strong>되기 때문이다.</p>\n\n<p>다음 그림을 보고 4가지 조합에 대해 천천히 살펴보자.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b894be55-d296-424d-913f-ee989233eb60\" alt=\"image\" width=\"100%\" class=\"center\" /></p>\n\n<p>먼저 흔히 쓰이는 [동기/볼로킹 &amp; 비동기/논블로킹] 에 대해 보자.</p>\n\n<h2 id=\"4-1-동기--블로킹\">4-1. 동기 + 블로킹</h2>\n\n<p>작업의 흐름이 순차적으로 진행되는 것이 보장된다. (<strong>동기</strong>)</p>\n\n<p>제어권을 함수 B에게 넘겨준 후 함수 A는 대기하게 된다. (<strong>블로킹</strong>)</p>\n\n<p>함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄 때까지 함수 A는 기다리는 것이다.</p>\n\n<blockquote>\n  <p>이러한 조합은 <strong>작업이 완료될 때까지 기다려야 하는 경우</strong>에 사용된다. <br />\n예를 들면, 파일을 읽은 후 이를 처리하는 코드를 생각해보자. <br />\n파일을 처리하는 과정은 <strong>필연적으로 파일을 모두 읽은 후에 작업이 가능</strong>하기 때문이다. <br />\n또한, 일반적으로 작업이 간단하거나 작업량이 적은 경우에 사용된다. <br />\n작업량이 많거나 오래 걸리는 작업을 해당 방식으로 처리하면 <strong>전체 프로그램이 멈춘 것 처럼 보여</strong> 사용자 경험 측면에서 나빠질 수 있다.</p>\n</blockquote>\n\n<h2 id=\"4-2-비동기--논블로킹\">4-2. 비동기 + 논블로킹</h2>\n\n<p>비동기 + 논블로킹 방식도 비교적 이해가 쉽다.</p>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다. (<strong>논블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 방식이다. (<strong>동기</strong>)</p>\n\n<p>함수 B를 호출 할 때, 콜백 함수를 함께 줌으로써, 함수 B는 자신의 작업이 끝났을 때 <strong>함수 A에게 준 콜백 함수를 실행시켜 자신의 작업이 끝났음</strong>을 알려준다.</p>\n\n<p>작업 A는 함수 B의 종료 여부에는 일단 관심이 없다.</p>\n\n<p>B 함수가 자신의 실행을 완료했다면, A 함수의 어깨를 톡톡 쳐서 알려주면 되는 것이다.</p>\n\n<blockquote>\n  <p>다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우에 활용할 수 있다. <br />\n또한, 대용량의 데이터를 처리하는 서비스에서 흔히 사용된다. <br />\n가장 큰 특징은 호출 함수에 콜백 함수를 넣었다는 점이다.</p>\n</blockquote>\n\n<h2 id=\"4-3-동기--논블로킹\">4-3. 동기 + 논블로킹</h2>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다.</p>\n\n<p>이후 바로 자신의 코드를 실행한다. (<strong>논블로킹</strong>)</p>\n\n<p>즉, 다른 작업이 진행되는 동안에도 자신의 작업을 별개로 처리할 수 있다.</p>\n\n<p>조심할 것이 함수 A는 함수 B의 Return 값을 필요로 하는 것은 변함이 없다는 점이다.</p>\n\n<p>A 함수는 B 함수의 리턴값이 필요하기 때문에, 중간중간 B 함수에게 함수 실행을 완료했는지 물어본다.</p>\n\n<p>즉, A 함수(caller)가 B 함수(callee)의 실행이 종료되었는지 계속 예의 주시해야 한다. (순서 보장을 위해)</p>\n\n<p>이로써 작업을 순차대로 수행할 수 있는 것이다. (<strong>동기</strong>)</p>\n\n<p>여기서 조금 더 깊게 생각해보자.</p>\n\n<p>어떻게 동기적으로 진행되면서 메인 쓰레드가 논블로킹이 될 수 있을까?</p>\n\n<p>이 조합의 특징은 “작업 완료는 비동기로 처리하지만, 호출자는 필요할 때 결과를 동기적으로 받는다.”로 정리할 수 있다.</p>\n\n<p>즉, <strong>순서를 유지하면서 결과를 사용해야 할 때 동기적으로 기다릴 수 있다.</strong></p>\n\n<p>결국 <strong>동기적</strong> 이라는 말은 <strong>호출자의 결과가 필요한 시점에서 순서를 보장</strong>하며 작업을 진행한다는 것이다.</p>\n\n<p>다음 JAVA 코드의 예시를 봐보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SimpleDownloader</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>  <span class=\"c1\">// 다운로드 진행률</span>\n        \n        <span class=\"c1\">// 다운로드 시작</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"파일 다운로드를 시작합니다.\"</span><span class=\"o\">);</span>\n        \n        <span class=\"c1\">// 진행률 확인하면서 다른 작업 수행 (논블로킹)</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">downloadProgress</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">{</span>  <span class=\"c1\">// 동기적: 순서 보장</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"진행률: \"</span> <span class=\"o\">+</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">+</span> <span class=\"s\">\"%\"</span><span class=\"o\">);</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다른 작업을 할 수 있어요!\"</span><span class=\"o\">);</span>\n            \n            <span class=\"c1\">// 진행률이 증가한다고 가정</span>\n            <span class=\"n\">downloadProgress</span> <span class=\"o\">+=</span> <span class=\"mi\">20</span><span class=\"o\">;</span>\n            \n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>  <span class=\"c1\">// 1초 대기</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        \n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다운로드 완료!\"</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><em>🚨 주의: 이 예시 코드는 Thread를 사용하고 있다. <br />\nThread는 기본적으로 작업을 병렬적으로 처리하기 위한 도구이다. <br />\n비동기 프로그래밍에서는 이러한 Thread의 병렬 처리 능력을 활용하여 비동기 작업을 구현하는 것이 일반적이다. <br />\n하지만 이 예시의 주된 목적은 작업이 어떻게 논블로킹하면서도 동기적으로 처리될 수 있는지를 시각적으로 보여주는 것이다. <br />\nThread를 사용한 것은 개념을 쉽게 설명하기 위한 것이다.</em></p>\n\n<p>이 코드의 결과는 다음과 같을 것이다.</p>\n<div class=\"language-css highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">나는</span> <span class=\"nt\">다른</span> <span class=\"nt\">작업을</span> <span class=\"nt\">진행할게</span><span class=\"o\">.</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">시작</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">0</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">1</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">2</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">완료</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드</span> <span class=\"nt\">종료</span> <span class=\"nt\">확인</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">모든</span> <span class=\"nt\">작업</span> <span class=\"nt\">완료</span><span class=\"o\">.</span>\n</code></pre></div></div>\n\n<p>물론, 논블로킹 메서드로 비동기 작업을 시작하더라도, 결과를 기다려야 하는 시점에서는 블로킹처럼 동작할 수 있다. <br />\n왜냐하면 메인 스레드가 결과를 받아야만 다음 작업을 진행할 수 있기 때문에, 그 시점에서는 블로킹이 되는 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b43ec8c4-9783-4fbf-9f7a-3736dff051bb\" alt=\"image\" width=\"80%\" class=\"center\" /></p>\n\n<p>사실 이러한 방식의 구현은 흔치 않다. <br />\n하지만, 몇 가지 활용 예를 알아보자면 <strong>게임 로딩화면 구성</strong> 등에 활용될 수 있다. <br />\n보통 게임에서 패치나 다운로드를 할 때, 사용자에게 ProgressBar나 게임 Tip등을 띄워줘야 할 때가 있다. <br />\n이 때는 Load 하는 동작이 완료될 때 까지 (작업 순서는 보장 = Sync) <br />\n다른 작업이 진행될 수 있다. (Non-Blocking)\n즉, 사용자 경험 측면에서 유용하게 활용될 수 있다.</p>\n\n<blockquote>\n  <p>언어 간에는 구현 방식에 차이가 있을 수 있다. <br />\n이는 각 언어의 특성과 제공되는 라이브러리나 기술에 따라 달라질 수 있다. <br />\n예를 들어, JavaScript는 단일 스레드 기반으로 동작하며, 콜백 함수, 프로미스(Promise), async/await 등의 메커니즘을 사용해 동기와 논블로킹 처리를 구현할 수 있다. <br />\n기본적으로 Promise.then 방식은 비동기적이고 논블로킹 방식으로 처리된다. <br />\n그러나 async/await 키워드를 사용하면, 비동기 작업의 순서를 지정할 수 있다.<br />\n중요한 점은, async 함수가 내부적으로 비동기적으로 동작하며, 메인 콜 스택이 모두 비워져야 실행된다는 것이다. <br />\n이로 인해 async/await도 내부적으로는 여전히 비동기적이고 논블로킹 방식으로 동작한다는 점을 유의해야 한다.\n(동기적인 코드 흐름처럼 보이게 하는 트릭)</p>\n</blockquote>\n\n<h2 id=\"4-4-비동기--블로킹\">4-4. 비동기 + 블로킹</h2>\n\n<p>이러한 방식은 사실 실무에서 마주치기 더더욱 흔치 않다.</p>\n\n<p>개념만 간단히 설명하자면,</p>\n\n<p>다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다린다. (<strong>블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않고, 콜백함수를 보낸 후 기다린다.</p>\n\n<p>이로써 작업 완료의 순서는 보장되지 않을 수 있다. (<strong>비동기</strong>)</p>\n\n<p><strong>즉, 함수 A는 자신과 관련없는 함수 B의 작업이 끝날 때까지 기다려야 한다.</strong>\n<em>매우 비효율적인 로직…</em></p>\n\n<p>1 작업 중에 2 작업을 해야지 Async의 이점을 살릴 수 있는 것인데,\n이것을 다시 Blocking 방식을 사용함여 대기시킴으로써 이점을 제거해버린 것이다…😅\n대부분의 경우 비동기+논블로킹 모델이 더 효율적인 선택이 될 것이다.</p>\n\n<p><br /></p>\n\n<h1 id=\"5-현대-프로그래밍에서-이러한-개념이-왜-중요한가\">5. 현대 프로그래밍에서 이러한 개념이 왜 중요한가?</h1>\n\n<p>이러한 이해는 현대 소프트웨어 개발에서 매우 중요하다. 오늘날의 애플리케이션들은 수많은 동시다발적인 작업을 처리해야 한다. 사용자는 파일을 다운로드하면서 동시에 문서를 편집하길 원하고, 데이터가 백그라운드에서 처리되는 동안에도 끊김 없는 인터페이스 사용을 기대한다.</p>\n\n<p>더군다나 클라우드 컴퓨팅과 마이크로서비스 아키텍처가 보편화된 현대 개발 환경에서는, 네트워크를 통한 수많은 비동기 작업들이 동시에 발생한다. 이때 각 작업을 어떻게 처리할지, 작업 간의 의존성은 어떻게 관리할지를 결정하는 것은 시스템의 성능과 사용자 경험을 좌우하는 핵심 요소가 된다.</p>\n\n<p>결국 이러한 개념들의 이해는 단순히 기술적인 지식을 넘어서, 현대 소프트웨어가 직면한 복잡성과 사용자 경험의 요구사항을 어떻게 조화롭게 해결할 수 있을지에 대한 통찰을 제공한다. 이는 우리가 더 효율적이고, 반응성 높은, 그리고 사용자 친화적인 소프트웨어를 설계하고 구현하는 데 있어 필수적인 기반이 될 것이다.</p>\n\n<h1 id=\"6-마무리\">6. 마무리</h1>\n<p>그렇다면 Java에서는 이러한 비동기 처리를 어떻게 구현할 수 있을까?</p>\n\n<p>Java의 비동기 프로그래밍은 Thread를 시작으로, 현대적인 CompletableFuture까지 꾸준히 발전해왔다.</p>\n\n<p>이제 각각의 방식을 자세히 살펴보겠다.</p>\n",
                        "tags": ["Java","Spring-Boot","Backend","Sync","Async","Concurrency","Blocking","NonBlocking"]
                    }
                
            ],
        
            "NonBlocking": [
                
                    {
                        "title": "동기/비동기와 블로킹/논블로킹에 대해 깊이 파헤치기",
                        "url": "/2025/01/12/understanding-sync-async-blocking-non-blocking.html",
                        "subtitle": "Java/SpringBoot에서의 비동기 처리",
                        "excerpt": "1. 개념적 이해\n",
                        "author": "Jinho",
                        "date": "January 12, 2025",
                        "background": "/img/posts/sync-async-concept.jpeg",
                        "content": "<h1 id=\"1-개념적-이해\">1. 개념적 이해</h1>\n\n<p>비동기 처리에 대해 이야기하기 앞서, 과연 “동기”란 어떤 것인지부터 바로 잡고 가려고한다.</p>\n\n<p>왜냐하면 <strong>비(非)동기</strong>란 동기가 아니다라는 의미이기 때문에 동기가 무엇인지부터 정확히 하고 싶었다.</p>\n\n<p>또한 나는 처음에 ‘동기=블로킹, 비동기=논블로킹’이라고 단순하게 이해하고 있었다.</p>\n\n<p>하지만 실제로는 두 개념이 분류 기준이 전혀 다른 독립적인 개념이라는 것을 알게 되었다.</p>\n\n<p>이렇듯 서로 혼동되어 쓰이는 각 명칭은 어떤 의미인지 알아보려고 한다.</p>\n\n<p>이에 대해 자세히 알아보자.</p>\n\n<p><br /></p>\n\n<h1 id=\"2-동기와-비동기\">2. 동기와 비동기</h1>\n\n<p><img src=\"https://velog.velcdn.com/images/jinho7/post/a47f1973-3895-4438-a47f-80dd80245e41/image.png\" alt=\"\" width=\"100%\" height=\"100%\" class=\"center\" /></p>\n\n<blockquote>\n  <p>동기와 비동기는 “작업의 처리 방식”을 나타내는 개념이다. <br />\n결론부터 말하자면, 이둘의 주요한 차이점은 “작업 순서 처리 차이”이다.</p>\n</blockquote>\n\n<h2 id=\"2-1-동기-순차적으로-실행\">2-1. 동기: 순차적으로 실행</h2>\n<p>필자는 이전에 동기를 <strong>겹치지 않고 순차적으로 작업을 진행하는 것</strong> 정도로 이해하고 있었다.</p>\n\n<p>영어 사전을 참고해보자.</p>\n\n<blockquote>\n  <p>synchronous\nadjective\nhappening or done at the same time or speed:</p>\n</blockquote>\n\n<p><strong>Synchronous</strong> 는 동시에 발생하는 두 개 이상의 사건이나 프로세스가 동일한 시간에서 진행되는 것을 의미하는 형용사이다.</p>\n\n<p>중요한 워딩은 [동일한 시간에 여러 개의 사건이 진행] 된다는 것이다.</p>\n\n<p>‘순차적’과 ‘동시’라는 단어가 서로 상충된다고 생각할 수 있다.</p>\n\n<p>여기서 오해하면 안되는 것이 이는 <strong>병렬적인 작업방식을 말하는 것이 아니다.</strong></p>\n\n<p>“어떠한 일정 시점에 현재 작업의 Response과 다음 작업의 Request이 함께 진행되는 것”</p>\n\n<p>위의 그림을 참고하면 이해가 쉽다.\n작업 A가 끝나는 시간과 작업 B가 시작하는 시간이 동기화된다고 이해하면 좋을 것 같다.</p>\n\n<p>이는 <strong>작업이 순차적으로 처리되며, 이전 작업이 완료될 때까지는 다음 작업이 시작되지 않음을 나타낸다.</strong></p>\n\n<p>즉, <strong>작업들이 서로 시간적 의존성을 가지고 실행된다</strong>는 뜻이다.</p>\n\n<p>동기 방식은 실행 순서가 보장되며 예측 가능하다는 장점이 있지만, <br />\n앞선 작업이 오래 걸리면 전체 작업이 지연된다는 단점도 있다.</p>\n\n<h2 id=\"2-2-비동기-독립적으로-실행\">2-2. 비동기: 독립적으로 실행</h2>\n<p>그렇다면 비동기 방식은 무엇일까?</p>\n\n<p>반대의 경우를 생각하면 된다.</p>\n\n<p>위의 그림을 참고하면 작업들이 병렬적으로 일어나고 있음을 알 수 있다.</p>\n\n<p>동기와 반대로 <strong>“요청을 보냈을 때 응답 상태와 상관없이 다른 동작을 수행할 수 있다.”</strong>는 점이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/0a188e4a-b35f-41aa-9953-94504330dd9f\" alt=\"다운로드\" width=\"68%\" height=\"50%\" class=\"center\" />\n<em class=\"image-caption\">파일 다운로드가 동기 방식이라면?</em></p>\n\n<p>만약에 파일 다운로드를 동기적으로 처리한다고 해보자.</p>\n\n<p>아마 파일이 다운로드될 때까지 아무런 작업도 수행할 수 없을 것이고,\n파일이 완전히 다운로드된 후에 다음 작업을 진행할 수 있을 것이다. 😅</p>\n\n<p>매우 비효율적인 방식이다…</p>\n\n<p>그러나 비동기적인 방식을 활용한다면, 파일 다운로드 작업을 시작시켜놓고, 다른 작업을 수행할 수 있다.</p>\n\n<p>파일이 다운로드되면 특정 콜백 함수를 호출하여, 다운로드된 파일을 처리하거나 결과를 반환받을 수 있다.</p>\n\n<p>콜백 뿐만이 아니고, 그 결과는 콜백 함수, Promise, 이벤트 등을 통해 전달받을 수 있다.</p>\n\n<p>마치 택배를 주문하고 배송 알림을 받는 것과 비슷하다고 할 수 있다.</p>\n\n<h3 id=\"비동기-동작-방식에-대한-오해\">비동기 동작 방식에 대한 오해</h3>\n<p>많은 개발자들이 <strong>비동기 = 멀티 쓰레드</strong>라고 이해하고 있다.</p>\n\n<p>단순히 생각해보아도, 여러 작업이 동시에 처리되는 비동기 동작을 구현하기 위해서는 당연히 여러 개의 쓰레드가 필요할 것 같기 때문이다.</p>\n\n<p>또한, 특히나 대부분의 Java 개발자들이 비동기 프로그래밍을 접할 때 아래와 같은 코드를 통해 배우기 때문이다.</p>\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 여기서 실제로 별도의 스레드에서 실행됨</span>\n    <span class=\"k\">return</span> <span class=\"nf\">heavyTask</span><span class=\"o\">();</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p>우리는 Java에서 비동기 처리에 대해 다룰 때, ExecutorService나 CompletableFuture와 같은 도구들을 함께 배운다.</p>\n\n<p>이들은 내부적으로 <strong>스레드 풀</strong>을 사용하기 때문에, 자연스럽게 비동기 처리와 멀티 쓰레드를 동일시하게 된다.</p>\n\n<p>실제로 Spring Framework의 @Async 어노테이션도 비동기 처리를 위해 기본적으로 스레드 풀을 사용한다.</p>\n\n<p>하지만 비동기 처리의 본질은 <strong>“작업의 완료를 기다리지 않고 다른 작업을 수행할 수 있는 것”</strong>이다.</p>\n\n<p>이는 반드시 멀티스레드로만 구현되어야 하는 것이 아니며, Node.js가 좋은 예시다.</p>\n\n<p>Node.js는 싱글 스레드 기반의 이벤트 루프를 사용하여 비동기 처리를 구현한다.</p>\n\n<p>이벤트 루프는 OS의 비동기 I/O 기능을 활용하여 실제 I/O 작업을 커널 레벨에서 처리하고,</p>\n\n<p>작업이 완료되면 이벤트를 통해 알림을 받는 방식으로 동작한다.</p>\n\n<div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Node.js의 비동기 처리 (싱글스레드)</span>\n<span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nf\">readFile</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">file.txt</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">파일 읽기 완료</span><span class=\"dl\">'</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nf\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">다음 작업 실행</span><span class=\"dl\">'</span><span class=\"p\">);</span>  <span class=\"c1\">// 파일 읽기를 기다리지 않고 실행</span>\n</code></pre></div></div>\n<p>이러한 이벤트 루프 기반의 비동기 처리는 멀티스레드 없이도 효율적인 비동기 처리를 가능하게 한다.\nOS의 비동기 I/O 기능을 활용하여, 실제 I/O 작업은 커널 레벨에서 처리되고, 완료되면 이벤트를 통해 알림을 받는 방식이다.\n<em>정확히는 JavaScript 엔진이 싱글 스레드 기반이다</em>\n<em>해당 내용에 대해 더 자세히 알고 싶다면 <a href=\"https://puleugo.tistory.com/133\">해당 블로그</a>를 참고하자</em></p>\n\n<p><br /></p>\n\n<h1 id=\"3-블로킹과-논블로킹\">3. 블로킹과 논블로킹</h1>\n<blockquote>\n  <p>블로킹과 논블로킹은 “제어권의 이동” 관점에서 바라보는 개념이다.</p>\n</blockquote>\n\n<p>결국 “호출한 함수가 다른 일을 할 수 있는가?”의 여부를 의미한다.</p>\n\n<h2 id=\"3-1-제어권control-flow의-의미\">3-1. 제어권(Control Flow)의 의미</h2>\n<p>여기서 <strong>제어권</strong>이란 어떤 의미를 갖는지 먼저 보자.\nOS적인 관점에서 보자면, <strong>현재 작업을 진행하고 있는 함수가 CPU를 점유하는 것</strong>을 의미한다.\n쉽게 말해 “코드를 실행시킬 수 있는 권한” 정도로 말할 수 있다.</p>\n\n<p>동기 와 비동기는 Jobs 들이 순서대로 혹은 독립적으로 처리되는가에 관한 이야기라면,\n이번에는 호출한 함수가 별개의 일을 할 수 있는지의 이야기이다.</p>\n\n<h2 id=\"3-2-블로킹-제어권을-넘겨주는-방식\">3-2. 블로킹: 제어권을 넘겨주는 방식</h2>\n<p>마치 시험지를 넘겨주는 방식을 생각하면 편할 것 같다.\n<img src=\"https://github.com/user-attachments/assets/6eb36e86-150c-4144-86ce-6080ef86bece\" alt=\"image\" width=\"60%\" height=\"100%\" class=\"center\" />\n<em class=\"image-caption\">출처 : https://www.veritas-a.com/news/articleView.html?idxno=156699</em></p>\n\n<p>내가 뒷 사람에게 시험지를 넘겨줄 때,\n나는 아무런 행동도 하지 않고 <strong>뒷 사람(호출된 함수)가 시험지를 가져가는(자신의 작업을 완료)할 때 까지</strong> 나는 손에 시험지를 쥐고 뒷사람을 바라보고 대기할 수 밖에 없다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/d799e31b-9406-44f3-8dcc-9df15b8f8a79\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>둘 간의 구분 방법은 제어권이 누구에게 있는지로 결정된다.</p>\n\n<p>블로킹에서는 함수 A가 함수 B를 호출할 때 제어권이 B로 넘어간다.</p>\n\n<p>제어권을 넘겨준 A는 B의 작업이 완료될 때까지 아무 작업도 수행할 수 없는 상태, 즉 블로킹 상태가 된다.</p>\n\n<p>즉, 위의 사진에서 A함수는 B함수에게 제어권을 넘겨줌과 동시에 함수 실행이 일시 정지된다. = Blocking</p>\n\n<h2 id=\"3-3-논블로킹-제어권을-유지하는-방식\">3-3. 논블로킹: 제어권을 유지하는 방식</h2>\n<p>하지만 시험지를 그냥 뒷 사람 책상에 올려 놓는다면 어떨까.</p>\n\n<p>나는 실제 뒷 사람이 받는 것을 대기할 필요없이, 바로 나의 다른 작업을 할 수 있다.</p>\n\n<p>즉, 뒷 사람(호출된 함수)이 나에 대한 제어권을 바로 반환해줌으로, 호출한 쪽(나)에서는 계속 다른 작업을 할 수 있는 것이다.</p>\n\n<p>같은 “읽기” 작업이어도 동기와 비동기 처리에 따라 어떻게 다르게 동작하는지 보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹: 제어권을 넘겨줌</span>\n<span class=\"nc\">String</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">readFile</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 파일 읽을 때까지 다른 일 못함</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                          <span class=\"c1\">// 파일 다 읽고 나서야 실행</span>\n\n<span class=\"c1\">// 논블로킹: 제어권을 유지</span>\n<span class=\"nc\">Future</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">readFileAsync</span><span class=\"o\">(</span><span class=\"s\">\"file.txt\"</span><span class=\"o\">);</span>  <span class=\"c1\">// 요청만 하고</span>\n<span class=\"n\">doNextWork</span><span class=\"o\">();</span>                               <span class=\"c1\">// 바로 다른 일 할 수 있음</span>\n</code></pre></div></div>\n<p><img src=\"https://github.com/user-attachments/assets/4a59addb-b12d-4eaa-90c9-fe783a7556e0\" alt=\"image\" width=\"60%\" height=\"60%\" class=\"center\" /></p>\n\n<p>반면 논블로킹에서는 A함수가 B함수를 호출하더라도 제어권을 계속 유지한다.</p>\n\n<p>따라서 B함수가 실행되는 동안에도, A함수는 제어권을 가지고 있기 때문에 다른 작업을 수행할 수 있다.</p>\n\n<p>이렇게 호출자(caller)인 A함수는 B함수의 작업 완료 여부와 관계없이 자신의 작업을 계속 수행할 수 있다.</p>\n\n<p><br /></p>\n\n<h1 id=\"4-네-가지-조합의-동작-방식\">4. 네 가지 조합의 동작 방식</h1>\n\n<p>가끔 동기 처리에서는 무조건적으로 블로킹이 일어나고, 비동기에서는 논블로킹이 일어난다고 오해하는 경우가 많다.</p>\n\n<p>하지만 두 쌍의 개념은 서로 다른 관점에서 바라보는 개념이라는 것을 확실하게 하고 넘어가자.</p>\n\n<blockquote>\n  <p>동기/비동기 : 작업들의 시간적 관계성 <br />\n블로킹/논블로킹 : 제어권의 소재</p>\n</blockquote>\n\n<p>하지만 이 개념들이 오해가 잦은 이유는 실제 구현에서 [동기/볼로킹 &amp; 비동기/논블로킹]이 <strong>자주 함께 사용</strong>되기 때문이다.</p>\n\n<p>다음 그림을 보고 4가지 조합에 대해 천천히 살펴보자.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b894be55-d296-424d-913f-ee989233eb60\" alt=\"image\" width=\"100%\" class=\"center\" /></p>\n\n<p>먼저 흔히 쓰이는 [동기/볼로킹 &amp; 비동기/논블로킹] 에 대해 보자.</p>\n\n<h2 id=\"4-1-동기--블로킹\">4-1. 동기 + 블로킹</h2>\n\n<p>작업의 흐름이 순차적으로 진행되는 것이 보장된다. (<strong>동기</strong>)</p>\n\n<p>제어권을 함수 B에게 넘겨준 후 함수 A는 대기하게 된다. (<strong>블로킹</strong>)</p>\n\n<p>함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄 때까지 함수 A는 기다리는 것이다.</p>\n\n<blockquote>\n  <p>이러한 조합은 <strong>작업이 완료될 때까지 기다려야 하는 경우</strong>에 사용된다. <br />\n예를 들면, 파일을 읽은 후 이를 처리하는 코드를 생각해보자. <br />\n파일을 처리하는 과정은 <strong>필연적으로 파일을 모두 읽은 후에 작업이 가능</strong>하기 때문이다. <br />\n또한, 일반적으로 작업이 간단하거나 작업량이 적은 경우에 사용된다. <br />\n작업량이 많거나 오래 걸리는 작업을 해당 방식으로 처리하면 <strong>전체 프로그램이 멈춘 것 처럼 보여</strong> 사용자 경험 측면에서 나빠질 수 있다.</p>\n</blockquote>\n\n<h2 id=\"4-2-비동기--논블로킹\">4-2. 비동기 + 논블로킹</h2>\n\n<p>비동기 + 논블로킹 방식도 비교적 이해가 쉽다.</p>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다. (<strong>논블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 방식이다. (<strong>동기</strong>)</p>\n\n<p>함수 B를 호출 할 때, 콜백 함수를 함께 줌으로써, 함수 B는 자신의 작업이 끝났을 때 <strong>함수 A에게 준 콜백 함수를 실행시켜 자신의 작업이 끝났음</strong>을 알려준다.</p>\n\n<p>작업 A는 함수 B의 종료 여부에는 일단 관심이 없다.</p>\n\n<p>B 함수가 자신의 실행을 완료했다면, A 함수의 어깨를 톡톡 쳐서 알려주면 되는 것이다.</p>\n\n<blockquote>\n  <p>다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우에 활용할 수 있다. <br />\n또한, 대용량의 데이터를 처리하는 서비스에서 흔히 사용된다. <br />\n가장 큰 특징은 호출 함수에 콜백 함수를 넣었다는 점이다.</p>\n</blockquote>\n\n<h2 id=\"4-3-동기--논블로킹\">4-3. 동기 + 논블로킹</h2>\n\n<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다.</p>\n\n<p>이후 바로 자신의 코드를 실행한다. (<strong>논블로킹</strong>)</p>\n\n<p>즉, 다른 작업이 진행되는 동안에도 자신의 작업을 별개로 처리할 수 있다.</p>\n\n<p>조심할 것이 함수 A는 함수 B의 Return 값을 필요로 하는 것은 변함이 없다는 점이다.</p>\n\n<p>A 함수는 B 함수의 리턴값이 필요하기 때문에, 중간중간 B 함수에게 함수 실행을 완료했는지 물어본다.</p>\n\n<p>즉, A 함수(caller)가 B 함수(callee)의 실행이 종료되었는지 계속 예의 주시해야 한다. (순서 보장을 위해)</p>\n\n<p>이로써 작업을 순차대로 수행할 수 있는 것이다. (<strong>동기</strong>)</p>\n\n<p>여기서 조금 더 깊게 생각해보자.</p>\n\n<p>어떻게 동기적으로 진행되면서 메인 쓰레드가 논블로킹이 될 수 있을까?</p>\n\n<p>이 조합의 특징은 “작업 완료는 비동기로 처리하지만, 호출자는 필요할 때 결과를 동기적으로 받는다.”로 정리할 수 있다.</p>\n\n<p>즉, <strong>순서를 유지하면서 결과를 사용해야 할 때 동기적으로 기다릴 수 있다.</strong></p>\n\n<p>결국 <strong>동기적</strong> 이라는 말은 <strong>호출자의 결과가 필요한 시점에서 순서를 보장</strong>하며 작업을 진행한다는 것이다.</p>\n\n<p>다음 JAVA 코드의 예시를 봐보자.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SimpleDownloader</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>  <span class=\"c1\">// 다운로드 진행률</span>\n        \n        <span class=\"c1\">// 다운로드 시작</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"파일 다운로드를 시작합니다.\"</span><span class=\"o\">);</span>\n        \n        <span class=\"c1\">// 진행률 확인하면서 다른 작업 수행 (논블로킹)</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">downloadProgress</span> <span class=\"o\">&lt;</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">{</span>  <span class=\"c1\">// 동기적: 순서 보장</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"진행률: \"</span> <span class=\"o\">+</span> <span class=\"n\">downloadProgress</span> <span class=\"o\">+</span> <span class=\"s\">\"%\"</span><span class=\"o\">);</span>\n            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다른 작업을 할 수 있어요!\"</span><span class=\"o\">);</span>\n            \n            <span class=\"c1\">// 진행률이 증가한다고 가정</span>\n            <span class=\"n\">downloadProgress</span> <span class=\"o\">+=</span> <span class=\"mi\">20</span><span class=\"o\">;</span>\n            \n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>  <span class=\"c1\">// 1초 대기</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        \n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"다운로드 완료!\"</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><em>🚨 주의: 이 예시 코드는 Thread를 사용하고 있다. <br />\nThread는 기본적으로 작업을 병렬적으로 처리하기 위한 도구이다. <br />\n비동기 프로그래밍에서는 이러한 Thread의 병렬 처리 능력을 활용하여 비동기 작업을 구현하는 것이 일반적이다. <br />\n하지만 이 예시의 주된 목적은 작업이 어떻게 논블로킹하면서도 동기적으로 처리될 수 있는지를 시각적으로 보여주는 것이다. <br />\nThread를 사용한 것은 개념을 쉽게 설명하기 위한 것이다.</em></p>\n\n<p>이 코드의 결과는 다음과 같을 것이다.</p>\n<div class=\"language-css highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">나는</span> <span class=\"nt\">다른</span> <span class=\"nt\">작업을</span> <span class=\"nt\">진행할게</span><span class=\"o\">.</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">시작</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">0</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">1</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"err\">2</span><span class=\"nt\">번째</span> <span class=\"nt\">작업</span> <span class=\"nt\">수행</span> <span class=\"nt\">중</span><span class=\"o\">...</span>\n<span class=\"o\">...</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드야</span><span class=\"o\">,</span> <span class=\"nt\">작업</span> <span class=\"nt\">끝났니</span><span class=\"o\">?</span> <span class=\"o\">=</span> <span class=\"nt\">No</span>\n<span class=\"o\">[</span><span class=\"nt\">작업</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">실행</span> <span class=\"nt\">완료</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">작업</span> <span class=\"nt\">스레드</span> <span class=\"nt\">종료</span> <span class=\"nt\">확인</span><span class=\"o\">!</span>\n<span class=\"o\">[</span><span class=\"nt\">메인</span> <span class=\"nt\">스레드</span><span class=\"o\">]</span> <span class=\"nt\">모든</span> <span class=\"nt\">작업</span> <span class=\"nt\">완료</span><span class=\"o\">.</span>\n</code></pre></div></div>\n\n<p>물론, 논블로킹 메서드로 비동기 작업을 시작하더라도, 결과를 기다려야 하는 시점에서는 블로킹처럼 동작할 수 있다. <br />\n왜냐하면 메인 스레드가 결과를 받아야만 다음 작업을 진행할 수 있기 때문에, 그 시점에서는 블로킹이 되는 것이다.</p>\n\n<p><img src=\"https://github.com/user-attachments/assets/b43ec8c4-9783-4fbf-9f7a-3736dff051bb\" alt=\"image\" width=\"80%\" class=\"center\" /></p>\n\n<p>사실 이러한 방식의 구현은 흔치 않다. <br />\n하지만, 몇 가지 활용 예를 알아보자면 <strong>게임 로딩화면 구성</strong> 등에 활용될 수 있다. <br />\n보통 게임에서 패치나 다운로드를 할 때, 사용자에게 ProgressBar나 게임 Tip등을 띄워줘야 할 때가 있다. <br />\n이 때는 Load 하는 동작이 완료될 때 까지 (작업 순서는 보장 = Sync) <br />\n다른 작업이 진행될 수 있다. (Non-Blocking)\n즉, 사용자 경험 측면에서 유용하게 활용될 수 있다.</p>\n\n<blockquote>\n  <p>언어 간에는 구현 방식에 차이가 있을 수 있다. <br />\n이는 각 언어의 특성과 제공되는 라이브러리나 기술에 따라 달라질 수 있다. <br />\n예를 들어, JavaScript는 단일 스레드 기반으로 동작하며, 콜백 함수, 프로미스(Promise), async/await 등의 메커니즘을 사용해 동기와 논블로킹 처리를 구현할 수 있다. <br />\n기본적으로 Promise.then 방식은 비동기적이고 논블로킹 방식으로 처리된다. <br />\n그러나 async/await 키워드를 사용하면, 비동기 작업의 순서를 지정할 수 있다.<br />\n중요한 점은, async 함수가 내부적으로 비동기적으로 동작하며, 메인 콜 스택이 모두 비워져야 실행된다는 것이다. <br />\n이로 인해 async/await도 내부적으로는 여전히 비동기적이고 논블로킹 방식으로 동작한다는 점을 유의해야 한다.\n(동기적인 코드 흐름처럼 보이게 하는 트릭)</p>\n</blockquote>\n\n<h2 id=\"4-4-비동기--블로킹\">4-4. 비동기 + 블로킹</h2>\n\n<p>이러한 방식은 사실 실무에서 마주치기 더더욱 흔치 않다.</p>\n\n<p>개념만 간단히 설명하자면,</p>\n\n<p>다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다린다. (<strong>블로킹</strong>)</p>\n\n<p>다른 작업의 결과를 바로 처리하지 않고, 콜백함수를 보낸 후 기다린다.</p>\n\n<p>이로써 작업 완료의 순서는 보장되지 않을 수 있다. (<strong>비동기</strong>)</p>\n\n<p><strong>즉, 함수 A는 자신과 관련없는 함수 B의 작업이 끝날 때까지 기다려야 한다.</strong>\n<em>매우 비효율적인 로직…</em></p>\n\n<p>1 작업 중에 2 작업을 해야지 Async의 이점을 살릴 수 있는 것인데,\n이것을 다시 Blocking 방식을 사용함여 대기시킴으로써 이점을 제거해버린 것이다…😅\n대부분의 경우 비동기+논블로킹 모델이 더 효율적인 선택이 될 것이다.</p>\n\n<p><br /></p>\n\n<h1 id=\"5-현대-프로그래밍에서-이러한-개념이-왜-중요한가\">5. 현대 프로그래밍에서 이러한 개념이 왜 중요한가?</h1>\n\n<p>이러한 이해는 현대 소프트웨어 개발에서 매우 중요하다. 오늘날의 애플리케이션들은 수많은 동시다발적인 작업을 처리해야 한다. 사용자는 파일을 다운로드하면서 동시에 문서를 편집하길 원하고, 데이터가 백그라운드에서 처리되는 동안에도 끊김 없는 인터페이스 사용을 기대한다.</p>\n\n<p>더군다나 클라우드 컴퓨팅과 마이크로서비스 아키텍처가 보편화된 현대 개발 환경에서는, 네트워크를 통한 수많은 비동기 작업들이 동시에 발생한다. 이때 각 작업을 어떻게 처리할지, 작업 간의 의존성은 어떻게 관리할지를 결정하는 것은 시스템의 성능과 사용자 경험을 좌우하는 핵심 요소가 된다.</p>\n\n<p>결국 이러한 개념들의 이해는 단순히 기술적인 지식을 넘어서, 현대 소프트웨어가 직면한 복잡성과 사용자 경험의 요구사항을 어떻게 조화롭게 해결할 수 있을지에 대한 통찰을 제공한다. 이는 우리가 더 효율적이고, 반응성 높은, 그리고 사용자 친화적인 소프트웨어를 설계하고 구현하는 데 있어 필수적인 기반이 될 것이다.</p>\n\n<h1 id=\"6-마무리\">6. 마무리</h1>\n<p>그렇다면 Java에서는 이러한 비동기 처리를 어떻게 구현할 수 있을까?</p>\n\n<p>Java의 비동기 프로그래밍은 Thread를 시작으로, 현대적인 CompletableFuture까지 꾸준히 발전해왔다.</p>\n\n<p>이제 각각의 방식을 자세히 살펴보겠다.</p>\n",
                        "tags": ["Java","Spring-Boot","Backend","Sync","Async","Concurrency","Blocking","NonBlocking"]
                    }
                
            ],
        
            "Spring": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    }
                
            ],
        
            "SpringBoot": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    }
                
            ],
        
            "Thread": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    }
                
            ],
        
            "Runnable": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    }
                
            ],
        
            "CompletableFuture": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    }
                
            ],
        
            "ThreadPool": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    }
                
            ],
        
            "ThreadPoolTaskExecutor": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    }
                
            ],
        
            "I/O": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    }
                
            ],
        
            "Performance": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    }
                
            ],
        
            "WebFlux": [
                
                    {
                        "title": "Java/SpringBoot에서의 비동기 처리",
                        "url": "/2025/01/15/asynchronous-processing-in-java-spring.html",
                        "subtitle": "효율적인 비동기 처리",
                        "excerpt": "2. Java에서의 구현과 실제 경험\n2.1 스레드와 비동기 처리\n",
                        "author": "Jinho",
                        "date": "January 15, 2025",
                        "background": "/img/posts/asynchronous-processing-in-java-spring.png",
                        "content": "<h1 id=\"2-java에서의-구현과-실제-경험\">2. Java에서의 구현과 실제 경험</h1>\n<h2 id=\"21-스레드와-비동기-처리\">2.1 스레드와 비동기 처리</h2>\n\n<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>\n\n<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>\n\n<h3 id=\"thread와-runnable\">Thread와 Runnable</h3>\n\n<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>\n\n<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>\n\n<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>\n\n<ul>\n  <li>Thread 클래스 상속</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"nc\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">MyThread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">MyThread</span><span class=\"o\">();</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Runnable 인터페이스 구현</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"nc\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Thread: \"</span> <span class=\"o\">+</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 사용</span>\n<span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">MyRunnable</span><span class=\"o\">());</span>\n<span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>  <span class=\"c1\">// 새로운 스레드 시작</span>\n</code></pre></div></div>\n\n<p><br /></p>\n\n<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>\n<ul>\n  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>\n</ul>\n\n<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>\n\n<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>\n\n<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread에-대해-이해하기---생명주기--주의할-점\">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>\n\n<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>\n\n<p><strong>[Thread의 생명주기]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLifecycleDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"nc\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span> <span class=\"c1\">// TIMED_WAITING 상태</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"1. 초기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// NEW</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"2. 실행 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// RUNNABLE</span>\n        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">500</span><span class=\"o\">);</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"3. 대기 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TIMED_WAITING</span>\n        <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"4. 종료 상태: \"</span> <span class=\"o\">+</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">getState</span><span class=\"o\">());</span> <span class=\"c1\">// TERMINATED</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<ol>\n  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>\n  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>\n  <li>BLOCKED: 모니터 락을 기다리는 상태</li>\n  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>\n  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>\n  <li>TERMINATED: 실행이 완료된 상태</li>\n</ol>\n\n<p><strong>[Thread 사용 시 주의할 점]</strong></p>\n\n<ul>\n  <li>동기화 문제</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadSafetyExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"c1\">// 잘못된 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementWrong</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전하지 않음</span>\n    <span class=\"o\">}</span>\n    \n    <span class=\"c1\">// 올바른 구현</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">incrementCorrect</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span> <span class=\"c1\">// 스레드 안전함</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>\n\n<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>\n\n<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>\n\n<ul>\n  <li>데드락 방지</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeadlockExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">Object</span> <span class=\"n\">lock2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">();</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">method1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">lock2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>\n                <span class=\"c1\">// 데드락 발생 가능</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>\n\n<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>\n\n<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>\n\n<ul>\n  <li>스레드 인터럽트 처리</li>\n</ul>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">longRunningTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 작업 수행</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 인터럽트 발생 시 적절한 처리</span>\n            <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">interrupt</span><span class=\"o\">();</span> <span class=\"c1\">// 인터럽트 상태 복구</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>\n\n<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>\n\n<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>\n\n<p><br /></p>\n\n<h3 id=\"thread와-runnable의-한계\">Thread와 Runnable의 한계</h3>\n\n<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>\n\n<ul>\n  <li>스레드 생성과 종료의 오버헤드</li>\n  <li>결과값을 반환하기 어려움</li>\n  <li>예외 처리가 복잡함</li>\n  <li>스레드 풀 관리의 어려움</li>\n</ul>\n\n<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>\n\n<p><strong>[1. Callable 인터페이스]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Callable</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">callable</span> <span class=\"o\">=</span> <span class=\"o\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>  <span class=\"c1\">// 결과값 반환 가능</span>\n<span class=\"o\">};</span>\n\n<span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newSingleThreadExecutor</span><span class=\"o\">();</span>\n<span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">callable</span><span class=\"o\">);</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 결과값 받기</span>\n</code></pre></div></div>\n\n<ul>\n  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.\n[Runable은 아무것도 리턴하지 않는다.]</li>\n  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>\n</ul>\n\n<p><strong>[2. ExecutorService]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ExecutorService</span> <span class=\"n\">executor</span> <span class=\"o\">=</span> <span class=\"nc\">Executors</span><span class=\"o\">.</span><span class=\"na\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">);</span>  <span class=\"c1\">// 스레드 풀 생성</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 작업 수행</span>\n<span class=\"o\">});</span>\n<span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업 완료 후 스레드 풀 정리</span>\n</code></pre></div></div>\n\n<ul>\n  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>\n</ul>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>\n\n<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>\n\n<p><strong>[3. Future]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">1000</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"Future의 결과값\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// Future의 주요 메서드 활용</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isDone</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isDone</span><span class=\"o\">();</span>        <span class=\"c1\">// 작업 완료 여부 확인</span>\n<span class=\"kt\">boolean</span> <span class=\"n\">isCancelled</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">isCancelled</span><span class=\"o\">();</span> <span class=\"c1\">// 작업 취소 여부 확인</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>            <span class=\"c1\">// 결과 가져오기 (블로킹)</span>\n<span class=\"nc\">String</span> <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span> <span class=\"c1\">// 타임아웃 설정</span>\n</code></pre></div></div>\n<ul>\n  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>\n  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>\n</ul>\n\n<p>허나 다음과 같은 한계가 존재한다.</p>\n\n<ul>\n  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>\n  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.\n    <div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 블로킹이 발생하는 get() 호출</span>\n<span class=\"nc\">String</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>  <span class=\"c1\">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>\n</code></pre></div>    </div>\n  </li>\n  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>\n  <li>예외처리가 불편하다.</li>\n  <li>콜백이나 완료 통보 기능이 없다.</li>\n</ul>\n\n<blockquote>\n  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />\n이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>\n</blockquote>\n\n<p><br /></p>\n\n<h3 id=\"completablefuture-비동기-프로그래밍의-진화\">CompletableFuture: 비동기 프로그래밍의 진화</h3>\n\n<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>\n\n<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>\n\n<blockquote>\n  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>\n</blockquote>\n\n<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>\n\n<p><strong>[1. 비동기 작업 생성]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 결과가 없는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">runAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"비동기 작업 실행\"</span><span class=\"o\">);</span>\n<span class=\"o\">});</span>\n\n<span class=\"c1\">// 결과를 반환하는 비동기 작업</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"s\">\"작업 결과\"</span><span class=\"o\">;</span>\n<span class=\"o\">});</span>\n</code></pre></div></div>\n\n<p><strong>[2. 작업 조합하기]</strong></p>\n\n<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n    <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"Hello\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 첫 번째 작업</span>\n    <span class=\"o\">.</span><span class=\"na\">thenApply</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\" World\"</span><span class=\"o\">)</span>  <span class=\"c1\">// 결과를 변환</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCompose</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"s\">\"!\"</span><span class=\"o\">));</span>  <span class=\"c1\">// 다른 Future와 조합</span>\n\n<span class=\"c1\">// 두 작업의 결과 조합</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future1</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">1</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">future2</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">2</span><span class=\"o\">);</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">future1</span>\n    <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">future2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">result1</span><span class=\"o\">,</span> <span class=\"n\">result2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span><span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[3. 예외 처리]</strong></p>\n\n<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>\n\n<p><strong>[4. 타임아웃처리]</strong></p>\n\n<p>타임 아웃에 대한 처리도 가능하다.</p>\n\n<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">String</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업1\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업2\"</span><span class=\"o\">),</span>\n    <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"s\">\"작업3\"</span><span class=\"o\">)</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 모든 작업이 완료될 때까지 대기</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Void</span><span class=\"o\">&gt;</span> <span class=\"n\">allOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">allOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n\n<span class=\"c1\">// 가장 빨리 완료되는 작업 처리</span>\n<span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">anyOf</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">.</span><span class=\"na\">anyOf</span><span class=\"o\">(</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"o\">);</span>\n</code></pre></div></div>\n\n<p><strong>[실제 활용 예시]</strong></p>\n\n<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">UserService</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">UserRepository</span> <span class=\"n\">userRepository</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"nc\">PaymentApiClient</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">UserInfo</span><span class=\"o\">&gt;</span> <span class=\"nf\">getUserInfo</span><span class=\"o\">(</span><span class=\"nc\">Long</span> <span class=\"n\">userId</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">User</span><span class=\"o\">&gt;</span> <span class=\"n\">userFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">userRepository</span><span class=\"o\">.</span><span class=\"na\">findById</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">orElseThrow</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">UserNotFoundException</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">)));</span>\n\n        <span class=\"nc\">CompletableFuture</span><span class=\"o\">&lt;</span><span class=\"nc\">PaymentInfo</span><span class=\"o\">&gt;</span> <span class=\"n\">paymentFuture</span> <span class=\"o\">=</span> <span class=\"nc\">CompletableFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">supplyAsync</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">paymentApiClient</span><span class=\"o\">.</span><span class=\"na\">getPaymentInfo</span><span class=\"o\">(</span><span class=\"n\">userId</span><span class=\"o\">))</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">warn</span><span class=\"o\">(</span><span class=\"s\">\"Payment info fetch failed\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">PaymentInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultPaymentInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">userFuture</span>\n            <span class=\"o\">.</span><span class=\"na\">thenCombine</span><span class=\"o\">(</span><span class=\"n\">paymentFuture</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nf\">UserInfo</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">payment</span><span class=\"o\">);</span>\n            <span class=\"o\">})</span>\n            <span class=\"o\">.</span><span class=\"na\">orTimeout</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">)</span>  <span class=\"c1\">// 타임아웃 설정</span>\n            <span class=\"o\">.</span><span class=\"na\">exceptionally</span><span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"na\">error</span><span class=\"o\">(</span><span class=\"s\">\"Error fetching user info\"</span><span class=\"o\">,</span> <span class=\"n\">ex</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"nc\">UserInfo</span><span class=\"o\">.</span><span class=\"na\">getDefaultUserInfo</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<p><br /></p>\n\n<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>\n<ul>\n  <li>데이터 베이스에서 사용자 정보 조회</li>\n  <li>외부 API에서 결제 정보 조회</li>\n</ul>\n\n<blockquote>\n  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />\n각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>\n</blockquote>\n\n<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>\n\n<ul>\n  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>\n  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>\n</ul>\n\n<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>\n\n<blockquote>\n  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>\n</blockquote>\n\n<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>\n\n<p><br /></p>\n\n<h3 id=\"스레드-풀의-이해\">스레드 풀의 이해</h3>\n<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>\n\n<p><br />\n<br /></p>\n\n<p>// 수정중</p>\n\n<h2 id=\"22-spring의-비동기-처리\">2.2 Spring의 비동기 처리</h2>\n\n<h3 id=\"async-사용-경험과-주의점\">@Async 사용 경험과 주의점</h3>\n<h3 id=\"threadpooltaskexecutor-설정-최적화\">ThreadPoolTaskExecutor 설정 최적화</h3>\n\n<p><br /></p>\n\n<h1 id=\"3-이론적-고찰\">3. 이론적 고찰</h1>\n<h2 id=\"31-언제-비동기를-사용할까\">3.1 언제 비동기를 사용할까?</h2>\n\n<h3 id=\"io-작업이-많은-경우의-선택\">I/O 작업이 많은 경우의 선택</h3>\n<h3 id=\"대용량-데이터-처리시의-고려사항\">대용량 데이터 처리시의 고려사항</h3>\n\n<p><br /></p>\n\n<h2 id=\"32-트레이드오프\">3.2 트레이드오프</h2>\n\n<h3 id=\"디버깅의-어려움\">디버깅의 어려움</h3>\n<h3 id=\"리소스-사용량-증가\">리소스 사용량 증가</h3>\n<h3 id=\"복잡성-vs-성능-개선\">복잡성 vs 성능 개선</h3>\n\n<h1 id=\"4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍\">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>\n",
                        "tags": ["Java","Spring","SpringBoot","Async","Thread","Runnable","CompletableFuture","ThreadPool","ThreadPoolTaskExecutor","Concurrency","I/O","Performance","WebFlux"]
                    }
                
            ]
        
    };

    const posts = postsData[decodeURIComponent(tag)] || [];
    const postList = document.getElementById('post-list');
    
    if (posts.length > 0) {
        const postElements = posts.map(post => `
            <div class="post-item">
                <article class="post-preview">
                    <a href="${post.url}">
                        <h2 class="post-title">${post.title}</h2>
                        ${post.subtitle ? 
                            `<h3 class="post-subtitle">${post.subtitle}</h3>` :
                            `<h3 class="post-subtitle">${post.excerpt}</h3>`
                        }
                    </a>
                    <p class="post-meta">Posted by
                        ${post.author}
                        on
                        ${post.date} &middot; ${calculateReadTime(post.content)}
                    </p>
                    ${post.tags && post.tags.length > 0 ? `
                        <ul class="post-tags">
                            <li class="tags-label">Tags:</li>
                            ${post.tags.map(t => `
                                <a href="/tag/?tag=${encodeURIComponent(t)}" class="tag">${t}</a>
                            `).join(' ')}
                        </ul>
                    ` : ''}
                </article>

                ${post.background ? `
                    <div class="post-thumbnail">
                        <a href="${post.url}">
                            <img src="${post.background}" alt="Post Thumbnail" />
                        </a>
                    </div>
                ` : ''}
            </div>
            <hr>
        `).join('');
        
        postList.innerHTML = postElements;
    } else {
        postList.innerHTML = '<p>No posts found with this tag.</p>';
    }
}

function calculateReadTime(content) {
    const wordsPerMinute = 200;
    const wordCount = content.trim().split(/\s+/).length;
    const readTime = Math.ceil(wordCount / wordsPerMinute);
    return `${readTime} min read`;
}
</script>

  <!-- Footer -->

<hr>

<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        <ul class="list-inline text-center">
          
          <li class="list-inline-item">
            <a href="mailto:jh7524jh7524@gmail.com">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="far fa-envelope fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
          
          
          
          
          <li class="list-inline-item">
            <a href="https://github.com/jinho7">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
          
        </ul>
        <p class="copyright text-muted">Copyright &copy; Jinho 2025</p>
      </div>
    </div>
  </div>
</footer>


  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js"></script>
<script src="/assets/vendor/startbootstrap-clean-blog/js/scripts.js"></script>
<script src="/assets/vendor/startbootstrap-clean-blog/js/code-block.js"></script>
<script src="/assets/scripts.js"></script>






  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXXXX-X"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-XXXXXXXXX-X');
</script>



</body>

</html>
