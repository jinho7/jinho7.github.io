<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-01-29T16:03:10+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jinho’s Tech Blog</title><subtitle>개발에 대한 이야기를 담아내다</subtitle><author><name>Jinho</name></author><entry><title type="html">WAS(Web Application Server)와 Servlet</title><link href="http://localhost:4000/2025/01/28/about-was.html" rel="alternate" type="text/html" title="WAS(Web Application Server)와 Servlet" /><published>2025-01-28T12:30:00+09:00</published><updated>2025-01-28T12:30:00+09:00</updated><id>http://localhost:4000/2025/01/28/about-was</id><content type="html" xml:base="http://localhost:4000/2025/01/28/about-was.html"><![CDATA[<p><a href="https://jinho7.github.io/2025/01/27/ws-and-was.html" target="웹 서버(WS)의 진화 : Apache vs NGINX ">웹 서버(WS)의 진화 : Apache vs NGINX</a><br />
<em>위 post에 이어지는 내용입니다.</em></p>

<h1 id="was-란">WAS 란?</h1>

<h2 id="was의-정의">WAS의 정의</h2>

<p>먼저 WAS(Web Application Server)의 정의는 다음과 같다.</p>
<blockquote>
  <p><span class="post-highlight">웹 애플리케이션과 서버 환경을 만들어 동작시키는 기능을 제공하는 소프트웨어 프레임워크</span></p>
</blockquote>

<p>대표적으로 Apache <span class="post-highlight">Tomcat</span>이 있다.</p>
<ul>
  <li><em>참고로 Apache Tomcat는 WS 단계에서 계속 이야기했던 Apache와는 아예 별개의 소프트웨어이다.</em></li>
</ul>

<details>
<summary>Apache와 Tomcat</summary>
Apache HTTP Server (보통 Apache라고 부름)
<ul>
    <li>웹 서버(WS) 역할을 담당</li>
    <li>주로 정적 콘텐츠를 처리</li>
    <li>HTTP 요청을 처리하며, 동적 콘텐츠를 처리할 경우에는 WAS(Tomcat)와 연동하여 작업을 나눕니다.</li>
</ul>
Apache Tomcat (보통 Tomcat이라고 부름)
<ul>
    <li>WAS 역할을 담당</li>
    <li>Servlet Container로서 동작하며, Servlet/JSP 기반의 동적 콘텐츠를 처리
        <ul>
            <li><em>정적 콘텐츠도 처리할 수는 있다.</em></li>
            <li><em>정적 콘텐츠 처리 성능은 Apache HTTP Server보다 낮다.</em></li>
        </ul>
    </li>
    <li>Java EE 표준의 일부인 Servlet/JSP 스펙을 구현하며, Spring MVC와 같은 프레임워크의 기반이 되는 동작을 지원한다.</li>
</ul>
</details>

<p><br /></p>

<p>그러나 이런 물음표가 떠오른다.</p>

<p><strong>❓ WAS? TOMCAT? Servlet? Servlet Container? Spring MVC?</strong></p>

<p>다음 기본 개념부터 인지하고 넘어가면 이해하기 쉽다.</p>

<ol>
  <li><strong>WAS</strong>는 클라이언트의 요청을 처리하여 <strong>동적인 웹 콘텐츠</strong>를 제공하는 서버를 말한다.</li>
  <li><strong>Tomcat</strong>은 WAS의 대표적인 예시 중 하나이다.</li>
  <li>Tomcat은 <strong>Servlet Container의 한 종류</strong>이며, <strong>Servlet/JSP 요청을 처리</strong>하는 역할을 한다.</li>
  <li>Tomcat은 <strong>Servlet 표준</strong>에 맞춘 애플리케이션을 실행하는 데 최적화되어 있다.
    <ol>
      <li><strong>Servlet 표준</strong>은 <strong>Java EE</strong>(현재는 <strong>Jakarta EE</strong>) 명세의 일부로, <strong>Java 기반 동적 웹 콘텐츠 처리</strong>를 위한 규격이다.</li>
      <li>즉, Tomcat은 <strong>Java 기반의 웹 애플리케이션</strong>을 실행하기 위한 서버이다.</li>
    </ol>
  </li>
</ol>

<p><strong>WS와 WAS의 차이의 핵심는 ‘동적 처리 여부’에 있다.</strong></p>
<ul>
  <li>현대 웹사이트는 스크롤에 따라 새로운 피드를 보여주거나,<br />
사용자 맞춤 광고를 제공하는 등의 동적 기능을 포함한다.</li>
  <li>이러한 <strong>“사용자 맞춤 가공 처리(동적 콘텐츠)”는 결국 서버가 특정 코드를 실행했다</strong>는 의미다.</li>
  <li>결국 궁금한 것은 ‘<strong>서버가 어떻게 이 코드를 실행하고, 그 결과를 클라이언트에게 제공하는가</strong>’이다.</li>
</ul>

<div style="display: flex; justify-content: space-between; gap: 20px;">
    <div style="flex: 1;">
        <img src="https://github.com/user-attachments/assets/203ab158-60b0-4376-be93-1de497da3d19" alt="Memory Usage" style="width: 100%;" />
        <p style="text-align: center; color: #666;">누구나에게 제공되는 “정적인” 컨텐츠이다.</p>
    </div>
    <div style="flex: 1;">
        <img src="https://github.com/user-attachments/assets/5795047e-ae12-4cda-a1f6-e2b3ab8dfd72" alt="Requests Per Second" style="width: 100%;" />
        <p style="text-align: center; color: #666;">하지만 로그인하고 나면 “동적인” 컨텐츠가 로드된다.</p>
    </div>
</div>

<p>아래는 동적 페이지를 로드하는 과정을 그림으로 표현한 것이다.</p>

<p><img src="https://github.com/user-attachments/assets/ef604672-3c6c-4724-9f9a-9a226cc6e513" alt="Image" width="100%" height="100%" class="center" /></p>

<p>우리는 앞서 실제 운영/대규모 서비스는 <span class="post-highlight">WS-WAS 분리 구조</span>를 선호한다고 말했다.</p>

<p>나는 WAS의 한 종류인 Tomcat까지의 웹통신 흐름이 어떻게 이루어지는 지가 궁금해졌다.<br />
그리고 <u>‘jvm, survlet, spring 등 어떤 개념이고 어떤 연관관계가 있고 어떻게 유동적으로 작동할까…?’</u> 가 궁금했다.</p>

<p><br /></p>

<h2 id="jvmjava-virtual-machine">JVM(Java Virtual Machine)</h2>

<p><img src="https://github.com/user-attachments/assets/f48a2ce2-5aa4-495c-a686-79e32ce7eed2" alt="Image" width="70%" height="100%" class="center" /></p>

<p><em>JVM 자체가 현재 내용에서 매우 중요한 내용은 아니라 짧게 이야기하면,</em></p>
<ul>
  <li>⇒ 그냥 JVM은 간단히 Java 코드를 실행시켜주는 놈이라고 생각하자.</li>
  <li>WAS(Tomcat)는 Java로 작성된 웹 애플리케이션을 실행하는 컨테이너이므로,<br />
WAS도 JVM 위에서 동작한다.</li>
</ul>

<details>
<summary>JVM 이란?</summary>
Apache HTTP Server (보통 Apache라고 부름)
<ul>
    <li>JVM은 JVM은 Java 바이트코드(.class 파일)를 해석하고 실행하는 가상 머신</li>
    <li>JRE는 Java 프로그램을 실행하는 데 필요한 모든 것을 포함한다. 라이브러리 등</li>
        <ul>
            <li><em>JRE은 JVM을 시작, 필요한 클래스 라이브러리 로드, main() 메서드를 실행한다.</em></li>
        </ul>
    <li>JDK는 Java 애플리케이션을 개발하는 데 필요한 모든 도구를 포함한다.</li>
</ul>
</details>

<p><br /></p>

<h2 id="servlet-container-tomcat">Servlet Container [Tomcat]</h2>

<p>위에서 “Tomcat은 <strong><u>Servlet Container의 한 종류</u></strong>이며, <strong><u>Servlet/JSP 요청을 처리</u></strong>하는 역할을 한다.” 라고 했다.</p>

<p>1) <strong>Servlet Container</strong>는 Servlet<strong>의 생명 주기</strong>를 관리하는 곳이다.</p>
<ul>
  <li>Servlet과 Servlet Container의 관계를 Bean과 Bean Container의 관계와 흡사하다고 생각하면 된다. (“컨테이너와 관리 대상”의 관계로 이해)
    <ul>
      <li>Servlet Container는 HTTP 요청과 응답을 처리하는 Servlet을 관리</li>
      <li>Bean Container는 Spring의 <strong>애플리케이션 내 객체(Bean)</strong>의 생명 주기와 의존성을 관리</li>
    </ul>
  </li>
</ul>

<p>2) 또한, <strong>HTTP 요청 처리 및 응답 생성 과정</strong>은 Servlet Container의 핵심 기능 중 하나이다.</p>
<ul>
  <li>웹 브라우저에서 요청이 들어오면, Tomcat은 그 요청을 받아서 적절한 Java 코드(서블릿)로 전달하고, 그 결과를 다시 브라우저로 보내는 역할을 한다.</li>
</ul>

<p><br /></p>

<h2 id="servlet">Servlet</h2>

<p>Servlet은 <strong>HTTP 요청을 처리하고 응답을 생성하는 스펙을 정의한 인터페이스</strong>이다.</p>
<ul>
  <li>Servlet은 <strong>jakarta.servlet.Servlet</strong>을 최상위 인터페이스로 가진다. (Java API)</li>
</ul>

<p>Servlet은 <strong>Servlet Container</strong>에 의해 관리되며, 요청이 들어오면 컨테이너가 Servlet의 생명 주기를 관리하고 요청을 처리하기 위한 스레드를 생성한다.</p>

<p>Servlet은 HTTP 요청을 처리하고, 그에 따른 적절한 응답을 생성하는 기본 단위이다. 이를 통해 <span class="post-highlight">REST API의 엔드포인트</span>가 되거나 <span class="post-highlight">동적 웹 페이지를 생성</span>하는 역할을 수행할 수 있다.</p>

<ol>
  <li>Servlet은 HTTP 요청을 받아 비즈니스 로직을 처리하고 JSON, XML 등의 형식으로 데이터를 응답할 수 있다.</li>
  <li>동적인 HTML 콘텐츠를 생성할 때도 사용된다.
    <ul>
      <li>예를 들어, 비즈니스 로직 처리가 필요한 HTTP 요청이 Web Server로 들어오면, Web Server는 이를 Servlet Container가 실행하는 Servlet에 전달한다.</li>
      <li>Servlet은 요청을 처리하고 동적인 웹 콘텐츠를 생성한 뒤, 결과를 Web Server를 통해 클라이언트로 반환한다.</li>
    </ul>
  </li>
</ol>

<p>전체적인 통신 흐름은 다음과 같다.</p>
<ul>
  <li>WS 는 HTTP 요청을 받아 정적 리소스를 처리하거나, 요청을 WAS에 전달한다.</li>
  <li>WAS는 Servlet Container를 통해 요청을 처리하고, 처리 결과를 Web Server를 거쳐 클라이언트에 반환한다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/06d2213c-0f90-4a1b-a765-33531aeed39d" alt="Image" width="100%" height="100%" class="center" /></p>

<p><br /></p>

<h3 id="servlet의-생명주기">Servlet의 생명주기</h3>

<p>위 그림을 보면 알 수 있듯, Servlet은 다음과 같은 생명 주기를 가진다.</p>

<p>1) <strong>초기화 단계</strong>:</p>
<ul>
  <li>최초 요청이 오면 Servlet 클래스(HelloServlet.class)가 로딩된다.</li>
  <li>web.xml 설정을 참고하여 매핑할 Servlet을 확인한다.</li>
  <li><span class="post-highlight">해당 Servlet 인스턴스가 있다면 사용하고, 없다면 init()으로 초기화한다.</span></li>
</ul>

<p>2) <strong>서비스 단계</strong>:</p>
<ul>
  <li>Servlet Container는 각 요청마다 새로운 스레드를 생성한다.</li>
  <li>새로운 Request/Response 객체를 생성하여 service() 메서드를 실행한다.</li>
  <li>service()는 요청 방식(GET, POST 등)에 따라 적절한 do메서드를 호출한다.</li>
  <li>요청 처리가 완료되면 해당 Request/Response 객체는 소멸된다.</li>
</ul>

<p>3) <strong>소멸 단계</strong>:</p>
<ul>
  <li><em>서버 종료나 애플리케이션 재배포 시에만 destroy()가 호출된다.</em></li>
  <li><em>Servlet이 사용하던 리소스를 정리한다.</em></li>
</ul>

<p><br /></p>

<p>정리하자면,</p>
<ul>
  <li>Tomcat은 Servlet 객체를 한 번 생성하면 메모리에 유지하고, 요청이 올 때마다 해당 객체의 <strong>service()</strong> 메서드를 호출한다.</li>
  <li>따라서, <strong>init()</strong> 메서드는 <strong>최초 요청 시(또는 설정에 따라 애플리케이션 시작 시)</strong> 단 한 번 실행된다.</li>
  <li>또 종료되기 전이나 reload 전에 destroy()를 호출하여 매번 객체가 생성되는 것을 방지한다.</li>
</ul>

<p><strong>(🤔 궁금증) servlet은 왜 생성만 하고 제거는 안하지?</strong>
만약 사용이 끝날 때마다 제거한다면 다음과 같은 문제가 있다.</p>
<ul>
  <li>모든 요청에 대해 servlet을 생성하고 소멸하는 것은 OS 와 JVM 에게 필요없는 부하를 일으킨다.
    <ul>
      <li>JVM의 <strong>Garbage Collection</strong>과 <strong>메모리 할당/해제</strong>를 빈번하게 유발</li>
    </ul>
  </li>
  <li>동시에 다수의 요청이 들어올 경우 CPU 또는 메모리 리소스 소모에 대한 제한이 어렵다. 
결국 순간적으로 서버가 다운되거나 동시 처리에 문제가 생길 수 있다.
    <ul>
      <li><em>(참고로 Tomcat 3.2 이전 버전은 실제 매번 생성과 제거를 했다.)</em></li>
    </ul>
  </li>
</ul>

<p><strong>(✨해결) 해답은 Servlet의 특징과 관리 방식에 있다.</strong></p>
<ul>
  <li>수많은 클라이언트의 요청을 동시에 처리해야 하는 WAS의 특성상,
Servlet은 싱글톤 패턴으로 관리하게 되었다.
    <ul>
      <li>한 번 생성된 Servlet 인스턴스는 메모리에 계속 유지된다.</li>
      <li>모든 요청은 동일한 Servlet 인스턴스를 공유한다.</li>
      <li>init()은 최초 요청 시 한 번만 실행된다.</li>
      <li>destroy()는 서버 종료나 재배포 시에만 실행된다.</li>
    </ul>
  </li>
  <li><em>(Tomcat 3.2 부터는 디폴트로 <span class="post-highlight">싱글톤 패턴 도입</span>와 <span class="post-highlight">Thread Pool</span> 을 사용)</em></li>
</ul>

<p><br /></p>

<h1 id="servlet-처리-구조의-발전">Servlet 처리 구조의 발전</h1>

<h2 id="기존-servlet-처리-방식">기존 Servlet 처리 방식</h2>

<p>Tomcat은 다음과 같은 역할을 한다고 하였다.</p>
<ul>
  <li>Servlet Container로서 HTTP 요청과 응답을 처리하는 환경 제공</li>
  <li>Servlet 객체의 생성, 초기화, 요청 처리, 소멸 등 <strong>생명주기를 관리</strong>하는 역할</li>
</ul>

<p><strong>(🤔 문제점) Servlet은 요청마다 개별적으로 처리 로직을 구현해야 하므로,</strong><br />
<strong>비슷한 요청을 처리하는 여러 Servlet에서 <span class="post-highlight">중복된 코드가 발생</span>할 수 있다.</strong></p>

<p><img src="https://github.com/user-attachments/assets/7c5e684e-cd0f-4167-8e55-f3d24172f58e" alt="Image" width="80%" height="100%" class="center" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 기존 서블릿 방식 - 각 URL마다 서블릿을 따로 만들어야 했습니다</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserServlet</span> <span class="kd">extends</span> <span class="nc">HttpServlet</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doGet</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 로깅 처리</span>
        <span class="c1">// 인증 처리</span>
        <span class="c1">// 공통 에러 처리</span>
        <span class="c1">// 실제 비즈니스 로직</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductServlet</span> <span class="kd">extends</span> <span class="nc">HttpServlet</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doGet</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 위와 동일한 로깅, 인증, 에러 처리 코드가 반복됨</span>
        <span class="c1">// 실제 비즈니스 로직</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이러한 방식은 다음과 같은 문제가 있다.</p>
<ol>
  <li>하나의 서블릿 클래스에 너무 많은 책임이 집중된다.</li>
  <li>URL 매핑, 파라미터 처리, 뷰 선택 등을 모두 수동으로 처리해야 함</li>
  <li>모든 서블릿에서 공통 로직(로깅, 인증, 에러 처리 등)이 반복됨</li>
  <li>각각의 서블릿을 web.xml에 일일이 등록해야 함<br />
 (web.xml : 웹 애플리케이션의 <strong>구성 정보</strong>를 제공)</li>
</ol>

<ul>
  <li>과거 web.xml은 다음과 같은 중요한 정보들을 담고 있었다.
    <ul>
      <li>어떤 서블릿이 존재하는지</li>
      <li>각 서블릿이 어떤 URL 패턴을 처리하는지</li>
      <li>어떤 필터들이 요청을 처리하는지</li>
      <li>웹 애플리케이션의 시작과 종료 시 필요한 리스너는 무엇인지</li>
    </ul>
  </li>
</ul>

<p>⇒ 각 서블릿(요청을 처리하는 클래스)에 대한 정보를 등록해야 한다는 것이다… 😢</p>

<p><br /></p>

<h2 id="dispatcherservlet---spring-mvc--공통-로직의-중앙-집중화"><strong>DispatcherServlet</strong> - Spring MVC : 공통 로직의 중앙 집중화</h2>

<p><strong>(✨ 해결책) 공통 로직의 중앙 집중화</strong></p>

<p>Spring Framework는 기존 서블릿 스펙의 장점을 활용하면서도 그 한계를 개선하는 방향으로 발전했다.</p>

<p><span class="post-highlight">DispatcherServlet이라는 Front Controller를 사용해 공통 로직을 처리하고 요청에 맞는 컨트롤러를 호출하는 특수한 Servlet</span>을 만들어 새로운 구조를 도입했다.</p>

<ul>
  <li><em>참고로 <strong>DispatcherServlet</strong> 도 <strong>Servlet이다.</strong></em>
    <ul>
      <li><em>(이쯤에서 Spring에서의 Controller의 역할이 아구 맞게 떠오른다.)</em></li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/user-attachments/assets/945895b9-66a2-4713-b7a4-8461f3a66075" alt="Image" width="80%" height="100%" class="center" /></p>

<p>Spring MVC는 이러한 문제를 DispatcherServlet이라는 하나의 Front Controller로 해결했다.</p>

<ul>
  <li><em>이제 우리가 아는 친숙한 코드가 나온다….</em></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Spring MVC 방식</span>
<span class="nd">@Controller</span>  <span class="c1">// 더 이상 HttpServlet을 상속할 필요가 없음</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserController</span> <span class="o">{</span>
    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/users"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">handleUsers</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 비즈니스 로직에만 집중</span>
        <span class="k">return</span> <span class="s">"userList"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductController</span> <span class="o">{</span>
    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/products"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">handleProducts</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 비즈니스 로직에만 집중</span>
        <span class="k">return</span> <span class="s">"productList"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>DispatcherServlet</strong>은 다음과 같은 일을 한다.</p>

<ol>
  <li><strong>DispatcherServlet</strong>은 웹 애플리케이션에 들어오는 모든 HTTP 요청을 먼저 받는다.</li>
  <li>요청을 <strong>어떤 컨트롤러가 처리할지 결정</strong>하고, 해당 컨트롤러로 요청을 <strong>디스패치(위임)</strong> 한다.</li>
  <li>요청에 대해 <strong>공통 처리</strong>(예: 인증, 로깅 등)를 먼저 한 후, 적절한 컨트롤러로 요청을 전달한다.</li>
  <li><strong>DispatcherServlet</strong> 덕분에, 이제 다른 컨트롤러는 굳이 서블릿을 상속할 필요가 없다.</li>
</ol>

<p>4번에 대해 추가 설명을 하자면, <strong>Spring MVC</strong>에서는 <strong>DispatcherServlet</strong>만 서블릿으로 등록하고, 실제 비즈니스 로직을 처리하는 <strong>컨트롤러</strong>는 <strong>서블릿</strong>이 아니어도 된다는 뜻이다.</p>

<ul>
  <li><strong>Spring MVC</strong>에서는 <strong>DispatcherServlet</strong>만 서블릿으로 등록하고, 실제 비즈니스 로직을 처리하는 <strong>컨트롤러</strong>는 <strong>서블릿</strong>이 아니어도 된다는 뜻이다.</li>
  <li>Spring MVC의 <strong>컨트롤러</strong>는 단순한 <strong>자바 클래스</strong>로, <strong>@Controller</strong> 어노테이션을 붙인 클래스를 만들어 요청을 처리할 수 있다.</li>
  <li>이때, <strong>컨트롤러 클래스는 Servlet을 상속하지 않아도</strong> 된다.</li>
  <li><strong>DispatcherServlet</strong>이 모든 요청을 처리하고, 요청을 <strong>컨트롤러</strong>로 전달하기 때문에, 실제로는 <strong>서블릿이 아닌 컨트롤러</strong>가 <strong>Servlet 객체를 상속</strong>하지 않아도 된다는 뜻이다.</li>
</ul>

<p>이렇듯 Spring 프레임워크는 Front Controller를 제공해주고 이를 Dispather Servlet 이라 부른다.</p>

<p><img src="https://github.com/user-attachments/assets/f5b5a218-c501-43c6-8869-c0ccd63acc77" alt="Image" width="100%" height="100%" class="center" /></p>

<p><br /></p>

<h2 id="servlet과-dispatcherservlet의-역할-분담의-의의"><strong>Servlet</strong>과 DispatcherServlet의 역할 분담의 의의</h2>

<p>Servlet 표준에서 중요한 점은 Servlet이 <span class="post-highlight">전체 데이터 처리 과정에서 특정한 역할만 수행</span>한다는 것이다.</p>

<p><strong><u>전통적인 서블릿 방식</u></strong>에서는 HTTP 요청/응답 처리부터 비즈니스 로직까지 모든 것을 책임져야했다.</p>

<p>변화한 Spring MVC 구조에는 다음과 같은 장점이 있다.</p>

<p>1) <strong>관심사의 분리(Separation of Concerns)</strong></p>
<ol>
  <li>DispatcherServlet이 모든 HTTP 요청을 먼저 받아서 적절한 Controller로 라우팅하는 역할을 담당하게 되었다.</li>
  <li>이로 인해 Controller는 비즈니스 로직에만 집중할 수 있게 되었다.</li>
</ol>

<p>2) <strong>POJO(Plain Old Java Object) 기반 개발</strong></p>
<ol>
  <li>Controller가 더 이상 HttpServlet을 상속받지 않아도 된다는 것은 매우 중요한 의미를 가진다.</li>
  <li>이는 일반적인 자바 클래스로 웹 개발이 가능해졌다는 뜻이다.</li>
</ol>

<p>3) <strong>각 엔드포인트가 명확하게 분리된다.</strong></p>

<p><br /></p>

<p>⇒ Spring Boot는 이러한 통합을 더욱 단순화했다.</p>

<p>개발자는 복잡한 설정 없이도 Tomcat과 Spring이 자연스럽게 협력하는 환경에서 개발할 수 있게 되었다.</p>

<p>web.xml 없이도 자동 구성을 통해 모든 것이 가능해졌다.</p>

<p><em>@SpringBootApplication 어노테이션은 다음 3가지 핵심 어노테이션의 조합이다.</em></p>

<ol>
  <li>@SpringBootConfiguration</li>
  <li><span class="post-highlight">@EnableAutoConfiguration</span> [자동 구성]</li>
  <li>@ComponentScan</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootApplication</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyApplication</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Spring Boot가 내장 Tomcat을 자동으로 구성하고 시작</span>
        <span class="nc">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">MyApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>즉, 현대에 와서 <strong>DispatcherServlet이 서블릿 역할을 하면서</strong> 요청을 <strong>Controller</strong>에 전달하고, <strong>Controller</strong>는 <strong>서비스</strong>를 호출하여 실제 비즈니스 로직을 처리하게 하는 방식으로 발전하였다.</p>

<ul>
  <li>단지 <strong>DispatcherServlet</strong>은 요청을 받아서 적절한 컨트롤러에게 넘겨주는 역할을 한다.</li>
</ul>

<p>지금까지 살펴본 WAS의 발전 과정을 보면 다음과 같다.</p>
<ol>
  <li>WAS는 동적 컨텐츠 처리를 위한 웹 애플리케이션 서버로 분리되며 시작됐다.</li>
  <li>Tomcat은 Servlet Container로서 Java 기반 웹 애플리케이션을 실행시킨다.</li>
  <li>초기 Servlet 방식의 한계(중복 코드, 복잡한 설정)를 Spring MVC가 해결했다.</li>
  <li>DispatcherServlet의 도입으로 공통 로직 처리와 요청 위임이 체계화되었다.</li>
</ol>

<p>결국 DispatcherServlet이 모든 요청을 받아 적절한 Controller에 위임하므로
Controller는 순수 비즈니스 로직에만 집중할 수 있게 되었다.</p>
<ul>
  <li>개발자는 반복적인 설정 없이 핵심 기능 개발에 집중 가능!</li>
</ul>

<p>이처럼 WAS와 Servlet, 그리고 Spring MVC로 이어지는 발전 과정은 더 나은 웹 개발 환경을 만들어왔다.</p>

<p>더 나아가, 웹 애플리케이션 아키텍처는 계속해서 진화하고 있다.</p>
<ul>
  <li>Spring WebFlux를 통한 리액티브 프로그래밍 도입</li>
  <li>클라우드 네이티브 환경 지원</li>
  <li>마이크로서비스 아키텍처로의 전환</li>
  <li>서버리스 아키텍처의 등장</li>
</ul>]]></content><author><name>Jinho</name></author><category term="WAS" /><category term="Tomcat" /><category term="Servlet" /><category term="SpringMVC" /><category term="Java" /><category term="WebDevelopment" /><category term="Architecture" /><category term="DispatcherServlet" /><category term="SpringBoot" /><summary type="html"><![CDATA[웹 서버(WS)의 진화 : Apache vs NGINX 위 post에 이어지는 내용입니다.]]></summary></entry><entry><title type="html">웹 서버(WS)의 진화</title><link href="http://localhost:4000/2025/01/27/ws-and-was.html" rel="alternate" type="text/html" title="웹 서버(WS)의 진화" /><published>2025-01-27T12:00:00+09:00</published><updated>2025-01-27T12:00:00+09:00</updated><id>http://localhost:4000/2025/01/27/ws-and-was</id><content type="html" xml:base="http://localhost:4000/2025/01/27/ws-and-was.html"><![CDATA[<h1 id="1-웹서버ws에-대하여">1. 웹서버(WS)에 대하여</h1>

<h2 id="웹서버ws-란">웹서버(WS) 란?</h2>

<p>NGINX, Apache 두 소프트웨어 모두 “<u>웹서버 소프트웨어</u>”이다.</p>

<p>그렇다면 WS(웹서버)란 무엇일까?</p>

<p>클라이언트의 HTTP 요청을 받아 <span class="post-highlight">정적인 컨텐츠를 제공하는 서버 혹은 프로그램이다.</span></p>

<p>이후에 다시 말하겠지만, WS는 정적인 컨텐츠를 서비스하는 데에 <strong>특화된</strong> 서버 소프트웨어이다.</p>
<ul>
  <li>동적인 콘텐츠를 처리 못한다는 것은 아니다.
    <ul>
      <li>참고로, Apache의 경우 자체적으로 동적인 컨텐츠 또한 처리가 가능하다.</li>
    </ul>
  </li>
  <li>NGINX의 경우 불가능하다.
    <ul>
      <li>하지만, 동적 처리는 보통 WAS(Web Application Server)에서 주로 수행하므로, Web Server는 프록시 역할만 하면 충분하다.</li>
    </ul>
  </li>
</ul>

<p>여기서 주요한 점은 <span class="post-highlight">“정적인 컨텐츠”</span>이다.</p>

<p>html, JS 같은 정적인 컨텐츠들 정도는 웹서버를 구축한다면 웹서버 선에서 요청을 정리할 수 있다.</p>

<h3 id="과거-2-tier-architecture">과거 (2-tier Architecture)</h3>

<p><img src="https://github.com/user-attachments/assets/a2d9a118-4b95-46ec-b303-a4b9c084f5eb" alt="Image" width="80%" height="80%" class="center" /></p>

<p>우선 과거의 버그가 많았던 초기의 웹서버(WS) 프로그램이 수정되고 개발된게 <strong>Apache</strong>이다.</p>

<p>과거에 html, js, css 등과 같은 정적인 콘텐츠만을 주고 받는 구조에서는<br />
<span class="post-highlight">클라이언트 → WS [Apache] (정적 및 동적 요청 모두 처리) → DB</span> 만으로도 충분했다.</p>
<ul>
  <li>사실은 Apache의 경우, 정적/동적 모두 커버가 가능하기 때문에 기능적으로는 문제가 없었다.</li>
  <li>하지만 다음과 같은 단점이 제기되었다.
    <ul>
      <li>동적 요청 처리가 필요할 경우, Apache가 너무 많은 부담을 가진다.</li>
      <li>보안과 성능 측면에서 아쉬움이 있다.</li>
      <li><em>그리고 이후에 다시 소개하겠다…</em></li>
    </ul>
  </li>
  <li>그래서 앞단에 <u>정적 처리를 전문적으로 해주는 서버</u>가 있었으면 좋겠다는 생각을 하게 된다.</li>
</ul>

<p><br /></p>

<h3 id="현재-3-tier-architecture">현재 (3-tier Architecture)</h3>

<p>정적/동적 컨텐츠에 대한 책임을 분리하고,<br />
효율성과 확장성에 용이하기 위해 아키텍처가 발전했다.</p>

<p><span class="post-highlight">클라이언트 → [WS (정적 요청 처리) → WAS (동적 요청 처리)] → DB  </span><br />
<em>(초기 발전 과정에서는 Apache가 WAS 역할로 동적 요청을 처리하고, 앞단에 정적 요청 처리를 NGINX가 붙는 방식으로 사용되었다.)</em></p>

<p><img src="https://github.com/user-attachments/assets/76082af9-7162-4a41-b5d4-be1d96020bfc" alt="Image" width="100%" height="100%" class="center" /></p>

<p>WAS는 동적 처리에 리소스 집중할 수 있게 되었고, 트래픽 증가에 유연한 대응이 가능하게 되었다.</p>
<ul>
  <li>소프트웨어 측면 말고, 개발자의 측면에서 보아도 효율적이다.
    <ul>
      <li>WS는 정적 파일, 보안, 로드밸런싱에만 집중하면 되고, WAS에서는 비즈니스 로직에만 집중하면 된다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h1 id="apache와-nginx">Apache와 NGINX</h1>

<h2 id="1-apache-처리-방식-커넥션-기반"><strong>1. Apache 처리 방식 (커넥션 기반)</strong></h2>

<p>아파치는 <strong>Multi-Process Module</strong> 방식이다.<br />
클라이언트가 요청 하나를 보내면, 하나의 process를 생성해서 연결한다.<br />
요청당 프로세스/스레드 생성한다는 뜻이다.</p>

<p><img src="https://github.com/user-attachments/assets/84ca44e3-a224-4f75-864d-f8f121f642da" alt="Image" width="100%" height="100%" class="center" /></p>

<p>이런 구조는 확장성 면에서 장점이 크다.<br />
→ <span class="post-highlight">이러한 측면에서 개발자들은 다양한 모듈을 만들어서 서버에 동적으로 빠르게 추가할 수 있는 장점이 있었다.</span></p>

<p>하지만 다음과 같은 문제가 제기되었다.</p>

<p>(🤔문제) <strong>프로세스 생성이 가벼운 작업이 아니기에, 매번 생성하기에는 너무 속도가 느려진다.</strong></p>

<p>(✨발전 1) 요청 이전에 몇 개의 프로세스를 미리 만들어주는 prefork() 방식을 사용했다.</p>

<p>(✨발전 2) 어찌됐든 매번 커넥션을 만드는 것은 비효율적이라고 판단했고, 이미 연결된 커넥션이 있다면 재활용하자는 생각을 한다.</p>
<ul>
  <li>http 헤더 종류 중에 keep-alive가 있다.</li>
  <li><strong>→ Keep-Alive 옵션을 통해 일정 기간 동안 클라이언트와 Connection을 유지하는 방식</strong></li>
</ul>

<p><br /></p>

<p>그러나 또 다른 문제가 제기되었다.</p>

<p>(🤔또 다른 문제) <strong>클라이언트 수가 늘어나면서 결국 동시에 연결되어 있는 커넥션의 수도 매우 늘어나게 되었다.</strong></p>
<ul>
  <li>이렇게 동시 연결된 커넥션 수가 10,000개의 동시 연결을 넘어서는 순간, 서버는 더이상 커넥션을 형성하지 못하게 되는 현상이 발생했다. (<em>C10K 문제…</em>)</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/25bda5d5-aea5-4238-bc7b-3a499875a5e6" alt="Image" width="100%" height="100%" class="center" /></p>

<ul>
  <li>그런데 이 C10K 문제에서 하드웨어적으로 문제되는 것은 없었다.</li>
  <li>이 당시 웹 페이지 용량 자체가 적었기 때문에 컴퓨터의 성능은 충분했지만,<br />
비효율적인 서버의 구조 때문에 <strong>메모리 부족</strong> 현상이 일어난 것이다.</li>
  <li>많은 커넥션에서 요청이 들어오기 시작하면, CPU 코어는 계속해서 프로세스를 바꿔가며 일을 해야 했다.</li>
  <li>결론적으로, <strong>수 많은 동시 커넥션을 감당하기엔 아파치 서버의 구조가 적합하지 않았다.</strong></li>
</ul>

<p><br /></p>

<h2 id="2-nginx의-등장-이벤트-기반"><strong>2. “NGINX”의 등장 (이벤트 기반)</strong></h2>

<p>사실 NGINX는 Apache 를 대체하려고 나온 소프트웨어가 아니다.<br />
NGINX는 Apache 앞 단에 붙여서 <span class="post-highlight">보완하는 방식</span>으로 사용되었다.</p>

<p><img src="https://github.com/user-attachments/assets/c78538ef-1f3a-4e1a-b014-63afd34ca6c2" alt="Image" width="100%" height="100%" class="center" /></p>

<p>구조적으로 동시 커넥션을 많이 유지 못하는 아파치 서버의 부하를 nginx가 크게 줄일 수 있었다.</p>
<ul>
  <li><em>참고로,<br />
[동시에 연결 가능한 커넥션 수(한 시점에 감당되는 동시 커넥션 수)] 와 초당 요청 처리 수는 다른 의미이다.</em></li>
</ul>

<p>이때 NGINX 가 정적인 페이지 처리를 모두 하고,<br />
Apache는 동적 파일 처리만 담당하는 (현대의 WAS 느낌) 구조로 바뀌게 되었다.</p>

<p>그렇다면 어떻게 NGINX는 많은 동시 커넥션을 견뎌 낼 수 있을까?</p>

<p><br /></p>

<h3 id="nginx-처리-방식에-대해">NGINX 처리 방식에 대해</h3>

<p>Nginx는 Master-Worker 구조의 Process 방식을 채용했다.</p>

<p><img src="https://github.com/user-attachments/assets/a1d0bf67-8aca-4d49-8d74-690aaba06c50" alt="Image" width="100%" height="100%" class="center" /></p>

<p>Master Process는 설정파일에 맞게 실제 일하는 Worker Process를 만들어낸다.</p>

<p>그리고 Worker가 만들어질 때 각자 지정된 Listen 소켓을 배정받는다.<br />
(수신기를 받는다.)</p>

<p>그리고 그 소켓에 새로운 클라이언트로부터 Request가 들어오면, 커넥션을 형성하고 요청을 처리한다.</p>
<ul>
  <li>마찬가지로 이 커넥션은 정해진 Keep-alive의 Timeout까지 연결을 유지하게 된다.</li>
</ul>

<p>하지만, Apache와의 차이는<br />
<span class="post-highlight">“그 커넥션이 형성되었다고 해서, Worker Process 1개가 그 커넥션 1개만을 담당하지는 않는다.”</span></p>
<ul>
  <li>형성된 커넥션에 아무런 요청이 없으면 새로운 커넥션을 형성하거나,<br />
이미 만들어진 다른 커넥션으로부터 들어온 요청을 처리한다. (여러 커넥션을 쥐고 있는다.)</li>
  <li>이런 <span class="post-highlight">[커넥션 형성 / 커넥션 제거 / 새로운 요청 처리] 등을 모두 이벤트</span>라고 부른다.</li>
</ul>

<p>NGINX의 OS커널은 이러한 이벤트를 큐형식으로 줄세우고, Worker에게 전달한다.<br />
<em>(멀티플레싱, epoll 에 대해 이해하면 어떻게 커널이 이벤트를 제공하는지 알 수 있다.)</em></p>

<p><img src="https://github.com/user-attachments/assets/26d73207-0e57-4358-894d-2f4450efcaf8" alt="Image" width="80%" height="100%" class="center" />
<em class="image-caption">→ 는 커넥션 연결, O는 Request이며, 모두 “이벤트”이다.</em></p>

<p>그리고 이 이벤트들은 큐에 담긴 채 비동기 방식으로 대기하고 있다.</p>

<p>그리고 Worker Process는 하나의 스레드로 이벤트를 꺼내서 처리해 나간다.<br />
이러면 Worker는 쉬지 않고 일을 계속 할 수 있다.</p>

<p><span class="post-highlight">요청이 없다면 방치되던 Apache의 구조보다 서버 자원을 훨씬 효율적으로 사용하는 셈</span>이다.</p>

<p>(🤔문제) <strong>그런데 순서대로 꺼내서 쓰는 Queue에서 앞단에 들어오연 요청하나가 매우 시간이 오래걸리는 Disk I/O 작업이라면 어떨까..?</strong></p>

<p><img src="https://github.com/user-attachments/assets/d1abad7d-7b40-42be-9ff9-a293fe7a132b" alt="Image" width="60%" height="100%" class="center" /></p>

<p>매우 긴 IO 작업 중 큐에 대기하는 모든 이벤트들은 블로킹 될 것이다.</p>

<p>(✨해결책) 오랜 기간 작업을 요하는 요청들을 위한 쓰레드 풀을 미리 만들어놓고,<br />
Worker Process가 지금 처리하는 요청이 오래 걸린다고 판단되면,<br />
해당 스레드 풀에 그 작업을 위임하고, 큐의 다른 이벤트를 처리하러 간다.</p>

<p><img src="https://github.com/user-attachments/assets/766c1772-fed9-4a42-b6ce-7fbbe7317f55" alt="Image" width="75%" height="100%" class="center" /></p>

<p>이러한 Worker Process 는 보통 Cpu의 코어 개수만큼 생성하고,<br />
이러한 구조는 코어가 부담하는 Context Switch의 횟수를 대폭 줄일 수 있다.</p>

<p>Apache와 비교하자면,</p>

<p><img src="https://github.com/user-attachments/assets/3e7909b6-7fd3-48df-b669-6b55a303b835" alt="Image" width="100%" height="100%" class="center" /></p>

<ul>
  <li>Apache
    <ul>
      <li>CPU가 여러 프로세스 간 스위칭</li>
      <li>요청당 프로세스/스레드 필요</li>
    </ul>
  </li>
  <li>Nginx
    <ul>
      <li>하나의 Worker Process가 이벤트 큐로 관리</li>
      <li>단일 스레드로 여러 이벤트 처리</li>
      <li>CPU 코어당 하나의 Worker 고정</li>
      <li>이러한 <strong>Event-Driven Model이 Apache 구조와의 가장 큰 차이</strong>이다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="3-apache와-nginx">3. Apache와 NGINX</h2>

<p>항상 어떤 기술을 사용할 때에는 “최신 기술이여서”, “많이들 써서”가 이유가 될 수는 없다.</p>

<p>어떤 기술, 어떤 아키텍처건 Trade-Off는 존재한다.</p>

<p>과연 NGINX는 장점만 있을까?</p>

<p>개발자가 <strong>기능(모듈) 추가를 시도했다가 돌아가고 있는 Worker Process를 종료해야 하는 상황</strong>이 생길 수 있다.</p>

<p>그러면 <span class="post-highlight">해당 Worker Process는 관리하고 있던 커넥션과 관려된 요청을 더이상 처리할 수 없다</span>는 문제가 발생한다.</p>
<ul>
  <li>그래서 NGINX는 개발자가 직접 모듈을 만들기에 좀 까다롭다.</li>
</ul>

<p>하지만, 단점보다 장점이 명확했다.</p>

<p>수많은 동시 커넥션을 빠르게 처리하는 데에 있어 프로세스를 적게 만들다보니<br />
(One Worker Process per CPU core)<br />
⇒ 동시 커넥션 양 최소 10배 증가<br />
⇒ 동일한 커넥션 수일 때 Apache에 비해 속도 2배 향상</p>

<ul>
  <li><strong>NGINX의 명확한 장점</strong>
    <ol>
      <li>One Worker Process per CPU core</li>
      <li>Event-driven, asynchronous processing</li>
      <li>Event Queue management</li>
      <li>Thread Pool for long-running tasks</li>
    </ol>
  </li>
</ul>

<p>그리고 적은 프로세스는 관리가 쉽고, 새 Worker 생성 시 리소스 부담이 적다.</p>

<p>이러한 구조는 “<span class="post-highlight">NGINX가 설정을 동적으로 바꾸는 것</span>”을 가능하게 했다.</p>
<ul>
  <li>개발자가 설정 파일을 Runtime에 변경하고, NGINX에 적용하면,<br />
이후부터는 Mater Process는 그 설정에 맞는 Worker Process를 찍어내게 된다.</li>
  <li>그리고 기존 Worker Process에는 더이상 커넥션을 형성하지 못하게 막고,<br />
Queue에 있는 이벤트들을 마저 처리한 뒤 기존 Worker들은 종료된다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/4f16c765-c2d8-44c2-850b-7c88a560dbb6" alt="Image" width="100%" height="100%" class="center" /></p>

<p>그런데 이러한 <strong>동적 설정 변경은 언제 사용</strong>할까?</p>
<ul>
  <li>대표적인 예로, NGINX가 여러 동시 커넥션을 관리하는 중에 뒷단에 새로운 서버를 추가하려는 상황이다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/b4f4191d-f32d-482f-a73c-6c14492350b2" alt="Image" width="100%" height="100%" class="center" /></p>

<p>NGINX는 이제부터 로드밸런싱 역할도 담당해야 한다.</p>

<p>역할의 추가/변경이 의미하는 것은 무엇일까?</p>

<ul>
  <li>= Master Process가 찍어내야 하는 Worker Process의 역할의 추가/변경<br />
= 기존 Connection 및 기존 Request들의 손실 없이 역할의 변경이 필요하다.</li>
  <li>NGINX는 동시 커넥션을 유지한 채, 기존의 요청을 마저 처리하며, 뒷단의 서버를 추가할 수 있다.</li>
  <li>이벤트 기반 구조이기 때문에 이러한 설정 변경을 초당 수십번 해도 무리없이 커넥션을 관리하고 요청을 서버에 전달할 수 있다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/842b0dc3-119e-4168-93f9-0e6b6f14b960" alt="Image" width="100%" height="100%" class="center" />
<em class="image-caption">출처 : NetCraft Web Server Survey</em></p>

<p>그런데 위 자료를 보면 의문이 든다.<br />
NGINX가 탄생한 지 2004년부터 2007년 까지도 압도적으로 Apache가 1위를 차지하고 있다.</p>

<p>이때까지만 해도 NIGNX는 소수의 문제 상황에 대한 해결책을 제시한 것 뿐이지,<br />
대다수의 서비스를 가동하는 데에는 Apache로도 큰 문제가 없었다.</p>

<h3 id="스마트폰의-탄생">스마트폰의 탄생</h3>

<p><img src="https://github.com/user-attachments/assets/2a75d845-635a-4d46-a0d2-68629d3fdd1f" alt="Image" width="100%" height="100%" class="center" />
<em class="image-caption">출처 : NetCraft Web Server Survey</em></p>

<p>2008년부터 급격하게 상황이 역전된다. 바로 <strong>스마트폰의 등장</strong> 때문이다.</p>

<ul>
  <li>단순히 ‘스마트폰의 등장 = 인터넷 사용자의 증가’의 이유가 아니다.</li>
  <li>“<span class="post-highlight">동시 커넥션을 훨씬 더 많이 생성한 계기</span>”로써 문제가 발생한다.</li>
  <li>PC의 경우 클라이언트가 일정 시간 사용하고 전원을 끄는 방식으로 사용되었지만,<br />
스마트폰은 실시간으로 정보를 받고 싶어하는 사용자의 니즈에 맞게 알림 등<br />
<strong>동시 커넥션을 계속해서 유지</strong>하는 방식으로써 유용하게 사용되었다.</li>
</ul>

<p>이러다보니 “동시 커넥션 문제”가 현실로 다가온 것이다.</p>
<ul>
  <li>대규모 사이트들이 좋아할 만한 솔루션 이었고, NGINX는 급성장하게 된다.<br />
(<em>현재 우리가 쿠버네티스고, 뭐고 배우는 이유도 이러한 문제의 솔루션으로써 대두된다는 것을 알고 넘어가자</em>)</li>
</ul>

<p>그렇다면 Apache는 가만히 있었을까?</p>

<p>Apache도 MPM이라는 모듈을 추가해서 성능을 개선하기 시작한다.</p>

<ul>
  <li>Multi-Processing Module</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/acf7ede3-b612-417c-b4a5-82c352ba4c37" alt="Image" width="100%" height="100%" class="center" /></p>

<ul>
  <li>Apache 서버를 어떤 방식으로 운영할 지 선택할 수 있는 모듈이다.
    <ul>
      <li>안정성이나 소규모 프로젝트에서는 기존의 prefork 방식을</li>
      <li>성능 향상이나 대규모 프로젝트에서는 worker라는 스레드를 만들어 worker가 요청을 처리하도록 했다.</li>
    </ul>
  </li>
</ul>

<p>그렇다면 왜 아직도 동시 커넥션 지표에서 NGINX가 Apache를 압도적으로 앞설까?</p>

<div style="display: flex; justify-content: space-between; gap: 20px;">
    <div style="flex: 1;">
        <img src="https://github.com/user-attachments/assets/1b280974-4d15-4e5d-ac6c-c21e2093f673" alt="Memory Usage" style="width: 100%;" />
    </div>
    <div style="flex: 1;">
        <img src="https://github.com/user-attachments/assets/6a787d51-fb2d-4c1f-a973-3f380a838d29" alt="Requests Per Second" style="width: 100%;" />
    </div>
</div>
<p style="text-align: center; color: #666;">출처: dreamhost.com</p>

<p>왼쪽 동시 커넥션 수당 메모리 사용률 지표를 보면,</p>
<ul>
  <li>NGINX는 동시 커넥션이 많아져도 메모리 사용률이 낮고 일정한 반면,<br />
Apache는 굉장히 많은 메모리 사용률을 요구한다.</li>
</ul>

<p>오른쪽 동시 커넥션 수가 많아졌을 때 처리하는 초당 요청 수 지표를 보아도,<br />
NGINX가 Apache에 비해 압도적으로 많다.</p>
<ul>
  <li>NGINX가 커넥션 관리를 얼마나 잘하는 지 볼 수 있다.</li>
</ul>

<p>사실 지금까지 <strong>동시 커넥션</strong>이라는 포인트에만 집중해서 NGINX의 장점과 현재 많이 쓰이는 이유를 알아보았다.</p>

<p><strong>그렇다면 Apache의 장점은 무엇이 있을까?</strong></p>

<p><br /></p>

<h2 id="4-apache가-아직-쓰이는-이유와-nginx의-단점">4. Apache가 아직 쓰이는 이유와 NGINX의 단점</h2>

<p>근본자체가 “NCSA HTTPd”라는 소프트웨어의 버그를 수정해오며 커온 Apache이기에,
<span class="post-highlight">호환성과 확장성의 측면</span>에서는 장점이 있다.</p>

<p>아직도 오픈소스로써 활발한 수정과 개선이 이루어지고 있다. [<span class="post-highlight">풍부한 모듈 생태계</span>]</p>
<ul>
  <li><a href="https://projects.apache.org/projects.html">Apache는 현재에도 Apache Kafka, Apache Hadoop 등 시대에 발맞춰 발전 중이다</a>.</li>
</ul>

<p>또한, Apache는 여러 운영 체제(리눅스, 윈도우, 유닉스 등)에서 폭넓은 호환성과 안정성을 자랑한다.</p>

<p>NGINX는 그렇지 않아서, Windows에서 성능이 매우 낮게 나온다.</p>
<ul>
  <li>NGINX는 원래 <strong>리눅스</strong> 환경에서 설계되었기 때문에, 리눅스 OS에서 최고의 성능이 나오며,</li>
  <li>윈도우에서도 동작은 하지만,<br />
윈도우의 <strong>비동기 I/O</strong> 시스템에 최적화되지 않았기 때문에 <strong>성능이 상대적으로 낮다</strong>.</li>
</ul>

<p>현재 서비스에서 큰 성능 문제 없이 잘 돌아가고 있고, 모듈을 계속해서 추가/제거할 일이 많다면 굳이 NGINX로 옮길 이유는 없는 것이다.</p>
<ul>
  <li>오해하면 안되는 것이 NGINX는 설정 변경과 이에 따른 Worker Process의 로직 변경이 무중단으로 이루어진다는 것이며,<br />
NGINX는 모듈 자체를 동적으로 로드할 수 없으므로, 새 모듈을 추가하려면 재컴파일이 필요하다.</li>
  <li>Apache는 설정 변경 없이 실행 중 동적 모듈 로드가 가능하므로, 특정 기능을 빠르게 추가하거나 제거할 때 더 유연하다.</li>
</ul>

<p><strong>둘은 서로 대립관계가 아니며, 목적이 다르게 탄생한 것이다.</strong></p>

<p><br /></p>

<h2 id="5-그렇다면-현재-nginx를-어떻게-이용해야-하는가">5. 그렇다면 현재 NGINX를 어떻게 이용해야 하는가?</h2>

<p>앞서 우리는 NGINX의 WS로써, 로드밸런싱으로서의 역할을 보았다.</p>

<p><img src="https://github.com/user-attachments/assets/04bf32c2-7d72-4229-a31e-2b3e639e6b2d" alt="Image" width="100%" height="100%" class="center" /></p>

<p>비동기 이벤트 기반 구조로 동시 커넥션 처리가 효율적이며, Reverse Proxy로써 서버 부하를 줄일 수 있다.</p>

<p>이 자체로 웹 서버 가속(성능 개선) 역할을 한다.</p>

<p>추가적으로 NGINX를 사용하며 고려해야할 관점이다.</p>

<p><strong>1) SSL 터미네이션 역할을 한다.</strong></p>

<p><img src="https://github.com/user-attachments/assets/baaa7488-05be-473f-8d84-27912891b0f3" alt="Image" width="80%" height="100%" class="center" /></p>

<p>NGINX가 앞단에서 SSL을 처리하여, 클라이언트와는 HTTPS로 통신하고, 뒷단 서버와는 HTTP로 통신하는 방식이다.</p>
<ul>
  <li>어차피, NGINX와 SERVER가 같은 네트워크 안에 있는 경우가 많기 떄문에,<br />
이렇게 통신을 해도 보안 위험이 비교적 적다.</li>
</ul>

<p>이 방식은 뒷단 서버가 <span class="post-highlight">복호화 과정에서 발생하는 부하를 줄이는 장점</span>이 있다.</p>

<p><strong>2) 캐싱 역할을 한다.</strong></p>

<p><img src="https://github.com/user-attachments/assets/6c43e842-cbfa-44fd-99e0-75b079dc4a20" alt="Image" width="80%" height="100%" class="center" /></p>

<p>NGINX는 &lt;span class=”post-highlight”HTTP 콘텐츠 캐싱&lt;/span&gt;을 지원하며,<br />
이를 통해 서버 부하를 줄이고 클라이언트 요청에 빠르게 응답할 수 있습니다.</p>
<ul>
  <li>한 번 서버로부터 받은 응답을 스스로 보관하고 클라이언트에게 전달하므로 효율적이다.</li>
</ul>

<p>이러한 경우 1번과 달리 NGINX를 클라이언트와 가까운 곳(예: CDN이나 엣지 서버)에 배치하여<br />
캐싱 효과를 극대화할 수 있다.</p>

<p><strong>3)NGINX와 컨테이너화</strong></p>

<p>현재 클라우드 네이티브와 컨테이너화가 대세인 환경에서, NGINX는 더욱 중요한 역할을 수행하고 있다.</p>

<p>특히 Kubernetes의 Ingress Controller로서, 또는 마이크로서비스 아키텍처에서의 API Gateway로서 그 가치가 두드러진다.</p>

<p>Kubernetes에서 Ingress Controller로 사용될 때, API Gateway로서의 설정 등등</p>
<ul>
  <li>이러한 설정들을 통해 NGINX는 현대적인 마이크로서비스 환경에서 트래픽 라우팅, 로드밸런싱, SSL 종료, API 게이트웨이 등 다양한 역할을 효율적으로 수행할 수 있다.</li>
  <li>특히 컨테이너 환경에서는 가볍고 빠른 NGINX의 특성이 더욱 큰 장점으로 작용한다.</li>
</ul>

<p>이 외에도 HSTS, CORS 처리, TCP/UDP 커넥션 분산 부하, HTTP/2 지원 (최근에는 /3도 지원) 등 서버를 보완하는 역할을 할 수 있다.</p>

<p>어떠한 기능이 있는지를 알아보고 상황에 따라 알맞는 기능을 적용하는 자세가 필요하다.</p>

<hr />
<p>참고: <a href="https://www.youtube.com/watch?v=mcnJcjbfjrs" target="_blank">우아한테크 [10분 테코톡] 알리의 Web Server vs WAS</a></p>

<p><a href="https://www.youtube.com/watch?v=6FAwAXXj5N0" target="_blank">우아한테크 [10분 테코톡] 피케이의 Nginx</a></p>]]></content><author><name>Jinho</name></author><category term="WebServer" /><category term="Apache" /><category term="NGINX" /><category term="Architecture" /><category term="DevOps" /><category term="Network" /><category term="Performance" /><category term="LoadBalancing" /><category term="ReverseProxy" /><summary type="html"><![CDATA[1. 웹서버(WS)에 대하여]]></summary></entry><entry><title type="html">Java/SpringBoot에서의 비동기 처리</title><link href="http://localhost:4000/2025/01/15/asynchronous-processing-in-java-spring.html" rel="alternate" type="text/html" title="Java/SpringBoot에서의 비동기 처리" /><published>2025-01-15T12:43:00+09:00</published><updated>2025-01-15T12:43:00+09:00</updated><id>http://localhost:4000/2025/01/15/asynchronous-processing-in-java-spring</id><content type="html" xml:base="http://localhost:4000/2025/01/15/asynchronous-processing-in-java-spring.html"><![CDATA[<h1 id="2-java에서의-구현과-실제-경험">2. Java에서의 구현과 실제 경험</h1>
<h2 id="21-스레드와-비동기-처리">2.1 스레드와 비동기 처리</h2>

<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>

<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>

<h3 id="thread와-runnable">Thread와 Runnable</h3>

<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>

<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>

<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>

<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>

<ul>
  <li>Thread 클래스 상속</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread: "</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 사용</span>
<span class="nc">MyThread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyThread</span><span class="o">();</span>
<span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>  <span class="c1">// 새로운 스레드 시작</span>
</code></pre></div></div>

<ul>
  <li>Runnable 인터페이스 구현</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyRunnable</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread: "</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 사용</span>
<span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyRunnable</span><span class="o">());</span>
<span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>  <span class="c1">// 새로운 스레드 시작</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>
<ul>
  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>
</ul>

<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>

<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>

<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>

<p><br /></p>

<h3 id="thread에-대해-이해하기---생명주기--주의할-점">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>

<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>

<p><strong>[Thread의 생명주기]</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadLifecycleDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span> <span class="c1">// TIMED_WAITING 상태</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">interrupt</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"1. 초기 상태: "</span> <span class="o">+</span> <span class="n">thread</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span> <span class="c1">// NEW</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"2. 실행 상태: "</span> <span class="o">+</span> <span class="n">thread</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span> <span class="c1">// RUNNABLE</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"3. 대기 상태: "</span> <span class="o">+</span> <span class="n">thread</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span> <span class="c1">// TIMED_WAITING</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"4. 종료 상태: "</span> <span class="o">+</span> <span class="n">thread</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span> <span class="c1">// TERMINATED</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ol>
  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>
  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>
  <li>BLOCKED: 모니터 락을 기다리는 상태</li>
  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>
  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>
  <li>TERMINATED: 실행이 완료된 상태</li>
</ol>

<p><strong>[Thread 사용 시 주의할 점]</strong></p>

<ul>
  <li>동기화 문제</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadSafetyExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    
    <span class="c1">// 잘못된 구현</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">incrementWrong</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">count</span><span class="o">++;</span> <span class="c1">// 스레드 안전하지 않음</span>
    <span class="o">}</span>
    
    <span class="c1">// 올바른 구현</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">incrementCorrect</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">count</span><span class="o">++;</span> <span class="c1">// 스레드 안전함</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>

<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>

<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>

<ul>
  <li>데드락 방지</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DeadlockExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="n">lock1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="n">lock2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method1</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock1</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock2</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>
                <span class="c1">// 데드락 발생 가능</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>

<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>

<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>

<ul>
  <li>스레드 인터럽트 처리</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">InterruptExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">longRunningTask</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(!</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">isInterrupted</span><span class="o">())</span> <span class="o">{</span>
                <span class="c1">// 작업 수행</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 인터럽트 발생 시 적절한 처리</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">interrupt</span><span class="o">();</span> <span class="c1">// 인터럽트 상태 복구</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>

<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>

<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>

<p><br /></p>

<h3 id="thread와-runnable의-한계">Thread와 Runnable의 한계</h3>

<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>

<ul>
  <li>스레드 생성과 종료의 오버헤드</li>
  <li>결과값을 반환하기 어려움</li>
  <li>예외 처리가 복잡함</li>
  <li>스레드 풀 관리의 어려움</li>
</ul>

<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>

<p><strong>[1. Callable 인터페이스]</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">callable</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="c1">// 작업 수행</span>
    <span class="k">return</span> <span class="s">"작업 결과"</span><span class="o">;</span>  <span class="c1">// 결과값 반환 가능</span>
<span class="o">};</span>

<span class="nc">ExecutorService</span> <span class="n">executor</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newSingleThreadExecutor</span><span class="o">();</span>
<span class="nc">Future</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">callable</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>  <span class="c1">// 결과값 받기</span>
</code></pre></div></div>

<ul>
  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.
[Runable은 아무것도 리턴하지 않는다.]</li>
  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>
</ul>

<p><strong>[2. ExecutorService]</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ExecutorService</span> <span class="n">executor</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>  <span class="c1">// 스레드 풀 생성</span>
<span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="c1">// 작업 수행</span>
<span class="o">});</span>
<span class="n">executor</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>  <span class="c1">// 작업 완료 후 스레드 풀 정리</span>
</code></pre></div></div>

<ul>
  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>
</ul>

<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>

<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>

<p><strong>[3. Future]</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Future</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
    <span class="k">return</span> <span class="s">"Future의 결과값"</span><span class="o">;</span>
<span class="o">});</span>

<span class="c1">// Future의 주요 메서드 활용</span>
<span class="kt">boolean</span> <span class="n">isDone</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">isDone</span><span class="o">();</span>        <span class="c1">// 작업 완료 여부 확인</span>
<span class="kt">boolean</span> <span class="n">isCancelled</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">isCancelled</span><span class="o">();</span> <span class="c1">// 작업 취소 여부 확인</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>            <span class="c1">// 결과 가져오기 (블로킹)</span>
<span class="nc">String</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">);</span> <span class="c1">// 타임아웃 설정</span>
</code></pre></div></div>
<ul>
  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>
  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>
</ul>

<p>허나 다음과 같은 한계가 존재한다.</p>

<ul>
  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>
  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 블로킹이 발생하는 get() 호출</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>  <span class="c1">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>
</code></pre></div>    </div>
  </li>
  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>
  <li>예외처리가 불편하다.</li>
  <li>콜백이나 완료 통보 기능이 없다.</li>
</ul>

<blockquote>
  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />
이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>
</blockquote>

<p><br /></p>

<h3 id="completablefuture-비동기-프로그래밍의-진화">CompletableFuture: 비동기 프로그래밍의 진화</h3>

<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>

<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>

<blockquote>
  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>
</blockquote>

<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>

<p><strong>[1. 비동기 작업 생성]</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 결과가 없는 비동기 작업</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="n">future1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">runAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"비동기 작업 실행"</span><span class="o">);</span>
<span class="o">});</span>

<span class="c1">// 결과를 반환하는 비동기 작업</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future2</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">return</span> <span class="s">"작업 결과"</span><span class="o">;</span>
<span class="o">});</span>
</code></pre></div></div>

<p><strong>[2. 작업 조합하기]</strong></p>

<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="nc">CompletableFuture</span>
    <span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="s">"Hello"</span><span class="o">)</span>  <span class="c1">// 첫 번째 작업</span>
    <span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" World"</span><span class="o">)</span>  <span class="c1">// 결과를 변환</span>
    <span class="o">.</span><span class="na">thenCompose</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"!"</span><span class="o">));</span>  <span class="c1">// 다른 Future와 조합</span>

<span class="c1">// 두 작업의 결과 조합</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">future1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">);</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">future2</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">);</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">combined</span> <span class="o">=</span> <span class="n">future1</span>
    <span class="o">.</span><span class="na">thenCombine</span><span class="o">(</span><span class="n">future2</span><span class="o">,</span> <span class="o">(</span><span class="n">result1</span><span class="o">,</span> <span class="n">result2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">result1</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>
</code></pre></div></div>

<p><strong>[3. 예외 처리]</strong></p>

<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>

<p><strong>[4. 타임아웃처리]</strong></p>

<p>타임 아웃에 대한 처리도 가능하다.</p>

<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">futures</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
    <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="s">"작업1"</span><span class="o">),</span>
    <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="s">"작업2"</span><span class="o">),</span>
    <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="s">"작업3"</span><span class="o">)</span>
<span class="o">);</span>

<span class="c1">// 모든 작업이 완료될 때까지 대기</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="n">allOf</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">allOf</span><span class="o">(</span>
    <span class="n">futures</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">CompletableFuture</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span>
<span class="o">);</span>

<span class="c1">// 가장 빨리 완료되는 작업 처리</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">anyOf</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">anyOf</span><span class="o">(</span>
    <span class="n">futures</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">CompletableFuture</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span>
<span class="o">);</span>
</code></pre></div></div>

<p><strong>[실제 활용 예시]</strong></p>

<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">PaymentApiClient</span> <span class="n">paymentApiClient</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">UserInfo</span><span class="o">&gt;</span> <span class="nf">getUserInfo</span><span class="o">(</span><span class="nc">Long</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="n">userFuture</span> <span class="o">=</span> <span class="nc">CompletableFuture</span>
            <span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">userId</span><span class="o">)</span>
                <span class="o">.</span><span class="na">orElseThrow</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">UserNotFoundException</span><span class="o">(</span><span class="n">userId</span><span class="o">)));</span>

        <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">PaymentInfo</span><span class="o">&gt;</span> <span class="n">paymentFuture</span> <span class="o">=</span> <span class="nc">CompletableFuture</span>
            <span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">paymentApiClient</span><span class="o">.</span><span class="na">getPaymentInfo</span><span class="o">(</span><span class="n">userId</span><span class="o">))</span>
            <span class="o">.</span><span class="na">exceptionally</span><span class="o">(</span><span class="n">ex</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="n">log</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">"Payment info fetch failed"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
                <span class="k">return</span> <span class="nc">PaymentInfo</span><span class="o">.</span><span class="na">getDefaultPaymentInfo</span><span class="o">();</span>
            <span class="o">});</span>

        <span class="k">return</span> <span class="n">userFuture</span>
            <span class="o">.</span><span class="na">thenCombine</span><span class="o">(</span><span class="n">paymentFuture</span><span class="o">,</span> <span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">payment</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="k">return</span> <span class="k">new</span> <span class="nf">UserInfo</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">payment</span><span class="o">);</span>
            <span class="o">})</span>
            <span class="o">.</span><span class="na">orTimeout</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">)</span>  <span class="c1">// 타임아웃 설정</span>
            <span class="o">.</span><span class="na">exceptionally</span><span class="o">(</span><span class="n">ex</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Error fetching user info"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
                <span class="k">return</span> <span class="nc">UserInfo</span><span class="o">.</span><span class="na">getDefaultUserInfo</span><span class="o">();</span>
            <span class="o">});</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>
<ul>
  <li>데이터 베이스에서 사용자 정보 조회</li>
  <li>외부 API에서 결제 정보 조회</li>
</ul>

<blockquote>
  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />
각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>
</blockquote>

<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>

<ul>
  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>
  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>
</ul>

<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>

<blockquote>
  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>
</blockquote>

<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>

<p><br /></p>

<h3 id="스레드-풀의-이해">스레드 풀의 이해</h3>
<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>

<p><br />
<br /></p>

<p>// 수정중</p>

<h2 id="22-spring의-비동기-처리">2.2 Spring의 비동기 처리</h2>

<h3 id="async-사용-경험과-주의점">@Async 사용 경험과 주의점</h3>
<h3 id="threadpooltaskexecutor-설정-최적화">ThreadPoolTaskExecutor 설정 최적화</h3>

<p><br /></p>

<h1 id="3-이론적-고찰">3. 이론적 고찰</h1>
<h2 id="31-언제-비동기를-사용할까">3.1 언제 비동기를 사용할까?</h2>

<h3 id="io-작업이-많은-경우의-선택">I/O 작업이 많은 경우의 선택</h3>
<h3 id="대용량-데이터-처리시의-고려사항">대용량 데이터 처리시의 고려사항</h3>

<p><br /></p>

<h2 id="32-트레이드오프">3.2 트레이드오프</h2>

<h3 id="디버깅의-어려움">디버깅의 어려움</h3>
<h3 id="리소스-사용량-증가">리소스 사용량 증가</h3>
<h3 id="복잡성-vs-성능-개선">복잡성 vs 성능 개선</h3>

<h1 id="4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>]]></content><author><name>Jinho</name></author><category term="Java" /><category term="Spring" /><category term="SpringBoot" /><category term="Async" /><category term="Thread" /><category term="Runnable" /><category term="CompletableFuture" /><category term="ThreadPool" /><category term="ThreadPoolTaskExecutor" /><category term="Concurrency" /><category term="I/O" /><category term="Performance" /><category term="WebFlux" /><summary type="html"><![CDATA[2. Java에서의 구현과 실제 경험 2.1 스레드와 비동기 처리]]></summary></entry><entry><title type="html">동기/비동기와 블로킹/논블로킹에 대해 깊이 파헤치기</title><link href="http://localhost:4000/2025/01/12/understanding-sync-async-blocking-non-blocking.html" rel="alternate" type="text/html" title="동기/비동기와 블로킹/논블로킹에 대해 깊이 파헤치기" /><published>2025-01-12T12:00:00+09:00</published><updated>2025-01-12T12:00:00+09:00</updated><id>http://localhost:4000/2025/01/12/understanding-sync-async-blocking-non-blocking</id><content type="html" xml:base="http://localhost:4000/2025/01/12/understanding-sync-async-blocking-non-blocking.html"><![CDATA[<h1 id="1-개념적-이해">1. 개념적 이해</h1>

<p>비동기 처리에 대해 이야기하기 앞서, 과연 “동기”란 어떤 것인지부터 바로 잡고 가려고한다.</p>

<p>왜냐하면 <strong>비(非)동기</strong>란 동기가 아니다라는 의미이기 때문에 동기가 무엇인지부터 정확히 하고 싶었다.</p>

<p>또한 나는 처음에 ‘동기=블로킹, 비동기=논블로킹’이라고 단순하게 이해하고 있었다.</p>

<p>하지만 실제로는 두 개념이 분류 기준이 전혀 다른 독립적인 개념이라는 것을 알게 되었다.</p>

<p>이렇듯 서로 혼동되어 쓰이는 각 명칭은 어떤 의미인지 알아보려고 한다.</p>

<p>이에 대해 자세히 알아보자.</p>

<p><br /></p>

<h1 id="2-동기와-비동기">2. 동기와 비동기</h1>

<p><img src="https://velog.velcdn.com/images/jinho7/post/a47f1973-3895-4438-a47f-80dd80245e41/image.png" alt="" width="100%" height="100%" class="center" /></p>

<blockquote>
  <p>동기와 비동기는 “작업의 처리 방식”을 나타내는 개념이다. <br />
결론부터 말하자면, 이둘의 주요한 차이점은 “작업 순서 처리 차이”이다.</p>
</blockquote>

<h2 id="2-1-동기-순차적으로-실행">2-1. 동기: 순차적으로 실행</h2>
<p>필자는 이전에 동기를 <strong>겹치지 않고 순차적으로 작업을 진행하는 것</strong> 정도로 이해하고 있었다.</p>

<p>영어 사전을 참고해보자.</p>

<blockquote>
  <p>synchronous
adjective
happening or done at the same time or speed:</p>
</blockquote>

<p><strong>Synchronous</strong> 는 동시에 발생하는 두 개 이상의 사건이나 프로세스가 동일한 시간에서 진행되는 것을 의미하는 형용사이다.</p>

<p>중요한 워딩은 [동일한 시간에 여러 개의 사건이 진행] 된다는 것이다.</p>

<p>‘순차적’과 ‘동시’라는 단어가 서로 상충된다고 생각할 수 있다.</p>

<p>여기서 오해하면 안되는 것이 이는 <strong>병렬적인 작업방식을 말하는 것이 아니다.</strong></p>

<p>“어떠한 일정 시점에 현재 작업의 Response과 다음 작업의 Request이 함께 진행되는 것”</p>

<p>위의 그림을 참고하면 이해가 쉽다.
작업 A가 끝나는 시간과 작업 B가 시작하는 시간이 동기화된다고 이해하면 좋을 것 같다.</p>

<p>이는 <strong>작업이 순차적으로 처리되며, 이전 작업이 완료될 때까지는 다음 작업이 시작되지 않음을 나타낸다.</strong></p>

<p>즉, <strong>작업들이 서로 시간적 의존성을 가지고 실행된다</strong>는 뜻이다.</p>

<p>동기 방식은 실행 순서가 보장되며 예측 가능하다는 장점이 있지만, <br />
앞선 작업이 오래 걸리면 전체 작업이 지연된다는 단점도 있다.</p>

<h2 id="2-2-비동기-독립적으로-실행">2-2. 비동기: 독립적으로 실행</h2>
<p>그렇다면 비동기 방식은 무엇일까?</p>

<p>반대의 경우를 생각하면 된다.</p>

<p>위의 그림을 참고하면 작업들이 병렬적으로 일어나고 있음을 알 수 있다.</p>

<p>동기와 반대로 <strong>“요청을 보냈을 때 응답 상태와 상관없이 다른 동작을 수행할 수 있다.”</strong>는 점이다.</p>

<p><img src="https://github.com/user-attachments/assets/0a188e4a-b35f-41aa-9953-94504330dd9f" alt="다운로드" width="68%" height="50%" class="center" />
<em class="image-caption">파일 다운로드가 동기 방식이라면?</em></p>

<p>만약에 파일 다운로드를 동기적으로 처리한다고 해보자.</p>

<p>아마 파일이 다운로드될 때까지 아무런 작업도 수행할 수 없을 것이고,
파일이 완전히 다운로드된 후에 다음 작업을 진행할 수 있을 것이다. 😅</p>

<p>매우 비효율적인 방식이다…</p>

<p>그러나 비동기적인 방식을 활용한다면, 파일 다운로드 작업을 시작시켜놓고, 다른 작업을 수행할 수 있다.</p>

<p>파일이 다운로드되면 특정 콜백 함수를 호출하여, 다운로드된 파일을 처리하거나 결과를 반환받을 수 있다.</p>

<p>콜백 뿐만이 아니고, 그 결과는 콜백 함수, Promise, 이벤트 등을 통해 전달받을 수 있다.</p>

<p>마치 택배를 주문하고 배송 알림을 받는 것과 비슷하다고 할 수 있다.</p>

<h3 id="비동기-동작-방식에-대한-오해">비동기 동작 방식에 대한 오해</h3>
<p>많은 개발자들이 <strong>비동기 = 멀티 쓰레드</strong>라고 이해하고 있다.</p>

<p>단순히 생각해보아도, 여러 작업이 동시에 처리되는 비동기 동작을 구현하기 위해서는 당연히 여러 개의 쓰레드가 필요할 것 같기 때문이다.</p>

<p>또한, 특히나 대부분의 Java 개발자들이 비동기 프로그래밍을 접할 때 아래와 같은 코드를 통해 배우기 때문이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="c1">// 여기서 실제로 별도의 스레드에서 실행됨</span>
    <span class="k">return</span> <span class="nf">heavyTask</span><span class="o">();</span>
<span class="o">});</span>
</code></pre></div></div>

<p>우리는 Java에서 비동기 처리에 대해 다룰 때, ExecutorService나 CompletableFuture와 같은 도구들을 함께 배운다.</p>

<p>이들은 내부적으로 <strong>스레드 풀</strong>을 사용하기 때문에, 자연스럽게 비동기 처리와 멀티 쓰레드를 동일시하게 된다.</p>

<p>실제로 Spring Framework의 @Async 어노테이션도 비동기 처리를 위해 기본적으로 스레드 풀을 사용한다.</p>

<p>하지만 비동기 처리의 본질은 <strong>“작업의 완료를 기다리지 않고 다른 작업을 수행할 수 있는 것”</strong>이다.</p>

<p>이는 반드시 멀티스레드로만 구현되어야 하는 것이 아니며, Node.js가 좋은 예시다.</p>

<p>Node.js는 싱글 스레드 기반의 이벤트 루프를 사용하여 비동기 처리를 구현한다.</p>

<p>이벤트 루프는 OS의 비동기 I/O 기능을 활용하여 실제 I/O 작업을 커널 레벨에서 처리하고,</p>

<p>작업이 완료되면 이벤트를 통해 알림을 받는 방식으로 동작한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Node.js의 비동기 처리 (싱글스레드)</span>
<span class="nx">fs</span><span class="p">.</span><span class="nf">readFile</span><span class="p">(</span><span class="dl">'</span><span class="s1">file.txt</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">파일 읽기 완료</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">다음 작업 실행</span><span class="dl">'</span><span class="p">);</span>  <span class="c1">// 파일 읽기를 기다리지 않고 실행</span>
</code></pre></div></div>
<p>이러한 이벤트 루프 기반의 비동기 처리는 멀티스레드 없이도 효율적인 비동기 처리를 가능하게 한다.
OS의 비동기 I/O 기능을 활용하여, 실제 I/O 작업은 커널 레벨에서 처리되고, 완료되면 이벤트를 통해 알림을 받는 방식이다.
<em>정확히는 JavaScript 엔진이 싱글 스레드 기반이다</em>
<em>해당 내용에 대해 더 자세히 알고 싶다면 <a href="https://puleugo.tistory.com/133">해당 블로그</a>를 참고하자</em></p>

<p><br /></p>

<h1 id="3-블로킹과-논블로킹">3. 블로킹과 논블로킹</h1>
<blockquote>
  <p>블로킹과 논블로킹은 “제어권의 이동” 관점에서 바라보는 개념이다.</p>
</blockquote>

<p>결국 “호출한 함수가 다른 일을 할 수 있는가?”의 여부를 의미한다.</p>

<h2 id="3-1-제어권control-flow의-의미">3-1. 제어권(Control Flow)의 의미</h2>
<p>여기서 <strong>제어권</strong>이란 어떤 의미를 갖는지 먼저 보자.
OS적인 관점에서 보자면, <strong>현재 작업을 진행하고 있는 함수가 CPU를 점유하는 것</strong>을 의미한다.
쉽게 말해 “코드를 실행시킬 수 있는 권한” 정도로 말할 수 있다.</p>

<p>동기 와 비동기는 Jobs 들이 순서대로 혹은 독립적으로 처리되는가에 관한 이야기라면,
이번에는 호출한 함수가 별개의 일을 할 수 있는지의 이야기이다.</p>

<h2 id="3-2-블로킹-제어권을-넘겨주는-방식">3-2. 블로킹: 제어권을 넘겨주는 방식</h2>
<p>마치 시험지를 넘겨주는 방식을 생각하면 편할 것 같다.
<img src="https://github.com/user-attachments/assets/6eb36e86-150c-4144-86ce-6080ef86bece" alt="image" width="60%" height="100%" class="center" />
<em class="image-caption">출처 : https://www.veritas-a.com/news/articleView.html?idxno=156699</em></p>

<p>내가 뒷 사람에게 시험지를 넘겨줄 때,
나는 아무런 행동도 하지 않고 <strong>뒷 사람(호출된 함수)가 시험지를 가져가는(자신의 작업을 완료)할 때 까지</strong> 나는 손에 시험지를 쥐고 뒷사람을 바라보고 대기할 수 밖에 없다.</p>

<p><img src="https://github.com/user-attachments/assets/d799e31b-9406-44f3-8dcc-9df15b8f8a79" alt="image" width="60%" height="60%" class="center" /></p>

<p>둘 간의 구분 방법은 제어권이 누구에게 있는지로 결정된다.</p>

<p>블로킹에서는 함수 A가 함수 B를 호출할 때 제어권이 B로 넘어간다.</p>

<p>제어권을 넘겨준 A는 B의 작업이 완료될 때까지 아무 작업도 수행할 수 없는 상태, 즉 블로킹 상태가 된다.</p>

<p>즉, 위의 사진에서 A함수는 B함수에게 제어권을 넘겨줌과 동시에 함수 실행이 일시 정지된다. = Blocking</p>

<h2 id="3-3-논블로킹-제어권을-유지하는-방식">3-3. 논블로킹: 제어권을 유지하는 방식</h2>
<p>하지만 시험지를 그냥 뒷 사람 책상에 올려 놓는다면 어떨까.</p>

<p>나는 실제 뒷 사람이 받는 것을 대기할 필요없이, 바로 나의 다른 작업을 할 수 있다.</p>

<p>즉, 뒷 사람(호출된 함수)이 나에 대한 제어권을 바로 반환해줌으로, 호출한 쪽(나)에서는 계속 다른 작업을 할 수 있는 것이다.</p>

<p>같은 “읽기” 작업이어도 동기와 비동기 처리에 따라 어떻게 다르게 동작하는지 보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 블로킹: 제어권을 넘겨줌</span>
<span class="nc">String</span> <span class="n">content</span> <span class="o">=</span> <span class="n">readFile</span><span class="o">(</span><span class="s">"file.txt"</span><span class="o">);</span>  <span class="c1">// 파일 읽을 때까지 다른 일 못함</span>
<span class="n">doNextWork</span><span class="o">();</span>                          <span class="c1">// 파일 다 읽고 나서야 실행</span>

<span class="c1">// 논블로킹: 제어권을 유지</span>
<span class="nc">Future</span> <span class="n">future</span> <span class="o">=</span> <span class="n">readFileAsync</span><span class="o">(</span><span class="s">"file.txt"</span><span class="o">);</span>  <span class="c1">// 요청만 하고</span>
<span class="n">doNextWork</span><span class="o">();</span>                               <span class="c1">// 바로 다른 일 할 수 있음</span>
</code></pre></div></div>
<p><img src="https://github.com/user-attachments/assets/4a59addb-b12d-4eaa-90c9-fe783a7556e0" alt="image" width="60%" height="60%" class="center" /></p>

<p>반면 논블로킹에서는 A함수가 B함수를 호출하더라도 제어권을 계속 유지한다.</p>

<p>따라서 B함수가 실행되는 동안에도, A함수는 제어권을 가지고 있기 때문에 다른 작업을 수행할 수 있다.</p>

<p>이렇게 호출자(caller)인 A함수는 B함수의 작업 완료 여부와 관계없이 자신의 작업을 계속 수행할 수 있다.</p>

<p><br /></p>

<h1 id="4-네-가지-조합의-동작-방식">4. 네 가지 조합의 동작 방식</h1>

<p>가끔 동기 처리에서는 무조건적으로 블로킹이 일어나고, 비동기에서는 논블로킹이 일어난다고 오해하는 경우가 많다.</p>

<p>하지만 두 쌍의 개념은 서로 다른 관점에서 바라보는 개념이라는 것을 확실하게 하고 넘어가자.</p>

<blockquote>
  <p>동기/비동기 : 작업들의 시간적 관계성 <br />
블로킹/논블로킹 : 제어권의 소재</p>
</blockquote>

<p>하지만 이 개념들이 오해가 잦은 이유는 실제 구현에서 [동기/볼로킹 &amp; 비동기/논블로킹]이 <strong>자주 함께 사용</strong>되기 때문이다.</p>

<p>다음 그림을 보고 4가지 조합에 대해 천천히 살펴보자.</p>

<p><img src="https://github.com/user-attachments/assets/b894be55-d296-424d-913f-ee989233eb60" alt="image" width="100%" class="center" /></p>

<p>먼저 흔히 쓰이는 [동기/볼로킹 &amp; 비동기/논블로킹] 에 대해 보자.</p>

<h2 id="4-1-동기--블로킹">4-1. 동기 + 블로킹</h2>

<p>작업의 흐름이 순차적으로 진행되는 것이 보장된다. (<strong>동기</strong>)</p>

<p>제어권을 함수 B에게 넘겨준 후 함수 A는 대기하게 된다. (<strong>블로킹</strong>)</p>

<p>함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄 때까지 함수 A는 기다리는 것이다.</p>

<blockquote>
  <p>이러한 조합은 <strong>작업이 완료될 때까지 기다려야 하는 경우</strong>에 사용된다. <br />
예를 들면, 파일을 읽은 후 이를 처리하는 코드를 생각해보자. <br />
파일을 처리하는 과정은 <strong>필연적으로 파일을 모두 읽은 후에 작업이 가능</strong>하기 때문이다. <br />
또한, 일반적으로 작업이 간단하거나 작업량이 적은 경우에 사용된다. <br />
작업량이 많거나 오래 걸리는 작업을 해당 방식으로 처리하면 <strong>전체 프로그램이 멈춘 것 처럼 보여</strong> 사용자 경험 측면에서 나빠질 수 있다.</p>
</blockquote>

<h2 id="4-2-비동기--논블로킹">4-2. 비동기 + 논블로킹</h2>

<p>비동기 + 논블로킹 방식도 비교적 이해가 쉽다.</p>

<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다. (<strong>논블로킹</strong>)</p>

<p>다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 방식이다. (<strong>동기</strong>)</p>

<p>함수 B를 호출 할 때, 콜백 함수를 함께 줌으로써, 함수 B는 자신의 작업이 끝났을 때 <strong>함수 A에게 준 콜백 함수를 실행시켜 자신의 작업이 끝났음</strong>을 알려준다.</p>

<p>작업 A는 함수 B의 종료 여부에는 일단 관심이 없다.</p>

<p>B 함수가 자신의 실행을 완료했다면, A 함수의 어깨를 톡톡 쳐서 알려주면 되는 것이다.</p>

<blockquote>
  <p>다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우에 활용할 수 있다. <br />
또한, 대용량의 데이터를 처리하는 서비스에서 흔히 사용된다. <br />
가장 큰 특징은 호출 함수에 콜백 함수를 넣었다는 점이다.</p>
</blockquote>

<h2 id="4-3-동기--논블로킹">4-3. 동기 + 논블로킹</h2>

<p>함수 A가 함수 B를 호출할 때, 함수 A는 함수 B의 작업이 완료되길 기다리지 않고 제어권을 즉시 반환 받는다.</p>

<p>이후 바로 자신의 코드를 실행한다. (<strong>논블로킹</strong>)</p>

<p>즉, 다른 작업이 진행되는 동안에도 자신의 작업을 별개로 처리할 수 있다.</p>

<p>조심할 것이 함수 A는 함수 B의 Return 값을 필요로 하는 것은 변함이 없다는 점이다.</p>

<p>A 함수는 B 함수의 리턴값이 필요하기 때문에, 중간중간 B 함수에게 함수 실행을 완료했는지 물어본다.</p>

<p>즉, A 함수(caller)가 B 함수(callee)의 실행이 종료되었는지 계속 예의 주시해야 한다. (순서 보장을 위해)</p>

<p>이로써 작업을 순차대로 수행할 수 있는 것이다. (<strong>동기</strong>)</p>

<p>여기서 조금 더 깊게 생각해보자.</p>

<p>어떻게 동기적으로 진행되면서 메인 쓰레드가 논블로킹이 될 수 있을까?</p>

<p>이 조합의 특징은 “작업 완료는 비동기로 처리하지만, 호출자는 필요할 때 결과를 동기적으로 받는다.”로 정리할 수 있다.</p>

<p>즉, <strong>순서를 유지하면서 결과를 사용해야 할 때 동기적으로 기다릴 수 있다.</strong></p>

<p>결국 <strong>동기적</strong> 이라는 말은 <strong>호출자의 결과가 필요한 시점에서 순서를 보장</strong>하며 작업을 진행한다는 것이다.</p>

<p>다음 JAVA 코드의 예시를 봐보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleDownloader</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">downloadProgress</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// 다운로드 진행률</span>
        
        <span class="c1">// 다운로드 시작</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"파일 다운로드를 시작합니다."</span><span class="o">);</span>
        
        <span class="c1">// 진행률 확인하면서 다른 작업 수행 (논블로킹)</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">downloadProgress</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// 동기적: 순서 보장</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"진행률: "</span> <span class="o">+</span> <span class="n">downloadProgress</span> <span class="o">+</span> <span class="s">"%"</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"다른 작업을 할 수 있어요!"</span><span class="o">);</span>
            
            <span class="c1">// 진행률이 증가한다고 가정</span>
            <span class="n">downloadProgress</span> <span class="o">+=</span> <span class="mi">20</span><span class="o">;</span>
            
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>  <span class="c1">// 1초 대기</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"다운로드 완료!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><em>🚨 주의: 이 예시 코드는 Thread를 사용하고 있다. <br />
Thread는 기본적으로 작업을 병렬적으로 처리하기 위한 도구이다. <br />
비동기 프로그래밍에서는 이러한 Thread의 병렬 처리 능력을 활용하여 비동기 작업을 구현하는 것이 일반적이다. <br />
하지만 이 예시의 주된 목적은 작업이 어떻게 논블로킹하면서도 동기적으로 처리될 수 있는지를 시각적으로 보여주는 것이다. <br />
Thread를 사용한 것은 개념을 쉽게 설명하기 위한 것이다.</em></p>

<p>이 코드의 결과는 다음과 같을 것이다.</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="nt">메인</span> <span class="nt">스레드</span><span class="o">]</span> <span class="nt">나는</span> <span class="nt">다른</span> <span class="nt">작업을</span> <span class="nt">진행할게</span><span class="o">.</span>
<span class="o">[</span><span class="nt">작업</span> <span class="nt">스레드</span><span class="o">]</span> <span class="nt">실행</span> <span class="nt">시작</span><span class="o">!</span>
<span class="o">[</span><span class="nt">작업</span> <span class="nt">스레드</span><span class="o">]</span> <span class="err">0</span><span class="nt">번째</span> <span class="nt">작업</span> <span class="nt">수행</span> <span class="nt">중</span><span class="o">...</span>
<span class="o">[</span><span class="nt">메인</span> <span class="nt">스레드</span><span class="o">]</span> <span class="nt">작업</span> <span class="nt">스레드야</span><span class="o">,</span> <span class="nt">작업</span> <span class="nt">끝났니</span><span class="o">?</span> <span class="o">=</span> <span class="nt">No</span>
<span class="o">[</span><span class="nt">메인</span> <span class="nt">스레드</span><span class="o">]</span> <span class="nt">작업</span> <span class="nt">스레드야</span><span class="o">,</span> <span class="nt">작업</span> <span class="nt">끝났니</span><span class="o">?</span> <span class="o">=</span> <span class="nt">No</span>
<span class="o">[</span><span class="nt">작업</span> <span class="nt">스레드</span><span class="o">]</span> <span class="err">1</span><span class="nt">번째</span> <span class="nt">작업</span> <span class="nt">수행</span> <span class="nt">중</span><span class="o">...</span>
<span class="o">[</span><span class="nt">메인</span> <span class="nt">스레드</span><span class="o">]</span> <span class="nt">작업</span> <span class="nt">스레드야</span><span class="o">,</span> <span class="nt">작업</span> <span class="nt">끝났니</span><span class="o">?</span> <span class="o">=</span> <span class="nt">No</span>
<span class="o">[</span><span class="nt">메인</span> <span class="nt">스레드</span><span class="o">]</span> <span class="nt">작업</span> <span class="nt">스레드야</span><span class="o">,</span> <span class="nt">작업</span> <span class="nt">끝났니</span><span class="o">?</span> <span class="o">=</span> <span class="nt">No</span>
<span class="o">[</span><span class="nt">작업</span> <span class="nt">스레드</span><span class="o">]</span> <span class="err">2</span><span class="nt">번째</span> <span class="nt">작업</span> <span class="nt">수행</span> <span class="nt">중</span><span class="o">...</span>
<span class="o">...</span>
<span class="o">[</span><span class="nt">메인</span> <span class="nt">스레드</span><span class="o">]</span> <span class="nt">작업</span> <span class="nt">스레드야</span><span class="o">,</span> <span class="nt">작업</span> <span class="nt">끝났니</span><span class="o">?</span> <span class="o">=</span> <span class="nt">No</span>
<span class="o">[</span><span class="nt">작업</span> <span class="nt">스레드</span><span class="o">]</span> <span class="nt">실행</span> <span class="nt">완료</span><span class="o">!</span>
<span class="o">[</span><span class="nt">메인</span> <span class="nt">스레드</span><span class="o">]</span> <span class="nt">작업</span> <span class="nt">스레드</span> <span class="nt">종료</span> <span class="nt">확인</span><span class="o">!</span>
<span class="o">[</span><span class="nt">메인</span> <span class="nt">스레드</span><span class="o">]</span> <span class="nt">모든</span> <span class="nt">작업</span> <span class="nt">완료</span><span class="o">.</span>
</code></pre></div></div>

<p>물론, 논블로킹 메서드로 비동기 작업을 시작하더라도, 결과를 기다려야 하는 시점에서는 블로킹처럼 동작할 수 있다. <br />
왜냐하면 메인 스레드가 결과를 받아야만 다음 작업을 진행할 수 있기 때문에, 그 시점에서는 블로킹이 되는 것이다.</p>

<p><img src="https://github.com/user-attachments/assets/b43ec8c4-9783-4fbf-9f7a-3736dff051bb" alt="image" width="80%" class="center" /></p>

<p>사실 이러한 방식의 구현은 흔치 않다. <br />
하지만, 몇 가지 활용 예를 알아보자면 <strong>게임 로딩화면 구성</strong> 등에 활용될 수 있다. <br />
보통 게임에서 패치나 다운로드를 할 때, 사용자에게 ProgressBar나 게임 Tip등을 띄워줘야 할 때가 있다. <br />
이 때는 Load 하는 동작이 완료될 때 까지 (작업 순서는 보장 = Sync) <br />
다른 작업이 진행될 수 있다. (Non-Blocking)
즉, 사용자 경험 측면에서 유용하게 활용될 수 있다.</p>

<blockquote>
  <p>언어 간에는 구현 방식에 차이가 있을 수 있다. <br />
이는 각 언어의 특성과 제공되는 라이브러리나 기술에 따라 달라질 수 있다. <br />
예를 들어, JavaScript는 단일 스레드 기반으로 동작하며, 콜백 함수, 프로미스(Promise), async/await 등의 메커니즘을 사용해 동기와 논블로킹 처리를 구현할 수 있다. <br />
기본적으로 Promise.then 방식은 비동기적이고 논블로킹 방식으로 처리된다. <br />
그러나 async/await 키워드를 사용하면, 비동기 작업의 순서를 지정할 수 있다.<br />
중요한 점은, async 함수가 내부적으로 비동기적으로 동작하며, 메인 콜 스택이 모두 비워져야 실행된다는 것이다. <br />
이로 인해 async/await도 내부적으로는 여전히 비동기적이고 논블로킹 방식으로 동작한다는 점을 유의해야 한다.
(동기적인 코드 흐름처럼 보이게 하는 트릭)</p>
</blockquote>

<h2 id="4-4-비동기--블로킹">4-4. 비동기 + 블로킹</h2>

<p>이러한 방식은 사실 실무에서 마주치기 더더욱 흔치 않다.</p>

<p>개념만 간단히 설명하자면,</p>

<p>다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다린다. (<strong>블로킹</strong>)</p>

<p>다른 작업의 결과를 바로 처리하지 않고, 콜백함수를 보낸 후 기다린다.</p>

<p>이로써 작업 완료의 순서는 보장되지 않을 수 있다. (<strong>비동기</strong>)</p>

<p><strong>즉, 함수 A는 자신과 관련없는 함수 B의 작업이 끝날 때까지 기다려야 한다.</strong>
<em>매우 비효율적인 로직…</em></p>

<p>1 작업 중에 2 작업을 해야지 Async의 이점을 살릴 수 있는 것인데,
이것을 다시 Blocking 방식을 사용함여 대기시킴으로써 이점을 제거해버린 것이다…😅
대부분의 경우 비동기+논블로킹 모델이 더 효율적인 선택이 될 것이다.</p>

<p><br /></p>

<h1 id="5-현대-프로그래밍에서-이러한-개념이-왜-중요한가">5. 현대 프로그래밍에서 이러한 개념이 왜 중요한가?</h1>

<p>이러한 이해는 현대 소프트웨어 개발에서 매우 중요하다. 오늘날의 애플리케이션들은 수많은 동시다발적인 작업을 처리해야 한다. 사용자는 파일을 다운로드하면서 동시에 문서를 편집하길 원하고, 데이터가 백그라운드에서 처리되는 동안에도 끊김 없는 인터페이스 사용을 기대한다.</p>

<p>더군다나 클라우드 컴퓨팅과 마이크로서비스 아키텍처가 보편화된 현대 개발 환경에서는, 네트워크를 통한 수많은 비동기 작업들이 동시에 발생한다. 이때 각 작업을 어떻게 처리할지, 작업 간의 의존성은 어떻게 관리할지를 결정하는 것은 시스템의 성능과 사용자 경험을 좌우하는 핵심 요소가 된다.</p>

<p>결국 이러한 개념들의 이해는 단순히 기술적인 지식을 넘어서, 현대 소프트웨어가 직면한 복잡성과 사용자 경험의 요구사항을 어떻게 조화롭게 해결할 수 있을지에 대한 통찰을 제공한다. 이는 우리가 더 효율적이고, 반응성 높은, 그리고 사용자 친화적인 소프트웨어를 설계하고 구현하는 데 있어 필수적인 기반이 될 것이다.</p>

<h1 id="6-마무리">6. 마무리</h1>
<p>그렇다면 Java에서는 이러한 비동기 처리를 어떻게 구현할 수 있을까?</p>

<p>Java의 비동기 프로그래밍은 Thread를 시작으로, 현대적인 CompletableFuture까지 꾸준히 발전해왔다.</p>

<p>이제 각각의 방식을 자세히 살펴보겠다.</p>]]></content><author><name>Jinho</name></author><category term="Java" /><category term="Spring-Boot" /><category term="Backend" /><category term="Sync" /><category term="Async" /><category term="Concurrency" /><category term="Blocking" /><category term="NonBlocking" /><summary type="html"><![CDATA[1. 개념적 이해]]></summary></entry></feed>