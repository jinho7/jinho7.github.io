<!DOCTYPE html>
<html>

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>
    Java/SpringBoot에서의 비동기 처리 - Jinho&#39;s Tech Blog
    
  </title>

  <meta name="description" content="2. Java에서의 구현과 실제 경험 2.1 스레드와 비동기 처리">

  <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

  <script src="https://use.fontawesome.com/releases/v5.15.3/js/all.js" crossorigin="anonymous"></script>

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/2025/01/15/asynchronous-processing-in-java-spring.html">
  <link rel="alternate" type="application/rss+xml" title="Jinho&#39;s Tech Blog" href="/feed.xml">

</head>


<body>

  <!-- Navigation -->
<nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="/">Jinho&#39;s Tech Blog</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
      Menu
      <i class="fa fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        <li class="nav-item">
          <a class="nav-link" href="/">Home</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/about">About</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/posts">Posts</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/contact">Contact</a>
        </li>
      </ul>
    </div>
  </div>
</nav>


  <!-- Page Header -->

<header class="masthead" style="background-image: url('/img/posts/asynchronous-processing-in-java-spring.png')">
  
    <div class="overlay"></div>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
            <div class="post-heading">
                <h1>Java/SpringBoot에서의 비동기 처리</h1>
                
                <h2 class="subheading">효율적인 비동기 처리</h2>
                
                <span class="meta">Posted by
                  <a href="#">Jinho</a>
                  on January 15, 2025 &middot; <span class="reading-time" title="Estimated read time">
  
  
  
  <!-- 기본 텍스트 읽기 시간 계산 - 개발 문서는 더 천천히 읽음 -->
  
  
  
  <!-- 코드 분석 시간 추가 -->
  
  
  <!-- 복잡한 개념 이해 시간 추가 -->
  
  
  <!-- 총 예상 시간 계산 -->
  
  
  
    33 mins
   read
</span>
                </span>
                
                <span class="post-tags">
                    <span class="font-size: 20px;
                    font-weight: 300;
                    font-style: italic;">Tags:</span>
                    
                        <li><a href="/tag/?tag=Java" class="tag">Java</a></li>
                    
                        <li><a href="/tag/?tag=Spring" class="tag">Spring</a></li>
                    
                        <li><a href="/tag/?tag=SpringBoot" class="tag">SpringBoot</a></li>
                    
                        <li><a href="/tag/?tag=Async" class="tag">Async</a></li>
                    
                        <li><a href="/tag/?tag=Thread" class="tag">Thread</a></li>
                    
                        <li><a href="/tag/?tag=Runnable" class="tag">Runnable</a></li>
                    
                        <li><a href="/tag/?tag=CompletableFuture" class="tag">CompletableFuture</a></li>
                    
                        <li><a href="/tag/?tag=ThreadPool" class="tag">ThreadPool</a></li>
                    
                        <li><a href="/tag/?tag=ThreadPoolTaskExecutor" class="tag">ThreadPoolTaskExecutor</a></li>
                    
                        <li><a href="/tag/?tag=Concurrency" class="tag">Concurrency</a></li>
                    
                        <li><a href="/tag/?tag=I%2FO" class="tag">I/O</a></li>
                    
                        <li><a href="/tag/?tag=Performance" class="tag">Performance</a></li>
                    
                        <li><a href="/tag/?tag=WebFlux" class="tag">WebFlux</a></li>
                    
                </spans>
                
            </div>
        </div>
      </div>
    </div>
  </header>

  <div class="container ">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto post-content nexon-font">
        <h1 id="2-java에서의-구현과-실제-경험">2. Java에서의 구현과 실제 경험</h1>
<h2 id="21-스레드와-비동기-처리">2.1 스레드와 비동기 처리</h2>

<p>Javascript에서 callback뿐만이 아니라 Promise, async/await 등의 다양한 방법으로 비동기 처리를 구현할 수 있다.</p>

<p>그렇다면, <strong>Java에서는 어떻게 비동기 처리</strong>를 할 수 있을까?</p>

<h3 id="thread와-runnable">Thread와 Runnable</h3>

<p>Java에서 비동기 프로그래밍을 처음 접하게 되면 보통 Thread와 Runnable을 마주치게 된다.</p>

<p>가장 기본적인 비동기 처리 방식이며, 비동기 프로그래밍의 핵심 개념을 이해하는 데에 매우 중요하다.</p>

<p>Thread는 <strong>프로그램 내에서 실행되는 독립적인 실행 흐름</strong>을 의미한다.</p>

<p>Java에서 Thread를 생성하는 방식은 크게 2가지가 있다.</p>

<ul>
  <li>Thread 클래스 상속</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread: "</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 사용</span>
<span class="nc">MyThread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyThread</span><span class="o">();</span>
<span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>  <span class="c1">// 새로운 스레드 시작</span>
</code></pre></div></div>

<ul>
  <li>Runnable 인터페이스 구현</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyRunnable</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread: "</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 사용</span>
<span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyRunnable</span><span class="o">());</span>
<span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>  <span class="c1">// 새로운 스레드 시작</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>🤔 왜 두 가지 방법이 존재할까?</strong></p>
<ul>
  <li>Java는 다중 상속을 지원하지 않는다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없게 된다.</li>
</ul>

<p>_ 또한, 스레드 코드와 비즈니스 로직이 강하게 결합되는 단점도 있다._</p>

<p>반면 Runnable은 인터페이스이기 때문에, 다른 클래스를 상속받으면서도 Runnable을 구현할 수 있다.</p>

<p>이는 Java 설계 철학인 “<strong>상속보다는 구성 (Composition over inheritance)</strong>“를 잘 보여주는 예시인 것 같다.</p>

<p><br /></p>

<h3 id="thread에-대해-이해하기---생명주기--주의할-점">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</h3>

<p>Thread를 사용하면서 가장 중요한 것은 생명주기를 이해하는 것이다.</p>

<p><strong>[Thread의 생명주기]</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadLifecycleDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span> <span class="c1">// TIMED_WAITING 상태</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">interrupt</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"1. 초기 상태: "</span> <span class="o">+</span> <span class="n">thread</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span> <span class="c1">// NEW</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"2. 실행 상태: "</span> <span class="o">+</span> <span class="n">thread</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span> <span class="c1">// RUNNABLE</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"3. 대기 상태: "</span> <span class="o">+</span> <span class="n">thread</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span> <span class="c1">// TIMED_WAITING</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"4. 종료 상태: "</span> <span class="o">+</span> <span class="n">thread</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span> <span class="c1">// TERMINATED</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ol>
  <li>NEW: 스레드가 생성되었지만, 아직 start()가 호출되지 않은 상태</li>
  <li>RUNNABLE: 실행 중이거나 실행 가능한 상태</li>
  <li>BLOCKED: 모니터 락을 기다리는 상태</li>
  <li>WAITING: 다른 스레드의 특정 동작을 기다리는 상태</li>
  <li>TIMED_WAITING: 특정 시간 동안 대기하는 상태</li>
  <li>TERMINATED: 실행이 완료된 상태</li>
</ol>

<p><strong>[Thread 사용 시 주의할 점]</strong></p>

<ul>
  <li>동기화 문제</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadSafetyExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    
    <span class="c1">// 잘못된 구현</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">incrementWrong</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">count</span><span class="o">++;</span> <span class="c1">// 스레드 안전하지 않음</span>
    <span class="o">}</span>
    
    <span class="c1">// 올바른 구현</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">incrementCorrect</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">count</span><span class="o">++;</span> <span class="c1">// 스레드 안전함</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>여러 스레드가 동시에 같은 자원에 접근할 때 발생하는 race condition을 방지하기 위해 동기화가 필요하다.</p>

<p>synchronized 키워드나 volatile 변수, atomic 클래스 등을 활용하여 스레드 안전성을 보장해야 한다.</p>

<p>특히 공유 자원을 수정하는 작업에서는 반드시 적절한 동기화 메커니즘을 사용해야 한다.</p>

<ul>
  <li>데드락 방지</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DeadlockExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="n">lock1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="n">lock2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method1</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock1</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock2</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 위험: 다른 스레드가 lock2-&gt;lock1 순서로 락을 획득하려 할 경우</span>
                <span class="c1">// 데드락 발생 가능</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태이다.</p>

<p>이를 방지하기 위해서는 락 획득의 순서를 일관되게 유지하고, 가능한 한 여러 락을 동시에 획득하는 것을 피해야 한다.</p>

<p>또한 락 획득에 타임아웃을 설정하는 것도 좋은 방법이다.</p>

<ul>
  <li>스레드 인터럽트 처리</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">InterruptExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">longRunningTask</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(!</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">isInterrupted</span><span class="o">())</span> <span class="o">{</span>
                <span class="c1">// 작업 수행</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 인터럽트 발생 시 적절한 처리</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">interrupt</span><span class="o">();</span> <span class="c1">// 인터럽트 상태 복구</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>스레드 인터럽트는 실행 중인 스레드에게 작업을 중단하라는 신호를 보내는 메커니즘이다.</p>

<p>InterruptedException이 발생했을 때 단순히 예외를 무시하면 안 되며, 적절한 정리 작업을 수행하고 인터럽트 상태를 복구해야 한다.</p>

<p>특히 장시간 실행되는 작업의 경우, 주기적으로 인터럽트 상태를 확인하고 적절히 응답하는 것이 중요하다.</p>

<p><br /></p>

<h3 id="thread와-runnable의-한계">Thread와 Runnable의 한계</h3>

<p>Thread와 Runnable은 비동기 처리의 기초를 이해하는데 좋지만, 다음과 같은 한계가 있다.</p>

<ul>
  <li>스레드 생성과 종료의 오버헤드</li>
  <li>결과값을 반환하기 어려움</li>
  <li>예외 처리가 복잡함</li>
  <li>스레드 풀 관리의 어려움</li>
</ul>

<p>이러한 한계점들을 보완하기 위해 Java는 더 발전된 형태의 API들을 제공하게 되었다.</p>

<p><strong>[1. Callable 인터페이스]</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">callable</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="c1">// 작업 수행</span>
    <span class="k">return</span> <span class="s">"작업 결과"</span><span class="o">;</span>  <span class="c1">// 결과값 반환 가능</span>
<span class="o">};</span>

<span class="nc">ExecutorService</span> <span class="n">executor</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newSingleThreadExecutor</span><span class="o">();</span>
<span class="nc">Future</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">callable</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>  <span class="c1">// 결과값 받기</span>
</code></pre></div></div>

<ul>
  <li>Callable은 Runnable과 달리 <strong>작업 결과를 반환하고 예외를 throw</strong>할 수 있다.
[Runable은 아무것도 리턴하지 않는다.]</li>
  <li>이를 통해 비동기 작업에서 <strong>결과값을 다루기 쉬워졌다</strong>.</li>
</ul>

<p><strong>[2. ExecutorService]</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ExecutorService</span> <span class="n">executor</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>  <span class="c1">// 스레드 풀 생성</span>
<span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="c1">// 작업 수행</span>
<span class="o">});</span>
<span class="n">executor</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>  <span class="c1">// 작업 완료 후 스레드 풀 정리</span>
</code></pre></div></div>

<ul>
  <li>ExecutorService는 <strong>스레드 생성과 관리의 복잡성을 제거</strong>하고, <strong>스레드 풀을 통해 리소스를 효율적으로 사용</strong>할 수 있도록 도와준다.</li>
</ul>

<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데에 매우 중요하다.</p>

<p>이러한 저수준의 Thread 활용은 실무 환경에서 거의 사용되지는 않지만, 비동기 프로그래밍의 기본 개념을 이해하는 데 매우 중요하다.</p>

<p><strong>[3. Future]</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Future</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
    <span class="k">return</span> <span class="s">"Future의 결과값"</span><span class="o">;</span>
<span class="o">});</span>

<span class="c1">// Future의 주요 메서드 활용</span>
<span class="kt">boolean</span> <span class="n">isDone</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">isDone</span><span class="o">();</span>        <span class="c1">// 작업 완료 여부 확인</span>
<span class="kt">boolean</span> <span class="n">isCancelled</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">isCancelled</span><span class="o">();</span> <span class="c1">// 작업 취소 여부 확인</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>            <span class="c1">// 결과 가져오기 (블로킹)</span>
<span class="nc">String</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">);</span> <span class="c1">// 타임아웃 설정</span>
</code></pre></div></div>
<ul>
  <li>Future는 <strong>비동기 작업의 결과를 표현하는 인터페이스</strong>로, 작업의 상태를 확인하고 결과를 받을 수 있다.</li>
  <li>작업 취소와 타임아웃 설정 등 <strong>비동기 작업의 제어</strong>가 가능하다.</li>
</ul>

<p>허나 다음과 같은 한계가 존재한다.</p>

<ul>
  <li>결국 다른 주체의 작업 결과를 얻어오려면 잠시라도 블로킹 상태에 들어갈 수 밖에 없다.</li>
  <li>가장 큰 단점은 <strong>작업 완료를 기다리는 동안 블로킹</strong>된다는 점이다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 블로킹이 발생하는 get() 호출</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>  <span class="c1">// 작업이 완료될 때까지 현재 스레드는 블로킹됨</span>
</code></pre></div>    </div>
  </li>
  <li>또한, 여러 Futrure을 조합하기 어렵다.</li>
  <li>예외처리가 불편하다.</li>
  <li>콜백이나 완료 통보 기능이 없다.</li>
</ul>

<blockquote>
  <p>CompletableFuture는 비동기 작업의 흐름 제어와 조합을 더욱 쉽게 처리할 수 있도록 설계된 고수준 API이다. <br />
이를 통해 비동기 프로그래밍이 실무에서 어떻게 효율적으로 활용되는지 알아보자.</p>
</blockquote>

<p><br /></p>

<h3 id="completablefuture-비동기-프로그래밍의-진화">CompletableFuture: 비동기 프로그래밍의 진화</h3>

<p>앞서 살펴본 Thread, Runnable, 그리고 Callable/Future는 각각의 한계점이 있었다.</p>

<p>특히 Future의 경우, 비동기 작업의 결과를 표현하기는 했지만 결과를 조합하거나 에러를 처리하는 것이 어려웠다</p>

<blockquote>
  <p>CompletableFuture는 이러한 문제들을 해결하기 위해 Java 8에서 도입되었다.</p>
</blockquote>

<p>CompletableFuture는 Future 인터페이스를 구현하면서, 훨씬 더 구체적인 기능들을 제공한다.</p>

<p><strong>[1. 비동기 작업 생성]</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 결과가 없는 비동기 작업</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="n">future1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">runAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"비동기 작업 실행"</span><span class="o">);</span>
<span class="o">});</span>

<span class="c1">// 결과를 반환하는 비동기 작업</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future2</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">return</span> <span class="s">"작업 결과"</span><span class="o">;</span>
<span class="o">});</span>
</code></pre></div></div>

<p><strong>[2. 작업 조합하기]</strong></p>

<p>여러 비동기 작업을 연결하거나 조합할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="nc">CompletableFuture</span>
    <span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="s">"Hello"</span><span class="o">)</span>  <span class="c1">// 첫 번째 작업</span>
    <span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" World"</span><span class="o">)</span>  <span class="c1">// 결과를 변환</span>
    <span class="o">.</span><span class="na">thenCompose</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"!"</span><span class="o">));</span>  <span class="c1">// 다른 Future와 조합</span>

<span class="c1">// 두 작업의 결과 조합</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">future1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">);</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">future2</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">);</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">combined</span> <span class="o">=</span> <span class="n">future1</span>
    <span class="o">.</span><span class="na">thenCombine</span><span class="o">(</span><span class="n">future2</span><span class="o">,</span> <span class="o">(</span><span class="n">result1</span><span class="o">,</span> <span class="n">result2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">result1</span> <span class="o">+</span> <span class="n">result2</span><span class="o">);</span>
</code></pre></div></div>

<p><strong>[3. 예외 처리]</strong></p>

<p>CompletableFuture는 예외 처리를 위한 다양한 메서드를 제공한다.</p>

<p><strong>[4. 타임아웃처리]</strong></p>

<p>타임 아웃에 대한 처리도 가능하다.</p>

<p><strong>[5. 여러 작업의 병렬 처리]</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">futures</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
    <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="s">"작업1"</span><span class="o">),</span>
    <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="s">"작업2"</span><span class="o">),</span>
    <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="s">"작업3"</span><span class="o">)</span>
<span class="o">);</span>

<span class="c1">// 모든 작업이 완료될 때까지 대기</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="n">allOf</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">allOf</span><span class="o">(</span>
    <span class="n">futures</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">CompletableFuture</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span>
<span class="o">);</span>

<span class="c1">// 가장 빨리 완료되는 작업 처리</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">anyOf</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">anyOf</span><span class="o">(</span>
    <span class="n">futures</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">CompletableFuture</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span>
<span class="o">);</span>
</code></pre></div></div>

<p><strong>[실제 활용 예시]</strong></p>

<p>아래 코드는 사용자 정보를 조회하는 과정에서 데이터베이스 조회와 외부 API 호출을 병렬로 처리하는 실제 서비스 코드이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">PaymentApiClient</span> <span class="n">paymentApiClient</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">UserInfo</span><span class="o">&gt;</span> <span class="nf">getUserInfo</span><span class="o">(</span><span class="nc">Long</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="n">userFuture</span> <span class="o">=</span> <span class="nc">CompletableFuture</span>
            <span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">userId</span><span class="o">)</span>
                <span class="o">.</span><span class="na">orElseThrow</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">UserNotFoundException</span><span class="o">(</span><span class="n">userId</span><span class="o">)));</span>

        <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">PaymentInfo</span><span class="o">&gt;</span> <span class="n">paymentFuture</span> <span class="o">=</span> <span class="nc">CompletableFuture</span>
            <span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">paymentApiClient</span><span class="o">.</span><span class="na">getPaymentInfo</span><span class="o">(</span><span class="n">userId</span><span class="o">))</span>
            <span class="o">.</span><span class="na">exceptionally</span><span class="o">(</span><span class="n">ex</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="n">log</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">"Payment info fetch failed"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
                <span class="k">return</span> <span class="nc">PaymentInfo</span><span class="o">.</span><span class="na">getDefaultPaymentInfo</span><span class="o">();</span>
            <span class="o">});</span>

        <span class="k">return</span> <span class="n">userFuture</span>
            <span class="o">.</span><span class="na">thenCombine</span><span class="o">(</span><span class="n">paymentFuture</span><span class="o">,</span> <span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">payment</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="k">return</span> <span class="k">new</span> <span class="nf">UserInfo</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">payment</span><span class="o">);</span>
            <span class="o">})</span>
            <span class="o">.</span><span class="na">orTimeout</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">)</span>  <span class="c1">// 타임아웃 설정</span>
            <span class="o">.</span><span class="na">exceptionally</span><span class="o">(</span><span class="n">ex</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Error fetching user info"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
                <span class="k">return</span> <span class="nc">UserInfo</span><span class="o">.</span><span class="na">getDefaultUserInfo</span><span class="o">();</span>
            <span class="o">});</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<p>먼저, userFuture와 paymentFuture 객체를 받아올 때 두 작업이 독립적으로 실행되는 것을 알 수 있다.</p>
<ul>
  <li>데이터 베이스에서 사용자 정보 조회</li>
  <li>외부 API에서 결제 정보 조회</li>
</ul>

<blockquote>
  <p>두 작업이 독립적으로 병렬 실행되어 전체 응답 시간을 단축 <br />
각 작업은 별도의 스레드에서 실행되므로 서로 블로킹하지 않음</p>
</blockquote>

<p>또한, <strong>.exceptionally</strong> 을 사용한 예외 처리 전략을 구체화할 수 있다.</p>

<ul>
  <li>결제 정보 조회 실패 시 서비스 전체가 실패하지 않도록 기본값 사용</li>
  <li>각 단계별로 적절한 예외 처리와 폴백(fallback) 전략 구현</li>
</ul>

<p>또한, <strong>thenCombine</strong>을 사용해 두 비동기 작업의 결과를 하나로 조합할 수 있다.</p>

<blockquote>
  <p>두 작업이 모두 완료되었을 때만 최종 결과 생성</p>
</blockquote>

<p>마지막으로, <strong>타임아웃 처리</strong>를 통해 시스템의 응답성 보장을 위한 안전장치를 설정할 수 있다.</p>

<p><br /></p>

<h3 id="스레드-풀의-이해">스레드 풀의 이해</h3>
<p>앞서 살펴본 CompletableFuture의 실제 활용 예시에서, 우리는 여러 비동기 작업을 동시에 처리했습니다. 그러나 무분별한 스레드 생성은 시스템 리소스를 빠르게 고갈시킬 수 있습니다. 이러한 문제를 해결하기 위해 스레드 풀이 등장했습니다.</p>

<p><br />
<br /></p>

<p>// 수정중</p>

<h2 id="22-spring의-비동기-처리">2.2 Spring의 비동기 처리</h2>

<h3 id="async-사용-경험과-주의점">@Async 사용 경험과 주의점</h3>
<h3 id="threadpooltaskexecutor-설정-최적화">ThreadPoolTaskExecutor 설정 최적화</h3>

<p><br /></p>

<h1 id="3-이론적-고찰">3. 이론적 고찰</h1>
<h2 id="31-언제-비동기를-사용할까">3.1 언제 비동기를 사용할까?</h2>

<h3 id="io-작업이-많은-경우의-선택">I/O 작업이 많은 경우의 선택</h3>
<h3 id="대용량-데이터-처리시의-고려사항">대용량 데이터 처리시의 고려사항</h3>

<p><br /></p>

<h2 id="32-트레이드오프">3.2 트레이드오프</h2>

<h3 id="디버깅의-어려움">디버깅의 어려움</h3>
<h3 id="리소스-사용량-증가">리소스 사용량 증가</h3>
<h3 id="복잡성-vs-성능-개선">복잡성 vs 성능 개선</h3>

<h1 id="4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</h1>


        <div class="clearfix">
          
          <a class="btn btn-primary float-left" href="/2025/01/12/understanding-sync-async-blocking-non-blocking.html" data-toggle="tooltip" data-placement="top" title="동기/비동기와 블로킹/논블로킹에 대해 깊이 파헤치기">&larr; Previous<span class="d-none d-md-inline">
              Post</span></a>
          
          
        </div>
      </div>
      <div class="toc">
        <div class="toc-heading">In This Article</div>
        <ul><li><a href="#2-java에서의-구현과-실제-경험">2. Java에서의 구현과 실제 경험</a><ul><li><a href="#21-스레드와-비동기-처리">2.1 스레드와 비동기 처리</a><ul><li><a href="#thread와-runnable">Thread와 Runnable</a></li><li><a href="#thread에-대해-이해하기---생명주기--주의할-점">Thread에 대해 이해하기 - 생명주기 &amp; 주의할 점</a></li><li><a href="#thread와-runnable의-한계">Thread와 Runnable의 한계</a></li><li><a href="#completablefuture-비동기-프로그래밍의-진화">CompletableFuture: 비동기 프로그래밍의 진화</a></li><li><a href="#스레드-풀의-이해">스레드 풀의 이해</a></li></ul></li><li><a href="#22-spring의-비동기-처리">2.2 Spring의 비동기 처리</a><ul><li><a href="#async-사용-경험과-주의점">@Async 사용 경험과 주의점</a></li><li><a href="#threadpooltaskexecutor-설정-최적화">ThreadPoolTaskExecutor 설정 최적화</a></li></ul></li></ul></li><li><a href="#3-이론적-고찰">3. 이론적 고찰</a><ul><li><a href="#31-언제-비동기를-사용할까">3.1 언제 비동기를 사용할까?</a><ul><li><a href="#io-작업이-많은-경우의-선택">I/O 작업이 많은 경우의 선택</a></li><li><a href="#대용량-데이터-처리시의-고려사항">대용량 데이터 처리시의 고려사항</a></li></ul></li><li><a href="#32-트레이드오프">3.2 트레이드오프</a><ul><li><a href="#디버깅의-어려움">디버깅의 어려움</a></li><li><a href="#리소스-사용량-증가">리소스 사용량 증가</a></li><li><a href="#복잡성-vs-성능-개선">복잡성 vs 성능 개선</a></li></ul></li></ul></li><li><a href="#4-마무리--주니어-개발자의-관점에서-본-비동기-프로그래밍">4. 마무리 : 주니어 개발자의 관점에서 본 비동기 프로그래밍</a></li></ul>

      </div>
      <div class="scroll-to-top">
          <a href="#">🔼</a>
      </div>
    </div>
  </div>

  <!-- Footer -->

<hr>

<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        <ul class="list-inline text-center">
          
          <li class="list-inline-item">
            <a href="mailto:jh7524jh7524@gmail.com">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="far fa-envelope fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
          
          
          
          
          <li class="list-inline-item">
            <a href="https://github.com/jinho7">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
          
        </ul>
        <p class="copyright text-muted">Copyright &copy; Jinho 2025</p>
      </div>
    </div>
  </div>
</footer>


  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js"></script>
<script src="/assets/vendor/startbootstrap-clean-blog/js/scripts.js"></script>
<script src="/assets/vendor/startbootstrap-clean-blog/js/code-block.js"></script>
<script src="/assets/scripts.js"></script>






  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXXXX-X"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-XXXXXXXXX-X');
</script>



</body>

</html>
